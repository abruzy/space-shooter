!(function (t) { const e = {}; function i(n) { if (e[n]) return e[n].exports; const s = e[n] = { i: n, l: !1, exports: {} }; return t[n].call(s.exports, s, s.exports, i), s.l = !0, s.exports; }i.m = t, i.c = e, i.d = function (t, e, n) { i.o(t, e) || Object.defineProperty(t, e, { enumerable: !0, get: n }); }, i.r = function (t) { typeof Symbol !== 'undefined' && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, { value: 'Module' }), Object.defineProperty(t, '__esModule', { value: !0 }); }, i.t = function (t, e) { if (1 & e && (t = i(t)), 8 & e) return t; if (4 & e && typeof t === 'object' && t && t.__esModule) return t; const n = Object.create(null); if (i.r(n), Object.defineProperty(n, 'default', { enumerable: !0, value: t }), 2 & e && typeof t !== 'string') for (const s in t)i.d(n, s, ((e) => t[e]).bind(null, s)); return n; }, i.n = function (t) { const e = t && t.__esModule ? function () { return t.default; } : function () { return t; }; return i.d(e, 'a', e), e; }, i.o = function (t, e) { return Object.prototype.hasOwnProperty.call(t, e); }, i.p = '/build/', i(i.s = 1447); }([function (t, e) { function i(t, e, i) { let n = i ? t[e] : Object.getOwnPropertyDescriptor(t, e); return !i && n.value && typeof n.value === 'object' && (n = n.value), !(!n || !(function (t) { return !!t.get && typeof t.get === 'function' || !!t.set && typeof t.set === 'function'; }(n))) && (void 0 === n.enumerable && (n.enumerable = !0), void 0 === n.configurable && (n.configurable = !0), n); } function n(t, e) { let i = Object.getOwnPropertyDescriptor(t, e); return !!i && (i.value && typeof i.value === 'object' && (i = i.value), !1 === i.configurable); } function s(t, e, s, r) { for (const a in e) if (e.hasOwnProperty(a)) { const h = i(e, a, s); if (!1 !== h) { if (n((r || t).prototype, a)) { if (o.ignoreFinals) continue; throw new Error(`cannot override final property '${a}', set Class.ignoreFinals = true to skip`); }Object.defineProperty(t.prototype, a, h); } else t.prototype[a] = e[a]; } } function r(t, e) { if (e) { Array.isArray(e) || (e = [e]); for (let i = 0; i < e.length; i++)s(t, e[i].prototype || e[i]); } } function o(t) { let e; let i; if (t || (t = {}), t.initialize) { if (typeof t.initialize !== 'function') throw new Error('initialize must be a function'); e = t.initialize, delete t.initialize; } else if (t.Extends) { const n = t.Extends; e = function () { n.apply(this, arguments); }; } else e = function () {}; t.Extends ? (e.prototype = Object.create(t.Extends.prototype), e.prototype.constructor = e, i = t.Extends, delete t.Extends) : e.prototype.constructor = e; let o = null; return t.Mixins && (o = t.Mixins, delete t.Mixins), r(e, o), s(e, t, !0, i), e; }o.extend = s, o.mixin = r, o.ignoreFinals = !1, t.exports = o; }, function (t, e) { t.exports = function () {}; }, function (t, e) { t.exports = function (t, e, i) { const n = typeof t; return t && n !== 'number' && n !== 'string' && t.hasOwnProperty(e) && void 0 !== t[e] ? t[e] : i; }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(98); var r = new n({
    initialize(t, e) { this.x = 0, this.y = 0, typeof t === 'object' ? (this.x = t.x || 0, this.y = t.y || 0) : (void 0 === e && (e = t), this.x = t || 0, this.y = e || 0); }, clone() { return new r(this.x, this.y); }, copy(t) { return this.x = t.x || 0, this.y = t.y || 0, this; }, setFromObject(t) { return this.x = t.x || 0, this.y = t.y || 0, this; }, set(t, e) { return void 0 === e && (e = t), this.x = t, this.y = e, this; }, setTo(t, e) { return this.set(t, e); }, setToPolar(t, e) { return e == null && (e = 1), this.x = Math.cos(t) * e, this.y = Math.sin(t) * e, this; }, equals(t) { return this.x === t.x && this.y === t.y; }, fuzzyEquals(t, e) { return s(this.x, t.x, e) && s(this.y, t.y, e); }, angle() { let t = Math.atan2(this.y, this.x); return t < 0 && (t += 2 * Math.PI), t; }, setAngle(t) { return this.setToPolar(t, this.length()); }, add(t) { return this.x += t.x, this.y += t.y, this; }, subtract(t) { return this.x -= t.x, this.y -= t.y, this; }, multiply(t) { return this.x *= t.x, this.y *= t.y, this; }, scale(t) { return isFinite(t) ? (this.x *= t, this.y *= t) : (this.x = 0, this.y = 0), this; }, divide(t) { return this.x /= t.x, this.y /= t.y, this; }, negate() { return this.x = -this.x, this.y = -this.y, this; }, distance(t) { const e = t.x - this.x; const i = t.y - this.y; return Math.sqrt(e * e + i * i); }, distanceSq(t) { const e = t.x - this.x; const i = t.y - this.y; return e * e + i * i; }, length() { const t = this.x; const e = this.y; return Math.sqrt(t * t + e * e); }, setLength(t) { return this.normalize().scale(t); }, lengthSq() { const t = this.x; const e = this.y; return t * t + e * e; }, normalize() { const t = this.x; const e = this.y; let i = t * t + e * e; return i > 0 && (i = 1 / Math.sqrt(i), this.x = t * i, this.y = e * i), this; }, normalizeRightHand() { const t = this.x; return this.x = -1 * this.y, this.y = t, this; }, normalizeLeftHand() { const t = this.x; return this.x = this.y, this.y = -1 * t, this; }, dot(t) { return this.x * t.x + this.y * t.y; }, cross(t) { return this.x * t.y - this.y * t.x; }, lerp(t, e) { void 0 === e && (e = 0); const i = this.x; const n = this.y; return this.x = i + e * (t.x - i), this.y = n + e * (t.y - n), this; }, transformMat3(t) { const e = this.x; const i = this.y; const n = t.val; return this.x = n[0] * e + n[3] * i + n[6], this.y = n[1] * e + n[4] * i + n[7], this; }, transformMat4(t) { const e = this.x; const i = this.y; const n = t.val; return this.x = n[0] * e + n[4] * i + n[12], this.y = n[1] * e + n[5] * i + n[13], this; }, reset() { return this.x = 0, this.y = 0, this; }, limit(t) { const e = this.length(); return e && e > t && this.scale(t / e), this; }, reflect(t) { return t = t.clone().normalize(), this.subtract(t.scale(2 * this.dot(t))); }, mirror(t) { return this.reflect(t).negate(); }, rotate(t) { const e = Math.cos(t); const i = Math.sin(t); return this.set(e * this.x - i * this.y, i * this.x + e * this.y); },
  }); r.ZERO = new r(), r.RIGHT = new r(1, 0), r.LEFT = new r(-1, 0), r.UP = new r(0, -1), r.DOWN = new r(0, 1), r.ONE = new r(1, 1), t.exports = r;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(54); const r = new n({ initialize(t, e) { void 0 === t && (t = 0), void 0 === e && (e = t), this.type = s.POINT, this.x = t, this.y = e; }, setTo(t, e) { return void 0 === t && (t = 0), void 0 === e && (e = t), this.x = t, this.y = e, this; } }); t.exports = r;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(23); const r = i(24); const o = new n({
    initialize(t) { this.scene = t, this.systems = t.sys, this.displayList, this.updateList, t.sys.events.once(r.BOOT, this.boot, this), t.sys.events.on(r.START, this.start, this); }, boot() { this.displayList = this.systems.displayList, this.updateList = this.systems.updateList, this.systems.events.once(r.DESTROY, this.destroy, this); }, start() { this.systems.events.once(r.SHUTDOWN, this.shutdown, this); }, existing(t) { return (t.renderCanvas || t.renderWebGL) && this.displayList.add(t), t.preUpdate && this.updateList.add(t), t; }, shutdown() { this.systems.events.off(r.SHUTDOWN, this.shutdown, this); }, destroy() { this.shutdown(), this.scene.sys.events.off(r.START, this.start, this), this.scene = null, this.systems = null, this.displayList = null, this.updateList = null; },
  }); o.register = function (t, e) { o.prototype.hasOwnProperty(t) || (o.prototype[t] = e); }, o.remove = function (t) { o.prototype.hasOwnProperty(t) && delete o.prototype[t]; }, s.register('GameObjectFactory', o, 'add'), t.exports = o;
}, function (t, e) { t.exports = function (t, e, i) { if (t && typeof t !== 'number') { if (t.hasOwnProperty(e)) return t[e]; if (e.indexOf('.') !== -1) { for (var n = e.split('.'), s = t, r = i, o = 0; o < n.length; o++) { if (!s.hasOwnProperty(n[o])) { r = i; break; }r = s[n[o]], s = s[n[o]]; } return r; } return i; } return i; }; }, function (t, e, i) {
  (function (e) {
    /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
    i(547); const n = i(39); const s = i(19); let r = {
      Actions: i(264), Animations: i(667), BlendModes: i(45), Cache: i(668), Cameras: i(671), Core: i(757), Class: i(0), Create: i(815), Curves: i(821), Data: i(824), Display: i(826), DOM: i(843), Events: i(844), Game: i(846), GameObjects: i(944), Geom: i(462), Input: i(1231), Loader: i(1265), Math: i(185), Physics: i(1291), Plugins: i(1359), Renderer: i(1361), Scale: i(1366), ScaleModes: i(162), Scene: i(406), Scenes: i(1367), Structs: i(1369), Textures: i(1370), Tilemaps: i(1372), Time: i(1413), Tweens: i(1415), Utils: i(1432),
    }; r.Sound = i(1442), r.Cameras.Sprite3D = i(1443), r.GameObjects.Sprite3D = i(161), r.GameObjects.Factories.Sprite3D = i(1445), r.GameObjects.Creators.Sprite3D = i(1446), r.FacebookInstantGamesPlugin = i(422), r = s(!1, r, n), t.exports = r, e.Phaser = r;
  }).call(this, i(546));
}, function (t, e) { t.exports = function (t) { if (typeof t !== 'object' || t.nodeType || t === t.window) return !1; try { if (t.constructor && !{}.hasOwnProperty.call(t.constructor.prototype, 'isPrototypeOf')) return !1; } catch (t) { return !1; } return !0; }; }, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  let i = {}; const n = { install(t) { for (const e in i)t[e] = i[e]; }, register(t, e) { i[t] = e; }, destroy() { i = {}; } }; t.exports = n;
}, function (t, e, i) {
  const n = Object.prototype.hasOwnProperty; let s = '~'; function r() {} function o(t, e, i) { this.fn = t, this.context = e, this.once = i || !1; } function a(t, e, i, n, r) { if (typeof i !== 'function') throw new TypeError('The listener must be a function'); const a = new o(i, n || t, r); const h = s ? s + e : e; return t._events[h] ? t._events[h].fn ? t._events[h] = [t._events[h], a] : t._events[h].push(a) : (t._events[h] = a, t._eventsCount++), t; } function h(t, e) { --t._eventsCount == 0 ? t._events = new r() : delete t._events[e]; } function l() { this._events = new r(), this._eventsCount = 0; }Object.create && (r.prototype = Object.create(null), (new r()).__proto__ || (s = !1)), l.prototype.eventNames = function () { let t; let e; const i = []; if (this._eventsCount === 0) return i; for (e in t = this._events)n.call(t, e) && i.push(s ? e.slice(1) : e); return Object.getOwnPropertySymbols ? i.concat(Object.getOwnPropertySymbols(t)) : i; }, l.prototype.listeners = function (t) { const e = s ? s + t : t; const i = this._events[e]; if (!i) return []; if (i.fn) return [i.fn]; for (var n = 0, r = i.length, o = new Array(r); n < r; n++)o[n] = i[n].fn; return o; }, l.prototype.listenerCount = function (t) { const e = s ? s + t : t; const i = this._events[e]; return i ? i.fn ? 1 : i.length : 0; }, l.prototype.emit = function (t, e, i, n, r, o) { const a = s ? s + t : t; if (!this._events[a]) return !1; let h; let l; const u = this._events[a]; const c = arguments.length; if (u.fn) { switch (u.once && this.removeListener(t, u.fn, void 0, !0), c) { case 1: return u.fn.call(u.context), !0; case 2: return u.fn.call(u.context, e), !0; case 3: return u.fn.call(u.context, e, i), !0; case 4: return u.fn.call(u.context, e, i, n), !0; case 5: return u.fn.call(u.context, e, i, n, r), !0; case 6: return u.fn.call(u.context, e, i, n, r, o), !0; } for (l = 1, h = new Array(c - 1); l < c; l++)h[l - 1] = arguments[l]; u.fn.apply(u.context, h); } else { let d; const f = u.length; for (l = 0; l < f; l++) switch (u[l].once && this.removeListener(t, u[l].fn, void 0, !0), c) { case 1: u[l].fn.call(u[l].context); break; case 2: u[l].fn.call(u[l].context, e); break; case 3: u[l].fn.call(u[l].context, e, i); break; case 4: u[l].fn.call(u[l].context, e, i, n); break; default: if (!h) for (d = 1, h = new Array(c - 1); d < c; d++)h[d - 1] = arguments[d]; u[l].fn.apply(u[l].context, h); } } return !0; }, l.prototype.on = function (t, e, i) { return a(this, t, e, i, !1); }, l.prototype.once = function (t, e, i) { return a(this, t, e, i, !0); }, l.prototype.removeListener = function (t, e, i, n) { const r = s ? s + t : t; if (!this._events[r]) return this; if (!e) return h(this, r), this; const o = this._events[r]; if (o.fn)o.fn !== e || n && !o.once || i && o.context !== i || h(this, r); else { for (var a = 0, l = [], u = o.length; a < u; a++)(o[a].fn !== e || n && !o[a].once || i && o[a].context !== i) && l.push(o[a]); l.length ? this._events[r] = l.length === 1 ? l[0] : l : h(this, r); } return this; }, l.prototype.removeAllListeners = function (t) { let e; return t ? (e = s ? s + t : t, this._events[e] && h(this, e)) : (this._events = new r(), this._eventsCount = 0), this; }, l.prototype.off = l.prototype.removeListener, l.prototype.addListener = l.prototype.on, l.prefixed = s, l.EventEmitter = l, t.exports = l;
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Felipe Alfonso <@bitnenfer>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = {
    getTintFromFloats(t, e, i, n) { return ((255 & (255 * n | 0)) << 24 | (255 & (255 * t | 0)) << 16 | (255 & (255 * e | 0)) << 8 | 255 & (255 * i | 0)) >>> 0; }, getTintAppendFloatAlpha(t, e) { return ((255 & (255 * e | 0)) << 24 | t) >>> 0; }, getTintAppendFloatAlphaAndSwap(t, e) { return ((255 & (255 * e | 0)) << 24 | (255 & (0 | t)) << 16 | (255 & (t >> 8 | 0)) << 8 | 255 & (t >> 16 | 0)) >>> 0; }, getFloatsFromUintRGB(t) { return [(255 & (t >> 16 | 0)) / 255, (255 & (t >> 8 | 0)) / 255, (255 & (0 | t)) / 255]; }, getComponentCount(t, e) { for (var i = 0, n = 0; n < t.length; ++n) { const s = t[n]; s.type === e.FLOAT ? i += s.size : i += 1; } return i; },
  };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(55); const r = i(166); const o = i(298); const a = i(54); const h = i(62); const l = i(169); const u = new n({
    initialize(t, e, i, n) { void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 0), this.type = a.RECTANGLE, this.x = t, this.y = e, this.width = i, this.height = n; }, contains(t, e) { return s(this, t, e); }, getPoint(t, e) { return r(this, t, e); }, getPoints(t, e, i) { return o(this, t, e, i); }, getRandomPoint(t) { return l(this, t); }, setTo(t, e, i, n) { return this.x = t, this.y = e, this.width = i, this.height = n, this; }, setEmpty() { return this.setTo(0, 0, 0, 0); }, setPosition(t, e) { return void 0 === e && (e = t), this.x = t, this.y = e, this; }, setSize(t, e) { return void 0 === e && (e = t), this.width = t, this.height = e, this; }, isEmpty() { return this.width <= 0 || this.height <= 0; }, getLineA(t) { return void 0 === t && (t = new h()), t.setTo(this.x, this.y, this.right, this.y), t; }, getLineB(t) { return void 0 === t && (t = new h()), t.setTo(this.right, this.y, this.right, this.bottom), t; }, getLineC(t) { return void 0 === t && (t = new h()), t.setTo(this.right, this.bottom, this.x, this.bottom), t; }, getLineD(t) { return void 0 === t && (t = new h()), t.setTo(this.x, this.bottom, this.x, this.y), t; }, left: { get() { return this.x; }, set(t) { t >= this.right ? this.width = 0 : this.width = this.right - t, this.x = t; } }, right: { get() { return this.x + this.width; }, set(t) { t <= this.x ? this.width = 0 : this.width = t - this.x; } }, top: { get() { return this.y; }, set(t) { t >= this.bottom ? this.height = 0 : this.height = this.bottom - t, this.y = t; } }, bottom: { get() { return this.y + this.height; }, set(t) { t <= this.y ? this.height = 0 : this.height = t - this.y; } }, centerX: { get() { return this.x + this.width / 2; }, set(t) { this.x = t - this.width / 2; } }, centerY: { get() { return this.y + this.height / 2; }, set(t) { this.y = t - this.height / 2; } },
  }); t.exports = u;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = {
    Alpha: i(562), AlphaSingle: i(292), Animation: i(293), BlendMode: i(296), ComputedSize: i(581), Crop: i(582), Depth: i(297), Flip: i(583), GetBounds: i(584), Mask: i(301), Origin: i(601), PathFollower: i(602), Pipeline: i(123), ScrollFactor: i(304), Size: i(603), Texture: i(604), TextureCrop: i(605), Tint: i(606), ToJSON: i(305), Transform: i(306), TransformMatrix: i(33), Visible: i(307),
  };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(305); const r = i(101); const o = i(10); const a = i(102); var h = new n({
    Extends: o, initialize(t, e) { o.call(this), this.scene = t, this.type = e, this.state = 0, this.parentContainer = null, this.name = '', this.active = !0, this.tabIndex = -1, this.data = null, this.renderFlags = 15, this.cameraFilter = 0, this.input = null, this.body = null, this.ignoreDestroy = !1, t.sys.queueDepthSort(); }, setActive(t) { return this.active = t, this; }, setName(t) { return this.name = t, this; }, setState(t) { return this.state = t, this; }, setDataEnabled() { return this.data || (this.data = new r(this)), this; }, setData(t, e) { return this.data || (this.data = new r(this)), this.data.set(t, e), this; }, incData(t, e) { return this.data || (this.data = new r(this)), this.data.inc(t, e), this; }, toggleData(t) { return this.data || (this.data = new r(this)), this.data.toggle(t), this; }, getData(t) { return this.data || (this.data = new r(this)), this.data.get(t); }, setInteractive(t, e, i) { return this.scene.sys.input.enable(this, t, e, i), this; }, disableInteractive() { return this.input && (this.input.enabled = !1), this; }, removeInteractive() { return this.scene.sys.input.clear(this), this.input = void 0, this; }, update() {}, toJSON() { return s(this); }, willRender(t) { return !(h.RENDER_MASK !== this.renderFlags || this.cameraFilter !== 0 && this.cameraFilter & t.id); }, getIndexList() { for (var t = this, e = this.parentContainer, i = []; e && (i.unshift(e.getIndex(t)), t = e, e.parentContainer);)e = e.parentContainer; return i.unshift(this.scene.sys.displayList.getIndex(t)), i; }, destroy(t) { if (void 0 === t && (t = !1), this.scene && !this.ignoreDestroy) { this.preDestroy && this.preDestroy.call(this), this.emit(a.DESTROY, this); const e = this.scene.sys; t || (e.displayList.remove(this), e.updateList.remove(this)), this.input && (e.input.clear(this), this.input = void 0), this.data && (this.data.destroy(), this.data = void 0), this.body && (this.body.destroy(), this.body = void 0), t || e.queueDepthSort(), this.active = !1, this.visible = !1, this.scene = void 0, this.parentContainer = void 0, this.removeAllListeners(); } },
  }); h.RENDER_MASK = 15, t.exports = h;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(185); const s = i(6); t.exports = function (t, e, i) { const r = s(t, e, null); if (r === null) return i; if (Array.isArray(r)) return n.RND.pick(r); if (typeof r === 'object') { if (r.hasOwnProperty('randInt')) return n.RND.integerInRange(r.randInt[0], r.randInt[1]); if (r.hasOwnProperty('randFloat')) return n.RND.realInRange(r.randFloat[0], r.randFloat[1]); } else if (typeof r === 'function') return r(e); return r; };
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const i = {
    PI2: 2 * Math.PI, TAU: 0.5 * Math.PI, EPSILON: 1e-6, DEG_TO_RAD: Math.PI / 180, RAD_TO_DEG: 180 / Math.PI, RND: null, MIN_SAFE_INTEGER: Number.MIN_SAFE_INTEGER || -9007199254740991, MAX_SAFE_INTEGER: Number.MAX_SAFE_INTEGER || 9007199254740991,
  }; t.exports = i;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(23); const r = i(24); const o = new n({
    initialize(t) { this.scene = t, this.systems = t.sys, this.displayList, this.updateList, t.sys.events.once(r.BOOT, this.boot, this), t.sys.events.on(r.START, this.start, this); }, boot() { this.displayList = this.systems.displayList, this.updateList = this.systems.updateList, this.systems.events.once(r.DESTROY, this.destroy, this); }, start() { this.systems.events.once(r.SHUTDOWN, this.shutdown, this); }, shutdown() { this.systems.events.off(r.SHUTDOWN, this.shutdown, this); }, destroy() { this.shutdown(), this.scene.sys.events.off(r.START, this.start, this), this.scene = null, this.systems = null, this.displayList = null, this.updateList = null; },
  }); o.register = function (t, e) { o.prototype.hasOwnProperty(t) || (o.prototype[t] = e); }, o.remove = function (t) { o.prototype.hasOwnProperty(t) && delete o.prototype[t]; }, s.register('GameObjectCreator', o, 'make'), t.exports = o;
}, function (t, e) {
  t.exports = {
    LOADER_IDLE: 0, LOADER_LOADING: 1, LOADER_PROCESSING: 2, LOADER_COMPLETE: 3, LOADER_SHUTDOWN: 4, LOADER_DESTROYED: 5, FILE_PENDING: 10, FILE_LOADING: 11, FILE_LOADED: 12, FILE_FAILED: 13, FILE_PROCESSING: 14, FILE_ERRORED: 16, FILE_COMPLETE: 17, FILE_DESTROYED: 18, FILE_POPULATED: 19,
  };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(8); var s = function () { let t; let e; let i; let r; let o; let a; let h = arguments[0] || {}; let l = 1; const u = arguments.length; let c = !1; for (typeof h === 'boolean' && (c = h, h = arguments[1] || {}, l = 2), u === l && (h = this, --l); l < u; l++) if ((t = arguments[l]) != null) for (e in t)i = h[e], h !== (r = t[e]) && (c && r && (n(r) || (o = Array.isArray(r))) ? (o ? (o = !1, a = i && Array.isArray(i) ? i : []) : a = i && n(i) ? i : {}, h[e] = s(c, a, r)) : void 0 !== r && (h[e] = r)); return h; }; t.exports = s;
}, function (t, e) { t.exports = function (t, e, i) { return Math.max(e, Math.min(i, t)); }; }, function (t, e) { const i = {}; t.exports = i, (function () { i._nextId = 0, i._seed = 0, i._nowStartTime = +new Date(), i.extend = function (t, e) { let n; let s; typeof e === 'boolean' ? (n = 2, s = e) : (n = 1, s = !0); for (let r = n; r < arguments.length; r++) { const o = arguments[r]; if (o) for (const a in o)s && o[a] && o[a].constructor === Object ? t[a] && t[a].constructor !== Object ? t[a] = o[a] : (t[a] = t[a] || {}, i.extend(t[a], s, o[a])) : t[a] = o[a]; } return t; }, i.clone = function (t, e) { return i.extend({}, e, t); }, i.keys = function (t) { if (Object.keys) return Object.keys(t); const e = []; for (const i in t)e.push(i); return e; }, i.values = function (t) { const e = []; if (Object.keys) { for (let i = Object.keys(t), n = 0; n < i.length; n++)e.push(t[i[n]]); return e; } for (const s in t)e.push(t[s]); return e; }, i.get = function (t, e, i, n) { e = e.split('.').slice(i, n); for (let s = 0; s < e.length; s += 1)t = t[e[s]]; return t; }, i.set = function (t, e, n, s, r) { const o = e.split('.').slice(s, r); return i.get(t, e, 0, -1)[o[o.length - 1]] = n, n; }, i.shuffle = function (t) { for (let e = t.length - 1; e > 0; e--) { const n = Math.floor(i.random() * (e + 1)); const s = t[e]; t[e] = t[n], t[n] = s; } return t; }, i.choose = function (t) { return t[Math.floor(i.random() * t.length)]; }, i.isElement = function (t) { return typeof HTMLElement !== 'undefined' ? t instanceof HTMLElement : !!(t && t.nodeType && t.nodeName); }, i.isArray = function (t) { return Object.prototype.toString.call(t) === '[object Array]'; }, i.isFunction = function (t) { return typeof t === 'function'; }, i.isPlainObject = function (t) { return typeof t === 'object' && t.constructor === Object; }, i.isString = function (t) { return Object.prototype.toString.call(t) === '[object String]'; }, i.clamp = function (t, e, i) { return t < e ? e : t > i ? i : t; }, i.sign = function (t) { return t < 0 ? -1 : 1; }, i.now = function () { if (typeof window !== 'undefined' && window.performance) { if (window.performance.now) return window.performance.now(); if (window.performance.webkitNow) return window.performance.webkitNow(); } return new Date() - i._nowStartTime; }, i.random = function (e, i) { return i = void 0 !== i ? i : 1, (e = void 0 !== e ? e : 0) + t() * (i - e); }; var t = function () { return i._seed = (9301 * i._seed + 49297) % 233280, i._seed / 233280; }; i.colorToNumber = function (t) { return (t = t.replace('#', '')).length == 3 && (t = t.charAt(0) + t.charAt(0) + t.charAt(1) + t.charAt(1) + t.charAt(2) + t.charAt(2)), parseInt(t, 16); }, i.logLevel = 1, i.log = function () { console && i.logLevel > 0 && i.logLevel <= 3 && console.log.apply(console, ['matter-js:'].concat(Array.prototype.slice.call(arguments))); }, i.info = function () { console && i.logLevel > 0 && i.logLevel <= 2 && console.info.apply(console, ['matter-js:'].concat(Array.prototype.slice.call(arguments))); }, i.warn = function () { console && i.logLevel > 0 && i.logLevel <= 3 && console.warn.apply(console, ['matter-js:'].concat(Array.prototype.slice.call(arguments))); }, i.nextId = function () { return i._nextId++; }, i.indexOf = function (t, e) { if (t.indexOf) return t.indexOf(e); for (let i = 0; i < t.length; i++) if (t[i] === e) return i; return -1; }, i.map = function (t, e) { if (t.map) return t.map(e); for (var i = [], n = 0; n < t.length; n += 1)i.push(e(t[n])); return i; }, i.topologicalSort = function (t) { const e = []; const n = []; const s = []; for (const r in t)n[r] || s[r] || i._topologicalSort(r, n, s, t, e); return e; }, i._topologicalSort = function (t, e, n, s, r) { const o = s[t] || []; n[t] = !0; for (let a = 0; a < o.length; a += 1) { const h = o[a]; n[h] || (e[h] || i._topologicalSort(h, e, n, s, r)); }n[t] = !1, e[t] = !0, r.push(t); }, i.chain = function () { for (var t = [], e = 0; e < arguments.length; e += 1) { const i = arguments[e]; i._chained ? t.push.apply(t, i._chained) : t.push(i); } const n = function () { for (var e, i = new Array(arguments.length), n = 0, s = arguments.length; n < s; n++)i[n] = arguments[n]; for (n = 0; n < t.length; n += 1) { const r = t[n].apply(e, i); void 0 !== r && (e = r); } return e; }; return n._chained = t, n; }, i.chainPathBefore = function (t, e, n) { return i.set(t, e, i.chain(n, i.get(t, e))); }, i.chainPathAfter = function (t, e, n) { return i.set(t, e, i.chain(i.get(t, e), n)); }; }()); }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = {
    BLUR: i(585), BOOT: i(586), CONTEXT_LOST: i(587), CONTEXT_RESTORED: i(588), DESTROY: i(589), FOCUS: i(590), HIDDEN: i(591), PAUSE: i(592), POST_RENDER: i(593), POST_STEP: i(594), PRE_RENDER: i(595), PRE_STEP: i(596), READY: i(597), RESUME: i(598), STEP: i(599), VISIBLE: i(600),
  };
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const i = {}; const n = {}; const s = {
    register(t, e, n, s) { void 0 === s && (s = !1), i[t] = { plugin: e, mapping: n, custom: s }; }, registerCustom(t, e, i, s) { n[t] = { plugin: e, mapping: i, data: s }; }, hasCore(t) { return i.hasOwnProperty(t); }, hasCustom(t) { return n.hasOwnProperty(t); }, getCore(t) { return i[t]; }, getCustom(t) { return n[t]; }, getCustomClass(t) { return n.hasOwnProperty(t) ? n[t].plugin : null; }, remove(t) { i.hasOwnProperty(t) && delete i[t]; }, removeCustom(t) { n.hasOwnProperty(t) && delete n[t]; }, destroyCorePlugins() { for (const t in i)i.hasOwnProperty(t) && delete i[t]; }, destroyCustomPlugins() { for (const t in n)n.hasOwnProperty(t) && delete n[t]; },
  }; t.exports = s;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = {
    BOOT: i(738), CREATE: i(739), DESTROY: i(740), PAUSE: i(741), POST_UPDATE: i(742), PRE_UPDATE: i(743), READY: i(744), RENDER: i(745), RESUME: i(746), SHUTDOWN: i(747), SLEEP: i(748), START: i(749), TRANSITION_COMPLETE: i(750), TRANSITION_INIT: i(751), TRANSITION_OUT: i(752), TRANSITION_START: i(753), TRANSITION_WAKE: i(754), UPDATE: i(755), WAKE: i(756),
  };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(18); const r = i(90); const o = i(2); const a = i(148); const h = i(233); const l = i(487); const u = i(149); const c = new n({
    initialize(t, e) { this.loader = t, this.cache = o(e, 'cache', !1), this.type = o(e, 'type', !1), this.key = o(e, 'key', !1); const i = this.key; if (t.prefix && t.prefix !== '' && (this.key = t.prefix + i), !this.type || !this.key) throw new Error(`Error calling 'Loader.${this.type}' invalid key provided.`); this.url = o(e, 'url'), void 0 === this.url ? this.url = `${t.path + i}.${o(e, 'extension', '')}` : typeof this.url !== 'function' && this.url.indexOf('blob:') !== 0 && this.url.indexOf('data:') !== 0 && (this.url = t.path + this.url), this.src = '', this.xhrSettings = u(o(e, 'responseType', void 0)), o(e, 'xhrSettings', !1) && (this.xhrSettings = h(this.xhrSettings, o(e, 'xhrSettings', {}))), this.xhrLoader = null, this.state = typeof this.url === 'function' ? s.FILE_POPULATED : s.FILE_PENDING, this.bytesTotal = 0, this.bytesLoaded = -1, this.percentComplete = -1, this.crossOrigin = void 0, this.data = void 0, this.config = o(e, 'config', {}), this.multiFile, this.linkFile; }, setLink(t) { this.linkFile = t, t.linkFile = this; }, resetXHR() { this.xhrLoader && (this.xhrLoader.onload = void 0, this.xhrLoader.onerror = void 0, this.xhrLoader.onprogress = void 0); }, load() { this.state === s.FILE_POPULATED ? this.loader.nextFile(this, !0) : (this.src = a(this, this.loader.baseURL), this.src.indexOf('data:') === 0 ? console.warn(`Local data URIs are not supported: ${this.key}`) : this.xhrLoader = l(this, this.loader.xhr)); }, onLoad(t, e) { const i = t.responseURL && t.responseURL.indexOf('file://') === 0 && e.target.status === 0; let n = !(e.target && e.target.status !== 200) || i; t.readyState === 4 && t.status >= 400 && t.status <= 599 && (n = !1), this.resetXHR(), this.loader.nextFile(this, n); }, onError() { this.resetXHR(), this.loader.nextFile(this, !1); }, onProgress(t) { t.lengthComputable && (this.bytesLoaded = t.loaded, this.bytesTotal = t.total, this.percentComplete = Math.min(this.bytesLoaded / this.bytesTotal, 1), this.loader.emit(r.FILE_PROGRESS, this, this.percentComplete)); }, onProcess() { this.state = s.FILE_PROCESSING, this.onProcessComplete(); }, onProcessComplete() { this.state = s.FILE_COMPLETE, this.multiFile && this.multiFile.onFileComplete(this), this.loader.fileProcessComplete(this); }, onProcessError() { this.state = s.FILE_ERRORED, this.multiFile && this.multiFile.onFileFailed(this), this.loader.fileProcessComplete(this); }, hasCacheConflict() { return this.cache && this.cache.exists(this.key); }, addToCache() { this.cache && this.cache.add(this.key, this.data), this.pendingDestroy(); }, pendingDestroy(t) { void 0 === t && (t = this.data); const e = this.key; const i = this.type; this.loader.emit(r.FILE_COMPLETE, e, i, t), this.loader.emit(`${r.FILE_KEY_COMPLETE + i}-${e}`, e, i, t), this.loader.flagForRemoval(this); }, destroy() { this.loader = null, this.cache = null, this.xhrSettings = null, this.multiFile = null, this.linkFile = null, this.data = null; },
  }); c.createObjectURL = function (t, e, i) { if (typeof URL === 'function')t.src = URL.createObjectURL(e); else { const n = new FileReader(); n.onload = function () { t.removeAttribute('crossOrigin'), t.src = `data:${e.type || i};base64,${n.result.split(',')[1]}`; }, n.onerror = t.onerror, n.readAsDataURL(e); } }, c.revokeObjectURL = function (t) { typeof URL === 'function' && URL.revokeObjectURL(t.src); }, t.exports = c;
}, function (t, e, i) {
  const n = {}; t.exports = n; const s = i(32); const r = i(37); const o = i(94); const a = i(21); const h = i(38); const l = i(151); !(function () {
    n._inertiaScale = 4, n._nextCollidingGroupId = 1, n._nextNonCollidingGroupId = -1, n._nextCategory = 1, n.create = function (e) {
      const i = {
        id: a.nextId(),
        type: 'body',
        label: 'Body',
        parts: [],
        plugin: {},
        angle: 0,
        vertices: null,
        position: { x: 0, y: 0 },
        force: { x: 0, y: 0 },
        torque: 0,
        positionImpulse: { x: 0, y: 0 },
        previousPositionImpulse: { x: 0, y: 0 },
        constraintImpulse: { x: 0, y: 0, angle: 0 },
        totalContacts: 0,
        speed: 0,
        angularSpeed: 0,
        velocity: { x: 0, y: 0 },
        angularVelocity: 0,
        isSensor: !1,
        isStatic: !1,
        isSleeping: !1,
        motion: 0,
        sleepThreshold: 60,
        density: 0.001,
        restitution: 0,
        friction: 0.1,
        frictionStatic: 0.5,
        frictionAir: 0.01,
        collisionFilter: { category: 1, mask: 4294967295, group: 0 },
        slop: 0.05,
        timeScale: 1,
        events: null,
        bounds: null,
        chamfer: null,
        circleRadius: 0,
        positionPrev: null,
        anglePrev: 0,
        parent: null,
        axes: null,
        area: 0,
        mass: 0,
        inverseMass: 0,
        inertia: 0,
        inverseInertia: 0,
        _original: null,
        render: {
          visible: !0, opacity: 1, sprite: { xOffset: 0, yOffset: 0 }, fillColor: null, fillOpacity: null, lineColor: null, lineOpacity: null, lineThickness: null,
        },
        gameObject: null,
        scale: { x: 1, y: 1 },
        centerOfMass: { x: 0, y: 0 },
        centerOffset: { x: 0, y: 0 },
        gravityScale: { x: 1, y: 1 },
        ignoreGravity: !1,
        ignorePointer: !1,
        onCollideCallback: null,
        onCollideEndCallback: null,
        onCollideActiveCallback: null,
        onCollideWith: {},
      }; !e.hasOwnProperty('position') && e.hasOwnProperty('vertices') ? e.position = s.centre(e.vertices) : e.hasOwnProperty('vertices') || (i.vertices = s.fromPath('L 0 0 L 40 0 L 40 40 L 0 40')); const n = a.extend(i, e); return t(n, e), n.setOnCollideWith = function (t, e) { return e ? this.onCollideWith[t.id] = e : delete this.onCollideWith[t.id], this; }, n;
    }, n.nextGroup = function (t) { return t ? n._nextNonCollidingGroupId-- : n._nextCollidingGroupId++; }, n.nextCategory = function () { return n._nextCategory <<= 1, n._nextCategory; }; var t = function (t, e) {
      e = e || {}, n.set(t, {
        bounds: t.bounds || h.create(t.vertices), positionPrev: t.positionPrev || r.clone(t.position), anglePrev: t.anglePrev || t.angle, vertices: t.vertices, parts: t.parts || [t], isStatic: t.isStatic, isSleeping: t.isSleeping, parent: t.parent || t,
      }); const i = t.bounds; if (s.rotate(t.vertices, t.angle, t.position), l.rotate(t.axes, t.angle), h.update(i, t.vertices, t.velocity), n.set(t, {
        axes: e.axes || t.axes, area: e.area || t.area, mass: e.mass || t.mass, inertia: e.inertia || t.inertia,
      }), t.parts.length === 1) { const o = t.centerOfMass; const a = t.centerOffset; const u = i.max.x - i.min.x; const c = i.max.y - i.min.y; o.x = -(i.min.x - t.position.x) / u, o.y = -(i.min.y - t.position.y) / c, a.x = u * o.x, a.y = c * o.y; }
    }; n.set = function (t, e, i) { let s; for (s in typeof e === 'string' && (s = e, (e = {})[s] = i), e) if (Object.prototype.hasOwnProperty.call(e, s)) switch (i = e[s], s) { case 'isStatic': n.setStatic(t, i); break; case 'isSleeping': o.set(t, i); break; case 'mass': n.setMass(t, i); break; case 'density': n.setDensity(t, i); break; case 'inertia': n.setInertia(t, i); break; case 'vertices': n.setVertices(t, i); break; case 'position': n.setPosition(t, i); break; case 'angle': n.setAngle(t, i); break; case 'velocity': n.setVelocity(t, i); break; case 'angularVelocity': n.setAngularVelocity(t, i); break; case 'parts': n.setParts(t, i); break; case 'centre': n.setCentre(t, i); break; default: t[s] = i; } }, n.setStatic = function (t, e) {
      for (let i = 0; i < t.parts.length; i++) {
        const n = t.parts[i]; n.isStatic = e, e ? (n._original = {
          restitution: n.restitution, friction: n.friction, mass: n.mass, inertia: n.inertia, density: n.density, inverseMass: n.inverseMass, inverseInertia: n.inverseInertia,
        }, n.restitution = 0, n.friction = 1, n.mass = n.inertia = n.density = 1 / 0, n.inverseMass = n.inverseInertia = 0, n.positionPrev.x = n.position.x, n.positionPrev.y = n.position.y, n.anglePrev = n.angle, n.angularVelocity = 0, n.speed = 0, n.angularSpeed = 0, n.motion = 0) : n._original && (n.restitution = n._original.restitution, n.friction = n._original.friction, n.mass = n._original.mass, n.inertia = n._original.inertia, n.density = n._original.density, n.inverseMass = n._original.inverseMass, n.inverseInertia = n._original.inverseInertia, n._original = null);
      }
    }, n.setMass = function (t, e) { const i = t.inertia / (t.mass / 6); t.inertia = i * (e / 6), t.inverseInertia = 1 / t.inertia, t.mass = e, t.inverseMass = 1 / t.mass, t.density = t.mass / t.area; }, n.setDensity = function (t, e) { n.setMass(t, e * t.area), t.density = e; }, n.setInertia = function (t, e) { t.inertia = e, t.inverseInertia = 1 / t.inertia; }, n.setVertices = function (t, e) { e[0].body === t ? t.vertices = e : t.vertices = s.create(e, t), t.axes = l.fromVertices(t.vertices), t.area = s.area(t.vertices), n.setMass(t, t.density * t.area); const i = s.centre(t.vertices); s.translate(t.vertices, i, -1), n.setInertia(t, n._inertiaScale * s.inertia(t.vertices, t.mass)), s.translate(t.vertices, t.position), h.update(t.bounds, t.vertices, t.velocity); }, n.setParts = function (t, e, i) { let r; for (e = e.slice(0), t.parts.length = 0, t.parts.push(t), t.parent = t, r = 0; r < e.length; r++) { const o = e[r]; o !== t && (o.parent = t, t.parts.push(o)); } if (t.parts.length !== 1) { if (i = void 0 === i || i) { let a = []; for (r = 0; r < e.length; r++)a = a.concat(e[r].vertices); s.clockwiseSort(a); const l = s.hull(a); const u = s.centre(l); n.setVertices(t, l), s.translate(t.vertices, u); } const c = n._totalProperties(t); const d = c.centre.x; const f = c.centre.y; const p = t.bounds; const g = t.centerOfMass; const v = t.centerOffset; h.update(p, t.vertices, t.velocity), g.x = -(p.min.x - d) / (p.max.x - p.min.x), g.y = -(p.min.y - f) / (p.max.y - p.min.y), v.x = d, v.y = f, t.area = c.area, t.parent = t, t.position.x = d, t.position.y = f, t.positionPrev.x = d, t.positionPrev.y = f, n.setMass(t, c.mass), n.setInertia(t, c.inertia), n.setPosition(t, c.centre); } }, n.setCentre = function (t, e, i) { i ? (t.positionPrev.x += e.x, t.positionPrev.y += e.y, t.position.x += e.x, t.position.y += e.y) : (t.positionPrev.x = e.x - (t.position.x - t.positionPrev.x), t.positionPrev.y = e.y - (t.position.y - t.positionPrev.y), t.position.x = e.x, t.position.y = e.y); }, n.setPosition = function (t, e) { const i = r.sub(e, t.position); t.positionPrev.x += i.x, t.positionPrev.y += i.y; for (let n = 0; n < t.parts.length; n++) { const o = t.parts[n]; o.position.x += i.x, o.position.y += i.y, s.translate(o.vertices, i), h.update(o.bounds, o.vertices, t.velocity); } }, n.setAngle = function (t, e) { const i = e - t.angle; t.anglePrev += i; for (let n = 0; n < t.parts.length; n++) { const o = t.parts[n]; o.angle += i, s.rotate(o.vertices, i, t.position), l.rotate(o.axes, i), h.update(o.bounds, o.vertices, t.velocity), n > 0 && r.rotateAbout(o.position, i, t.position, o.position); } }, n.setVelocity = function (t, e) { t.positionPrev.x = t.position.x - e.x, t.positionPrev.y = t.position.y - e.y, t.velocity.x = e.x, t.velocity.y = e.y, t.speed = r.magnitude(t.velocity); }, n.setAngularVelocity = function (t, e) { t.anglePrev = t.angle - e, t.angularVelocity = e, t.angularSpeed = Math.abs(t.angularVelocity); }, n.translate = function (t, e) { n.setPosition(t, r.add(t.position, e)); }, n.rotate = function (t, e, i) { if (i) { const s = Math.cos(e); const r = Math.sin(e); const o = t.position.x - i.x; const a = t.position.y - i.y; n.setPosition(t, { x: i.x + (o * s - a * r), y: i.y + (o * r + a * s) }), n.setAngle(t, t.angle + e); } else n.setAngle(t, t.angle + e); }, n.scale = function (t, e, i, r) { let o = 0; let a = 0; r = r || t.position; for (let u = 0; u < t.parts.length; u++) { const c = t.parts[u]; c.scale.x = e, c.scale.y = i, s.scale(c.vertices, e, i, r), c.axes = l.fromVertices(c.vertices), c.area = s.area(c.vertices), n.setMass(c, t.density * c.area), s.translate(c.vertices, { x: -c.position.x, y: -c.position.y }), n.setInertia(c, n._inertiaScale * s.inertia(c.vertices, c.mass)), s.translate(c.vertices, { x: c.position.x, y: c.position.y }), u > 0 && (o += c.area, a += c.inertia), c.position.x = r.x + (c.position.x - r.x) * e, c.position.y = r.y + (c.position.y - r.y) * i, h.update(c.bounds, c.vertices, t.velocity); }t.parts.length > 1 && (t.area = o, t.isStatic || (n.setMass(t, t.density * o), n.setInertia(t, a))), t.circleRadius && (e === i ? t.circleRadius *= e : t.circleRadius = null); }, n.update = function (t, e, i, n) { const o = Math.pow(e * i * t.timeScale, 2); const a = 1 - t.frictionAir * i * t.timeScale; const u = t.position.x - t.positionPrev.x; const c = t.position.y - t.positionPrev.y; t.velocity.x = u * a * n + t.force.x / t.mass * o, t.velocity.y = c * a * n + t.force.y / t.mass * o, t.positionPrev.x = t.position.x, t.positionPrev.y = t.position.y, t.position.x += t.velocity.x, t.position.y += t.velocity.y, t.angularVelocity = (t.angle - t.anglePrev) * a * n + t.torque / t.inertia * o, t.anglePrev = t.angle, t.angle += t.angularVelocity, t.speed = r.magnitude(t.velocity), t.angularSpeed = Math.abs(t.angularVelocity); for (let d = 0; d < t.parts.length; d++) { const f = t.parts[d]; s.translate(f.vertices, t.velocity), d > 0 && (f.position.x += t.velocity.x, f.position.y += t.velocity.y), t.angularVelocity !== 0 && (s.rotate(f.vertices, t.angularVelocity, t.position), l.rotate(f.axes, t.angularVelocity), d > 0 && r.rotateAbout(f.position, t.angularVelocity, t.position, f.position)), h.update(f.bounds, f.vertices, t.velocity); } }, n.applyForce = function (t, e, i) { t.force.x += i.x, t.force.y += i.y; const n = e.x - t.position.x; const s = e.y - t.position.y; t.torque += n * i.y - s * i.x; }, n._totalProperties = function (t) {
      for (var e = {
          mass: 0, area: 0, inertia: 0, centre: { x: 0, y: 0 },
        }, i = t.parts.length === 1 ? 0 : 1; i < t.parts.length; i++) { const n = t.parts[i]; const s = n.mass !== 1 / 0 ? n.mass : 1; e.mass += s, e.area += n.area, e.inertia += n.inertia, e.centre = r.add(e.centre, r.mult(n.position, s)); } return e.centre = r.div(e.centre, e.mass), e;
    };
  }());
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(2); t.exports = function (t, e, i, s, r, o) { void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = o.width), void 0 === s && (s = o.height); const a = n(r, 'isNotEmpty', !1); const h = n(r, 'isColliding', !1); const l = n(r, 'hasInterestingFace', !1); t < 0 && (i += t, t = 0), e < 0 && (s += e, e = 0), t + i > o.width && (i = Math.max(o.width - t, 0)), e + s > o.height && (s = Math.max(o.height - e, 0)); for (var u = [], c = e; c < e + s; c++) for (let d = t; d < t + i; d++) { const f = o.data[c][d]; if (f !== null) { if (a && f.index === -1) continue; if (h && !f.collides) continue; if (l && !f.hasInterestingFace) continue; u.push(f); } } return u; };
}, function (t, e) { t.exports = function (t, e, i, n, s, r) { let o; void 0 === n && (n = 0), void 0 === s && (s = 0), void 0 === r && (r = 1); let a = 0; const h = t.length; if (r === 1) for (o = s; o < h; o++)t[o][e] = i + a * n, a++; else for (o = s; o >= 0; o--)t[o][e] = i + a * n, a++; return t; }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(45); const s = i(15); t.exports = function (t, e, i) { e.x = s(i, 'x', 0), e.y = s(i, 'y', 0), e.depth = s(i, 'depth', 0), e.flipX = s(i, 'flipX', !1), e.flipY = s(i, 'flipY', !1); const r = s(i, 'scale', null); typeof r === 'number' ? e.setScale(r) : r !== null && (e.scaleX = s(r, 'x', 1), e.scaleY = s(r, 'y', 1)); const o = s(i, 'scrollFactor', null); typeof o === 'number' ? e.setScrollFactor(o) : o !== null && (e.scrollFactorX = s(o, 'x', 1), e.scrollFactorY = s(o, 'y', 1)), e.rotation = s(i, 'rotation', 0); const a = s(i, 'angle', null); a !== null && (e.angle = a), e.alpha = s(i, 'alpha', 1); const h = s(i, 'origin', null); if (typeof h === 'number')e.setOrigin(h); else if (h !== null) { const l = s(h, 'x', 0.5); const u = s(h, 'y', 0.5); e.setOrigin(l, u); } return e.blendMode = s(i, 'blendMode', n.NORMAL), e.visible = s(i, 'visible', !0), s(i, 'add', !0) && t.sys.displayList.add(e), e.preUpdate && t.sys.updateList.add(e), e; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  let n; let s; let r; const o = i(39); const a = i(182); const h = []; let l = !1; t.exports = (r = function () { let t = 0; return h.forEach(((e) => { e.parent && t++; })), t; }, {
    create2D(t, e, i) { return n(t, e, i, o.CANVAS); }, create: n = function (t, e, i, n, r) { let u; void 0 === e && (e = 1), void 0 === i && (i = 1), void 0 === n && (n = o.CANVAS), void 0 === r && (r = !1); let c = s(n); return c === null ? (c = { parent: t, canvas: document.createElement('canvas'), type: n }, n === o.CANVAS && h.push(c), u = c.canvas) : (c.parent = t, u = c.canvas), r && (c.parent = u), u.width = e, u.height = i, l && n === o.CANVAS && a.disable(u.getContext('2d')), u; }, createWebGL(t, e, i) { return n(t, e, i, o.WEBGL); }, disableSmoothing() { l = !0; }, enableSmoothing() { l = !1; }, first: s = function (t) { if (void 0 === t && (t = o.CANVAS), t === o.WEBGL) return null; for (let e = 0; e < h.length; e++) { const i = h[e]; if (!i.parent && i.type === t) return i; } return null; }, free() { return h.length - r(); }, pool: h, remove(t) { const e = t instanceof HTMLCanvasElement; h.forEach(((i) => { (e && i.canvas === t || !e && i.parent === t) && (i.parent = null, i.canvas.width = 1, i.canvas.height = 1); })); }, total: r,
  });
}, function (t, e) { t.exports = function (t, e, i, n, s) { const r = n.alpha * i.alpha; if (r <= 0) return !1; const o = t._tempMatrix1.copyFromArray(n.matrix.matrix); const a = t._tempMatrix2.applyITRS(i.x, i.y, i.rotation, i.scaleX, i.scaleY); const h = t._tempMatrix3; return s ? (o.multiplyWithOffset(s, -n.scrollX * i.scrollFactorX, -n.scrollY * i.scrollFactorY), a.e = i.x, a.f = i.y, o.multiply(a, h)) : (a.e -= n.scrollX * i.scrollFactorX, a.f -= n.scrollY * i.scrollFactorY, o.multiply(a, h)), e.globalCompositeOperation = t.blendModes[i.blendMode], e.globalAlpha = r, e.save(), h.setToContext(e), e.imageSmoothingEnabled = !(!t.antialias || i.frame && i.frame.source.scaleMode), !0; }; }, function (t, e, i) {
  const n = {}; t.exports = n; const s = i(37); const r = i(21); n.create = function (t, e) {
    for (var i = [], n = 0; n < t.length; n++) {
      const s = t[n]; const r = {
        x: s.x, y: s.y, index: n, body: e, isInternal: !1, contact: null, offset: null,
      }; r.contact = { vertex: r, normalImpulse: 0, tangentImpulse: 0 }, i.push(r);
    } return i;
  }, n.fromPath = function (t, e) { const i = []; return t.replace(/L?\s*([-\d.e]+)[\s,]*([-\d.e]+)*/gi, ((t, e, n) => { i.push({ x: parseFloat(e), y: parseFloat(n) }); })), n.create(i, e); }, n.centre = function (t) { for (var e, i, r, o = n.area(t, !0), a = { x: 0, y: 0 }, h = 0; h < t.length; h++)r = (h + 1) % t.length, e = s.cross(t[h], t[r]), i = s.mult(s.add(t[h], t[r]), e), a = s.add(a, i); return s.div(a, 6 * o); }, n.mean = function (t) { for (var e = { x: 0, y: 0 }, i = 0; i < t.length; i++)e.x += t[i].x, e.y += t[i].y; return s.div(e, t.length); }, n.area = function (t, e) { for (var i = 0, n = t.length - 1, s = 0; s < t.length; s++)i += (t[n].x - t[s].x) * (t[n].y + t[s].y), n = s; return e ? i / 2 : Math.abs(i) / 2; }, n.inertia = function (t, e) { for (var i, n, r = 0, o = 0, a = t, h = 0; h < a.length; h++)n = (h + 1) % a.length, r += (i = Math.abs(s.cross(a[n], a[h]))) * (s.dot(a[n], a[n]) + s.dot(a[n], a[h]) + s.dot(a[h], a[h])), o += i; return e / 6 * (r / o); }, n.translate = function (t, e, i) { let n; if (i) for (n = 0; n < t.length; n++)t[n].x += e.x * i, t[n].y += e.y * i; else for (n = 0; n < t.length; n++)t[n].x += e.x, t[n].y += e.y; return t; }, n.rotate = function (t, e, i) { if (e !== 0) { for (let n = Math.cos(e), s = Math.sin(e), r = 0; r < t.length; r++) { const o = t[r]; const a = o.x - i.x; const h = o.y - i.y; o.x = i.x + (a * n - h * s), o.y = i.y + (a * s + h * n); } return t; } }, n.contains = function (t, e) { for (let i = 0; i < t.length; i++) { const n = t[i]; const s = t[(i + 1) % t.length]; if ((e.x - n.x) * (s.y - n.y) + (e.y - n.y) * (n.x - s.x) > 0) return !1; } return !0; }, n.scale = function (t, e, i, r) { if (e === 1 && i === 1) return t; let o; let a; r = r || n.centre(t); for (let h = 0; h < t.length; h++)o = t[h], a = s.sub(o, r), t[h].x = r.x + a.x * e, t[h].y = r.y + a.y * i; return t; }, n.chamfer = function (t, e, i, n, o) { e = typeof e === 'number' ? [e] : e || [8], i = void 0 !== i ? i : -1, n = n || 2, o = o || 14; for (var a = [], h = 0; h < t.length; h++) { const l = t[h - 1 >= 0 ? h - 1 : t.length - 1]; const u = t[h]; const c = t[(h + 1) % t.length]; const d = e[h < e.length ? h : e.length - 1]; if (d !== 0) { const f = s.normalise({ x: u.y - l.y, y: l.x - u.x }); const p = s.normalise({ x: c.y - u.y, y: u.x - c.x }); const g = Math.sqrt(2 * Math.pow(d, 2)); const v = s.mult(r.clone(f), d); const m = s.normalise(s.mult(s.add(f, p), 0.5)); const y = s.sub(u, s.mult(m, g)); let x = i; i === -1 && (x = 1.75 * Math.pow(d, 0.32)), (x = r.clamp(x, n, o)) % 2 == 1 && (x += 1); for (let T = Math.acos(s.dot(f, p)) / x, w = 0; w < x; w++)a.push(s.add(s.rotate(v, T * w), y)); } else a.push(u); } return a; }, n.clockwiseSort = function (t) { const e = n.mean(t); return t.sort(((t, i) => s.angle(e, t) - s.angle(e, i))), t; }, n.isConvex = function (t) { let e; let i; let n; let s; let r = 0; const o = t.length; if (o < 3) return null; for (e = 0; e < o; e++) if (n = (e + 2) % o, s = (t[i = (e + 1) % o].x - t[e].x) * (t[n].y - t[i].y), (s -= (t[i].y - t[e].y) * (t[n].x - t[i].x)) < 0 ? r |= 1 : s > 0 && (r |= 2), r === 3) return !1; return r !== 0 || null; }, n.hull = function (t) { let e; let i; const n = []; const r = []; for ((t = t.slice(0)).sort(((t, e) => { const i = t.x - e.x; return i !== 0 ? i : t.y - e.y; })), i = 0; i < t.length; i += 1) { for (e = t[i]; r.length >= 2 && s.cross3(r[r.length - 2], r[r.length - 1], e) <= 0;)r.pop(); r.push(e); } for (i = t.length - 1; i >= 0; i -= 1) { for (e = t[i]; n.length >= 2 && s.cross3(n[n.length - 2], n[n.length - 1], e) <= 0;)n.pop(); n.push(e); } return n.pop(), r.pop(), n.concat(r); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(16); const r = i(3); const o = new n({
    initialize(t, e, i, n, s, r) {
      void 0 === t && (t = 1), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 1), void 0 === s && (s = 0), void 0 === r && (r = 0), this.matrix = new Float32Array([t, e, i, n, s, r, 0, 0, 1]), this.decomposedMatrix = {
        translateX: 0, translateY: 0, scaleX: 1, scaleY: 1, rotation: 0,
      };
    },
    a: { get() { return this.matrix[0]; }, set(t) { this.matrix[0] = t; } },
    b: { get() { return this.matrix[1]; }, set(t) { this.matrix[1] = t; } },
    c: { get() { return this.matrix[2]; }, set(t) { this.matrix[2] = t; } },
    d: { get() { return this.matrix[3]; }, set(t) { this.matrix[3] = t; } },
    e: { get() { return this.matrix[4]; }, set(t) { this.matrix[4] = t; } },
    f: { get() { return this.matrix[5]; }, set(t) { this.matrix[5] = t; } },
    tx: { get() { return this.matrix[4]; }, set(t) { this.matrix[4] = t; } },
    ty: { get() { return this.matrix[5]; }, set(t) { this.matrix[5] = t; } },
    rotation: { get() { return Math.acos(this.a / this.scaleX) * (Math.atan(-this.c / this.a) < 0 ? -1 : 1); } },
    rotationNormalized: { get() { const t = this.matrix; const e = t[0]; const i = t[1]; const n = t[2]; const r = t[3]; return e || i ? i > 0 ? Math.acos(e / this.scaleX) : -Math.acos(e / this.scaleX) : n || r ? s.TAU - (r > 0 ? Math.acos(-n / this.scaleY) : -Math.acos(n / this.scaleY)) : 0; } },
    scaleX: { get() { return Math.sqrt(this.a * this.a + this.b * this.b); } },
    scaleY: { get() { return Math.sqrt(this.c * this.c + this.d * this.d); } },
    loadIdentity() { const t = this.matrix; return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 1, t[4] = 0, t[5] = 0, this; },
    translate(t, e) { const i = this.matrix; return i[4] = i[0] * t + i[2] * e + i[4], i[5] = i[1] * t + i[3] * e + i[5], this; },
    scale(t, e) { const i = this.matrix; return i[0] *= t, i[1] *= t, i[2] *= e, i[3] *= e, this; },
    rotate(t) { const e = Math.sin(t); const i = Math.cos(t); const n = this.matrix; const s = n[0]; const r = n[1]; const o = n[2]; const a = n[3]; return n[0] = s * i + o * e, n[1] = r * i + a * e, n[2] = s * -e + o * i, n[3] = r * -e + a * i, this; },
    multiply(t, e) { const i = this.matrix; const n = t.matrix; const s = i[0]; const r = i[1]; const o = i[2]; const a = i[3]; const h = i[4]; const l = i[5]; const u = n[0]; const c = n[1]; const d = n[2]; const f = n[3]; const p = n[4]; const g = n[5]; const v = void 0 === e ? this : e; return v.a = u * s + c * o, v.b = u * r + c * a, v.c = d * s + f * o, v.d = d * r + f * a, v.e = p * s + g * o + h, v.f = p * r + g * a + l, v; },
    multiplyWithOffset(t, e, i) { const n = this.matrix; const s = t.matrix; const r = n[0]; const o = n[1]; const a = n[2]; const h = n[3]; const l = e * r + i * a + n[4]; const u = e * o + i * h + n[5]; const c = s[0]; const d = s[1]; const f = s[2]; const p = s[3]; const g = s[4]; const v = s[5]; return n[0] = c * r + d * a, n[1] = c * o + d * h, n[2] = f * r + p * a, n[3] = f * o + p * h, n[4] = g * r + v * a + l, n[5] = g * o + v * h + u, this; },
    transform(t, e, i, n, s, r) { const o = this.matrix; const a = o[0]; const h = o[1]; const l = o[2]; const u = o[3]; const c = o[4]; const d = o[5]; return o[0] = t * a + e * l, o[1] = t * h + e * u, o[2] = i * a + n * l, o[3] = i * h + n * u, o[4] = s * a + r * l + c, o[5] = s * h + r * u + d, this; },
    transformPoint(t, e, i) { void 0 === i && (i = { x: 0, y: 0 }); const n = this.matrix; const s = n[0]; const r = n[1]; const o = n[2]; const a = n[3]; const h = n[4]; const l = n[5]; return i.x = t * s + e * o + h, i.y = t * r + e * a + l, i; },
    invert() { const t = this.matrix; const e = t[0]; const i = t[1]; const n = t[2]; const s = t[3]; const r = t[4]; const o = t[5]; const a = e * s - i * n; return t[0] = s / a, t[1] = -i / a, t[2] = -n / a, t[3] = e / a, t[4] = (n * o - s * r) / a, t[5] = -(e * o - i * r) / a, this; },
    copyFrom(t) { const e = this.matrix; return e[0] = t.a, e[1] = t.b, e[2] = t.c, e[3] = t.d, e[4] = t.e, e[5] = t.f, this; },
    copyFromArray(t) { const e = this.matrix; return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], this; },
    copyToContext(t) { const e = this.matrix; return t.transform(e[0], e[1], e[2], e[3], e[4], e[5]), t; },
    setToContext(t) { const e = this.matrix; return t.setTransform(e[0], e[1], e[2], e[3], e[4], e[5]), t; },
    copyToArray(t) { const e = this.matrix; return void 0 === t ? t = [e[0], e[1], e[2], e[3], e[4], e[5]] : (t[0] = e[0], t[1] = e[1], t[2] = e[2], t[3] = e[3], t[4] = e[4], t[5] = e[5]), t; },
    setTransform(t, e, i, n, s, r) { const o = this.matrix; return o[0] = t, o[1] = e, o[2] = i, o[3] = n, o[4] = s, o[5] = r, this; },
    decomposeMatrix() { const t = this.decomposedMatrix; const e = this.matrix; const i = e[0]; const n = e[1]; const s = e[2]; const r = e[3]; const o = i * r - n * s; if (t.translateX = e[4], t.translateY = e[5], i || n) { const a = Math.sqrt(i * i + n * n); t.rotation = n > 0 ? Math.acos(i / a) : -Math.acos(i / a), t.scaleX = a, t.scaleY = o / a; } else if (s || r) { const h = Math.sqrt(s * s + r * r); t.rotation = 0.5 * Math.PI - (r > 0 ? Math.acos(-s / h) : -Math.acos(s / h)), t.scaleX = o / h, t.scaleY = h; } else t.rotation = 0, t.scaleX = 0, t.scaleY = 0; return t; },
    applyITRS(t, e, i, n, s) { const r = this.matrix; const o = Math.sin(i); const a = Math.cos(i); return r[4] = t, r[5] = e, r[0] = a * n, r[1] = o * n, r[2] = -o * s, r[3] = a * s, this; },
    applyInverse(t, e, i) { void 0 === i && (i = new r()); const n = this.matrix; const s = n[0]; const o = n[1]; const a = n[2]; const h = n[3]; const l = n[4]; const u = n[5]; const c = 1 / (s * h + a * -o); return i.x = h * c * t + -a * c * e + (u * a - l * h) * c, i.y = s * c * e + -o * c * t + (-u * s + l * o) * c, i; },
    getX(t, e) { return t * this.a + e * this.c + this.e; },
    getY(t, e) { return t * this.b + e * this.d + this.f; },
    getCSSMatrix() { const t = this.matrix; return `matrix(${t[0]},${t[1]},${t[2]},${t[3]},${t[4]},${t[5]})`; },
    destroy() { this.matrix = null, this.decomposedMatrix = null; },
  }); t.exports = o;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(13); const r = i(14); const o = i(62); const a = new n({
    Extends: r, Mixins: [s.AlphaSingle, s.BlendMode, s.ComputedSize, s.Depth, s.GetBounds, s.Mask, s.Origin, s.Pipeline, s.ScrollFactor, s.Transform, s.Visible], initialize(t, e, i) { void 0 === e && (e = 'Shape'), r.call(this, t, e), this.geom = i, this.pathData = [], this.pathIndexes = [], this.fillColor = 16777215, this.fillAlpha = 1, this.strokeColor = 16777215, this.strokeAlpha = 1, this.lineWidth = 1, this.isFilled = !1, this.isStroked = !1, this.closePath = !0, this._tempLine = new o(), this.initPipeline(); }, setFillStyle(t, e) { return void 0 === e && (e = 1), void 0 === t ? this.isFilled = !1 : (this.fillColor = t, this.fillAlpha = e, this.isFilled = !0), this; }, setStrokeStyle(t, e, i) { return void 0 === i && (i = 1), void 0 === t ? this.isStroked = !1 : (this.lineWidth = t, this.strokeColor = e, this.strokeAlpha = i, this.isStroked = !0), this; }, setClosePath(t) { return this.closePath = t, this; }, preDestroy() { this.geom = null, this._tempLine = null, this.pathData = [], this.pathIndexes = []; },
  }); t.exports = a;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(180); const r = i(319); const o = i(181); const a = i(320); var h = new n({
    initialize(t, e, i, n) { void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 255), this.r = 0, this.g = 0, this.b = 0, this.a = 255, this._h = 0, this._s = 0, this._v = 0, this._locked = !1, this.gl = [0, 0, 0, 1], this._color = 0, this._color32 = 0, this._rgba = '', this.setTo(t, e, i, n); }, transparent() { return this._locked = !0, this.red = 0, this.green = 0, this.blue = 0, this.alpha = 0, this._locked = !1, this.update(!0); }, setTo(t, e, i, n, s) { return void 0 === n && (n = 255), void 0 === s && (s = !0), this._locked = !0, this.red = t, this.green = e, this.blue = i, this.alpha = n, this._locked = !1, this.update(s); }, setGLTo(t, e, i, n) { return void 0 === n && (n = 1), this._locked = !0, this.redGL = t, this.greenGL = e, this.blueGL = i, this.alphaGL = n, this._locked = !1, this.update(!0); }, setFromRGB(t) { return this._locked = !0, this.red = t.r, this.green = t.g, this.blue = t.b, t.hasOwnProperty('a') && (this.alpha = t.a), this._locked = !1, this.update(!0); }, setFromHSV(t, e, i) { return o(t, e, i, this); }, update(t) { if (void 0 === t && (t = !1), this._locked) return this; const e = this.r; const i = this.g; const n = this.b; const o = this.a; return this._color = s(e, i, n), this._color32 = r(e, i, n, o), this._rgba = `rgba(${e},${i},${n},${o / 255})`, t && a(e, i, n, this), this; }, updateHSV() { const t = this.r; const e = this.g; const i = this.b; return a(t, e, i, this), this; }, clone() { return new h(this.r, this.g, this.b, this.a); }, gray(t) { return this.setTo(t, t, t); }, random(t, e) { void 0 === t && (t = 0), void 0 === e && (e = 255); const i = Math.floor(t + Math.random() * (e - t)); const n = Math.floor(t + Math.random() * (e - t)); const s = Math.floor(t + Math.random() * (e - t)); return this.setTo(i, n, s); }, randomGray(t, e) { void 0 === t && (t = 0), void 0 === e && (e = 255); const i = Math.floor(t + Math.random() * (e - t)); return this.setTo(i, i, i); }, saturate(t) { return this.s += t / 100, this; }, desaturate(t) { return this.s -= t / 100, this; }, lighten(t) { return this.v += t / 100, this; }, darken(t) { return this.v -= t / 100, this; }, brighten(t) { let e = this.r; let i = this.g; let n = this.b; return e = Math.max(0, Math.min(255, e - Math.round(-t / 100 * 255))), i = Math.max(0, Math.min(255, i - Math.round(-t / 100 * 255))), n = Math.max(0, Math.min(255, n - Math.round(-t / 100 * 255))), this.setTo(e, i, n); }, color: { get() { return this._color; } }, color32: { get() { return this._color32; } }, rgba: { get() { return this._rgba; } }, redGL: { get() { return this.gl[0]; }, set(t) { this.gl[0] = Math.min(Math.abs(t), 1), this.r = Math.floor(255 * this.gl[0]), this.update(!0); } }, greenGL: { get() { return this.gl[1]; }, set(t) { this.gl[1] = Math.min(Math.abs(t), 1), this.g = Math.floor(255 * this.gl[1]), this.update(!0); } }, blueGL: { get() { return this.gl[2]; }, set(t) { this.gl[2] = Math.min(Math.abs(t), 1), this.b = Math.floor(255 * this.gl[2]), this.update(!0); } }, alphaGL: { get() { return this.gl[3]; }, set(t) { this.gl[3] = Math.min(Math.abs(t), 1), this.a = Math.floor(255 * this.gl[3]), this.update(); } }, red: { get() { return this.r; }, set(t) { t = Math.floor(Math.abs(t)), this.r = Math.min(t, 255), this.gl[0] = t / 255, this.update(!0); } }, green: { get() { return this.g; }, set(t) { t = Math.floor(Math.abs(t)), this.g = Math.min(t, 255), this.gl[1] = t / 255, this.update(!0); } }, blue: { get() { return this.b; }, set(t) { t = Math.floor(Math.abs(t)), this.b = Math.min(t, 255), this.gl[2] = t / 255, this.update(!0); } }, alpha: { get() { return this.a; }, set(t) { t = Math.floor(Math.abs(t)), this.a = Math.min(t, 255), this.gl[3] = t / 255, this.update(); } }, h: { get() { return this._h; }, set(t) { this._h = t, o(t, this._s, this._v, this); } }, s: { get() { return this._s; }, set(t) { this._s = t, o(this._h, t, this._v, this); } }, v: { get() { return this._v; }, set(t) { this._v = t, o(this._h, this._s, t, this); } },
  }); t.exports = h;
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = {
    CSV: 0, TILED_JSON: 1, ARRAY_2D: 2, WELTMEISTER: 3,
  };
}, function (t, e) { const i = {}; t.exports = i, i.create = function (t, e) { return { x: t || 0, y: e || 0 }; }, i.clone = function (t) { return { x: t.x, y: t.y }; }, i.magnitude = function (t) { return Math.sqrt(t.x * t.x + t.y * t.y); }, i.magnitudeSquared = function (t) { return t.x * t.x + t.y * t.y; }, i.rotate = function (t, e, i) { const n = Math.cos(e); const s = Math.sin(e); i || (i = {}); const r = t.x * n - t.y * s; return i.y = t.x * s + t.y * n, i.x = r, i; }, i.rotateAbout = function (t, e, i, n) { const s = Math.cos(e); const r = Math.sin(e); n || (n = {}); const o = i.x + ((t.x - i.x) * s - (t.y - i.y) * r); return n.y = i.y + ((t.x - i.x) * r + (t.y - i.y) * s), n.x = o, n; }, i.normalise = function (t) { const e = i.magnitude(t); return e === 0 ? { x: 0, y: 0 } : { x: t.x / e, y: t.y / e }; }, i.dot = function (t, e) { return t.x * e.x + t.y * e.y; }, i.cross = function (t, e) { return t.x * e.y - t.y * e.x; }, i.cross3 = function (t, e, i) { return (e.x - t.x) * (i.y - t.y) - (e.y - t.y) * (i.x - t.x); }, i.add = function (t, e, i) { return i || (i = {}), i.x = t.x + e.x, i.y = t.y + e.y, i; }, i.sub = function (t, e, i) { return i || (i = {}), i.x = t.x - e.x, i.y = t.y - e.y, i; }, i.mult = function (t, e) { return { x: t.x * e, y: t.y * e }; }, i.div = function (t, e) { return { x: t.x / e, y: t.y / e }; }, i.perp = function (t, e) { return { x: (e = !0 === e ? -1 : 1) * -t.y, y: e * t.x }; }, i.neg = function (t) { return { x: -t.x, y: -t.y }; }, i.angle = function (t, e) { return Math.atan2(e.y - t.y, e.x - t.x); }, i._temp = [i.create(), i.create(), i.create(), i.create(), i.create(), i.create()]; }, function (t, e) { const i = {}; t.exports = i, i.create = function (t) { const e = { min: { x: 0, y: 0 }, max: { x: 0, y: 0 } }; return t && i.update(e, t), e; }, i.update = function (t, e, i) { t.min.x = 1 / 0, t.max.x = -1 / 0, t.min.y = 1 / 0, t.max.y = -1 / 0; for (let n = 0; n < e.length; n++) { const s = e[n]; s.x > t.max.x && (t.max.x = s.x), s.x < t.min.x && (t.min.x = s.x), s.y > t.max.y && (t.max.y = s.y), s.y < t.min.y && (t.min.y = s.y); }i && (i.x > 0 ? t.max.x += i.x : t.min.x += i.x, i.y > 0 ? t.max.y += i.y : t.min.y += i.y); }, i.contains = function (t, e) { return e.x >= t.min.x && e.x <= t.max.x && e.y >= t.min.y && e.y <= t.max.y; }, i.overlaps = function (t, e) { return t.min.x <= e.max.x && t.max.x >= e.min.x && t.max.y >= e.min.y && t.min.y <= e.max.y; }, i.translate = function (t, e) { t.min.x += e.x, t.max.x += e.x, t.min.y += e.y, t.max.y += e.y; }, i.shift = function (t, e) { const i = t.max.x - t.min.x; const n = t.max.y - t.min.y; t.min.x = e.x, t.max.x = e.x + i, t.min.y = e.y, t.max.y = e.y + n; }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = {
    VERSION: '3.23.0', BlendModes: i(45), ScaleModes: i(162), AUTO: 0, CANVAS: 1, WEBGL: 2, HEADLESS: 3, FOREVER: -1, NONE: 4, UP: 5, DOWN: 6, LEFT: 7, RIGHT: 8,
  }; t.exports = n;
}, function (t, e) { t.exports = function (t, e, i, n, s, r) { let o; void 0 === n && (n = 0), void 0 === s && (s = 0), void 0 === r && (r = 1); let a = 0; const h = t.length; if (r === 1) for (o = s; o < h; o++)t[o][e] += i + a * n, a++; else for (o = s; o >= 0; o--)t[o][e] += i + a * n, a++; return t; }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(16); t.exports = function (t) { return t * n.DEG_TO_RAD; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = {
    DESTROY: i(676), FADE_IN_COMPLETE: i(677), FADE_IN_START: i(678), FADE_OUT_COMPLETE: i(679), FADE_OUT_START: i(680), FLASH_COMPLETE: i(681), FLASH_START: i(682), PAN_COMPLETE: i(683), PAN_START: i(684), POST_RENDER: i(685), PRE_RENDER: i(686), ROTATE_COMPLETE: i(687), ROTATE_START: i(688), SHAKE_COMPLETE: i(689), SHAKE_START: i(690), ZOOM_COMPLETE: i(691), ZOOM_START: i(692),
  };
}, function (t, e) { t.exports = function (t, e, i, n) { const s = i || e.fillColor; const r = n || e.fillAlpha; const o = (16711680 & s) >>> 16; const a = (65280 & s) >>> 8; const h = 255 & s; t.fillStyle = `rgba(${o},${a},${h},${r})`; }; }, function (t, e, i) { const n = {}; t.exports = n; const s = i(32); const r = i(21); const o = i(26); const a = i(38); const h = i(37); const l = i(507); n.rectangle = function (t, e, i, n, a) { a = a || {}; const h = { label: 'Rectangle Body', position: { x: t, y: e }, vertices: s.fromPath(`L 0 0 L ${i} 0 L ${i} ${n} L 0 ${n}`) }; if (a.chamfer) { const l = a.chamfer; h.vertices = s.chamfer(h.vertices, l.radius, l.quality, l.qualityMin, l.qualityMax), delete a.chamfer; } return o.create(r.extend({}, h, a)); }, n.trapezoid = function (t, e, i, n, a, h) { h = h || {}; let l; const u = i * (a *= 0.5); const c = u + (1 - 2 * a) * i; const d = c + u; l = a < 0.5 ? `L 0 0 L ${u} ${-n} L ${c} ${-n} L ${d} 0` : `L 0 0 L ${c} ${-n} L ${d} 0`; const f = { label: 'Trapezoid Body', position: { x: t, y: e }, vertices: s.fromPath(l) }; if (h.chamfer) { const p = h.chamfer; f.vertices = s.chamfer(f.vertices, p.radius, p.quality, p.qualityMin, p.qualityMax), delete h.chamfer; } return o.create(r.extend({}, f, h)); }, n.circle = function (t, e, i, s, o) { s = s || {}; const a = { label: 'Circle Body', circleRadius: i }; o = o || 25; let h = Math.ceil(Math.max(10, Math.min(o, i))); return h % 2 == 1 && (h += 1), n.polygon(t, e, h, i, r.extend({}, a, s)); }, n.polygon = function (t, e, i, a, h) { if (h = h || {}, i < 3) return n.circle(t, e, a, h); for (var l = 2 * Math.PI / i, u = '', c = 0.5 * l, d = 0; d < i; d += 1) { const f = c + d * l; const p = Math.cos(f) * a; const g = Math.sin(f) * a; u += `L ${p.toFixed(3)} ${g.toFixed(3)} `; } const v = { label: 'Polygon Body', position: { x: t, y: e }, vertices: s.fromPath(u) }; if (h.chamfer) { const m = h.chamfer; v.vertices = s.chamfer(v.vertices, m.radius, m.quality, m.qualityMin, m.qualityMax), delete h.chamfer; } return o.create(r.extend({}, v, h)); }, n.fromVertices = function (t, e, i, a, h, u, c) { let d; let f; let p; let g; let v; let m; for (a = a || {}, f = [], h = void 0 !== h && h, u = void 0 !== u ? u : 0.01, c = void 0 !== c ? c : 10, l || r.warn('Bodies.fromVertices: poly-decomp.js required. Could not decompose vertices. Fallback to convex hull.'), r.isArray(i[0]) || (i = [i]), m = 0; m < i.length; m += 1) if (g = i[m], (p = s.isConvex(g)) || !l)g = p ? s.clockwiseSort(g) : s.hull(g), f.push({ position: { x: t, y: e }, vertices: g }); else { const y = g.map(((t) => [t.x, t.y])); l.makeCCW(y), !1 !== u && l.removeCollinearPoints(y, u); const x = l.quickDecomp(y); for (v = 0; v < x.length; v++) { const T = x[v].map(((t) => ({ x: t[0], y: t[1] }))); c > 0 && s.area(T) < c || f.push({ position: s.centre(T), vertices: T }); } } for (v = 0; v < f.length; v++)f[v] = o.create(r.extend(f[v], a)); return h && n.flagCoincidentParts(f, 5), f.length > 1 ? (d = o.create(r.extend({ parts: f.slice(0) }, a)), o.setPosition(d, { x: t, y: e }), d) : f[0]; }, n.flagCoincidentParts = function (t, e) { void 0 === e && (e = 5); for (let i = 0; i < t.length; i++) for (let n = t[i], s = i + 1; s < t.length; s++) { const r = t[s]; if (a.overlaps(n.bounds, r.bounds)) for (let o = n.vertices, l = r.vertices, u = 0; u < n.vertices.length; u++) for (let c = 0; c < r.vertices.length; c++) { const d = h.magnitudeSquared(h.sub(o[(u + 1) % o.length], l[c])); const f = h.magnitudeSquared(h.sub(o[u], l[(c + 1) % l.length])); d < e && f < e && (o[u].isInternal = !0, l[c].isInternal = !0); } } return t; }; }, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = {
    SKIP_CHECK: -1, NORMAL: 0, ADD: 1, MULTIPLY: 2, SCREEN: 3, OVERLAY: 4, DARKEN: 5, LIGHTEN: 6, COLOR_DODGE: 7, COLOR_BURN: 8, HARD_LIGHT: 9, SOFT_LIGHT: 10, DIFFERENCE: 11, EXCLUSION: 12, HUE: 13, SATURATION: 14, COLOR: 15, LUMINOSITY: 16, ERASE: 17, SOURCE_IN: 18, SOURCE_OUT: 19, SOURCE_ATOP: 20, DESTINATION_OVER: 21, DESTINATION_IN: 22, DESTINATION_OUT: 23, DESTINATION_ATOP: 24, LIGHTER: 25, COPY: 26, XOR: 27,
  };
}, function (t, e) { t.exports = function (t) { return t.y + t.height - t.height * t.originY; }; }, function (t, e) { t.exports = function (t, e) { return t.y = e + t.height * t.originY, t; }; }, function (t, e) { t.exports = function (t) { return t.x - t.width * t.originX; }; }, function (t, e) { t.exports = function (t, e) { return t.x = e + t.width * t.originX, t; }; }, function (t, e) { t.exports = function (t) { return t.x + t.width - t.width * t.originX; }; }, function (t, e) { t.exports = function (t, e) { return t.x = e - t.width + t.width * t.originX, t; }; }, function (t, e) { t.exports = function (t, e) { return t.y = e - t.height + t.height * t.originY, t; }; }, function (t, e) { t.exports = function (t) { return t.y - t.height * t.originY; }; }, function (t, e) {
  t.exports = {
    CIRCLE: 0, ELLIPSE: 1, LINE: 2, POINT: 3, POLYGON: 4, RECTANGLE: 5, TRIANGLE: 6,
  };
}, function (t, e) { t.exports = function (t, e, i) { return !(t.width <= 0 || t.height <= 0) && (t.x <= e && t.x + t.width >= e && t.y <= i && t.y + t.height >= i); }; }, function (t, e) { t.exports = function (t, e, i, n) { const s = t - i; const r = e - n; return Math.sqrt(s * s + r * r); }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = {
    BOOT: i(848), DESTROY: i(849), DRAG_END: i(850), DRAG_ENTER: i(851), DRAG: i(852), DRAG_LEAVE: i(853), DRAG_OVER: i(854), DRAG_START: i(855), DROP: i(856), GAME_OUT: i(857), GAME_OVER: i(858), GAMEOBJECT_DOWN: i(859), GAMEOBJECT_DRAG_END: i(860), GAMEOBJECT_DRAG_ENTER: i(861), GAMEOBJECT_DRAG: i(862), GAMEOBJECT_DRAG_LEAVE: i(863), GAMEOBJECT_DRAG_OVER: i(864), GAMEOBJECT_DRAG_START: i(865), GAMEOBJECT_DROP: i(866), GAMEOBJECT_MOVE: i(867), GAMEOBJECT_OUT: i(868), GAMEOBJECT_OVER: i(869), GAMEOBJECT_POINTER_DOWN: i(870), GAMEOBJECT_POINTER_MOVE: i(871), GAMEOBJECT_POINTER_OUT: i(872), GAMEOBJECT_POINTER_OVER: i(873), GAMEOBJECT_POINTER_UP: i(874), GAMEOBJECT_POINTER_WHEEL: i(875), GAMEOBJECT_UP: i(876), GAMEOBJECT_WHEEL: i(877), MANAGER_BOOT: i(878), MANAGER_PROCESS: i(879), MANAGER_UPDATE: i(880), POINTER_DOWN: i(881), POINTER_DOWN_OUTSIDE: i(882), POINTER_MOVE: i(883), POINTER_OUT: i(884), POINTER_OVER: i(885), POINTER_UP: i(886), POINTER_UP_OUTSIDE: i(887), POINTER_WHEEL: i(888), POINTERLOCK_CHANGE: i(889), PRE_UPDATE: i(890), SHUTDOWN: i(891), START: i(892), UPDATE: i(893),
  };
}, function (t, e) { t.exports = function (t, e, i, n) { const s = i || e.strokeColor; const r = n || e.strokeAlpha; const o = (16711680 & s) >>> 16; const a = (65280 & s) >>> 8; const h = 255 & s; t.strokeStyle = `rgba(${o},${a},${h},${r})`, t.lineWidth = e.lineWidth; }; }, function (t, e) {
  t.exports = {
    DYNAMIC_BODY: 0, STATIC_BODY: 1, GROUP: 2, TILEMAPLAYER: 3, FACING_NONE: 10, FACING_UP: 11, FACING_DOWN: 12, FACING_LEFT: 13, FACING_RIGHT: 14,
  };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(156); const s = i(27); t.exports = function (t, e, i, r, o) { for (let a = null, h = null, l = null, u = null, c = s(t, e, i, r, null, o), d = 0; d < c.length; d++) { const f = c[d]; f && (f.collides ? (a = n(f.x, f.y - 1, !0, o), h = n(f.x, f.y + 1, !0, o), l = n(f.x - 1, f.y, !0, o), u = n(f.x + 1, f.y, !0, o), f.faceTop = !a || !a.collides, f.faceBottom = !h || !h.collides, f.faceLeft = !l || !l.collides, f.faceRight = !u || !u.collides) : f.resetFaces()); } };
}, function (t, e) { t.exports = function (t, e, i) { return t.radius > 0 && e >= t.left && e <= t.right && i >= t.top && i <= t.bottom && (t.x - e) * (t.x - e) + (t.y - i) * (t.y - i) <= t.radius * t.radius; }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(299); const r = i(167); const o = i(54); const a = i(168); const h = i(3); const l = new n({
    initialize(t, e, i, n) { void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 0), this.type = o.LINE, this.x1 = t, this.y1 = e, this.x2 = i, this.y2 = n; }, getPoint(t, e) { return s(this, t, e); }, getPoints(t, e, i) { return r(this, t, e, i); }, getRandomPoint(t) { return a(this, t); }, setTo(t, e, i, n) { return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 0), this.x1 = t, this.y1 = e, this.x2 = i, this.y2 = n, this; }, getPointA(t) { return void 0 === t && (t = new h()), t.set(this.x1, this.y1), t; }, getPointB(t) { return void 0 === t && (t = new h()), t.set(this.x2, this.y2), t; }, left: { get() { return Math.min(this.x1, this.x2); }, set(t) { this.x1 <= this.x2 ? this.x1 = t : this.x2 = t; } }, right: { get() { return Math.max(this.x1, this.x2); }, set(t) { this.x1 > this.x2 ? this.x1 = t : this.x2 = t; } }, top: { get() { return Math.min(this.y1, this.y2); }, set(t) { this.y1 <= this.y2 ? this.y1 = t : this.y2 = t; } }, bottom: { get() { return Math.max(this.y1, this.y2); }, set(t) { this.y1 > this.y2 ? this.y1 = t : this.y2 = t; } },
  }); t.exports = l;
}, function (t, e) { t.exports = function (t) { return Math.sqrt((t.x2 - t.x1) * (t.x2 - t.x1) + (t.y2 - t.y1) * (t.y2 - t.y1)); }; }, function (t, e) { t.exports = function (t, e, i) { const n = i - e; return e + ((t - e) % n + n) % n; }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = {
    COMPLETE: i(916), DECODED: i(917), DECODED_ALL: i(918), DESTROY: i(919), DETUNE: i(920), GLOBAL_DETUNE: i(921), GLOBAL_MUTE: i(922), GLOBAL_RATE: i(923), GLOBAL_VOLUME: i(924), LOOP: i(925), LOOPED: i(926), MUTE: i(927), PAUSE_ALL: i(928), PAUSE: i(929), PLAY: i(930), RATE: i(931), RESUME_ALL: i(932), RESUME: i(933), SEEK: i(934), STOP_ALL: i(935), STOP: i(936), UNLOCKED: i(937), VOLUME: i(938),
  };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(13); const r = i(14); const o = i(997); const a = new n({
    Extends: r, Mixins: [s.Alpha, s.BlendMode, s.Depth, s.Flip, s.GetBounds, s.Mask, s.Origin, s.Pipeline, s.ScrollFactor, s.Size, s.TextureCrop, s.Tint, s.Transform, s.Visible, o], initialize(t, e, i, n, o) { r.call(this, t, 'Sprite'), this._crop = this.resetCropObject(), this.anims = new s.Animation(this), this.setTexture(n, o), this.setPosition(e, i), this.setSizeToFrame(), this.setOriginFromFrame(), this.initPipeline(); }, preUpdate(t, e) { this.anims.update(t, e); }, play(t, e, i) { return this.anims.play(t, e, i), this; }, toJSON() { return s.ToJSON(this); }, preDestroy() { this.anims.destroy(), this.anims = void 0; },
  }); t.exports = a;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(18); const r = i(25); const o = i(9); const a = i(2); const h = i(6); const l = i(8); const u = new n({
    Extends: r,
    initialize(t, e, i, n, o) {
      let u = 'json'; if (l(e)) { const c = e; e = a(c, 'key'), i = a(c, 'url'), n = a(c, 'xhrSettings'), u = a(c, 'extension', u), o = a(c, 'dataKey', o); } const d = {
        type: 'json', cache: t.cacheManager.json, extension: u, responseType: 'text', key: e, url: i, xhrSettings: n, config: o,
      }; r.call(this, t, d), l(i) && (this.data = o ? h(i, o) : i, this.state = s.FILE_POPULATED);
    },
    onProcess() { if (this.state !== s.FILE_POPULATED) { this.state = s.FILE_PROCESSING; const t = JSON.parse(this.xhrLoader.responseText); const e = this.config; this.data = typeof e === 'string' ? h(t, e, t) : t; } this.onProcessComplete(); },
  }); o.register('json', (function (t, e, i, n) { if (Array.isArray(t)) for (let s = 0; s < t.length; s++) this.addFile(new u(this, t[s])); else this.addFile(new u(this, t, e, n, i)); return this; })), t.exports = u;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = new (i(0))({
    initialize(t, e, i, n) { this.loader = t, this.type = e, this.key = i, this.multiKeyIndex = t.multiKeyIndex++, this.files = n, this.complete = !1, this.pending = n.length, this.failed = 0, this.config = {}, this.baseURL = t.baseURL, this.path = t.path, this.prefix = t.prefix; for (let s = 0; s < n.length; s++)n[s].multiFile = this; }, isReadyToProcess() { return this.pending === 0 && this.failed === 0 && !this.complete; }, addToMultiFile(t) { return this.files.push(t), t.multiFile = this, this.pending++, this.complete = !1, this; }, onFileComplete(t) { this.files.indexOf(t) !== -1 && this.pending--; }, onFileFailed(t) { this.files.indexOf(t) !== -1 && this.failed++; },
  }); t.exports = n;
}, function (t, e, i) {
  const n = {}; t.exports = n; const s = i(95); const r = i(21); const o = i(38); const a = i(26); n.create = function (t) {
    return r.extend({
      id: r.nextId(), type: 'composite', parent: null, isModified: !1, bodies: [], constraints: [], composites: [], label: 'Composite', plugin: {},
    }, t);
  }, n.setModified = function (t, e, i, r) { if (s.trigger(t, 'compositeModified', t), t.isModified = e, i && t.parent && n.setModified(t.parent, e, i, r), r) for (let o = 0; o < t.composites.length; o++) { const a = t.composites[o]; n.setModified(a, e, i, r); } }, n.add = function (t, e) { const i = [].concat(e); s.trigger(t, 'beforeAdd', { object: e }); for (let o = 0; o < i.length; o++) { const a = i[o]; switch (a.type) { case 'body': if (a.parent !== a) { r.warn('Composite.add: skipped adding a compound body part (you must add its parent instead)'); break; }n.addBody(t, a); break; case 'constraint': n.addConstraint(t, a); break; case 'composite': n.addComposite(t, a); break; case 'mouseConstraint': n.addConstraint(t, a.constraint); } } return s.trigger(t, 'afterAdd', { object: e }), t; }, n.remove = function (t, e, i) { const r = [].concat(e); s.trigger(t, 'beforeRemove', { object: e }); for (let o = 0; o < r.length; o++) { const a = r[o]; switch (a.type) { case 'body': n.removeBody(t, a, i); break; case 'constraint': n.removeConstraint(t, a, i); break; case 'composite': n.removeComposite(t, a, i); break; case 'mouseConstraint': n.removeConstraint(t, a.constraint); } } return s.trigger(t, 'afterRemove', { object: e }), t; }, n.addComposite = function (t, e) { return t.composites.push(e), e.parent = t, n.setModified(t, !0, !0, !1), t; }, n.removeComposite = function (t, e, i) { const s = t.composites.indexOf(e); if (s !== -1 && (n.removeCompositeAt(t, s), n.setModified(t, !0, !0, !1)), i) for (let r = 0; r < t.composites.length; r++)n.removeComposite(t.composites[r], e, !0); return t; }, n.removeCompositeAt = function (t, e) { return t.composites.splice(e, 1), n.setModified(t, !0, !0, !1), t; }, n.addBody = function (t, e) { return t.bodies.push(e), n.setModified(t, !0, !0, !1), t; }, n.removeBody = function (t, e, i) { const s = t.bodies.indexOf(e); if (s !== -1 && (n.removeBodyAt(t, s), n.setModified(t, !0, !0, !1)), i) for (let r = 0; r < t.composites.length; r++)n.removeBody(t.composites[r], e, !0); return t; }, n.removeBodyAt = function (t, e) { return t.bodies.splice(e, 1), n.setModified(t, !0, !0, !1), t; }, n.addConstraint = function (t, e) { return t.constraints.push(e), n.setModified(t, !0, !0, !1), t; }, n.removeConstraint = function (t, e, i) { const s = t.constraints.indexOf(e); if (s !== -1 && n.removeConstraintAt(t, s), i) for (let r = 0; r < t.composites.length; r++)n.removeConstraint(t.composites[r], e, !0); return t; }, n.removeConstraintAt = function (t, e) { return t.constraints.splice(e, 1), n.setModified(t, !0, !0, !1), t; }, n.clear = function (t, e, i) { if (i) for (let s = 0; s < t.composites.length; s++)n.clear(t.composites[s], e, !0); return e ? t.bodies = t.bodies.filter(((t) => t.isStatic)) : t.bodies.length = 0, t.constraints.length = 0, t.composites.length = 0, n.setModified(t, !0, !0, !1), t; }, n.allBodies = function (t) { for (var e = [].concat(t.bodies), i = 0; i < t.composites.length; i++)e = e.concat(n.allBodies(t.composites[i])); return e; }, n.allConstraints = function (t) { for (var e = [].concat(t.constraints), i = 0; i < t.composites.length; i++)e = e.concat(n.allConstraints(t.composites[i])); return e; }, n.allComposites = function (t) { for (var e = [].concat(t.composites), i = 0; i < t.composites.length; i++)e = e.concat(n.allComposites(t.composites[i])); return e; }, n.get = function (t, e, i) { let s; let r; switch (i) { case 'body': s = n.allBodies(t); break; case 'constraint': s = n.allConstraints(t); break; case 'composite': s = n.allComposites(t).concat(t); } return s ? (r = s.filter(((t) => t.id.toString() === e.toString()))).length === 0 ? null : r[0] : null; }, n.move = function (t, e, i) { return n.remove(t, e), n.add(i, e), t; }, n.rebase = function (t) { for (let e = n.allBodies(t).concat(n.allConstraints(t)).concat(n.allComposites(t)), i = 0; i < e.length; i++)e[i].id = r.nextId(); return n.setModified(t, !0, !0, !1), t; }, n.translate = function (t, e, i) { for (let s = i ? n.allBodies(t) : t.bodies, r = 0; r < s.length; r++)a.translate(s[r], e); return n.setModified(t, !0, !0, !1), t; }, n.rotate = function (t, e, i, s) { for (let r = Math.cos(e), o = Math.sin(e), h = s ? n.allBodies(t) : t.bodies, l = 0; l < h.length; l++) { const u = h[l]; const c = u.position.x - i.x; const d = u.position.y - i.y; a.setPosition(u, { x: i.x + (c * r - d * o), y: i.y + (c * o + d * r) }), a.rotate(u, e); } return n.setModified(t, !0, !0, !1), t; }, n.scale = function (t, e, i, s, r) { for (let o = r ? n.allBodies(t) : t.bodies, h = 0; h < o.length; h++) { const l = o[h]; const u = l.position.x - s.x; const c = l.position.y - s.y; a.setPosition(l, { x: s.x + u * e, y: s.y + c * i }), a.scale(l, e, i); } return n.setModified(t, !0, !0, !1), t; }, n.bounds = function (t) { for (var e = n.allBodies(t), i = [], s = 0; s < e.length; s += 1) { const r = e[s]; i.push(r.bounds.min, r.bounds.max); } return o.create(i); };
}, function (t, e) { t.exports = function (t, e, i, n) { void 0 === e && (e = !0); let s = n.baseTileWidth; const r = n.tilemapLayer; return r && (void 0 === i && (i = r.scene.cameras.main), t -= r.x + i.scrollX * (1 - r.scrollFactorX), s *= r.scaleX), e ? Math.floor(t / s) : t / s; }; }, function (t, e) { t.exports = function (t, e, i, n) { void 0 === e && (e = !0); let s = n.baseTileHeight; const r = n.tilemapLayer; return r && (void 0 === i && (i = r.scene.cameras.main), t -= r.y + i.scrollY * (1 - r.scrollFactorY), s *= r.scaleY), e ? Math.floor(t / s) : t / s; }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(61); const r = i(289); const o = i(290); const a = i(54); const h = i(164); const l = new n({
    initialize(t, e, i) { void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), this.type = a.CIRCLE, this.x = t, this.y = e, this._radius = i, this._diameter = 2 * i; }, contains(t, e) { return s(this, t, e); }, getPoint(t, e) { return r(this, t, e); }, getPoints(t, e, i) { return o(this, t, e, i); }, getRandomPoint(t) { return h(this, t); }, setTo(t, e, i) { return this.x = t, this.y = e, this._radius = i, this._diameter = 2 * i, this; }, setEmpty() { return this._radius = 0, this._diameter = 0, this; }, setPosition(t, e) { return void 0 === e && (e = t), this.x = t, this.y = e, this; }, isEmpty() { return this._radius <= 0; }, radius: { get() { return this._radius; }, set(t) { this._radius = t, this._diameter = 2 * t; } }, diameter: { get() { return this._diameter; }, set(t) { this._diameter = t, this._radius = 0.5 * t; } }, left: { get() { return this.x - this._radius; }, set(t) { this.x = t + this._radius; } }, right: { get() { return this.x + this._radius; }, set(t) { this.x = t - this._radius; } }, top: { get() { return this.y - this._radius; }, set(t) { this.y = t + this._radius; } }, bottom: { get() { return this.y + this._radius; }, set(t) { this.y = t - this._radius; } },
  }); t.exports = l;
}, function (t, e, i) {
  /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */function n(t, e, i) { i = i || 2; let n; let a; let h; let l; let u; let f; let g; const v = e && e.length; const m = v ? e[0] * i : t.length; let y = s(t, 0, m, i, !0); const x = []; if (!y || y.next === y.prev) return x; if (v && (y = (function (t, e, i, n) { let o; let a; let h; let l; let u; const f = []; for (o = 0, a = e.length; o < a; o++)h = e[o] * n, l = o < a - 1 ? e[o + 1] * n : t.length, (u = s(t, h, l, n, !1)) === u.next && (u.steiner = !0), f.push(p(u)); for (f.sort(c), o = 0; o < f.length; o++)d(f[o], i), i = r(i, i.next); return i; }(t, e, y, i))), t.length > 80 * i) { n = h = t[0], a = l = t[1]; for (let T = i; T < m; T += i)(u = t[T]) < n && (n = u), (f = t[T + 1]) < a && (a = f), u > h && (h = u), f > l && (l = f); g = (g = Math.max(h - n, l - a)) !== 0 ? 1 / g : 0; } return o(y, x, i, n, a, g), x; } function s(t, e, i, n, s) { let r; let o; if (s === A(t, e, i, n) > 0) for (r = e; r < i; r += n)o = b(r, t[r], t[r + 1], o); else for (r = i - n; r >= e; r -= n)o = b(r, t[r], t[r + 1], o); return o && y(o, o.next) && (E(o), o = o.next), o; } function r(t, e) { if (!t) return t; e || (e = t); let i; let n = t; do { if (i = !1, n.steiner || !y(n, n.next) && m(n.prev, n, n.next) !== 0)n = n.next; else { if (E(n), (n = e = n.prev) === n.next) break; i = !0; } } while (i || n !== e);return e; } function o(t, e, i, n, s, c, d) { if (t) { !d && c && (function (t, e, i, n) { let s = t; do { s.z === null && (s.z = f(s.x, s.y, e, i, n)), s.prevZ = s.prev, s.nextZ = s.next, s = s.next; } while (s !== t);s.prevZ.nextZ = null, s.prevZ = null, (function (t) { let e; let i; let n; let s; let r; let o; let a; let h; let l = 1; do { for (i = t, t = null, r = null, o = 0; i;) { for (o++, n = i, a = 0, e = 0; e < l && (a++, n = n.nextZ); e++);for (h = l; a > 0 || h > 0 && n;)a !== 0 && (h === 0 || !n || i.z <= n.z) ? (s = i, i = i.nextZ, a--) : (s = n, n = n.nextZ, h--), r ? r.nextZ = s : t = s, s.prevZ = r, r = s; i = n; }r.nextZ = null, l *= 2; } while (o > 1); }(s)); }(t, n, s, c)); for (var p, g, v = t; t.prev !== t.next;) if (p = t.prev, g = t.next, c ? h(t, n, s, c) : a(t))e.push(p.i / i), e.push(t.i / i), e.push(g.i / i), E(t), t = g.next, v = g.next; else if ((t = g) === v) { d ? d === 1 ? o(t = l(t, e, i), e, i, n, s, c, 2) : d === 2 && u(t, e, i, n, s, c) : o(r(t), e, i, n, s, c, 1); break; } } } function a(t) { const e = t.prev; const i = t; const n = t.next; if (m(e, i, n) >= 0) return !1; for (let s = t.next.next; s !== t.prev;) { if (g(e.x, e.y, i.x, i.y, n.x, n.y, s.x, s.y) && m(s.prev, s, s.next) >= 0) return !1; s = s.next; } return !0; } function h(t, e, i, n) { const s = t.prev; const r = t; const o = t.next; if (m(s, r, o) >= 0) return !1; for (var a = s.x < r.x ? s.x < o.x ? s.x : o.x : r.x < o.x ? r.x : o.x, h = s.y < r.y ? s.y < o.y ? s.y : o.y : r.y < o.y ? r.y : o.y, l = s.x > r.x ? s.x > o.x ? s.x : o.x : r.x > o.x ? r.x : o.x, u = s.y > r.y ? s.y > o.y ? s.y : o.y : r.y > o.y ? r.y : o.y, c = f(a, h, e, i, n), d = f(l, u, e, i, n), p = t.prevZ, v = t.nextZ; p && p.z >= c && v && v.z <= d;) { if (p !== t.prev && p !== t.next && g(s.x, s.y, r.x, r.y, o.x, o.y, p.x, p.y) && m(p.prev, p, p.next) >= 0) return !1; if (p = p.prevZ, v !== t.prev && v !== t.next && g(s.x, s.y, r.x, r.y, o.x, o.y, v.x, v.y) && m(v.prev, v, v.next) >= 0) return !1; v = v.nextZ; } for (;p && p.z >= c;) { if (p !== t.prev && p !== t.next && g(s.x, s.y, r.x, r.y, o.x, o.y, p.x, p.y) && m(p.prev, p, p.next) >= 0) return !1; p = p.prevZ; } for (;v && v.z <= d;) { if (v !== t.prev && v !== t.next && g(s.x, s.y, r.x, r.y, o.x, o.y, v.x, v.y) && m(v.prev, v, v.next) >= 0) return !1; v = v.nextZ; } return !0; } function l(t, e, i) { let n = t; do { const s = n.prev; const r = n.next.next; !y(s, r) && x(s, n, n.next, r) && T(s, r) && T(r, s) && (e.push(s.i / i), e.push(n.i / i), e.push(r.i / i), E(n), E(n.next), n = t = r), n = n.next; } while (n !== t);return n; } function u(t, e, i, n, s, a) { let h = t; do { for (let l = h.next.next; l !== h.prev;) { if (h.i !== l.i && v(h, l)) { let u = w(h, l); return h = r(h, h.next), u = r(u, u.next), o(h, e, i, n, s, a), void o(u, e, i, n, s, a); }l = l.next; }h = h.next; } while (h !== t); } function c(t, e) { return t.x - e.x; } function d(t, e) { if (e = (function (t, e) { let i; let n = e; const s = t.x; const r = t.y; let o = -1 / 0; do { if (r <= n.y && r >= n.next.y && n.next.y !== n.y) { const a = n.x + (r - n.y) * (n.next.x - n.x) / (n.next.y - n.y); if (a <= s && a > o) { if (o = a, a === s) { if (r === n.y) return n; if (r === n.next.y) return n.next; }i = n.x < n.next.x ? n : n.next; } }n = n.next; } while (n !== e);if (!i) return null; if (s === o) return i.prev; let h; const l = i; const u = i.x; const c = i.y; let d = 1 / 0; n = i.next; for (;n !== l;)s >= n.x && n.x >= u && s !== n.x && g(r < c ? s : o, r, u, c, r < c ? o : s, r, n.x, n.y) && ((h = Math.abs(r - n.y) / (s - n.x)) < d || h === d && n.x > i.x) && T(n, t) && (i = n, d = h), n = n.next; return i; }(t, e))) { const i = w(e, t); r(i, i.next); } } function f(t, e, i, n, s) { return (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = 32767 * (t - i) * s) | t << 8)) | t << 4)) | t << 2)) | t << 1)) | (e = 1431655765 & ((e = 858993459 & ((e = 252645135 & ((e = 16711935 & ((e = 32767 * (e - n) * s) | e << 8)) | e << 4)) | e << 2)) | e << 1)) << 1; } function p(t) { let e = t; let i = t; do { e.x < i.x && (i = e), e = e.next; } while (e !== t);return i; } function g(t, e, i, n, s, r, o, a) { return (s - o) * (e - a) - (t - o) * (r - a) >= 0 && (t - o) * (n - a) - (i - o) * (e - a) >= 0 && (i - o) * (r - a) - (s - o) * (n - a) >= 0; } function v(t, e) { return t.next.i !== e.i && t.prev.i !== e.i && !(function (t, e) { let i = t; do { if (i.i !== t.i && i.next.i !== t.i && i.i !== e.i && i.next.i !== e.i && x(i, i.next, t, e)) return !0; i = i.next; } while (i !== t);return !1; }(t, e)) && T(t, e) && T(e, t) && (function (t, e) { let i = t; let n = !1; const s = (t.x + e.x) / 2; const r = (t.y + e.y) / 2; do { i.y > r != i.next.y > r && i.next.y !== i.y && s < (i.next.x - i.x) * (r - i.y) / (i.next.y - i.y) + i.x && (n = !n), i = i.next; } while (i !== t);return n; }(t, e)); } function m(t, e, i) { return (e.y - t.y) * (i.x - e.x) - (e.x - t.x) * (i.y - e.y); } function y(t, e) { return t.x === e.x && t.y === e.y; } function x(t, e, i, n) { return !!(y(t, e) && y(i, n) || y(t, n) && y(i, e)) || m(t, e, i) > 0 != m(t, e, n) > 0 && m(i, n, t) > 0 != m(i, n, e) > 0; } function T(t, e) { return m(t.prev, t, t.next) < 0 ? m(t, e, t.next) >= 0 && m(t, t.prev, e) >= 0 : m(t, e, t.prev) < 0 || m(t, t.next, e) < 0; } function w(t, e) { const i = new S(t.i, t.x, t.y); const n = new S(e.i, e.x, e.y); const s = t.next; const r = e.prev; return t.next = e, e.prev = t, i.next = s, s.prev = i, n.next = i, i.prev = n, r.next = n, n.prev = r, n; } function b(t, e, i, n) { const s = new S(t, e, i); return n ? (s.next = n.next, s.prev = n, n.next.prev = s, n.next = s) : (s.prev = s, s.next = s), s; } function E(t) { t.next.prev = t.prev, t.prev.next = t.next, t.prevZ && (t.prevZ.nextZ = t.nextZ), t.nextZ && (t.nextZ.prevZ = t.prevZ); } function S(t, e, i) { this.i = t, this.x = e, this.y = i, this.prev = null, this.next = null, this.z = null, this.prevZ = null, this.nextZ = null, this.steiner = !1; } function A(t, e, i, n) { for (var s = 0, r = e, o = i - n; r < i; r += n)s += (t[o] - t[r]) * (t[r + 1] + t[o + 1]), o = r; return s; }t.exports = n, n.deviation = function (t, e, i, n) { const s = e && e.length; const r = s ? e[0] * i : t.length; let o = Math.abs(A(t, 0, r, i)); if (s) for (var a = 0, h = e.length; a < h; a++) { const l = e[a] * i; const u = a < h - 1 ? e[a + 1] * i : t.length; o -= Math.abs(A(t, l, u, i)); } let c = 0; for (a = 0; a < n.length; a += 3) { const d = n[a] * i; const f = n[a + 1] * i; const p = n[a + 2] * i; c += Math.abs((t[d] - t[p]) * (t[f + 1] - t[d + 1]) - (t[d] - t[f]) * (t[p + 1] - t[d + 1])); } return o === 0 && c === 0 ? 0 : Math.abs((c - o) / o); }, n.flatten = function (t) { for (var e = t[0][0].length, i = { vertices: [], holes: [], dimensions: e }, n = 0, s = 0; s < t.length; s++) { for (let r = 0; r < t[s].length; r++) for (let o = 0; o < e; o++)i.vertices.push(t[s][r][o]); s > 0 && (n += t[s - 1].length, i.holes.push(n)); } return i; };
}, function (t, e) { t.exports = function (t) { const e = {}; for (const i in t)Array.isArray(t[i]) ? e[i] = t[i].slice(0) : e[i] = t[i]; return e; }; }, function (t, e) { t.exports = function (t, e, i, n) { const s = t.length; if (e < 0 || e > s || e >= i || i > s || e + i > s) { if (n) throw new Error('Range Error: Values outside acceptable range'); return !1; } return !0; }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(125); const s = i(198); t.exports = function (t, e) { let i = n.Power0; if (typeof t === 'string') if (n.hasOwnProperty(t))i = n[t]; else { let r = ''; t.indexOf('.') && ((r = t.substr(t.indexOf('.') + 1)).toLowerCase() === 'in' ? r = 'easeIn' : r.toLowerCase() === 'out' ? r = 'easeOut' : r.toLowerCase() === 'inout' && (r = 'easeInOut')), t = s(t.substr(0, t.indexOf('.') + 1) + r), n.hasOwnProperty(t) && (i = n[t]); } else typeof t === 'function' ? i = t : Array.isArray(t) && t.length; if (!e) return i; const o = e.slice(0); return o.unshift(0), function (t) { return o[0] = t, i.apply(this, o); }; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(11); t.exports = function (t, e, i, s, r) { const o = t.strokeTint; const a = n.getTintAppendFloatAlphaAndSwap(e.strokeColor, e.strokeAlpha * i); o.TL = a, o.TR = a, o.BL = a, o.BR = a; const h = e.pathData; let l = h.length - 1; const u = e.lineWidth; const c = u / 2; let d = h[0] - s; let f = h[1] - r; e.closePath || (l -= 2); for (let p = 2; p < l; p += 2) { const g = h[p] - s; const v = h[p + 1] - r; t.setTexture2D(), t.batchLine(d, f, g, v, c, c, u, p - 2, !!e.closePath && p === l - 1), d = g, f = v; } };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(91); const r = i(457); const o = i(458); const a = i(54); const h = i(62); const l = i(173); const u = new n({
    initialize(t, e, i, n, s, r) { void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 0), void 0 === s && (s = 0), void 0 === r && (r = 0), this.type = a.TRIANGLE, this.x1 = t, this.y1 = e, this.x2 = i, this.y2 = n, this.x3 = s, this.y3 = r; }, contains(t, e) { return s(this, t, e); }, getPoint(t, e) { return r(this, t, e); }, getPoints(t, e, i) { return o(this, t, e, i); }, getRandomPoint(t) { return l(this, t); }, setTo(t, e, i, n, s, r) { return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 0), void 0 === s && (s = 0), void 0 === r && (r = 0), this.x1 = t, this.y1 = e, this.x2 = i, this.y2 = n, this.x3 = s, this.y3 = r, this; }, getLineA(t) { return void 0 === t && (t = new h()), t.setTo(this.x1, this.y1, this.x2, this.y2), t; }, getLineB(t) { return void 0 === t && (t = new h()), t.setTo(this.x2, this.y2, this.x3, this.y3), t; }, getLineC(t) { return void 0 === t && (t = new h()), t.setTo(this.x3, this.y3, this.x1, this.y1), t; }, left: { get() { return Math.min(this.x1, this.x2, this.x3); }, set(t) { let e = 0; e = this.x1 <= this.x2 && this.x1 <= this.x3 ? this.x1 - t : this.x2 <= this.x1 && this.x2 <= this.x3 ? this.x2 - t : this.x3 - t, this.x1 -= e, this.x2 -= e, this.x3 -= e; } }, right: { get() { return Math.max(this.x1, this.x2, this.x3); }, set(t) { let e = 0; e = this.x1 >= this.x2 && this.x1 >= this.x3 ? this.x1 - t : this.x2 >= this.x1 && this.x2 >= this.x3 ? this.x2 - t : this.x3 - t, this.x1 -= e, this.x2 -= e, this.x3 -= e; } }, top: { get() { return Math.min(this.y1, this.y2, this.y3); }, set(t) { let e = 0; e = this.y1 <= this.y2 && this.y1 <= this.y3 ? this.y1 - t : this.y2 <= this.y1 && this.y2 <= this.y3 ? this.y2 - t : this.y3 - t, this.y1 -= e, this.y2 -= e, this.y3 -= e; } }, bottom: { get() { return Math.max(this.y1, this.y2, this.y3); }, set(t) { let e = 0; e = this.y1 >= this.y2 && this.y1 >= this.y3 ? this.y1 - t : this.y2 >= this.y1 && this.y2 >= this.y3 ? this.y2 - t : this.y3 - t, this.y1 -= e, this.y2 -= e, this.y3 -= e; } },
  }); t.exports = u;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(18); const r = i(25); const o = i(9); const a = i(2); const h = i(8); const l = new n({
    Extends: r,
    initialize: function t(e, i, n, s, o) {
      let l; let u = 'png'; if (h(i)) { const c = i; i = a(c, 'key'), n = a(c, 'url'), l = a(c, 'normalMap'), s = a(c, 'xhrSettings'), u = a(c, 'extension', u), o = a(c, 'frameConfig'); }Array.isArray(n) && (l = n[1], n = n[0]); const d = {
        type: 'image', cache: e.textureManager, extension: u, responseType: 'blob', key: i, url: n, xhrSettings: s, config: o,
      }; if (r.call(this, e, d), l) { const f = new t(e, this.key, l, s, o); f.type = 'normalMap', this.setLink(f), e.addFile(f); }
    },
    onProcess() { this.state = s.FILE_PROCESSING, this.data = new Image(), this.data.crossOrigin = this.crossOrigin; const t = this; this.data.onload = function () { r.revokeObjectURL(t.data), t.onProcessComplete(); }, this.data.onerror = function () { r.revokeObjectURL(t.data), t.onProcessError(); }, r.createObjectURL(this.data, this.xhrLoader.response, 'image/png'); },
    addToCache() { let t; const e = this.linkFile; e && e.state === s.FILE_COMPLETE ? (t = this.type === 'image' ? this.cache.addImage(this.key, this.data, e.data) : this.cache.addImage(e.key, e.data, this.data), this.pendingDestroy(t), e.pendingDestroy(t)) : e || (t = this.cache.addImage(this.key, this.data), this.pendingDestroy(t)); },
  }); o.register('image', (function (t, e, i) { if (Array.isArray(t)) for (let n = 0; n < t.length; n++) this.addFile(new l(this, t[n])); else this.addFile(new l(this, t, e, i)); return this; })), t.exports = l;
}, function (t, e, i) {
  const n = {}; t.exports = n; const s = i(32); const r = i(37); const o = i(94); const a = i(38); const h = i(151); const l = i(21); n._warming = 0.4, n._torqueDampen = 1, n._minLength = 1e-6, n.create = function (t) {
    const e = t; e.bodyA && !e.pointA && (e.pointA = { x: 0, y: 0 }), e.bodyB && !e.pointB && (e.pointB = { x: 0, y: 0 }); const i = e.bodyA ? r.add(e.bodyA.position, e.pointA) : e.pointA; const n = e.bodyB ? r.add(e.bodyB.position, e.pointB) : e.pointB; const s = r.magnitude(r.sub(i, n)); e.length = void 0 !== e.length ? e.length : s, e.id = e.id || l.nextId(), e.label = e.label || 'Constraint', e.type = 'constraint', e.stiffness = e.stiffness || (e.length > 0 ? 1 : 0.7), e.damping = e.damping || 0, e.angularStiffness = e.angularStiffness || 0, e.angleA = e.bodyA ? e.bodyA.angle : e.angleA, e.angleB = e.bodyB ? e.bodyB.angle : e.angleB, e.plugin = {}; const o = {
      visible: !0, type: 'line', anchors: !0, lineColor: null, lineOpacity: null, lineThickness: null, pinSize: null, anchorColor: null, anchorSize: null,
    }; return e.length === 0 && e.stiffness > 0.1 ? (o.type = 'pin', o.anchors = !1) : e.stiffness < 0.9 && (o.type = 'spring'), e.render = l.extend(o, e.render), e;
  }, n.preSolveAll = function (t) { for (let e = 0; e < t.length; e += 1) { const i = t[e]; const n = i.constraintImpulse; i.isStatic || n.x === 0 && n.y === 0 && n.angle === 0 || (i.position.x += n.x, i.position.y += n.y, i.angle += n.angle); } }, n.solveAll = function (t, e) { for (var i = 0; i < t.length; i += 1) { var s = t[i]; var r = !s.bodyA || s.bodyA && s.bodyA.isStatic; var o = !s.bodyB || s.bodyB && s.bodyB.isStatic; (r || o) && n.solve(t[i], e); } for (i = 0; i < t.length; i += 1)r = !(s = t[i]).bodyA || s.bodyA && s.bodyA.isStatic, o = !s.bodyB || s.bodyB && s.bodyB.isStatic, r || o || n.solve(t[i], e); }, n.solve = function (t, e) { const i = t.bodyA; const s = t.bodyB; const o = t.pointA; const a = t.pointB; if (i || s) { i && !i.isStatic && (r.rotate(o, i.angle - t.angleA, o), t.angleA = i.angle), s && !s.isStatic && (r.rotate(a, s.angle - t.angleB, a), t.angleB = s.angle); let h = o; let l = a; if (i && (h = r.add(i.position, o)), s && (l = r.add(s.position, a)), h && l) { const u = r.sub(h, l); let c = r.magnitude(u); c < n._minLength && (c = n._minLength); let d; let f; let p; let g; let v; const m = (c - t.length) / c; const y = t.stiffness < 1 ? t.stiffness * e : t.stiffness; const x = r.mult(u, m * y); const T = (i ? i.inverseMass : 0) + (s ? s.inverseMass : 0); const w = T + ((i ? i.inverseInertia : 0) + (s ? s.inverseInertia : 0)); if (t.damping) { const b = r.create(); p = r.div(u, c), v = r.sub(s && r.sub(s.position, s.positionPrev) || b, i && r.sub(i.position, i.positionPrev) || b), g = r.dot(p, v); }i && !i.isStatic && (f = i.inverseMass / T, i.constraintImpulse.x -= x.x * f, i.constraintImpulse.y -= x.y * f, i.position.x -= x.x * f, i.position.y -= x.y * f, t.damping && (i.positionPrev.x -= t.damping * p.x * g * f, i.positionPrev.y -= t.damping * p.y * g * f), d = r.cross(o, x) / w * n._torqueDampen * i.inverseInertia * (1 - t.angularStiffness), i.constraintImpulse.angle -= d, i.angle -= d), s && !s.isStatic && (f = s.inverseMass / T, s.constraintImpulse.x += x.x * f, s.constraintImpulse.y += x.y * f, s.position.x += x.x * f, s.position.y += x.y * f, t.damping && (s.positionPrev.x += t.damping * p.x * g * f, s.positionPrev.y += t.damping * p.y * g * f), d = r.cross(a, x) / w * n._torqueDampen * s.inverseInertia * (1 - t.angularStiffness), s.constraintImpulse.angle += d, s.angle += d); } } }, n.postSolveAll = function (t) { for (let e = 0; e < t.length; e++) { const i = t[e]; const l = i.constraintImpulse; if (!(i.isStatic || l.x === 0 && l.y === 0 && l.angle === 0)) { o.set(i, !1); for (let u = 0; u < i.parts.length; u++) { const c = i.parts[u]; s.translate(c.vertices, l), u > 0 && (c.position.x += l.x, c.position.y += l.y), l.angle !== 0 && (s.rotate(c.vertices, l.angle, i.position), h.rotate(c.axes, l.angle), u > 0 && r.rotateAbout(c.position, l.angle, i.position, c.position)), a.update(c.bounds, c.vertices, i.velocity); }l.angle *= n._warming, l.x *= n._warming, l.y *= n._warming; } } }, n.pointAWorld = function (t) { return { x: (t.bodyA ? t.bodyA.position.x : 0) + t.pointA.x, y: (t.bodyA ? t.bodyA.position.y : 0) + t.pointA.y }; }, n.pointBWorld = function (t) { return { x: (t.bodyB ? t.bodyB.position.x : 0) + t.pointB.x, y: (t.bodyB ? t.bodyB.position.y : 0) + t.pointB.y }; };
}, function (t, e) { t.exports = function (t, e) { e ? t.setCollision(!0, !0, !0, !0, !1) : t.resetCollision(!1); }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(13); const r = i(476); const o = new n({
    Mixins: [s.Alpha, s.Flip, s.Visible], initialize(t, e, i, n, s, r, o, a) { this.layer = t, this.index = e, this.x = i, this.y = n, this.width = s, this.height = r, this.baseWidth = void 0 !== o ? o : s, this.baseHeight = void 0 !== a ? a : r, this.pixelX = 0, this.pixelY = 0, this.updatePixelXY(), this.properties = {}, this.rotation = 0, this.collideLeft = !1, this.collideRight = !1, this.collideUp = !1, this.collideDown = !1, this.faceLeft = !1, this.faceRight = !1, this.faceTop = !1, this.faceBottom = !1, this.collisionCallback = null, this.collisionCallbackContext = this, this.tint = 16777215, this.physics = {}; }, containsPoint(t, e) { return !(t < this.pixelX || e < this.pixelY || t > this.right || e > this.bottom); }, copy(t) { return this.index = t.index, this.alpha = t.alpha, this.properties = t.properties, this.visible = t.visible, this.setFlip(t.flipX, t.flipY), this.tint = t.tint, this.rotation = t.rotation, this.collideUp = t.collideUp, this.collideDown = t.collideDown, this.collideLeft = t.collideLeft, this.collideRight = t.collideRight, this.collisionCallback = t.collisionCallback, this.collisionCallbackContext = t.collisionCallbackContext, this; }, getCollisionGroup() { return this.tileset ? this.tileset.getTileCollisionGroup(this.index) : null; }, getTileData() { return this.tileset ? this.tileset.getTileData(this.index) : null; }, getLeft(t) { const e = this.tilemapLayer; return e ? e.tileToWorldX(this.x, t) : this.x * this.baseWidth; }, getRight(t) { const e = this.tilemapLayer; return e ? this.getLeft(t) + this.width * e.scaleX : this.getLeft(t) + this.width; }, getTop(t) { const e = this.tilemapLayer; return e ? e.tileToWorldY(this.y, t) - (this.height - this.baseHeight) * e.scaleY : this.y * this.baseHeight - (this.height - this.baseHeight); }, getBottom(t) { const e = this.tilemapLayer; return e ? this.getTop(t) + this.height * e.scaleY : this.getTop(t) + this.height; }, getBounds(t, e) { return void 0 === e && (e = new r()), e.x = this.getLeft(), e.y = this.getTop(), e.width = this.getRight() - e.x, e.height = this.getBottom() - e.y, e; }, getCenterX(t) { return (this.getLeft(t) + this.getRight(t)) / 2; }, getCenterY(t) { return (this.getTop(t) + this.getBottom(t)) / 2; }, destroy() { this.collisionCallback = void 0, this.collisionCallbackContext = void 0, this.properties = void 0; }, intersects(t, e, i, n) { return !(i <= this.pixelX || n <= this.pixelY || t >= this.right || e >= this.bottom); }, isInteresting(t, e) { return t && e ? this.canCollide || this.hasInterestingFace : t ? this.collides : !!e && this.hasInterestingFace; }, resetCollision(t) { (void 0 === t && (t = !0), this.collideLeft = !1, this.collideRight = !1, this.collideUp = !1, this.collideDown = !1, this.faceTop = !1, this.faceBottom = !1, this.faceLeft = !1, this.faceRight = !1, t) && (this.tilemapLayer && this.tilemapLayer.calculateFacesAt(this.x, this.y)); return this; }, resetFaces() { return this.faceTop = !1, this.faceBottom = !1, this.faceLeft = !1, this.faceRight = !1, this; }, setCollision(t, e, i, n, s) { (void 0 === e && (e = t), void 0 === i && (i = t), void 0 === n && (n = t), void 0 === s && (s = !0), this.collideLeft = t, this.collideRight = e, this.collideUp = i, this.collideDown = n, this.faceLeft = t, this.faceRight = e, this.faceTop = i, this.faceBottom = n, s) && (this.tilemapLayer && this.tilemapLayer.calculateFacesAt(this.x, this.y)); return this; }, setCollisionCallback(t, e) { return t === null ? (this.collisionCallback = void 0, this.collisionCallbackContext = void 0) : (this.collisionCallback = t, this.collisionCallbackContext = e), this; }, setSize(t, e, i, n) { return void 0 !== t && (this.width = t), void 0 !== e && (this.height = e), void 0 !== i && (this.baseWidth = i), void 0 !== n && (this.baseHeight = n), this.updatePixelXY(), this; }, updatePixelXY() { return this.pixelX = this.x * this.baseWidth, this.pixelY = this.y * this.baseHeight, this; }, canCollide: { get() { return this.collideLeft || this.collideRight || this.collideUp || this.collideDown || this.collisionCallback; } }, collides: { get() { return this.collideLeft || this.collideRight || this.collideUp || this.collideDown; } }, hasInterestingFace: { get() { return this.faceTop || this.faceBottom || this.faceLeft || this.faceRight; } }, tileset: { get() { const t = this.layer.tilemapLayer; if (t) { const e = t.gidMap[this.index]; if (e) return e; } return null; } }, tilemapLayer: { get() { return this.layer.tilemapLayer; } }, tilemap: { get() { const t = this.tilemapLayer; return t ? t.tilemap : null; } },
  }); t.exports = o;
}, function (t, e) { t.exports = function (t) { return t.x - t.width * t.originX + 0.5 * t.width; }; }, function (t, e) { t.exports = function (t, e) { const i = t.width * t.originX; return t.x = e + i - 0.5 * t.width, t; }; }, function (t, e) { t.exports = function (t) { return t.y - t.height * t.originY + 0.5 * t.height; }; }, function (t, e) { t.exports = function (t, e) { const i = t.height * t.originY; return t.y = e + i - 0.5 * t.height, t; }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  var n = new (i(0))({
    initialize(t, e, i) { this.x = 0, this.y = 0, this.z = 0, typeof t === 'object' ? (this.x = t.x || 0, this.y = t.y || 0, this.z = t.z || 0) : (this.x = t || 0, this.y = e || 0, this.z = i || 0); }, up() { return this.x = 0, this.y = 1, this.z = 0, this; }, clone() { return new n(this.x, this.y, this.z); }, crossVectors(t, e) { const i = t.x; const n = t.y; const s = t.z; const r = e.x; const o = e.y; const a = e.z; return this.x = n * a - s * o, this.y = s * r - i * a, this.z = i * o - n * r, this; }, equals(t) { return this.x === t.x && this.y === t.y && this.z === t.z; }, copy(t) { return this.x = t.x, this.y = t.y, this.z = t.z || 0, this; }, set(t, e, i) { return typeof t === 'object' ? (this.x = t.x || 0, this.y = t.y || 0, this.z = t.z || 0) : (this.x = t || 0, this.y = e || 0, this.z = i || 0), this; }, add(t) { return this.x += t.x, this.y += t.y, this.z += t.z || 0, this; }, subtract(t) { return this.x -= t.x, this.y -= t.y, this.z -= t.z || 0, this; }, multiply(t) { return this.x *= t.x, this.y *= t.y, this.z *= t.z || 1, this; }, scale(t) { return isFinite(t) ? (this.x *= t, this.y *= t, this.z *= t) : (this.x = 0, this.y = 0, this.z = 0), this; }, divide(t) { return this.x /= t.x, this.y /= t.y, this.z /= t.z || 1, this; }, negate() { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this; }, distance(t) { const e = t.x - this.x; const i = t.y - this.y; const n = t.z - this.z || 0; return Math.sqrt(e * e + i * i + n * n); }, distanceSq(t) { const e = t.x - this.x; const i = t.y - this.y; const n = t.z - this.z || 0; return e * e + i * i + n * n; }, length() { const t = this.x; const e = this.y; const i = this.z; return Math.sqrt(t * t + e * e + i * i); }, lengthSq() { const t = this.x; const e = this.y; const i = this.z; return t * t + e * e + i * i; }, normalize() { const t = this.x; const e = this.y; const i = this.z; let n = t * t + e * e + i * i; return n > 0 && (n = 1 / Math.sqrt(n), this.x = t * n, this.y = e * n, this.z = i * n), this; }, dot(t) { return this.x * t.x + this.y * t.y + this.z * t.z; }, cross(t) { const e = this.x; const i = this.y; const n = this.z; const s = t.x; const r = t.y; const o = t.z; return this.x = i * o - n * r, this.y = n * s - e * o, this.z = e * r - i * s, this; }, lerp(t, e) { void 0 === e && (e = 0); const i = this.x; const n = this.y; const s = this.z; return this.x = i + e * (t.x - i), this.y = n + e * (t.y - n), this.z = s + e * (t.z - s), this; }, transformMat3(t) { const e = this.x; const i = this.y; const n = this.z; const s = t.val; return this.x = e * s[0] + i * s[3] + n * s[6], this.y = e * s[1] + i * s[4] + n * s[7], this.z = e * s[2] + i * s[5] + n * s[8], this; }, transformMat4(t) { const e = this.x; const i = this.y; const n = this.z; const s = t.val; return this.x = s[0] * e + s[4] * i + s[8] * n + s[12], this.y = s[1] * e + s[5] * i + s[9] * n + s[13], this.z = s[2] * e + s[6] * i + s[10] * n + s[14], this; }, transformCoordinates(t) { const e = this.x; const i = this.y; const n = this.z; const s = t.val; const r = e * s[0] + i * s[4] + n * s[8] + s[12]; const o = e * s[1] + i * s[5] + n * s[9] + s[13]; const a = e * s[2] + i * s[6] + n * s[10] + s[14]; const h = e * s[3] + i * s[7] + n * s[11] + s[15]; return this.x = r / h, this.y = o / h, this.z = a / h, this; }, transformQuat(t) { const e = this.x; const i = this.y; const n = this.z; const s = t.x; const r = t.y; const o = t.z; const a = t.w; const h = a * e + r * n - o * i; const l = a * i + o * e - s * n; const u = a * n + s * i - r * e; const c = -s * e - r * i - o * n; return this.x = h * a + c * -s + l * -o - u * -r, this.y = l * a + c * -r + u * -s - h * -o, this.z = u * a + c * -o + h * -r - l * -s, this; }, project(t) { const e = this.x; const i = this.y; const n = this.z; const s = t.val; const r = s[0]; const o = s[1]; const a = s[2]; const h = s[3]; const l = s[4]; const u = s[5]; const c = s[6]; const d = s[7]; const f = s[8]; const p = s[9]; const g = s[10]; const v = s[11]; const m = s[12]; const y = s[13]; const x = s[14]; const T = 1 / (e * h + i * d + n * v + s[15]); return this.x = (e * r + i * l + n * f + m) * T, this.y = (e * o + i * u + n * p + y) * T, this.z = (e * a + i * c + n * g + x) * T, this; }, unproject(t, e) { const i = t.x; const n = t.y; const s = t.z; const r = t.w; const o = this.x - i; const a = r - this.y - 1 - n; const h = this.z; return this.x = 2 * o / s - 1, this.y = 2 * a / r - 1, this.z = 2 * h - 1, this.project(e); }, reset() { return this.x = 0, this.y = 0, this.z = 0, this; },
  }); n.ZERO = new n(), n.RIGHT = new n(1, 0, 0), n.LEFT = new n(-1, 0, 0), n.UP = new n(0, -1, 0), n.DOWN = new n(0, 1, 0), n.FORWARD = new n(0, 0, 1), n.BACK = new n(0, 0, -1), n.ONE = new n(1, 1, 1), t.exports = n;
}, function (t, e) { t.exports = function (t, e) { if (!(e >= t.length)) { for (var i = t.length - 1, n = t[e], s = e; s < i; s++)t[s] = t[s + 1]; return t.length = i, n; } }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(193); const r = i(12); const o = i(3); const a = new n({
    initialize(t) { this.type = t, this.defaultDivisions = 5, this.arcLengthDivisions = 100, this.cacheArcLengths = [], this.needsUpdate = !0, this.active = !0, this._tmpVec2A = new o(), this._tmpVec2B = new o(); }, draw(t, e) { return void 0 === e && (e = 32), t.strokePoints(this.getPoints(e)); }, getBounds(t, e) { t || (t = new r()), void 0 === e && (e = 16); const i = this.getLength(); e > i && (e = i / 2); const n = Math.max(1, Math.round(i / e)); return s(this.getSpacedPoints(n), t); }, getDistancePoints(t) { const e = this.getLength(); const i = Math.max(1, e / t); return this.getSpacedPoints(i); }, getEndPoint(t) { return void 0 === t && (t = new o()), this.getPointAt(1, t); }, getLength() { const t = this.getLengths(); return t[t.length - 1]; }, getLengths(t) { if (void 0 === t && (t = this.arcLengthDivisions), this.cacheArcLengths.length === t + 1 && !this.needsUpdate) return this.cacheArcLengths; this.needsUpdate = !1; let e; const i = []; const n = this.getPoint(0, this._tmpVec2A); let s = 0; i.push(0); for (let r = 1; r <= t; r++)s += (e = this.getPoint(r / t, this._tmpVec2B)).distance(n), i.push(s), n.copy(e); return this.cacheArcLengths = i, i; }, getPointAt(t, e) { const i = this.getUtoTmapping(t); return this.getPoint(i, e); }, getPoints(t, e, i) { void 0 === i && (i = []), t || (t = e ? this.getLength() / e : this.defaultDivisions); for (let n = 0; n <= t; n++)i.push(this.getPoint(n / t)); return i; }, getRandomPoint(t) { return void 0 === t && (t = new o()), this.getPoint(Math.random(), t); }, getSpacedPoints(t, e, i) { void 0 === i && (i = []), t || (t = e ? this.getLength() / e : this.defaultDivisions); for (let n = 0; n <= t; n++) { const s = this.getUtoTmapping(n / t, null, t); i.push(this.getPoint(s)); } return i; }, getStartPoint(t) { return void 0 === t && (t = new o()), this.getPointAt(0, t); }, getTangent(t, e) { void 0 === e && (e = new o()); let i = t - 1e-4; let n = t + 1e-4; return i < 0 && (i = 0), n > 1 && (n = 1), this.getPoint(i, this._tmpVec2A), this.getPoint(n, e), e.subtract(this._tmpVec2A).normalize(); }, getTangentAt(t, e) { const i = this.getUtoTmapping(t); return this.getTangent(i, e); }, getTFromDistance(t, e) { return t <= 0 ? 0 : this.getUtoTmapping(0, t, e); }, getUtoTmapping(t, e, i) { let n; const s = this.getLengths(i); let r = 0; const o = s.length; n = e ? Math.min(e, s[o - 1]) : t * s[o - 1]; for (var a, h = 0, l = o - 1; h <= l;) if ((a = s[r = Math.floor(h + (l - h) / 2)] - n) < 0)h = r + 1; else { if (!(a > 0)) { l = r; break; }l = r - 1; } if (s[r = l] === n) return r / (o - 1); const u = s[r]; return (r + (n - u) / (s[r + 1] - u)) / (o - 1); }, updateArcLengths() { this.needsUpdate = !0, this.getLengths(); },
  }); t.exports = a;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = {
    ADD: i(895), COMPLETE: i(896), FILE_COMPLETE: i(897), FILE_KEY_COMPLETE: i(898), FILE_LOAD_ERROR: i(899), FILE_LOAD: i(900), FILE_PROGRESS: i(901), POST_PROCESS: i(902), PROGRESS: i(903), START: i(904),
  };
}, function (t, e) { t.exports = function (t, e, i) { const n = t.x3 - t.x1; const s = t.y3 - t.y1; const r = t.x2 - t.x1; const o = t.y2 - t.y1; const a = e - t.x1; const h = i - t.y1; const l = n * n + s * s; const u = n * r + s * o; const c = n * a + s * h; const d = r * r + o * o; const f = r * a + o * h; const p = l * d - u * u; const g = p === 0 ? 0 : 1 / p; const v = (d * c - u * f) * g; const m = (l * f - u * c) * g; return v >= 0 && m >= 0 && v + m < 1; }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(4); t.exports = function (t, e, i) { void 0 === i && (i = new n()); const s = t.x1; const r = t.y1; const o = t.x2; const a = t.y2; const h = e.x1; const l = e.y1; const u = e.x2; const c = e.y2; const d = (c - l) * (o - s) - (u - h) * (a - r); if (d === 0) return !1; const f = ((u - h) * (r - l) - (c - l) * (s - h)) / d; const p = ((o - s) * (r - l) - (a - r) * (s - h)) / d; return f >= 0 && f <= 1 && p >= 0 && p <= 1 && (i.x = s + f * (o - s), i.y = r + f * (a - r), !0); };
}, function (t, e) { t.exports = function (t) { return Math.atan2(t.y2 - t.y1, t.x2 - t.x1); }; }, function (t, e, i) { const n = {}; t.exports = n; const s = i(95); n._motionWakeThreshold = 0.18, n._motionSleepThreshold = 0.08, n._minBias = 0.9, n.update = function (t, e) { for (let i = e * e * e, s = 0; s < t.length; s++) { const r = t[s]; const o = r.speed * r.speed + r.angularSpeed * r.angularSpeed; if (r.force.x === 0 && r.force.y === 0) { const a = Math.min(r.motion, o); const h = Math.max(r.motion, o); r.motion = n._minBias * a + (1 - n._minBias) * h, r.sleepThreshold > 0 && r.motion < n._motionSleepThreshold * i ? (r.sleepCounter += 1, r.sleepCounter >= r.sleepThreshold && n.set(r, !0)) : r.sleepCounter > 0 && (r.sleepCounter -= 1); } else n.set(r, !1); } }, n.afterCollisions = function (t, e) { for (let i = e * e * e, s = 0; s < t.length; s++) { const r = t[s]; if (r.isActive) { const o = r.collision; const a = o.bodyA.parent; const h = o.bodyB.parent; if (!(a.isSleeping && h.isSleeping || a.isStatic || h.isStatic) && (a.isSleeping || h.isSleeping)) { const l = a.isSleeping && !a.isStatic ? a : h; const u = l === a ? h : a; !l.isStatic && u.motion > n._motionWakeThreshold * i && n.set(l, !1); } } } }, n.set = function (t, e) { const i = t.isSleeping; e ? (t.isSleeping = !0, t.sleepCounter = t.sleepThreshold, t.positionImpulse.x = 0, t.positionImpulse.y = 0, t.positionPrev.x = t.position.x, t.positionPrev.y = t.position.y, t.anglePrev = t.angle, t.speed = 0, t.angularSpeed = 0, t.motion = 0, i || s.trigger(t, 'sleepStart')) : (t.isSleeping = !1, t.sleepCounter = 0, i && s.trigger(t, 'sleepEnd')); }; }, function (t, e, i) { const n = {}; t.exports = n; const s = i(21); n.on = function (t, e, i) { for (var n, s = e.split(' '), r = 0; r < s.length; r++)n = s[r], t.events = t.events || {}, t.events[n] = t.events[n] || [], t.events[n].push(i); return i; }, n.off = function (t, e, i) { if (e) { typeof e === 'function' && (i = e, e = s.keys(t.events).join(' ')); for (let n = e.split(' '), r = 0; r < n.length; r++) { const o = t.events[n[r]]; const a = []; if (i && o) for (let h = 0; h < o.length; h++)o[h] !== i && a.push(o[h]); t.events[n[r]] = a; } } else t.events = {}; }, n.trigger = function (t, e, i) { let n; let r; let o; let a; const h = t.events; if (h && s.keys(h).length > 0) { i || (i = {}), n = e.split(' '); for (let l = 0; l < n.length; l++) if (o = h[r = n[l]]) { (a = s.clone(i, !1)).name = r, a.source = t; for (let u = 0; u < o.length; u++)o[u].apply(t, [a]); } } }; }, function (t, e) {
  t.exports = {
    TOP_LEFT: 0, TOP_CENTER: 1, TOP_RIGHT: 2, LEFT_TOP: 3, LEFT_CENTER: 4, LEFT_BOTTOM: 5, CENTER: 6, RIGHT_TOP: 7, RIGHT_CENTER: 8, RIGHT_BOTTOM: 9, BOTTOM_LEFT: 10, BOTTOM_CENTER: 11, BOTTOM_RIGHT: 12,
  };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(20); t.exports = function (t, e, i) { return (i - e) * (t = n(t, 0, 1)); };
}, function (t, e) { t.exports = function (t, e, i) { return void 0 === i && (i = 1e-4), Math.abs(t - e) < i; }; }, function (t, e) { t.exports = function (t, e, i) { return t && t.hasOwnProperty(e) ? t[e] : i; }; }, function (t, e) {
  t.exports = {
    CREATED: 0, INIT: 1, DELAY: 2, OFFSET_DELAY: 3, PENDING_RENDER: 4, PLAYING_FORWARD: 5, PLAYING_BACKWARD: 6, HOLD_DELAY: 7, REPEAT_DELAY: 8, COMPLETE: 9, PENDING_ADD: 20, PAUSED: 21, LOOP_DELAY: 22, ACTIVE: 23, COMPLETE_DELAY: 24, PENDING_REMOVE: 25, REMOVED: 26,
  };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(308); const r = new n({
    initialize(t, e) { this.parent = t, this.events = e, e || (this.events = t.events ? t.events : t), this.list = {}, this.values = {}, this._frozen = !1, !t.hasOwnProperty('sys') && this.events && this.events.once('destroy', this.destroy, this); },
    get(t) { const e = this.list; if (Array.isArray(t)) { for (var i = [], n = 0; n < t.length; n++)i.push(e[t[n]]); return i; } return e[t]; },
    getAll() { const t = {}; for (const e in this.list) this.list.hasOwnProperty(e) && (t[e] = this.list[e]); return t; },
    query(t) { const e = {}; for (const i in this.list) this.list.hasOwnProperty(i) && i.match(t) && (e[i] = this.list[i]); return e; },
    set(t, e) { if (this._frozen) return this; if (typeof t === 'string') return this.setValue(t, e); for (const i in t) this.setValue(i, t[i]); return this; },
    inc(t, e) { if (this._frozen) return this; void 0 === e && (e = 1); let i = this.get(t); return void 0 === i && (i = 0), this.set(t, i + e), this; },
    toggle(t) { return this._frozen || this.set(t, !this.get(t)), this; },
    setValue(t, e) {
      if (this._frozen) return this; if (this.has(t)) this.values[t] = e; else {
        const i = this; const n = this.list; const r = this.events; const o = this.parent; Object.defineProperty(this.values, t, {
          enumerable: !0, configurable: !0, get() { return n[t]; }, set(e) { if (!i._frozen) { const a = n[t]; n[t] = e, r.emit(s.CHANGE_DATA, o, t, e, a), r.emit(s.CHANGE_DATA_KEY + t, o, e, a); } },
        }), n[t] = e, r.emit(s.SET_DATA, o, t, e);
      } return this;
    },
    each(t, e) { for (var i = [this.parent, null, void 0], n = 1; n < arguments.length; n++)i.push(arguments[n]); for (const s in this.list)i[1] = s, i[2] = this.list[s], t.apply(e, i); return this; },
    merge(t, e) { for (const i in void 0 === e && (e = !0), t)t.hasOwnProperty(i) && (e || !e && !this.has(i)) && this.setValue(i, t[i]); return this; },
    remove(t) { if (this._frozen) return this; if (!Array.isArray(t)) return this.removeValue(t); for (let e = 0; e < t.length; e++) this.removeValue(t[e]); return this; },
    removeValue(t) { if (this.has(t)) { const e = this.list[t]; delete this.list[t], delete this.values[t], this.events.emit(s.REMOVE_DATA, this.parent, t, e); } return this; },
    pop(t) { let e = void 0; return !this._frozen && this.has(t) && (e = this.list[t], delete this.list[t], delete this.values[t], this.events.emit(s.REMOVE_DATA, this.parent, t, e)), e; },
    has(t) { return this.list.hasOwnProperty(t); },
    setFreeze(t) { return this._frozen = t, this; },
    reset() { for (const t in this.list) delete this.list[t], delete this.values[t]; return this._frozen = !1, this; },
    destroy() { this.reset(), this.events.off(s.CHANGE_DATA), this.events.off(s.SET_DATA), this.events.off(s.REMOVE_DATA), this.parent = null; },
    freeze: { get() { return this._frozen; }, set(t) { this._frozen = !!t; } },
    count: { get() { let t = 0; for (const e in this.list) void 0 !== this.list[e] && t++; return t; } },
  }); t.exports = r;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = {
    DESTROY: i(611), VIDEO_COMPLETE: i(612), VIDEO_CREATED: i(613), VIDEO_ERROR: i(614), VIDEO_LOOP: i(615), VIDEO_PLAY: i(616), VIDEO_SEEKED: i(617), VIDEO_SEEKING: i(618), VIDEO_STOP: i(619), VIDEO_TIMEOUT: i(620), VIDEO_UNLOCKED: i(621),
  };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(13); const r = i(41); const o = i(10); const a = i(42); const h = i(12); const l = i(33); const u = i(179); const c = i(3); const d = new n({
    Extends: o,
    Mixins: [s.Alpha, s.Visible],
    initialize(t, e, i, n) { void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 0), o.call(this), this.scene, this.sceneManager, this.scaleManager, this.cameraManager, this.id = 0, this.name = '', this.resolution = 1, this.roundPixels = !1, this.useBounds = !1, this.worldView = new h(), this.dirty = !0, this._x = t, this._y = e, this._cx = 0, this._cy = 0, this._cw = 0, this._ch = 0, this._width = i, this._height = n, this._bounds = new h(), this._scrollX = 0, this._scrollY = 0, this._zoom = 1, this._rotation = 0, this.matrix = new l(), this.transparent = !0, this.backgroundColor = u('rgba(0,0,0,0)'), this.disableCull = !1, this.culledObjects = [], this.midPoint = new c(i / 2, n / 2), this.originX = 0.5, this.originY = 0.5, this._customViewport = !1, this.mask = null, this._maskCamera = null; },
    setOrigin(t, e) { return void 0 === t && (t = 0.5), void 0 === e && (e = t), this.originX = t, this.originY = e, this; },
    getScroll(t, e, i) { void 0 === i && (i = new c()); const n = 0.5 * this.width; const s = 0.5 * this.height; return i.x = t - n, i.y = e - s, this.useBounds && (i.x = this.clampX(i.x), i.y = this.clampY(i.y)), i; },
    centerOnX(t) { const e = 0.5 * this.width; return this.midPoint.x = t, this.scrollX = t - e, this.useBounds && (this.scrollX = this.clampX(this.scrollX)), this; },
    centerOnY(t) { const e = 0.5 * this.height; return this.midPoint.y = t, this.scrollY = t - e, this.useBounds && (this.scrollY = this.clampY(this.scrollY)), this; },
    centerOn(t, e) { return this.centerOnX(t), this.centerOnY(e), this; },
    centerToBounds() { if (this.useBounds) { const t = this._bounds; const e = 0.5 * this.width; const i = 0.5 * this.height; this.midPoint.set(t.centerX, t.centerY), this.scrollX = t.centerX - e, this.scrollY = t.centerY - i; } return this; },
    centerToSize() { return this.scrollX = 0.5 * this.width, this.scrollY = 0.5 * this.height, this; },
    cull(t) { if (this.disableCull) return t; const e = this.matrix.matrix; const i = e[0]; const n = e[1]; const s = e[2]; const r = e[3]; let o = i * r - n * s; if (!o) return t; const a = e[4]; const h = e[5]; const l = this.scrollX; const u = this.scrollY; const c = this.width; const d = this.height; const f = this.culledObjects; const p = t.length; o = 1 / o, f.length = 0; for (let g = 0; g < p; ++g) { const v = t[g]; if (v.hasOwnProperty('width') && !v.parentContainer) { const m = v.width; const y = v.height; const x = v.x - l * v.scrollFactorX - m * v.originX; const T = v.y - u * v.scrollFactorY - y * v.originY; const w = x * i + T * s + a; const b = x * n + T * r + h; const E = (x + m) * i + (T + y) * s + a; const S = (x + m) * n + (T + y) * r + h; const A = this.y; const _ = A + d; const C = this.x; E > C && w < C + c && S > A && b < _ && f.push(v); } else f.push(v); } return f; },
    getWorldPoint(t, e, i) { void 0 === i && (i = new c()); const n = this.matrix.matrix; const s = n[0]; const r = n[1]; const o = n[2]; const a = n[3]; const h = n[4]; const l = n[5]; let u = s * a - r * o; if (!u) return i.x = t, i.y = e, i; const d = a * (u = 1 / u); const f = -r * u; const p = -o * u; const g = s * u; const v = (o * l - a * h) * u; const m = (r * h - s * l) * u; const y = Math.cos(this.rotation); const x = Math.sin(this.rotation); const T = this.zoom; const w = this.resolution; const b = this.scrollX; const E = this.scrollY; const S = t + (b * y - E * x) * T; const A = e + (b * x + E * y) * T; return i.x = (S * d + A * p) * w + v, i.y = (S * f + A * g) * w + m, i; },
    ignore(t) { const e = this.id; Array.isArray(t) || (t = [t]); for (let i = 0; i < t.length; i++) { const n = t[i]; Array.isArray(n) ? this.ignore(n) : n.isParent ? this.ignore(n.getChildren()) : n.cameraFilter |= e; } return this; },
    preRender(t) { const e = this.width; const i = this.height; const n = 0.5 * e; const s = 0.5 * i; const r = this.zoom * t; const o = this.matrix; let a = e * this.originX; let h = i * this.originY; let l = this.scrollX; let u = this.scrollY; this.useBounds && (l = this.clampX(l), u = this.clampY(u)), this.roundPixels && (a = Math.round(a), h = Math.round(h)), this.scrollX = l, this.scrollY = u; const c = l + n; const d = u + s; this.midPoint.set(c, d); const f = e / r; const p = i / r; this.worldView.setTo(c - f / 2, d - p / 2, f, p), o.applyITRS(this.x + a, this.y + h, this.rotation, r, r), o.translate(-a, -h); },
    clampX(t) { const e = this._bounds; const i = this.displayWidth; const n = e.x + (i - this.width) / 2; const s = Math.max(n, n + e.width - i); return t < n ? t = n : t > s && (t = s), t; },
    clampY(t) { const e = this._bounds; const i = this.displayHeight; const n = e.y + (i - this.height) / 2; const s = Math.max(n, n + e.height - i); return t < n ? t = n : t > s && (t = s), t; },
    removeBounds() { return this.useBounds = !1, this.dirty = !0, this._bounds.setEmpty(), this; },
    setAngle(t) { return void 0 === t && (t = 0), this.rotation = r(t), this; },
    setBackgroundColor(t) { return void 0 === t && (t = 'rgba(0,0,0,0)'), this.backgroundColor = u(t), this.transparent = this.backgroundColor.alpha === 0, this; },
    setBounds(t, e, i, n, s) { return void 0 === s && (s = !1), this._bounds.setTo(t, e, i, n), this.dirty = !0, this.useBounds = !0, s ? this.centerToBounds() : (this.scrollX = this.clampX(this.scrollX), this.scrollY = this.clampY(this.scrollY)), this; },
    getBounds(t) { void 0 === t && (t = new h()); const e = this._bounds; return t.setTo(e.x, e.y, e.width, e.height), t; },
    setName(t) { return void 0 === t && (t = ''), this.name = t, this; },
    setPosition(t, e) { return void 0 === e && (e = t), this.x = t, this.y = e, this; },
    setRotation(t) { return void 0 === t && (t = 0), this.rotation = t, this; },
    setRoundPixels(t) { return this.roundPixels = t, this; },
    setScene(t) { this.scene && this._customViewport && this.sceneManager.customViewports--, this.scene = t; const e = t.sys; this.sceneManager = e.game.scene, this.scaleManager = e.scale, this.cameraManager = e.cameras; const i = this.scaleManager.resolution; return this.resolution = i, this._cx = this._x * i, this._cy = this._y * i, this._cw = this._width * i, this._ch = this._height * i, this.updateSystem(), this; },
    setScroll(t, e) { return void 0 === e && (e = t), this.scrollX = t, this.scrollY = e, this; },
    setSize(t, e) { return void 0 === e && (e = t), this.width = t, this.height = e, this; },
    setViewport(t, e, i, n) { return this.x = t, this.y = e, this.width = i, this.height = n, this; },
    setZoom(t) { return void 0 === t && (t = 1), t === 0 && (t = 0.001), this.zoom = t, this; },
    setMask(t, e) { return void 0 === e && (e = !0), this.mask = t, this._maskCamera = e ? this.cameraManager.default : this, this; },
    clearMask(t) { return void 0 === t && (t = !1), t && this.mask && this.mask.destroy(), this.mask = null, this; },
    toJSON() {
      const t = {
        name: this.name, x: this.x, y: this.y, width: this.width, height: this.height, zoom: this.zoom, rotation: this.rotation, roundPixels: this.roundPixels, scrollX: this.scrollX, scrollY: this.scrollY, backgroundColor: this.backgroundColor.rgba,
      }; return this.useBounds && (t.bounds = {
        x: this._bounds.x, y: this._bounds.y, width: this._bounds.width, height: this._bounds.height,
      }), t;
    },
    update() {},
    updateSystem() { if (this.scaleManager) { const t = this._x !== 0 || this._y !== 0 || this.scaleManager.width !== this._width || this.scaleManager.height !== this._height; const e = this.sceneManager; t && !this._customViewport ? e.customViewports++ : !t && this._customViewport && e.customViewports--, this.dirty = !0, this._customViewport = t; } },
    destroy() { this.emit(a.DESTROY, this), this.removeAllListeners(), this.matrix.destroy(), this.culledObjects = [], this._customViewport && this.sceneManager.customViewports--, this._bounds = null, this.scene = null, this.scaleManager = null, this.sceneManager = null, this.cameraManager = null; },
    x: { get() { return this._x; }, set(t) { this._x = t, this._cx = t * this.resolution, this.updateSystem(); } },
    y: { get() { return this._y; }, set(t) { this._y = t, this._cy = t * this.resolution, this.updateSystem(); } },
    width: { get() { return this._width; }, set(t) { this._width = t, this._cw = t * this.resolution, this.updateSystem(); } },
    height: { get() { return this._height; }, set(t) { this._height = t, this._ch = t * this.resolution, this.updateSystem(); } },
    scrollX: { get() { return this._scrollX; }, set(t) { this._scrollX = t, this.dirty = !0; } },
    scrollY: { get() { return this._scrollY; }, set(t) { this._scrollY = t, this.dirty = !0; } },
    zoom: { get() { return this._zoom; }, set(t) { this._zoom = t, this.dirty = !0; } },
    rotation: { get() { return this._rotation; }, set(t) { this._rotation = t, this.dirty = !0; } },
    centerX: { get() { return this.x + 0.5 * this.width; } },
    centerY: { get() { return this.y + 0.5 * this.height; } },
    displayWidth: { get() { return this.width / this.zoom; } },
    displayHeight: { get() { return this.height / this.zoom; } },
  }); t.exports = d;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = {
    ENTER_FULLSCREEN: i(732), FULLSCREEN_FAILED: i(733), FULLSCREEN_UNSUPPORTED: i(734), LEAVE_FULLSCREEN: i(735), ORIENTATION_CHANGE: i(736), RESIZE: i(737),
  };
}, function (t, e) { t.exports = function (t, e, i, n) { return void 0 === i && (i = 0), e === 0 ? t : (t -= i, t = e * Math.floor(t / e), n ? (i + t) / e : i + t); }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(74); t.exports = function (t, e) { const i = n(t); for (const s in e)i.hasOwnProperty(s) || (i[s] = e[s]); return i; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(20); const r = i(19); var o = new n({
    initialize(t, e, i, n, s, r, o) {
      this.texture = t, this.name = e, this.source = t.source[i], this.sourceIndex = i, this.glTexture = this.source.glTexture, this.cutX, this.cutY, this.cutWidth, this.cutHeight, this.x = 0, this.y = 0, this.width, this.height, this.halfWidth, this.halfHeight, this.centerX, this.centerY, this.pivotX = 0, this.pivotY = 0, this.customPivot = !1, this.rotated = !1, this.autoRound = -1, this.customData = {}, this.u0 = 0, this.v0 = 0, this.u1 = 0, this.v1 = 0, this.data = {
        cut: {
          x: 0, y: 0, w: 0, h: 0, r: 0, b: 0,
        },
        trim: !1,
        sourceSize: { w: 0, h: 0 },
        spriteSourceSize: {
          x: 0, y: 0, w: 0, h: 0, r: 0, b: 0,
        },
        radius: 0,
        drawImage: {
          x: 0, y: 0, width: 0, height: 0,
        },
      }, this.setSize(r, o, n, s);
    },
    setSize(t, e, i, n) { void 0 === i && (i = 0), void 0 === n && (n = 0), this.cutX = i, this.cutY = n, this.cutWidth = t, this.cutHeight = e, this.width = t, this.height = e, this.halfWidth = Math.floor(0.5 * t), this.halfHeight = Math.floor(0.5 * e), this.centerX = Math.floor(t / 2), this.centerY = Math.floor(e / 2); const s = this.data; const r = s.cut; r.x = i, r.y = n, r.w = t, r.h = e, r.r = i + t, r.b = n + e, s.sourceSize.w = t, s.sourceSize.h = e, s.spriteSourceSize.w = t, s.spriteSourceSize.h = e, s.radius = 0.5 * Math.sqrt(t * t + e * e); const o = s.drawImage; return o.x = i, o.y = n, o.width = t, o.height = e, this.updateUVs(); },
    setTrim(t, e, i, n, s, r) { const o = this.data; const a = o.spriteSourceSize; return o.trim = !0, o.sourceSize.w = t, o.sourceSize.h = e, a.x = i, a.y = n, a.w = s, a.h = r, a.r = i + s, a.b = n + r, this.x = i, this.y = n, this.width = s, this.height = r, this.halfWidth = 0.5 * s, this.halfHeight = 0.5 * r, this.centerX = Math.floor(s / 2), this.centerY = Math.floor(r / 2), this.updateUVs(); },
    setCropUVs(t, e, i, n, r, o, a) { const h = this.cutX; const l = this.cutY; const u = this.cutWidth; const c = this.cutHeight; const d = this.realWidth; const f = this.realHeight; let p = h + (e = s(e, 0, d)); let g = l + (i = s(i, 0, f)); let v = n = s(n, 0, d - e); let m = r = s(r, 0, f - i); const y = this.data; if (y.trim) { const x = y.spriteSourceSize; const T = e + (n = s(n, 0, u - e)); const w = i + (r = s(r, 0, c - i)); if (!(x.r < e || x.b < i || x.x > T || x.y > w)) { const b = Math.max(x.x, e); const E = Math.max(x.y, i); const S = Math.min(x.r, T) - b; const A = Math.min(x.b, w) - E; v = S, m = A, p = o ? h + (u - (b - x.x) - S) : h + (b - x.x), g = a ? l + (c - (E - x.y) - A) : l + (E - x.y), e = b, i = E, n = S, r = A; } else p = 0, g = 0, v = 0, m = 0; } else o && (p = h + (u - e - n)), a && (g = l + (c - i - r)); const _ = this.source.width; const C = this.source.height; return t.u0 = Math.max(0, p / _), t.v0 = Math.max(0, g / C), t.u1 = Math.min(1, (p + v) / _), t.v1 = Math.min(1, (g + m) / C), t.x = e, t.y = i, t.cx = p, t.cy = g, t.cw = v, t.ch = m, t.width = n, t.height = r, t.flipX = o, t.flipY = a, t; },
    updateCropUVs(t, e, i) { return this.setCropUVs(t, t.x, t.y, t.width, t.height, e, i); },
    updateUVs() { const t = this.cutX; const e = this.cutY; const i = this.cutWidth; const n = this.cutHeight; const s = this.data.drawImage; s.width = i, s.height = n; const r = this.source.width; const o = this.source.height; return this.u0 = t / r, this.v0 = e / o, this.u1 = (t + i) / r, this.v1 = (e + n) / o, this; },
    updateUVsInverted() { const t = this.source.width; const e = this.source.height; return this.u0 = (this.cutX + this.cutHeight) / t, this.v0 = this.cutY / e, this.u1 = this.cutX / t, this.v1 = (this.cutY + this.cutWidth) / e, this; },
    clone() { const t = new o(this.texture, this.name, this.sourceIndex); return t.cutX = this.cutX, t.cutY = this.cutY, t.cutWidth = this.cutWidth, t.cutHeight = this.cutHeight, t.x = this.x, t.y = this.y, t.width = this.width, t.height = this.height, t.halfWidth = this.halfWidth, t.halfHeight = this.halfHeight, t.centerX = this.centerX, t.centerY = this.centerY, t.rotated = this.rotated, t.data = r(!0, t.data, this.data), t.updateUVs(), t; },
    destroy() { this.source = null, this.texture = null, this.glTexture = null, this.customData = null, this.data = null; },
    realWidth: { get() { return this.data.sourceSize.w; } },
    realHeight: { get() { return this.data.sourceSize.h; } },
    radius: { get() { return this.data.radius; } },
    trimmed: { get() { return this.data.trim; } },
    canvasData: { get() { return this.data.drawImage; } },
  }); t.exports = o;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(109); const r = i(430); const o = i(431); const a = i(54); const h = i(172); const l = new n({
    initialize(t, e, i, n) { void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 0), this.type = a.ELLIPSE, this.x = t, this.y = e, this.width = i, this.height = n; }, contains(t, e) { return s(this, t, e); }, getPoint(t, e) { return r(this, t, e); }, getPoints(t, e, i) { return o(this, t, e, i); }, getRandomPoint(t) { return h(this, t); }, setTo(t, e, i, n) { return this.x = t, this.y = e, this.width = i, this.height = n, this; }, setEmpty() { return this.width = 0, this.height = 0, this; }, setPosition(t, e) { return void 0 === e && (e = t), this.x = t, this.y = e, this; }, setSize(t, e) { return void 0 === e && (e = t), this.width = t, this.height = e, this; }, isEmpty() { return this.width <= 0 || this.height <= 0; }, getMinorRadius() { return Math.min(this.width, this.height) / 2; }, getMajorRadius() { return Math.max(this.width, this.height) / 2; }, left: { get() { return this.x - this.width / 2; }, set(t) { this.x = t + this.width / 2; } }, right: { get() { return this.x + this.width / 2; }, set(t) { this.x = t - this.width / 2; } }, top: { get() { return this.y - this.height / 2; }, set(t) { this.y = t + this.height / 2; } }, bottom: { get() { return this.y + this.height / 2; }, set(t) { this.y = t - this.height / 2; } },
  }); t.exports = l;
}, function (t, e) { t.exports = function (t, e, i) { if (t.width <= 0 || t.height <= 0) return !1; let n = (e - t.x) / t.width; let s = (i - t.y) / t.height; return (n *= n) + (s *= s) < 0.25; }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(264); const s = i(0); const r = i(102); const o = i(2); const a = i(6); const h = i(8); const l = i(425); const u = i(111); const c = i(66); const d = new s({
    initialize(t, e, i) { i ? e && !Array.isArray(e) && (e = [e]) : Array.isArray(e) ? h(e[0]) && (i = e, e = null) : h(e) && (i = e, e = null), this.scene = t, this.children = new u(e), this.isParent = !0, this.type = 'Group', this.classType = o(i, 'classType', c), this.name = o(i, 'name', ''), this.active = o(i, 'active', !0), this.maxSize = o(i, 'maxSize', -1), this.defaultKey = o(i, 'defaultKey', null), this.defaultFrame = o(i, 'defaultFrame', null), this.runChildUpdate = o(i, 'runChildUpdate', !1), this.createCallback = o(i, 'createCallback', null), this.removeCallback = o(i, 'removeCallback', null), this.createMultipleCallback = o(i, 'createMultipleCallback', null), this.internalCreateCallback = o(i, 'internalCreateCallback', null), this.internalRemoveCallback = o(i, 'internalRemoveCallback', null), i && this.createMultiple(i); },
    create(t, e, i, n, s, r) { if (void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = this.defaultKey), void 0 === n && (n = this.defaultFrame), void 0 === s && (s = !0), void 0 === r && (r = !0), this.isFull()) return null; const o = new this.classType(this.scene, t, e, i, n); return this.scene.sys.displayList.add(o), o.preUpdate && this.scene.sys.updateList.add(o), o.visible = s, o.setActive(r), this.add(o), o; },
    createMultiple(t) { if (this.isFull()) return []; Array.isArray(t) || (t = [t]); let e = []; if (t[0].key) for (let i = 0; i < t.length; i++) { const n = this.createFromConfig(t[i]); e = e.concat(n); } return e; },
    createFromConfig(t) {
      if (this.isFull()) return []; this.classType = o(t, 'classType', this.classType); let e = o(t, 'key', void 0); let i = o(t, 'frame', null); const s = o(t, 'visible', !0); const r = o(t, 'active', !0); const h = []; if (void 0 === e) return h; Array.isArray(e) || (e = [e]), Array.isArray(i) || (i = [i]); const u = o(t, 'repeat', 0); const c = o(t, 'randomKey', !1); const d = o(t, 'randomFrame', !1); const f = o(t, 'yoyo', !1); const p = o(t, 'quantity', !1); const g = o(t, 'frameQuantity', 1); const v = o(t, 'max', 0); const m = l(e, i, {
        max: v, qty: p || g, random: c, randomB: d, repeat: u, yoyo: f,
      }); t.createCallback && (this.createCallback = t.createCallback), t.removeCallback && (this.removeCallback = t.removeCallback); for (let y = 0; y < m.length; y++) { const x = this.create(0, 0, m[y].a, m[y].b, s, r); if (!x) break; h.push(x); } const T = a(t, 'setXY.x', 0); const w = a(t, 'setXY.y', 0); const b = a(t, 'setXY.stepX', 0); const E = a(t, 'setXY.stepY', 0); n.SetXY(h, T, w, b, E); const S = a(t, 'setRotation.value', 0); const A = a(t, 'setRotation.step', 0); n.SetRotation(h, S, A); const _ = a(t, 'setScale.x', 1); const C = a(t, 'setScale.y', _); const M = a(t, 'setScale.stepX', 0); const P = a(t, 'setScale.stepY', 0); n.SetScale(h, _, C, M, P); const O = a(t, 'setAlpha.value', 1); const R = a(t, 'setAlpha.step', 0); n.SetAlpha(h, O, R); const L = a(t, 'setDepth.value', 0); const D = a(t, 'setDepth.step', 0); n.SetDepth(h, L, D); const k = a(t, 'setScrollFactor.x', 1); const F = a(t, 'setScrollFactor.y', k); const I = a(t, 'setScrollFactor.stepX', 0); const B = a(t, 'setScrollFactor.stepY', 0); n.SetScrollFactor(h, k, F, I, B); const N = o(t, 'hitArea', null); const Y = o(t, 'hitAreaCallback', null); N && n.SetHitArea(h, N, Y); const X = o(t, 'gridAlign', !1); return X && n.GridAlign(h, X), this.createMultipleCallback && this.createMultipleCallback.call(this, h), h;
    },
    preUpdate(t, e) { if (this.runChildUpdate && this.children.size !== 0) for (let i = this.children.entries.slice(), n = 0; n < i.length; n++) { const s = i[n]; s.active && s.update(t, e); } },
    add(t, e) { return void 0 === e && (e = !1), this.isFull() || (this.children.set(t), this.internalCreateCallback && this.internalCreateCallback.call(this, t), this.createCallback && this.createCallback.call(this, t), e && (this.scene.sys.displayList.add(t), t.preUpdate && this.scene.sys.updateList.add(t)), t.on(r.DESTROY, this.remove, this)), this; },
    addMultiple(t, e) { if (void 0 === e && (e = !1), Array.isArray(t)) for (let i = 0; i < t.length; i++) this.add(t[i], e); return this; },
    remove(t, e, i) { return void 0 === e && (e = !1), void 0 === i && (i = !1), this.children.contains(t) ? (this.children.delete(t), this.internalRemoveCallback && this.internalRemoveCallback.call(this, t), this.removeCallback && this.removeCallback.call(this, t), t.off(r.DESTROY, this.remove, this), i ? t.destroy() : e && (t.scene.sys.displayList.remove(t), t.preUpdate && t.scene.sys.updateList.remove(t)), this) : this; },
    clear(t, e) { void 0 === t && (t = !1), void 0 === e && (e = !1); for (let i = this.children, n = 0; n < i.size; n++) { const s = i.entries[n]; s.off(r.DESTROY, this.remove, this), e ? s.destroy() : t && (s.scene.sys.displayList.remove(s), s.preUpdate && s.scene.sys.updateList.remove(s)); } return this.children.clear(), this; },
    contains(t) { return this.children.contains(t); },
    getChildren() { return this.children.entries; },
    getLength() { return this.children.size; },
    getFirst(t, e, i, n, s, r, o) { return this.getHandler(!0, 1, t, e, i, n, s, r, o); },
    getFirstNth(t, e, i, n, s, r, o, a) { return this.getHandler(!0, t, e, i, n, s, r, o, a); },
    getLast(t, e, i, n, s, r, o) { return this.getHandler(!1, 1, t, e, i, n, s, r, o); },
    getLastNth(t, e, i, n, s, r, o, a) { return this.getHandler(!1, t, e, i, n, s, r, o, a); },
    getHandler(t, e, i, n, s, r, o, a, h) { let l; let u; void 0 === i && (i = !1), void 0 === n && (n = !1); let c = 0; const d = this.children.entries; if (t) for (u = 0; u < d.length; u++) if ((l = d[u]).active === i) { if (++c === e) break; } else l = null; else for (u = d.length - 1; u >= 0; u--) if ((l = d[u]).active === i) { if (++c === e) break; } else l = null; return l ? (typeof s === 'number' && (l.x = s), typeof r === 'number' && (l.y = r), l) : n ? this.create(s, r, o, a, h) : null; },
    get(t, e, i, n, s) { return this.getFirst(!1, !0, t, e, i, n, s); },
    getFirstAlive(t, e, i, n, s, r) { return this.getFirst(!0, t, e, i, n, s, r); },
    getFirstDead(t, e, i, n, s, r) { return this.getFirst(!1, t, e, i, n, s, r); },
    playAnimation(t, e) { return n.PlayAnimation(this.children.entries, t, e), this; },
    isFull() { return this.maxSize !== -1 && this.children.size >= this.maxSize; },
    countActive(t) { void 0 === t && (t = !0); for (var e = 0, i = 0; i < this.children.size; i++) this.children.entries[i].active === t && e++; return e; },
    getTotalUsed() { return this.countActive(); },
    getTotalFree() { const t = this.getTotalUsed(); return (this.maxSize === -1 ? 999999999999 : this.maxSize) - t; },
    propertyValueSet(t, e, i, s, r) { return n.PropertyValueSet(this.children.entries, t, e, i, s, r), this; },
    propertyValueInc(t, e, i, s, r) { return n.PropertyValueInc(this.children.entries, t, e, i, s, r), this; },
    setX(t, e) { return n.SetX(this.children.entries, t, e), this; },
    setY(t, e) { return n.SetY(this.children.entries, t, e), this; },
    setXY(t, e, i, s) { return n.SetXY(this.children.entries, t, e, i, s), this; },
    incX(t, e) { return n.IncX(this.children.entries, t, e), this; },
    incY(t, e) { return n.IncY(this.children.entries, t, e), this; },
    incXY(t, e, i, s) { return n.IncXY(this.children.entries, t, e, i, s), this; },
    shiftPosition(t, e, i) { return n.ShiftPosition(this.children.entries, t, e, i), this; },
    angle(t, e) { return n.Angle(this.children.entries, t, e), this; },
    rotate(t, e) { return n.Rotate(this.children.entries, t, e), this; },
    rotateAround(t, e) { return n.RotateAround(this.children.entries, t, e), this; },
    rotateAroundDistance(t, e, i) { return n.RotateAroundDistance(this.children.entries, t, e, i), this; },
    setAlpha(t, e) { return n.SetAlpha(this.children.entries, t, e), this; },
    setTint(t, e, i, s) { return n.SetTint(this.children.entries, t, e, i, s), this; },
    setOrigin(t, e, i, s) { return n.SetOrigin(this.children.entries, t, e, i, s), this; },
    scaleX(t, e) { return n.ScaleX(this.children.entries, t, e), this; },
    scaleY(t, e) { return n.ScaleY(this.children.entries, t, e), this; },
    scaleXY(t, e, i, s) { return n.ScaleXY(this.children.entries, t, e, i, s), this; },
    setDepth(t, e) { return n.SetDepth(this.children.entries, t, e), this; },
    setBlendMode(t) { return n.SetBlendMode(this.children.entries, t), this; },
    setHitArea(t, e) { return n.SetHitArea(this.children.entries, t, e), this; },
    shuffle() { return n.Shuffle(this.children.entries), this; },
    kill(t) { this.children.contains(t) && t.setActive(!1); },
    killAndHide(t) { this.children.contains(t) && (t.setActive(!1), t.setVisible(!1)); },
    setVisible(t, e, i) { return n.SetVisible(this.children.entries, t, e, i), this; },
    toggleVisible() { return n.ToggleVisible(this.children.entries), this; },
    destroy(t) { void 0 === t && (t = !1), this.scene && !this.ignoreDestroy && (this.clear(!1, t), this.scene = void 0, this.children = void 0); },
  }); t.exports = d;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  var n = new (i(0))({
    initialize(t) { if (this.entries = [], Array.isArray(t)) for (let e = 0; e < t.length; e++) this.set(t[e]); }, set(t) { return this.entries.indexOf(t) === -1 && this.entries.push(t), this; }, get(t, e) { for (let i = 0; i < this.entries.length; i++) { const n = this.entries[i]; if (n[t] === e) return n; } }, getArray() { return this.entries.slice(0); }, delete(t) { const e = this.entries.indexOf(t); return e > -1 && this.entries.splice(e, 1), this; }, dump() { console.group('Set'); for (let t = 0; t < this.entries.length; t++) { const e = this.entries[t]; console.log(e); }console.groupEnd(); }, each(t, e) { let i; const n = this.entries.slice(); const s = n.length; if (e) for (i = 0; i < s && !1 !== t.call(e, n[i], i); i++);else for (i = 0; i < s && !1 !== t(n[i], i); i++);return this; }, iterate(t, e) { let i; const n = this.entries.length; if (e) for (i = 0; i < n && !1 !== t.call(e, this.entries[i], i); i++);else for (i = 0; i < n && !1 !== t(this.entries[i], i); i++);return this; }, iterateLocal(t) { let e; const i = []; for (e = 1; e < arguments.length; e++)i.push(arguments[e]); const n = this.entries.length; for (e = 0; e < n; e++) { const s = this.entries[e]; s[t].apply(s, i); } return this; }, clear() { return this.entries.length = 0, this; }, contains(t) { return this.entries.indexOf(t) > -1; }, union(t) { const e = new n(); return t.entries.forEach(((t) => { e.set(t); })), this.entries.forEach(((t) => { e.set(t); })), e; }, intersect(t) { const e = new n(); return this.entries.forEach(((i) => { t.contains(i) && e.set(i); })), e; }, difference(t) { const e = new n(); return this.entries.forEach(((i) => { t.contains(i) || e.set(i); })), e; }, size: { get() { return this.entries.length; }, set(t) { return t < this.entries.length ? this.entries.length = t : this.entries.length; } },
  }); t.exports = n;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(13); const r = i(14); const o = i(1e3); const a = new n({ Extends: r, Mixins: [s.Alpha, s.BlendMode, s.Depth, s.Flip, s.GetBounds, s.Mask, s.Origin, s.Pipeline, s.ScrollFactor, s.Size, s.TextureCrop, s.Tint, s.Transform, s.Visible, o], initialize(t, e, i, n, s) { r.call(this, t, 'Image'), this._crop = this.resetCropObject(), this.setTexture(n, s), this.setPosition(e, i), this.setSizeToFrame(), this.setOriginFromFrame(), this.initPipeline(); } }); t.exports = a;
}, function (t, e) { t.exports = function (t, e) { return t.hasOwnProperty(e); }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(11); t.exports = function (t, e, i, s, r, o) { for (let a = n.getTintAppendFloatAlphaAndSwap(i.fillColor, i.fillAlpha * s), h = i.pathData, l = i.pathIndexes, u = 0; u < l.length; u += 3) { const c = 2 * l[u]; const d = 2 * l[u + 1]; const f = 2 * l[u + 2]; const p = h[c + 0] - r; const g = h[c + 1] - o; const v = h[d + 0] - r; const m = h[d + 1] - o; const y = h[f + 0] - r; const x = h[f + 1] - o; const T = e.getX(p, g); const w = e.getY(p, g); const b = e.getX(v, m); const E = e.getY(v, m); const S = e.getX(y, x); const A = e.getY(y, x); t.setTexture2D(), t.batchTri(T, w, b, E, S, A, 0, 0, 1, 1, a, a, a, t.tintEffect); } };
}, function (t, e) {
  const i = {}; t.exports = i, i.create = function (t, e) {
    const n = t.bodyA; const s = t.bodyB; const r = {
      id: i.id(n, s), bodyA: n, bodyB: s, activeContacts: [], separation: 0, isActive: !0, confirmedActive: !0, isSensor: n.isSensor || s.isSensor, timeCreated: e, timeUpdated: e, collision: null, inverseMass: 0, friction: 0, frictionStatic: 0, restitution: 0, slop: 0,
    }; return i.update(r, t, e), r;
  }, i.update = function (t, e, n) { if (t.collision = e, e.collided) { const s = e.supports; const r = t.activeContacts; const o = e.parentA; const a = e.parentB; t.inverseMass = o.inverseMass + a.inverseMass, t.friction = Math.min(o.friction, a.friction), t.frictionStatic = Math.max(o.frictionStatic, a.frictionStatic), t.restitution = Math.max(o.restitution, a.restitution), t.slop = Math.max(o.slop, a.slop); for (let h = 0; h < s.length; h++)r[h] = s[h].contact; const l = s.length; l < r.length && (r.length = l), t.separation = e.depth, i.setActive(t, !0, n); } else !0 === t.isActive && i.setActive(t, !1, n); }, i.setActive = function (t, e, i) { e ? (t.isActive = !0, t.timeUpdated = i) : (t.isActive = !1, t.activeContacts.length = 0); }, i.id = function (t, e) { return t.id < e.id ? `A${t.id}B${e.id}` : `A${e.id}B${t.id}`; };
}, function (t, e) { t.exports = function (t, e, i) { return t >= 0 && t < i.width && e >= 0 && e < i.height; }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(2); const r = new n({ initialize(t) { void 0 === t && (t = {}), this.name = s(t, 'name', 'layer'), this.x = s(t, 'x', 0), this.y = s(t, 'y', 0), this.width = s(t, 'width', 0), this.height = s(t, 'height', 0), this.tileWidth = s(t, 'tileWidth', 0), this.tileHeight = s(t, 'tileHeight', 0), this.baseTileWidth = s(t, 'baseTileWidth', this.tileWidth), this.baseTileHeight = s(t, 'baseTileHeight', this.tileHeight), this.widthInPixels = s(t, 'widthInPixels', this.width * this.baseTileWidth), this.heightInPixels = s(t, 'heightInPixels', this.height * this.baseTileHeight), this.alpha = s(t, 'alpha', 1), this.visible = s(t, 'visible', !0), this.properties = s(t, 'properties', []), this.indexes = s(t, 'indexes', []), this.collideIndexes = s(t, 'collideIndexes', []), this.callbacks = s(t, 'callbacks', []), this.bodies = s(t, 'bodies', []), this.data = s(t, 'data', []), this.tilemapLayer = s(t, 'tilemapLayer', null); } }); t.exports = r;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(2); const r = new n({ initialize(t) { void 0 === t && (t = {}), this.name = s(t, 'name', 'map'), this.width = s(t, 'width', 0), this.height = s(t, 'height', 0), this.infinite = s(t, 'infinite', !1), this.tileWidth = s(t, 'tileWidth', 0), this.tileHeight = s(t, 'tileHeight', 0), this.widthInPixels = s(t, 'widthInPixels', this.width * this.tileWidth), this.heightInPixels = s(t, 'heightInPixels', this.height * this.tileHeight), this.format = s(t, 'format', null), this.orientation = s(t, 'orientation', 'orthogonal'), this.renderOrder = s(t, 'renderOrder', 'right-down'), this.version = s(t, 'version', '1'), this.properties = s(t, 'properties', {}), this.layers = s(t, 'layers', []), this.images = s(t, 'images', []), this.objects = s(t, 'objects', {}), this.collision = s(t, 'collision', {}), this.tilesets = s(t, 'tilesets', []), this.imageCollections = s(t, 'imageCollections', []), this.tiles = s(t, 'tiles', []); } }); t.exports = r;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = new (i(0))({
    initialize(t, e, i, n, s, r, o, a) { (void 0 === i || i <= 0) && (i = 32), (void 0 === n || n <= 0) && (n = 32), void 0 === s && (s = 0), void 0 === r && (r = 0), void 0 === o && (o = {}), void 0 === a && (a = {}), this.name = t, this.firstgid = e, this.tileWidth = i, this.tileHeight = n, this.tileMargin = s, this.tileSpacing = r, this.tileProperties = o, this.tileData = a, this.image = null, this.glTexture = null, this.rows = 0, this.columns = 0, this.total = 0, this.texCoordinates = []; }, getTileProperties(t) { return this.containsTileIndex(t) ? this.tileProperties[t - this.firstgid] : null; }, getTileData(t) { return this.containsTileIndex(t) ? this.tileData[t - this.firstgid] : null; }, getTileCollisionGroup(t) { const e = this.getTileData(t); return e && e.objectgroup ? e.objectgroup : null; }, containsTileIndex(t) { return t >= this.firstgid && t < this.firstgid + this.total; }, getTileTextureCoordinates(t) { return this.containsTileIndex(t) ? this.texCoordinates[t - this.firstgid] : null; }, setImage(t) { return this.image = t, this.glTexture = t.get().source.glTexture, this.updateTileData(this.image.source[0].width, this.image.source[0].height), this; }, setTileSize(t, e) { return void 0 !== t && (this.tileWidth = t), void 0 !== e && (this.tileHeight = e), this.image && this.updateTileData(this.image.source[0].width, this.image.source[0].height), this; }, setSpacing(t, e) { return void 0 !== t && (this.tileMargin = t), void 0 !== e && (this.tileSpacing = e), this.image && this.updateTileData(this.image.source[0].width, this.image.source[0].height), this; }, updateTileData(t, e) { let i = (e - 2 * this.tileMargin + this.tileSpacing) / (this.tileHeight + this.tileSpacing); let n = (t - 2 * this.tileMargin + this.tileSpacing) / (this.tileWidth + this.tileSpacing); i % 1 == 0 && n % 1 == 0 || console.warn(`Image tile area not tile size multiple in: ${this.name}`), i = Math.floor(i), n = Math.floor(n), this.rows = i, this.columns = n, this.total = i * n, this.texCoordinates.length = 0; for (let s = this.tileMargin, r = this.tileMargin, o = 0; o < this.rows; o++) { for (let a = 0; a < this.columns; a++) this.texCoordinates.push({ x: s, y: r }), s += this.tileWidth + this.tileSpacing; s = this.tileMargin, r += this.tileHeight + this.tileSpacing; } return this; },
  }); t.exports = n;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(45); const s = i(72); const r = i(61); const o = i(0); const a = i(13); const h = i(14); const l = i(12); const u = i(55); const c = new o({
    Extends: h, Mixins: [a.Depth, a.GetBounds, a.Origin, a.Transform, a.ScrollFactor, a.Visible], initialize(t, e, i, s, r) { void 0 === s && (s = 1), void 0 === r && (r = s), h.call(this, t, 'Zone'), this.setPosition(e, i), this.width = s, this.height = r, this.blendMode = n.NORMAL, this.updateDisplayOrigin(); }, displayWidth: { get() { return this.scaleX * this.width; }, set(t) { this.scaleX = t / this.width; } }, displayHeight: { get() { return this.scaleY * this.height; }, set(t) { this.scaleY = t / this.height; } }, setSize(t, e, i) { void 0 === i && (i = !0), this.width = t, this.height = e, this.updateDisplayOrigin(); const n = this.input; return i && n && !n.customHitArea && (n.hitArea.width = t, n.hitArea.height = e), this; }, setDisplaySize(t, e) { return this.displayWidth = t, this.displayHeight = e, this; }, setCircleDropZone(t) { return this.setDropZone(new s(0, 0, t), r); }, setRectangleDropZone(t, e) { return this.setDropZone(new l(0, 0, t, e), u); }, setDropZone(t, e) { return void 0 === t ? this.setRectangleDropZone(this.width, this.height) : this.input || this.setInteractive(t, e, !0), this; }, setAlpha() {}, setBlendMode() {}, renderCanvas() {}, renderWebGL() {},
  }); t.exports = c;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = {
    ADD_ANIMATION: i(563), ANIMATION_COMPLETE: i(564), ANIMATION_REPEAT: i(565), ANIMATION_RESTART: i(566), ANIMATION_START: i(567), PAUSE_ALL: i(568), REMOVE_ANIMATION: i(569), RESUME_ALL: i(570), SPRITE_ANIMATION_COMPLETE: i(571), SPRITE_ANIMATION_KEY_COMPLETE: i(572), SPRITE_ANIMATION_KEY_REPEAT: i(573), SPRITE_ANIMATION_KEY_RESTART: i(574), SPRITE_ANIMATION_KEY_START: i(575), SPRITE_ANIMATION_KEY_UPDATE: i(576), SPRITE_ANIMATION_REPEAT: i(577), SPRITE_ANIMATION_RESTART: i(578), SPRITE_ANIMATION_START: i(579), SPRITE_ANIMATION_UPDATE: i(580),
  };
}, function (t, e) { t.exports = function (t) { return 2 * (t.width + t.height); }; }, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const i = {
    defaultPipeline: null, pipeline: null, initPipeline(t) { void 0 === t && (t = 'TextureTintPipeline'); const e = this.scene.sys.game.renderer; return !!(e && e.gl && e.hasPipeline(t)) && (this.defaultPipeline = e.getPipeline(t), this.pipeline = this.defaultPipeline, !0); }, setPipeline(t) { const e = this.scene.sys.game.renderer; return e && e.gl && e.hasPipeline(t) && (this.pipeline = e.getPipeline(t)), this; }, resetPipeline() { return this.pipeline = this.defaultPipeline, this.pipeline !== null; }, getPipelineName() { return this.pipeline.name; },
  }; t.exports = i;
}, function (t, e) { t.exports = function (t) { for (let e = t.length - 1; e > 0; e--) { const i = Math.floor(Math.random() * (e + 1)); const n = t[e]; t[e] = t[i], t[i] = n; } return t; }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(326); const s = i(327); const r = i(328); const o = i(329); const a = i(330); const h = i(331); const l = i(332); const u = i(333); const c = i(334); const d = i(335); const f = i(336); const p = i(337); t.exports = {
    Power0: l, Power1: u.Out, Power2: o.Out, Power3: c.Out, Power4: d.Out, Linear: l, Quad: u.Out, Cubic: o.Out, Quart: c.Out, Quint: d.Out, Sine: f.Out, Expo: h.Out, Circ: r.Out, Elastic: a.Out, Back: n.Out, Bounce: s.Out, Stepped: p, 'Quad.easeIn': u.In, 'Cubic.easeIn': o.In, 'Quart.easeIn': c.In, 'Quint.easeIn': d.In, 'Sine.easeIn': f.In, 'Expo.easeIn': h.In, 'Circ.easeIn': r.In, 'Elastic.easeIn': a.In, 'Back.easeIn': n.In, 'Bounce.easeIn': s.In, 'Quad.easeOut': u.Out, 'Cubic.easeOut': o.Out, 'Quart.easeOut': c.Out, 'Quint.easeOut': d.Out, 'Sine.easeOut': f.Out, 'Expo.easeOut': h.Out, 'Circ.easeOut': r.Out, 'Elastic.easeOut': a.Out, 'Back.easeOut': n.Out, 'Bounce.easeOut': s.Out, 'Quad.easeInOut': u.InOut, 'Cubic.easeInOut': o.InOut, 'Quart.easeInOut': c.InOut, 'Quint.easeInOut': d.InOut, 'Sine.easeInOut': f.InOut, 'Expo.easeInOut': h.InOut, 'Circ.easeInOut': r.InOut, 'Elastic.easeInOut': a.InOut, 'Back.easeInOut': n.InOut, 'Bounce.easeInOut': s.InOut,
  };
}, function (t, e) { t.exports = function (t, e, i) { return (e - t) * i + t; }; }, function (t, e, i) {
  (function (e) {
    /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
    const i = {
      android: !1, chromeOS: !1, cordova: !1, crosswalk: !1, desktop: !1, ejecta: !1, electron: !1, iOS: !1, iOSVersion: 0, iPad: !1, iPhone: !1, kindle: !1, linux: !1, macOS: !1, node: !1, nodeWebkit: !1, pixelRatio: 1, webApp: !1, windows: !1, windowsPhone: !1,
    }; t.exports = (function () { const t = navigator.userAgent; /Windows/.test(t) ? i.windows = !0 : /Mac OS/.test(t) && !/like Mac OS/.test(t) ? i.macOS = !0 : /Android/.test(t) ? i.android = !0 : /Linux/.test(t) ? i.linux = !0 : /iP[ao]d|iPhone/i.test(t) ? (i.iOS = !0, navigator.appVersion.match(/OS (\d+)/), i.iOSVersion = parseInt(RegExp.$1, 10), i.iPhone = t.toLowerCase().indexOf('iphone') !== -1, i.iPad = t.toLowerCase().indexOf('ipad') !== -1) : /Kindle/.test(t) || /\bKF[A-Z][A-Z]+/.test(t) || /Silk.*Mobile Safari/.test(t) ? i.kindle = !0 : /CrOS/.test(t) && (i.chromeOS = !0), (/Windows Phone/i.test(t) || /IEMobile/i.test(t)) && (i.android = !1, i.iOS = !1, i.macOS = !1, i.windows = !0, i.windowsPhone = !0); const n = /Silk/.test(t); return (i.windows || i.macOS || i.linux && !n || i.chromeOS) && (i.desktop = !0), (i.windowsPhone || /Windows NT/i.test(t) && /Touch/i.test(t)) && (i.desktop = !1), navigator.standalone && (i.webApp = !0), void 0 !== window.cordova && (i.cordova = !0), void 0 !== e && e.versions && e.versions.node && (i.node = !0), i.node && typeof e.versions === 'object' && (i.nodeWebkit = !!e.versions['node-webkit'], i.electron = !!e.versions.electron), void 0 !== window.ejecta && (i.ejecta = !0), /Crosswalk/.test(t) && (i.crosswalk = !0), i.pixelRatio = window.devicePixelRatio || 1, i; }());
  }).call(this, i(758));
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  let n; const s = i(127); const r = {
    chrome: !1, chromeVersion: 0, edge: !1, firefox: !1, firefoxVersion: 0, ie: !1, ieVersion: 0, mobileSafari: !1, opera: !1, safari: !1, safariVersion: 0, silk: !1, trident: !1, tridentVersion: 0,
  }; t.exports = (n = navigator.userAgent, /Edge\/\d+/.test(n) ? r.edge = !0 : /Chrome\/(\d+)/.test(n) && !s.windowsPhone ? (r.chrome = !0, r.chromeVersion = parseInt(RegExp.$1, 10)) : /Firefox\D+(\d+)/.test(n) ? (r.firefox = !0, r.firefoxVersion = parseInt(RegExp.$1, 10)) : /AppleWebKit/.test(n) && s.iOS ? r.mobileSafari = !0 : /MSIE (\d+\.\d+);/.test(n) ? (r.ie = !0, r.ieVersion = parseInt(RegExp.$1, 10)) : /Opera/.test(n) ? r.opera = !0 : /Safari/.test(n) && !s.windowsPhone ? r.safari = !0 : /Trident\/(\d+\.\d+)(.*)rv:(\d+\.\d+)/.test(n) && (r.ie = !0, r.trident = !0, r.tridentVersion = parseInt(RegExp.$1, 10), r.ieVersion = parseInt(RegExp.$3, 10)), /Silk/.test(n) && (r.silk = !0), r);
}, function (t, e) { t.exports = function (t, e) { return Math.random() * (e - t) + t; }; }, function (t, e) { t.exports = function (t, e) { return t > 0 && (t & t - 1) == 0 && e > 0 && (e & e - 1) == 0; }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  var n = new (i(0))({
    initialize(t, e, i, n) { this.x = 0, this.y = 0, this.z = 0, this.w = 0, typeof t === 'object' ? (this.x = t.x || 0, this.y = t.y || 0, this.z = t.z || 0, this.w = t.w || 0) : (this.x = t || 0, this.y = e || 0, this.z = i || 0, this.w = n || 0); }, clone() { return new n(this.x, this.y, this.z, this.w); }, copy(t) { return this.x = t.x, this.y = t.y, this.z = t.z || 0, this.w = t.w || 0, this; }, equals(t) { return this.x === t.x && this.y === t.y && this.z === t.z && this.w === t.w; }, set(t, e, i, n) { return typeof t === 'object' ? (this.x = t.x || 0, this.y = t.y || 0, this.z = t.z || 0, this.w = t.w || 0) : (this.x = t || 0, this.y = e || 0, this.z = i || 0, this.w = n || 0), this; }, add(t) { return this.x += t.x, this.y += t.y, this.z += t.z || 0, this.w += t.w || 0, this; }, subtract(t) { return this.x -= t.x, this.y -= t.y, this.z -= t.z || 0, this.w -= t.w || 0, this; }, scale(t) { return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this; }, length() { const t = this.x; const e = this.y; const i = this.z; const n = this.w; return Math.sqrt(t * t + e * e + i * i + n * n); }, lengthSq() { const t = this.x; const e = this.y; const i = this.z; const n = this.w; return t * t + e * e + i * i + n * n; }, normalize() { const t = this.x; const e = this.y; const i = this.z; const n = this.w; let s = t * t + e * e + i * i + n * n; return s > 0 && (s = 1 / Math.sqrt(s), this.x = t * s, this.y = e * s, this.z = i * s, this.w = n * s), this; }, dot(t) { return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w; }, lerp(t, e) { void 0 === e && (e = 0); const i = this.x; const n = this.y; const s = this.z; const r = this.w; return this.x = i + e * (t.x - i), this.y = n + e * (t.y - n), this.z = s + e * (t.z - s), this.w = r + e * (t.w - r), this; }, multiply(t) { return this.x *= t.x, this.y *= t.y, this.z *= t.z || 1, this.w *= t.w || 1, this; }, divide(t) { return this.x /= t.x, this.y /= t.y, this.z /= t.z || 1, this.w /= t.w || 1, this; }, distance(t) { const e = t.x - this.x; const i = t.y - this.y; const n = t.z - this.z || 0; const s = t.w - this.w || 0; return Math.sqrt(e * e + i * i + n * n + s * s); }, distanceSq(t) { const e = t.x - this.x; const i = t.y - this.y; const n = t.z - this.z || 0; const s = t.w - this.w || 0; return e * e + i * i + n * n + s * s; }, negate() { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this; }, transformMat4(t) { const e = this.x; const i = this.y; const n = this.z; const s = this.w; const r = t.val; return this.x = r[0] * e + r[4] * i + r[8] * n + r[12] * s, this.y = r[1] * e + r[5] * i + r[9] * n + r[13] * s, this.z = r[2] * e + r[6] * i + r[10] * n + r[14] * s, this.w = r[3] * e + r[7] * i + r[11] * n + r[15] * s, this; }, transformQuat(t) { const e = this.x; const i = this.y; const n = this.z; const s = t.x; const r = t.y; const o = t.z; const a = t.w; const h = a * e + r * n - o * i; const l = a * i + o * e - s * n; const u = a * n + s * i - r * e; const c = -s * e - r * i - o * n; return this.x = h * a + c * -s + l * -o - u * -r, this.y = l * a + c * -r + u * -s - h * -o, this.z = u * a + c * -o + h * -r - l * -s, this; }, reset() { return this.x = 0, this.y = 0, this.z = 0, this.w = 0, this; },
  }); n.prototype.sub = n.prototype.subtract, n.prototype.mul = n.prototype.multiply, n.prototype.div = n.prototype.divide, n.prototype.dist = n.prototype.distance, n.prototype.distSq = n.prototype.distanceSq, n.prototype.len = n.prototype.length, n.prototype.lenSq = n.prototype.lengthSq, t.exports = n;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = {
    ADD: i(807), ERROR: i(808), LOAD: i(809), READY: i(810), REMOVE: i(811),
  };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Felipe Alfonso <@bitnenfer>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(11); const r = new n({
    initialize(t) { this.name = 'WebGLPipeline', this.game = t.game, this.view = t.game.canvas, this.resolution = 1, this.width = 0, this.height = 0, this.gl = t.gl, this.vertexCount = 0, this.vertexCapacity = t.vertexCapacity, this.renderer = t.renderer, this.vertexData = t.vertices ? t.vertices : new ArrayBuffer(t.vertexCapacity * t.vertexSize), this.vertexBuffer = this.renderer.createVertexBuffer(t.vertices ? t.vertices : this.vertexData.byteLength, this.gl.STREAM_DRAW), this.program = this.renderer.createProgram(t.vertShader, t.fragShader), this.attributes = t.attributes, this.vertexSize = t.vertexSize, this.topology = t.topology, this.bytes = new Uint8Array(this.vertexData), this.vertexComponentCount = s.getComponentCount(t.attributes, this.gl), this.flushLocked = !1, this.active = !1; },
    boot() {},
    addAttribute(t, e, i, n, r) {
      return this.attributes.push({
        name: t, size: e, type: this.renderer.glFormats[i], normalized: n, offset: r,
      }), this.vertexComponentCount = s.getComponentCount(this.attributes, this.gl), this;
    },
    shouldFlush() { return this.vertexCount >= this.vertexCapacity; },
    resize(t, e, i) { return this.width = t * i, this.height = e * i, this.resolution = i, this; },
    bind() { const t = this.gl; const e = this.vertexBuffer; const i = this.attributes; const n = this.program; const s = this.renderer; const r = this.vertexSize; s.setProgram(n), s.setVertexBuffer(e); for (let o = 0; o < i.length; ++o) { const a = i[o]; const h = t.getAttribLocation(n, a.name); h >= 0 ? (t.enableVertexAttribArray(h), t.vertexAttribPointer(h, a.size, a.type, a.normalized, r, a.offset)) : h !== -1 && t.disableVertexAttribArray(h); } return this; },
    onBind() { return this; },
    onPreRender() { return this; },
    onRender() { return this; },
    onPostRender() { return this; },
    flush() { if (this.flushLocked) return this; this.flushLocked = !0; const t = this.gl; const e = this.vertexCount; const i = this.topology; const n = this.vertexSize; if (e !== 0) return t.bufferSubData(t.ARRAY_BUFFER, 0, this.bytes.subarray(0, e * n)), t.drawArrays(i, 0, e), this.vertexCount = 0, this.flushLocked = !1, this; this.flushLocked = !1; },
    destroy() { const t = this.gl; return t.deleteProgram(this.program), t.deleteBuffer(this.vertexBuffer), delete this.program, delete this.vertexBuffer, delete this.gl, this; },
    setFloat1(t, e) { return this.renderer.setFloat1(this.program, t, e), this; },
    setFloat2(t, e, i) { return this.renderer.setFloat2(this.program, t, e, i), this; },
    setFloat3(t, e, i, n) { return this.renderer.setFloat3(this.program, t, e, i, n), this; },
    setFloat4(t, e, i, n, s) { return this.renderer.setFloat4(this.program, t, e, i, n, s), this; },
    setFloat1v(t, e) { return this.renderer.setFloat1v(this.program, t, e), this; },
    setFloat2v(t, e) { return this.renderer.setFloat2v(this.program, t, e), this; },
    setFloat3v(t, e) { return this.renderer.setFloat3v(this.program, t, e), this; },
    setFloat4v(t, e) { return this.renderer.setFloat4v(this.program, t, e), this; },
    setInt1(t, e) { return this.renderer.setInt1(this.program, t, e), this; },
    setInt2(t, e, i) { return this.renderer.setInt2(this.program, t, e, i), this; },
    setInt3(t, e, i, n) { return this.renderer.setInt3(this.program, t, e, i, n), this; },
    setInt4(t, e, i, n, s) { return this.renderer.setInt4(this.program, t, e, i, n, s), this; },
    setMatrix2(t, e, i) { return this.renderer.setMatrix2(this.program, t, e, i), this; },
    setMatrix3(t, e, i) { return this.renderer.setMatrix3(this.program, t, e, i), this; },
    setMatrix4(t, e, i) { return this.renderer.setMatrix4(this.program, t, e, i), this; },
  }); t.exports = r;
}, function (t, e) { t.exports = function (t, e) { let i; if (e) typeof e === 'string' ? i = document.getElementById(e) : typeof e === 'object' && e.nodeType === 1 && (i = e); else if (t.parentElement) return t; return i || (i = document.body), i.appendChild(t), t; }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(88); t.exports = function (t, e, i, s) { let r; if (void 0 === s && (s = t), !Array.isArray(e)) return (r = t.indexOf(e)) !== -1 ? (n(t, r), i && i.call(s, e), e) : null; for (let o = e.length - 1; o >= 0;) { const a = e[o]; (r = t.indexOf(a)) !== -1 ? (n(t, r), i && i.call(s, a)) : e.pop(), o--; } return e; };
}, function (t, e) {
  t.exports = {
    BACKSPACE: 8, TAB: 9, ENTER: 13, SHIFT: 16, CTRL: 17, ALT: 18, PAUSE: 19, CAPS_LOCK: 20, ESC: 27, SPACE: 32, PAGE_UP: 33, PAGE_DOWN: 34, END: 35, HOME: 36, LEFT: 37, UP: 38, RIGHT: 39, DOWN: 40, PRINT_SCREEN: 42, INSERT: 45, DELETE: 46, ZERO: 48, ONE: 49, TWO: 50, THREE: 51, FOUR: 52, FIVE: 53, SIX: 54, SEVEN: 55, EIGHT: 56, NINE: 57, NUMPAD_ZERO: 96, NUMPAD_ONE: 97, NUMPAD_TWO: 98, NUMPAD_THREE: 99, NUMPAD_FOUR: 100, NUMPAD_FIVE: 101, NUMPAD_SIX: 102, NUMPAD_SEVEN: 103, NUMPAD_EIGHT: 104, NUMPAD_NINE: 105, NUMPAD_ADD: 107, NUMPAD_SUBTRACT: 109, A: 65, B: 66, C: 67, D: 68, E: 69, F: 70, G: 71, H: 72, I: 73, J: 74, K: 75, L: 76, M: 77, N: 78, O: 79, P: 80, Q: 81, R: 82, S: 83, T: 84, U: 85, V: 86, W: 87, X: 88, Y: 89, Z: 90, F1: 112, F2: 113, F3: 114, F4: 115, F5: 116, F6: 117, F7: 118, F8: 119, F9: 120, F10: 121, F11: 122, F12: 123, SEMICOLON: 186, PLUS: 187, COMMA: 188, MINUS: 189, PERIOD: 190, FORWARD_SLASH: 191, BACK_SLASH: 220, QUOTES: 222, BACKTICK: 192, OPEN_BRACKET: 219, CLOSED_BRACKET: 221, SEMICOLON_FIREFOX: 59, COLON: 58, COMMA_FIREFOX_WINDOWS: 60, COMMA_FIREFOX: 62, BRACKET_RIGHT_FIREFOX: 174, BRACKET_LEFT_FIREFOX: 175,
  };
}, function (t, e) {
  t.exports = {
    PENDING: 0, INIT: 1, START: 2, LOADING: 3, CREATING: 4, RUNNING: 5, PAUSED: 6, SLEEPING: 7, SHUTDOWN: 8, DESTROYED: 9,
  };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Pavle Goloskokovic <pgoloskokovic@gmail.com> (http://prunegames.com)
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(74); const r = i(10); const o = i(65); const a = i(22); const h = i(1); const l = i(414); const u = i(415); const c = new n({
    Extends: r,
    initialize(t) { r.call(this), this.game = t, this.jsonCache = t.cache.json, this.sounds = [], this.mute = !1, this.volume = 1, this.pauseOnBlur = !0, this._rate = 1, this._detune = 0, this.locked = this.locked || !1, this.unlocked = !1, t.events.on(a.BLUR, this.onGameBlur, this), t.events.on(a.FOCUS, this.onGameFocus, this), t.events.on(a.PRE_STEP, this.update, this), t.events.once(a.DESTROY, this.destroy, this); },
    add: h,
    addAudioSprite(t, e) {
      void 0 === e && (e = {}); const i = this.add(t, e); for (const n in i.spritemap = this.jsonCache.get(t).spritemap, i.spritemap) {
        if (i.spritemap.hasOwnProperty(n)) {
          const r = s(e); const o = i.spritemap[n]; r.loop = !!o.hasOwnProperty('loop') && o.loop, i.addMarker({
            name: n, start: o.start, duration: o.end - o.start, config: r,
          });
        }
      } return i;
    },
    get(t) { return u(this.sounds, 'key', t); },
    getAll(t) { return l(this.sounds, 'key', t); },
    play(t, e) { const i = this.add(t); return i.once(o.COMPLETE, i.destroy, i), e ? e.name ? (i.addMarker(e), i.play(e.name)) : i.play(e) : i.play(); },
    playAudioSprite(t, e, i) { const n = this.addAudioSprite(t); return n.once(o.COMPLETE, n.destroy, n), n.play(e, i); },
    remove(t) { const e = this.sounds.indexOf(t); return e !== -1 && (t.destroy(), this.sounds.splice(e, 1), !0); },
    removeAll() { this.sounds.forEach(((t) => { t.destroy(); })), this.sounds.length = 0; },
    removeByKey(t) { for (var e = 0, i = this.sounds.length - 1; i >= 0; i--) { const n = this.sounds[i]; n.key === t && (n.destroy(), this.sounds.splice(i, 1), e++); } return e; },
    pauseAll() { this.forEachActiveSound(((t) => { t.pause(); })), this.emit(o.PAUSE_ALL, this); },
    resumeAll() { this.forEachActiveSound(((t) => { t.resume(); })), this.emit(o.RESUME_ALL, this); },
    stopAll() { this.forEachActiveSound(((t) => { t.stop(); })), this.emit(o.STOP_ALL, this); },
    stopByKey(t) { let e = 0; return this.getAll(t).forEach(((t) => { t.stop() && e++; })), e; },
    unlock: h,
    onBlur: h,
    onFocus: h,
    onGameBlur() { this.pauseOnBlur && this.onBlur(); },
    onGameFocus() { this.pauseOnBlur && this.onFocus(); },
    update(t, e) { this.unlocked && (this.unlocked = !1, this.locked = !1, this.emit(o.UNLOCKED, this)); for (let i = this.sounds.length - 1; i >= 0; i--) this.sounds[i].pendingRemove && this.sounds.splice(i, 1); this.sounds.forEach(((i) => { i.update(t, e); })); },
    destroy() { this.game.events.off(a.BLUR, this.onGameBlur, this), this.game.events.off(a.FOCUS, this.onGameFocus, this), this.game.events.off(a.PRE_STEP, this.update, this), this.removeAllListeners(), this.removeAll(), this.sounds.length = 0, this.sounds = null, this.game = null; },
    forEachActiveSound(t, e) { const i = this; this.sounds.forEach(((n, s) => { n && !n.pendingRemove && t.call(e || i, n, s, i.sounds); })); },
    setRate(t) { return this.rate = t, this; },
    rate: { get() { return this._rate; }, set(t) { this._rate = t, this.forEachActiveSound(((t) => { t.calculateRate(); })), this.emit(o.GLOBAL_RATE, this, t); } },
    setDetune(t) { return this.detune = t, this; },
    detune: { get() { return this._detune; }, set(t) { this._detune = t, this.forEachActiveSound(((t) => { t.calculateRate(); })), this.emit(o.GLOBAL_DETUNE, this, t); } },
  }); t.exports = c;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Pavle Goloskokovic <pgoloskokovic@gmail.com> (http://prunegames.com)
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(10); const r = i(65); const o = i(19); const a = i(1); const h = new n({
    Extends: s,
    initialize(t, e, i) {
      s.call(this), this.manager = t, this.key = e, this.isPlaying = !1, this.isPaused = !1, this.totalRate = 1, this.duration = this.duration || 0, this.totalDuration = this.totalDuration || 0, this.config = {
        mute: !1, volume: 1, rate: 1, detune: 0, seek: 0, loop: !1, delay: 0,
      }, this.currentConfig = this.config, this.config = o(this.config, i), this.markers = {}, this.currentMarker = null, this.pendingRemove = !1;
    },
    addMarker(t) {
      return !(!t || !t.name || typeof t.name !== 'string') && (this.markers[t.name] ? (console.error(`addMarker ${t.name} already exists in Sound`), !1) : (t = o(!0, {
        name: '',
        start: 0,
        duration: this.totalDuration - (t.start || 0),
        config: {
          mute: !1, volume: 1, rate: 1, detune: 0, seek: 0, loop: !1, delay: 0,
        },
      }, t), this.markers[t.name] = t, !0));
    },
    updateMarker(t) { return !(!t || !t.name || typeof t.name !== 'string') && (this.markers[t.name] ? (this.markers[t.name] = o(!0, this.markers[t.name], t), !0) : (console.warn(`Audio Marker: ${t.name} missing in Sound: ${this.key}`), !1)); },
    removeMarker(t) { const e = this.markers[t]; return e ? (this.markers[t] = null, e) : null; },
    play(t, e) { if (void 0 === t && (t = ''), typeof t === 'object' && (e = t, t = ''), typeof t !== 'string') return !1; if (t) { if (!this.markers[t]) return console.warn(`Marker: ${t} missing in Sound: ${this.key}`), !1; this.currentMarker = this.markers[t], this.currentConfig = this.currentMarker.config, this.duration = this.currentMarker.duration; } else this.currentMarker = null, this.currentConfig = this.config, this.duration = this.totalDuration; return this.resetConfig(), this.currentConfig = o(this.currentConfig, e), this.isPlaying = !0, this.isPaused = !1, !0; },
    pause() { return !(this.isPaused || !this.isPlaying) && (this.isPlaying = !1, this.isPaused = !0, !0); },
    resume() { return !(!this.isPaused || this.isPlaying) && (this.isPlaying = !0, this.isPaused = !1, !0); },
    stop() { return !(!this.isPaused && !this.isPlaying) && (this.isPlaying = !1, this.isPaused = !1, this.resetConfig(), !0); },
    applyConfig() { this.mute = this.currentConfig.mute, this.volume = this.currentConfig.volume, this.rate = this.currentConfig.rate, this.detune = this.currentConfig.detune, this.loop = this.currentConfig.loop; },
    resetConfig() { this.currentConfig.seek = 0, this.currentConfig.delay = 0; },
    update: a,
    calculateRate() { const t = this.currentConfig.detune + this.manager.detune; const e = Math.pow(1.0005777895065548, t); this.totalRate = this.currentConfig.rate * this.manager.rate * e; },
    destroy() { this.pendingRemove || (this.emit(r.DESTROY, this), this.pendingRemove = !0, this.manager = null, this.key = '', this.removeAllListeners(), this.isPlaying = !1, this.isPaused = !1, this.config = null, this.currentConfig = null, this.markers = null, this.currentMarker = null); },
  }); t.exports = h;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(200); const s = i(0); const r = i(1); const o = i(142); const a = new s({
    initialize(t) { this.parent = t, this.list = [], this.position = 0, this.addCallback = r, this.removeCallback = r, this._sortKey = ''; }, add(t, e) { return e ? n.Add(this.list, t) : n.Add(this.list, t, 0, this.addCallback, this); }, addAt(t, e, i) { return i ? n.AddAt(this.list, t, e) : n.AddAt(this.list, t, e, 0, this.addCallback, this); }, getAt(t) { return this.list[t]; }, getIndex(t) { return this.list.indexOf(t); }, sort(t, e) { return t ? (void 0 === e && (e = function (e, i) { return e[t] - i[t]; }), o.inplace(this.list, e), this) : this; }, getByName(t) { return n.GetFirst(this.list, 'name', t); }, getRandom(t, e) { return n.GetRandom(this.list, t, e); }, getFirst(t, e, i, s) { return n.GetFirst(this.list, t, e, i, s); }, getAll(t, e, i, s) { return n.GetAll(this.list, t, e, i, s); }, count(t, e) { return n.CountAllMatching(this.list, t, e); }, swap(t, e) { n.Swap(this.list, t, e); }, moveTo(t, e) { return n.MoveTo(this.list, t, e); }, remove(t, e) { return e ? n.Remove(this.list, t) : n.Remove(this.list, t, this.removeCallback, this); }, removeAt(t, e) { return e ? n.RemoveAt(this.list, t) : n.RemoveAt(this.list, t, this.removeCallback, this); }, removeBetween(t, e, i) { return i ? n.RemoveBetween(this.list, t, e) : n.RemoveBetween(this.list, t, e, this.removeCallback, this); }, removeAll(t) { for (let e = this.list.length; e--;) this.remove(this.list[e], t); return this; }, bringToTop(t) { return n.BringToTop(this.list, t); }, sendToBack(t) { return n.SendToBack(this.list, t); }, moveUp(t) { return n.MoveUp(this.list, t), t; }, moveDown(t) { return n.MoveDown(this.list, t), t; }, reverse() { return this.list.reverse(), this; }, shuffle() { return n.Shuffle(this.list), this; }, replace(t, e) { return n.Replace(this.list, t, e); }, exists(t) { return this.list.indexOf(t) > -1; }, setAll(t, e, i, s) { return n.SetAll(this.list, t, e, i, s), this; }, each(t, e) { for (var i = [null], n = 2; n < arguments.length; n++)i.push(arguments[n]); for (n = 0; n < this.list.length; n++)i[0] = this.list[n], t.apply(e, i); }, shutdown() { this.removeAll(), this.list = []; }, destroy() { this.removeAll(), this.parent = null, this.addCallback = null, this.removeCallback = null; }, length: { get() { return this.list.length; } }, first: { get() { return this.position = 0, this.list.length > 0 ? this.list[0] : null; } }, last: { get() { return this.list.length > 0 ? (this.position = this.list.length - 1, this.list[this.position]) : null; } }, next: { get() { return this.position < this.list.length ? (this.position++, this.list[this.position]) : null; } }, previous: { get() { return this.position > 0 ? (this.position--, this.list[this.position]) : null; } },
  }); t.exports = a;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(201); const s = i(423); t.exports = function (t, e) { if (void 0 === e && (e = 90), !n(t)) return null; if (typeof e !== 'string' && (e = (e % 360 + 360) % 360), e === 90 || e === -270 || e === 'rotateLeft')(t = s(t)).reverse(); else if (e === -90 || e === 270 || e === 'rotateRight')t.reverse(), t = s(t); else if (Math.abs(e) === 180 || e === 'rotate180') { for (let i = 0; i < t.length; i++)t[i].reverse(); t.reverse(); } return t; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  //! stable.js 0.1.6, https://github.com/Two-Screen/stable
  //!  2017 Angry Bytes and contributors. MIT licensed.
  !(function () { const e = function (t, e) { return i(t.slice(), e); }; function i(t, e) { typeof e !== 'function' && (e = function (t, e) { return String(t).localeCompare(e); }); const i = t.length; if (i <= 1) return t; for (let s = new Array(i), r = 1; r < i; r *= 2) { n(t, e, r, s); const o = t; t = s, s = o; } return t; }e.inplace = function (t, e) { const s = i(t, e); return s !== t && n(s, null, t.length, t), t; }; var n = function (t, e, i, n) { let s; let r; let o; let a; let h; const l = t.length; let u = 0; const c = 2 * i; for (s = 0; s < l; s += c) for (o = (r = s + i) + i, r > l && (r = l), o > l && (o = l), a = s, h = r; ;) if (a < r && h < o)e(t[a], t[h]) <= 0 ? n[u++] = t[a++] : n[u++] = t[h++]; else if (a < r)n[u++] = t[a++]; else { if (!(h < o)) break; n[u++] = t[h++]; } }; t.exports = e; }());
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(13); const r = i(14); const o = i(975); const a = i(976); const h = i(205); const l = i(977); var u = new n({
    Extends: r,
    Mixins: [s.Alpha, s.BlendMode, s.Depth, s.Mask, s.Origin, s.Pipeline, s.ScrollFactor, s.Texture, s.Tint, s.Transform, s.Visible, l],
    initialize(t, e, i, n, s, a, h) { void 0 === s && (s = ''), void 0 === h && (h = 0), r.call(this, t, 'BitmapText'), this.font = n; const l = this.scene.sys.cache.bitmapFont.get(n); this.fontData = l.data, this._text = '', this._fontSize = a || this.fontData.size, this._letterSpacing = 0, this._align = h, this._bounds = o(), this._dirty = !0, this._maxWidth = 0, this.wordWrapCharCode = 32, this.setTexture(l.texture, l.frame), this.setPosition(e, i), this.setOrigin(0, 0), this.initPipeline(), this.setText(s); },
    setLeftAlign() { return this._align = u.ALIGN_LEFT, this._dirty = !0, this; },
    setCenterAlign() { return this._align = u.ALIGN_CENTER, this._dirty = !0, this; },
    setRightAlign() { return this._align = u.ALIGN_RIGHT, this._dirty = !0, this; },
    setFontSize(t) { return this._fontSize = t, this._dirty = !0, this; },
    setLetterSpacing(t) { return void 0 === t && (t = 0), this._letterSpacing = t, this._dirty = !0, this; },
    setText(t) { return t || t === 0 || (t = ''), Array.isArray(t) && (t = t.join('\n')), t !== this.text && (this._text = t.toString(), this._dirty = !0, this.updateDisplayOrigin()), this; },
    getTextBounds(t) { const e = this._bounds; return (this._dirty || this.scaleX !== e.scaleX || this.scaleY !== e.scaleY) && (o(this, t, e), this._dirty = !1, this.updateDisplayOrigin()), e; },
    setFont(t, e, i) { if (void 0 === e && (e = this._fontSize), void 0 === i && (i = this._align), t !== this.font) { const n = this.scene.sys.cache.bitmapFont.get(t); n && (this.font = t, this.fontData = n.data, this._fontSize = e, this._align = i, this.setTexture(n.texture, n.frame), o(this, !1, this._bounds)); } return this; },
    setMaxWidth(t, e) { return this._maxWidth = t, this._dirty = !0, void 0 !== e && (this.wordWrapCharCode = e), this; },
    align: { set(t) { this._align = t, this._dirty = !0; }, get() { return this._align; } },
    text: { set(t) { this.setText(t); }, get() { return this._text; } },
    fontSize: { set(t) { this._fontSize = t, this._dirty = !0; }, get() { return this._fontSize; } },
    letterSpacing: { set(t) { this._letterSpacing = t, this._dirty = !0; }, get() { return this._letterSpacing; } },
    maxWidth: { set(t) { this._maxWidth = t, this._dirty = !0; }, get() { return this._maxWidth; } },
    width: { get() { return this.getTextBounds(!1), this._bounds.global.width; } },
    height: { get() { return this.getTextBounds(!1), this._bounds.global.height; } },
    toJSON() {
      const t = s.ToJSON(this); const e = {
        font: this.font, text: this.text, fontSize: this.fontSize, letterSpacing: this.letterSpacing, align: this.align,
      }; return t.data = e, t;
    },
  }); u.ALIGN_LEFT = 0, u.ALIGN_CENTER = 1, u.ALIGN_RIGHT = 2, u.ParseFromAtlas = a, u.ParseXMLBitmapFont = h, t.exports = u;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(13); const r = i(14); const o = i(1107); const a = i(1); const h = new n({
    Extends: r, Mixins: [s.BlendMode, s.Depth, s.Mask, s.Pipeline, s.Size, s.Texture, s.Transform, s.Visible, s.ScrollFactor, o], initialize(t, e, i, n, s, o, a, h, l) { if (r.call(this, t, 'Mesh'), n.length !== s.length) throw new Error('Mesh Vertex count must match UV count'); let u; const c = n.length / 2 | 0; if (o.length > 0 && o.length < c) throw new Error('Mesh Color count must match Vertex count'); if (a.length > 0 && a.length < c) throw new Error('Mesh Alpha count must match Vertex count'); if (o.length === 0) for (u = 0; u < c; ++u)o[u] = 16777215; if (a.length === 0) for (u = 0; u < c; ++u)a[u] = 1; this.vertices = new Float32Array(n), this.uv = new Float32Array(s), this.colors = new Uint32Array(o), this.alphas = new Float32Array(a), this.tintFill = !1, this.setTexture(h, l), this.setPosition(e, i), this.setSizeToFrame(), this.initPipeline(); }, setAlpha: a,
  }); t.exports = h;
}, function (t, e) { t.exports = function (t, e) { return !(t.width <= 0 || t.height <= 0 || e.width <= 0 || e.height <= 0) && !(t.right < e.x || t.bottom < e.y || t.x > e.right || t.y > e.bottom); }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(6); const s = {}; const r = {
    register(t, e, i, n, r) {
      s[t] = {
        plugin: e, mapping: i, settingsKey: n, configKey: r,
      };
    },
    getPlugin(t) { return s[t]; },
    install(t) { const e = t.scene.sys; const i = e.settings.input; const r = e.game.config; for (const o in s) { const a = s[o].plugin; const h = s[o].mapping; const l = s[o].settingsKey; const u = s[o].configKey; n(i, l, r[u]) && (t[h] = new a(t)); } },
    remove(t) { s.hasOwnProperty(t) && delete s[t]; },
  }; t.exports = r;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = {
    ANY_KEY_DOWN: i(1247), ANY_KEY_UP: i(1248), COMBO_MATCH: i(1249), DOWN: i(1250), KEY_DOWN: i(1251), KEY_UP: i(1252), UP: i(1253),
  };
}, function (t, e) { t.exports = function (t, e) { return !!t.url && (t.url.match(/^(?:blob:|data:|http:\/\/|https:\/\/|\/\/)/) ? t.url : e + t.url); }; }, function (t, e) {
  t.exports = function (t, e, i, n, s, r) {
    return void 0 === t && (t = ''), void 0 === e && (e = !0), void 0 === i && (i = ''), void 0 === n && (n = ''), void 0 === s && (s = 0), void 0 === r && (r = !1), {
      responseType: t, async: e, user: i, password: n, timeout: s, headers: void 0, header: void 0, headerValue: void 0, requestedWith: !1, overrideMimeType: void 0, withCredentials: r,
    };
  };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(235); const r = i(66); const o = new n({ Extends: r, Mixins: [s.Acceleration, s.Angular, s.Bounce, s.Debug, s.Drag, s.Enable, s.Friction, s.Gravity, s.Immovable, s.Mass, s.Size, s.Velocity], initialize(t, e, i, n, s) { r.call(this, t, e, i, n, s), this.body = null; } }); t.exports = o;
}, function (t, e, i) { const n = {}; t.exports = n; const s = i(37); const r = i(21); n.fromVertices = function (t) { for (var e = {}, i = 0; i < t.length; i++) { const n = (i + 1) % t.length; const o = s.normalise({ x: t[n].y - t[i].y, y: t[i].x - t[n].x }); let a = o.y === 0 ? 1 / 0 : o.x / o.y; e[a = a.toFixed(3).toString()] = o; } return r.values(e); }, n.rotate = function (t, e) { if (e !== 0) for (let i = Math.cos(e), n = Math.sin(e), s = 0; s < t.length; s++) { var r; const o = t[s]; r = o.x * i - o.y * n, o.y = o.x * n + o.y * i, o.x = r; } }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = {
    Bounce: i(1325), Collision: i(1326), Force: i(1327), Friction: i(1328), Gravity: i(1329), Mass: i(1330), Static: i(1331), Sensor: i(1332), SetBody: i(1333), Sleep: i(1334), Transform: i(1351), Velocity: i(1352),
  };
}, function (t, e, i) { const n = {}; t.exports = n; const s = i(154); const r = i(115); const o = i(38); n.collisions = function (t, e) { for (var i = [], a = e.pairs.table, h = e.metrics, l = 0; l < t.length; l++) { const u = t[l][0]; const c = t[l][1]; if ((!u.isStatic && !u.isSleeping || !c.isStatic && !c.isSleeping) && n.canCollide(u.collisionFilter, c.collisionFilter) && (h.midphaseTests += 1, o.overlaps(u.bounds, c.bounds))) for (let d = u.parts.length > 1 ? 1 : 0; d < u.parts.length; d++) for (let f = u.parts[d], p = c.parts.length > 1 ? 1 : 0; p < c.parts.length; p++) { const g = c.parts[p]; if (f === u && g === c || o.overlaps(f.bounds, g.bounds)) { var v; const m = a[r.id(f, g)]; v = m && m.isActive ? m.collision : null; const y = s.collides(f, g, v); h.narrowphaseTests += 1, y.reused && (h.narrowReuseCount += 1), y.collided && (i.push(y), h.narrowDetections += 1); } } } return i; }, n.canCollide = function (t, e) { return t.group === e.group && t.group !== 0 ? t.group > 0 : (t.mask & e.category) != 0 && (e.mask & t.category) != 0; }; }, function (t, e, i) { const n = {}; t.exports = n; const s = i(32); const r = i(37); n.collides = function (t, e, i) { let o; let a; let h; let l; let u = !1; if (i) { const c = t.parent; const d = e.parent; const f = c.speed * c.speed + c.angularSpeed * c.angularSpeed + d.speed * d.speed + d.angularSpeed * d.angularSpeed; u = i && i.collided && f < 0.2, l = i; } else l = { collided: !1, bodyA: t, bodyB: e }; if (i && u) { const p = l.axisBody; const g = p === t ? e : t; const v = [p.axes[i.axisNumber]]; if (h = n._overlapAxes(p.vertices, g.vertices, v), l.reused = !0, h.overlap <= 0) return l.collided = !1, l; } else { if ((o = n._overlapAxes(t.vertices, e.vertices, t.axes)).overlap <= 0) return l.collided = !1, l; if ((a = n._overlapAxes(e.vertices, t.vertices, e.axes)).overlap <= 0) return l.collided = !1, l; o.overlap < a.overlap ? (h = o, l.axisBody = t) : (h = a, l.axisBody = e), l.axisNumber = h.axisNumber; }l.bodyA = t.id < e.id ? t : e, l.bodyB = t.id < e.id ? e : t, l.collided = !0, l.depth = h.overlap, l.parentA = l.bodyA.parent, l.parentB = l.bodyB.parent, t = l.bodyA, e = l.bodyB, r.dot(h.axis, r.sub(e.position, t.position)) < 0 ? l.normal = { x: h.axis.x, y: h.axis.y } : l.normal = { x: -h.axis.x, y: -h.axis.y }, l.tangent = r.perp(l.normal), l.penetration = l.penetration || {}, l.penetration.x = l.normal.x * l.depth, l.penetration.y = l.normal.y * l.depth; const m = n._findSupports(t, e, l.normal); let y = []; if (s.contains(t.vertices, m[0]) && y.push(m[0]), s.contains(t.vertices, m[1]) && y.push(m[1]), y.length < 2) { const x = n._findSupports(e, t, r.neg(l.normal)); s.contains(e.vertices, x[0]) && y.push(x[0]), y.length < 2 && s.contains(e.vertices, x[1]) && y.push(x[1]); } return y.length < 1 && (y = [m[0]]), l.supports = y, l; }, n._overlapAxes = function (t, e, i) { for (var s, o, a = r._temp[0], h = r._temp[1], l = { overlap: Number.MAX_VALUE }, u = 0; u < i.length; u++) { if (o = i[u], n._projectToAxis(a, t, o), n._projectToAxis(h, e, o), (s = Math.min(a.max - h.min, h.max - a.min)) <= 0) return l.overlap = s, l; s < l.overlap && (l.overlap = s, l.axis = o, l.axisNumber = u); } return l; }, n._projectToAxis = function (t, e, i) { for (var n = r.dot(e[0], i), s = n, o = 1; o < e.length; o += 1) { const a = r.dot(e[o], i); a > s ? s = a : a < n && (n = a); }t.min = n, t.max = s; }, n._findSupports = function (t, e, i) { for (var n, s, o, a, h = Number.MAX_VALUE, l = r._temp[0], u = e.vertices, c = t.position, d = 0; d < u.length; d++)s = u[d], l.x = s.x - c.x, l.y = s.y - c.y, (n = -r.dot(i, l)) < h && (h = n, o = s); return s = u[o.index - 1 >= 0 ? o.index - 1 : u.length - 1], l.x = s.x - c.x, l.y = s.y - c.y, h = -r.dot(i, l), a = s, s = u[(o.index + 1) % u.length], l.x = s.x - c.x, l.y = s.y - c.y, (n = -r.dot(i, l)) < h && (a = s), [o, a]; }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = {
    CalculateFacesAt: i(249), CalculateFacesWithin: i(60), Copy: i(1373), CreateFromTiles: i(1374), CullTiles: i(1375), Fill: i(1376), FilterTiles: i(1377), FindByIndex: i(1378), FindTile: i(1379), ForEachTile: i(1380), GetTileAt: i(156), GetTileAtWorldXY: i(1381), GetTilesWithin: i(27), GetTilesWithinShape: i(1382), GetTilesWithinWorldXY: i(1383), HasTileAt: i(516), HasTileAtWorldXY: i(1384), IsInLayerBounds: i(116), PutTileAt: i(250), PutTileAtWorldXY: i(1385), PutTilesAt: i(1386), Randomize: i(1387), RemoveTileAt: i(517), RemoveTileAtWorldXY: i(1388), RenderDebug: i(1389), ReplaceByIndex: i(515), SetCollision: i(1390), SetCollisionBetween: i(1391), SetCollisionByExclusion: i(1392), SetCollisionByProperty: i(1393), SetCollisionFromCollisionGroup: i(1394), SetTileIndexCallback: i(1395), SetTileLocationCallback: i(1396), Shuffle: i(1397), SwapByIndex: i(1398), TileToWorldX: i(157), TileToWorldXY: i(1399), TileToWorldY: i(158), WeightedRandomize: i(1400), WorldToTileX: i(70), WorldToTileXY: i(1401), WorldToTileY: i(71),
  };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(116); t.exports = function (t, e, i, s) { if (void 0 === i && (i = !1), n(t, e, s)) { const r = s.data[e][t] || null; return r === null ? null : r.index === -1 ? i ? r : null : r; } return null; };
}, function (t, e) { t.exports = function (t, e, i) { let n = i.baseTileWidth; const s = i.tilemapLayer; let r = 0; return s && (void 0 === e && (e = s.scene.cameras.main), r = s.x + e.scrollX * (1 - s.scrollFactorX), n *= s.scaleX), r + t * n; }; }, function (t, e) { t.exports = function (t, e, i) { let n = i.baseTileHeight; const s = i.tilemapLayer; let r = 0; return s && (void 0 === e && (e = s.scene.cameras.main), r = s.y + e.scrollY * (1 - s.scrollFactorY), n *= s.scaleY), r + t * n; }; }, function (t, e) { t.exports = function (t, e, i) { let n; t.hasOwnProperty(e) ? n = typeof t[e] === 'function' ? function (i, n, s, r, o, a) { return t[e](i, n, s, r, o, a); } : function () { return t[e]; } : n = typeof i === 'function' ? i : function () { return i; }; return n; }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(259); const s = i(15); const r = i(99); const o = i(76); const a = i(159); const h = i(538); const l = i(257); const u = i(6); const c = i(258); const d = i(260); const f = i(262); t.exports = function (t, e, i) { void 0 === i && (i = n); for (var p = i.targets ? i.targets : l(e), g = h(e), v = a(e, 'delay', i.delay), m = a(e, 'duration', i.duration), y = u(e, 'easeParams', i.easeParams), x = o(u(e, 'ease', i.ease), y), T = a(e, 'hold', i.hold), w = a(e, 'repeat', i.repeat), b = a(e, 'repeatDelay', i.repeatDelay), E = r(e, 'yoyo', i.yoyo), S = r(e, 'flipX', i.flipX), A = r(e, 'flipY', i.flipY), _ = [], C = 0; C < g.length; C++) for (let M = g[C].key, P = g[C].value, O = 0; O < p.length; O++) { const R = c(M, P); const L = f(p[O], O, M, R.getEnd, R.getStart, R.getActive, o(u(P, 'ease', x), y), a(P, 'delay', v), a(P, 'duration', m), r(P, 'yoyo', E), a(P, 'hold', T), a(P, 'repeat', w), a(P, 'repeatDelay', b), r(P, 'flipX', S), r(P, 'flipY', A)); _.push(L); } const D = new d(t, _, p); D.offset = s(e, 'offset', null), D.completeDelay = s(e, 'completeDelay', 0), D.loop = Math.round(s(e, 'loop', 0)), D.loopDelay = Math.round(s(e, 'loopDelay', 0)), D.paused = r(e, 'paused', !1), D.useFrames = r(e, 'useFrames', !1); for (let k = u(e, 'callbackScope', D), F = [D, null], I = d.TYPES, B = 0; B < I.length; B++) { const N = I[B]; const Y = u(e, N, !1); if (Y) { const X = u(e, `${N}Scope`, k); const z = u(e, `${N}Params`, []); D.setCallback(N, Y, F.concat(z), X); } } return D; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2018 Photon Storm Ltd.
 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
 */
  const n = i(0); const s = i(14); const r = i(66); const o = i(3); const a = i(131); const h = new n({
    Extends: s, initialize(t, e, i, n, h, l) { s.call(this, t, 'Sprite3D'), this.gameObject = new r(t, 0, 0, h, l), this.position = new a(e, i, n), this.size = new o(this.gameObject.width, this.gameObject.height), this.scale = new o(1, 1), this.adjustScaleX = !0, this.adjustScaleY = !0, this._visible = !0; }, project(t) { const e = this.position; const i = this.gameObject; t.project(e, i), t.getPointSize(e, this.size, this.scale), this.scale.x <= 0 || this.scale.y <= 0 ? i.setVisible(!1) : (i.visible || i.setVisible(!0), this.adjustScaleX && (i.scaleX = this.scale.x), this.adjustScaleY && (i.scaleY = this.scale.y), i.setDepth(-1 * i.z)); }, setVisible(t) { return this.visible = t, this; }, visible: { get() { return this._visible; }, set(t) { this._visible = t, this.gameObject.visible = t; } }, x: { get() { return this.position.x; }, set(t) { this.position.x = t; } }, y: { get() { return this.position.y; }, set(t) { this.position.y = t; } }, z: { get() { return this.position.z; }, set(t) { this.position.z = t; } },
  }); t.exports = h;
}, function (t, e) { t.exports = { DEFAULT: 0, LINEAR: 0, NEAREST: 1 }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(4); t.exports = function (t, e, i) { return void 0 === i && (i = new n()), i.x = t.x + t.radius * Math.cos(e), i.y = t.y + t.radius * Math.sin(e), i; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(4); t.exports = function (t, e) { void 0 === e && (e = new n()); const i = 2 * Math.PI * Math.random(); const s = Math.random() + Math.random(); const r = s > 1 ? 2 - s : s; const o = r * Math.cos(i); const a = r * Math.sin(i); return e.x = t.x + o * t.radius, e.y = t.y + a * t.radius, e; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(20); const s = i(0); const r = i(10); const o = i(121); const a = i(294); const h = i(295); const l = i(6); const u = new s({
    Extends: r,
    initialize(t, e, i) { r.call(this), this.manager = t, this.key = e, this.type = 'frame', this.frames = this.getFrames(t.textureManager, l(i, 'frames', []), l(i, 'defaultTextureKey', null)), this.frameRate = l(i, 'frameRate', null), this.duration = l(i, 'duration', null), this.duration === null && this.frameRate === null ? (this.frameRate = 24, this.duration = this.frameRate / this.frames.length * 1e3) : this.duration && this.frameRate === null ? this.frameRate = this.frames.length / (this.duration / 1e3) : this.duration = this.frames.length / this.frameRate * 1e3, this.msPerFrame = 1e3 / this.frameRate, this.skipMissedFrames = l(i, 'skipMissedFrames', !0), this.delay = l(i, 'delay', 0), this.repeat = l(i, 'repeat', 0), this.repeatDelay = l(i, 'repeatDelay', 0), this.yoyo = l(i, 'yoyo', !1), this.showOnStart = l(i, 'showOnStart', !1), this.hideOnComplete = l(i, 'hideOnComplete', !1), this.paused = !1, this.manager.on(o.PAUSE_ALL, this.pause, this), this.manager.on(o.RESUME_ALL, this.resume, this); },
    addFrame(t) { return this.addFrameAt(this.frames.length, t); },
    addFrameAt(t, e) { const i = this.getFrames(this.manager.textureManager, e); if (i.length > 0) { if (t === 0) this.frames = i.concat(this.frames); else if (t === this.frames.length) this.frames = this.frames.concat(i); else { const n = this.frames.slice(0, t); const s = this.frames.slice(t); this.frames = n.concat(i, s); } this.updateFrameSequence(); } return this; },
    checkFrame(t) { return t >= 0 && t < this.frames.length; },
    completeAnimation(t) { this.hideOnComplete && (t.parent.visible = !1), t.stop(); },
    getFirstTick(t, e) { void 0 === e && (e = !0), t.accumulator = 0, t.nextTick = t.msPerFrame + t.currentFrame.duration, e && (t.nextTick += t._delay); },
    getFrameAt(t) { return this.frames[t]; },
    getFrames(t, e, i) { let n; let s; let r; let o; const a = []; let u = 1; if (typeof e === 'string') { o = e; const c = t.get(o).getFrameNames(); e = [], c.forEach(((t, i) => { e.push({ key: o, frame: i }); })); } if (!Array.isArray(e) || e.length === 0) return a; for (r = 0; r < e.length; r++) { const d = e[r]; const f = l(d, 'key', i); if (f) { const p = l(d, 'frame', 0); const g = t.getFrame(f, p); (s = new h(f, p, u, g)).duration = l(d, 'duration', 0), s.isFirst = !n, n && (n.nextFrame = s, s.prevFrame = n), a.push(s), n = s, u++; } } if (a.length > 0) { s.isLast = !0, s.nextFrame = a[0], a[0].prevFrame = s; const v = 1 / (a.length - 1); for (r = 0; r < a.length; r++)a[r].progress = r * v; } return a; },
    getNextTick(t) { t.accumulator -= t.nextTick, t.nextTick = t.msPerFrame + t.currentFrame.duration; },
    load(t, e) { e >= this.frames.length && (e = 0), t.currentAnim !== this && (t.currentAnim = this, t.frameRate = this.frameRate, t.duration = this.duration, t.msPerFrame = this.msPerFrame, t.skipMissedFrames = this.skipMissedFrames, t._delay = this.delay, t._repeat = this.repeat, t._repeatDelay = this.repeatDelay, t._yoyo = this.yoyo); let i = this.frames[e]; e !== 0 || t.forward || (i = this.getLastFrame()), t.updateFrame(i); },
    getFrameByProgress(t) { return t = n(t, 0, 1), a(t, this.frames, 'progress'); },
    nextFrame(t) { const e = t.currentFrame; e.isLast ? t._yoyo ? this.handleYoyoFrame(t, !1) : t.repeatCounter > 0 ? t._reverse && t.forward ? t.forward = !1 : this.repeatAnimation(t) : this.completeAnimation(t) : this.updateAndGetNextTick(t, e.nextFrame); },
    handleYoyoFrame(t, e) { if (e || (e = !1), t._reverse === !e && t.repeatCounter > 0) return t._repeatDelay && !t.pendingRepeat || (t.forward = e), void this.repeatAnimation(t); if (t._reverse === e || t.repeatCounter !== 0) { t.forward = e; const i = e ? t.currentFrame.nextFrame : t.currentFrame.prevFrame; this.updateAndGetNextTick(t, i); } else this.completeAnimation(t); },
    getLastFrame() { return this.frames[this.frames.length - 1]; },
    previousFrame(t) { const e = t.currentFrame; e.isFirst ? t._yoyo ? this.handleYoyoFrame(t, !0) : t.repeatCounter > 0 ? t._reverse && !t.forward ? (t.currentFrame = this.getLastFrame(), this.repeatAnimation(t)) : (t.forward = !0, this.repeatAnimation(t)) : this.completeAnimation(t) : this.updateAndGetNextTick(t, e.prevFrame); },
    updateAndGetNextTick(t, e) { t.updateFrame(e), this.getNextTick(t); },
    removeFrame(t) { const e = this.frames.indexOf(t); return e !== -1 && this.removeFrameAt(e), this; },
    removeFrameAt(t) { return this.frames.splice(t, 1), this.updateFrameSequence(), this; },
    repeatAnimation(t) { if (t._pendingStop === 2) return this.completeAnimation(t); if (t._repeatDelay > 0 && !1 === t.pendingRepeat)t.pendingRepeat = !0, t.accumulator -= t.nextTick, t.nextTick += t._repeatDelay; else if (t.repeatCounter--, t.updateFrame(t.currentFrame[t.forward ? 'nextFrame' : 'prevFrame']), t.isPlaying) { this.getNextTick(t), t.pendingRepeat = !1; const e = t.currentFrame; const i = t.parent; this.emit(o.ANIMATION_REPEAT, this, e), i.emit(o.SPRITE_ANIMATION_KEY_REPEAT + this.key, this, e, t.repeatCounter, i), i.emit(o.SPRITE_ANIMATION_REPEAT, this, e, t.repeatCounter, i); } },
    setFrame(t) { t.forward ? this.nextFrame(t) : this.previousFrame(t); },
    toJSON() {
      const t = {
        key: this.key, type: this.type, frames: [], frameRate: this.frameRate, duration: this.duration, skipMissedFrames: this.skipMissedFrames, delay: this.delay, repeat: this.repeat, repeatDelay: this.repeatDelay, yoyo: this.yoyo, showOnStart: this.showOnStart, hideOnComplete: this.hideOnComplete,
      }; return this.frames.forEach(((e) => { t.frames.push(e.toJSON()); })), t;
    },
    updateFrameSequence() { for (var t, e = this.frames.length, i = 1 / (e - 1), n = 0; n < e; n++)(t = this.frames[n]).index = n + 1, t.isFirst = !1, t.isLast = !1, t.progress = n * i, n === 0 ? (t.isFirst = !0, e === 1 ? (t.isLast = !0, t.nextFrame = t, t.prevFrame = t) : (t.isLast = !1, t.prevFrame = this.frames[e - 1], t.nextFrame = this.frames[n + 1])) : n === e - 1 && e > 1 ? (t.isLast = !0, t.prevFrame = this.frames[e - 2], t.nextFrame = this.frames[0]) : e > 1 && (t.prevFrame = this.frames[n - 1], t.nextFrame = this.frames[n + 1]); return this; },
    pause() { return this.paused = !0, this; },
    resume() { return this.paused = !1, this; },
    destroy() { this.removeAllListeners(), this.manager.off(o.PAUSE_ALL, this.pause, this), this.manager.off(o.RESUME_ALL, this.resume, this), this.manager.remove(this.key); for (let t = 0; t < this.frames.length; t++) this.frames[t].destroy(); this.frames = [], this.manager = null; },
  }); t.exports = u;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(122); const s = i(4); t.exports = function (t, e, i) { if (void 0 === i && (i = new s()), e <= 0 || e >= 1) return i.x = t.x, i.y = t.y, i; let r = n(t) * e; return e > 0.5 ? (r -= t.width + t.height) <= t.width ? (i.x = t.right - r, i.y = t.bottom) : (i.x = t.x, i.y = t.bottom - (r - t.width)) : r <= t.width ? (i.x = t.x + r, i.y = t.y) : (i.x = t.right, i.y = t.y + (r - t.width)), i; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(63); const s = i(4); t.exports = function (t, e, i, r) { void 0 === r && (r = []), !e && i > 0 && (e = n(t) / i); for (let o = t.x1, a = t.y1, h = t.x2, l = t.y2, u = 0; u < e; u++) { const c = u / e; const d = o + (h - o) * c; const f = a + (l - a) * c; r.push(new s(d, f)); } return r; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(4); t.exports = function (t, e) { void 0 === e && (e = new n()); const i = Math.random(); return e.x = t.x1 + i * (t.x2 - t.x1), e.y = t.y1 + i * (t.y2 - t.y1), e; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(4); t.exports = function (t, e) { return void 0 === e && (e = new n()), e.x = t.x + Math.random() * t.width, e.y = t.y + Math.random() * t.height, e; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(64); t.exports = function (t) { return n(t, -Math.PI, Math.PI); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(64); t.exports = function (t) { return n(t, -180, 180); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(4); t.exports = function (t, e) { void 0 === e && (e = new n()); const i = Math.random() * Math.PI * 2; const s = Math.sqrt(Math.random()); return e.x = t.x + s * Math.cos(i) * t.width / 2, e.y = t.y + s * Math.sin(i) * t.height / 2, e; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(4); t.exports = function (t, e) { void 0 === e && (e = new n()); const i = t.x2 - t.x1; const s = t.y2 - t.y1; const r = t.x3 - t.x1; const o = t.y3 - t.y1; let a = Math.random(); let h = Math.random(); return a + h >= 1 && (a = 1 - a, h = 1 - h), e.x = t.x1 + (i * a + r * h), e.y = t.y1 + (s * a + o * h), e; };
}, function (t, e) { t.exports = function (t, e, i, n, s) { const r = n + Math.atan2(t.y - i, t.x - e); return t.x = e + s * Math.cos(r), t.y = i + s * Math.sin(r), t; }; }, function (t, e) { t.exports = function (t, e, i) { return (t = Math.max(0, Math.min(1, (t - e) / (i - e)))) * t * t * (t * (6 * t - 15) + 10); }; }, function (t, e) { t.exports = function (t, e, i) { return t <= e ? 0 : t >= i ? 1 : (t = (t - e) / (i - e)) * t * (3 - 2 * t); }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = new (i(0))({
    initialize(t) { if (this.entries = {}, this.size = 0, Array.isArray(t)) for (let e = 0; e < t.length; e++) this.set(t[e][0], t[e][1]); }, set(t, e) { return this.has(t) || this.size++, this.entries[t] = e, this; }, get(t) { if (this.has(t)) return this.entries[t]; }, getArray() { const t = []; const e = this.entries; for (const i in e)t.push(e[i]); return t; }, has(t) { return this.entries.hasOwnProperty(t); }, delete(t) { return this.has(t) && (delete this.entries[t], this.size--), this; }, clear() { return Object.keys(this.entries).forEach((function (t) { delete this.entries[t]; }), this), this.size = 0, this; }, keys() { return Object.keys(this.entries); }, values() { const t = []; const e = this.entries; for (const i in e)t.push(e[i]); return t; }, dump() { const t = this.entries; for (const e in console.group('Map'), t)console.log(e, t[e]); console.groupEnd(); }, each(t) { const e = this.entries; for (const i in e) if (!1 === t(i, e[i])) break; return this; }, contains(t) { const e = this.entries; for (const i in e) if (e[i] === t) return !0; return !1; }, merge(t, e) { void 0 === e && (e = !1); const i = this.entries; const n = t.entries; for (const s in n)i.hasOwnProperty(s) && e ? i[s] = n[s] : this.set(s, n[s]); return this; },
  }); t.exports = n;
}, function (t, e) { t.exports = function (t, e, i, n) { void 0 === e && (e = 0), void 0 === i && (i = ' '), void 0 === n && (n = 3); let s = 0; if (e + 1 >= (t = t.toString()).length) switch (n) { case 1: t = new Array(e + 1 - t.length).join(i) + t; break; case 3: var r = Math.ceil((s = e - t.length) / 2); t = new Array(s - r + 1).join(i) + t + new Array(r + 1).join(i); break; default: t += new Array(e + 1 - t.length).join(i); } return t; }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(318); const s = i(321); const r = i(323); const o = i(324); t.exports = function (t) { switch (typeof t) { case 'string': return t.substr(0, 3).toLowerCase() === 'rgb' ? o(t) : n(t); case 'number': return s(t); case 'object': return r(t); } };
}, function (t, e) { t.exports = function (t, e, i) { return t << 16 | e << 8 | i; }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(180); t.exports = function (t, e, i, s) {
    void 0 === e && (e = 1), void 0 === i && (i = 1); const r = Math.floor(6 * t); const o = 6 * t - r; const a = Math.floor(i * (1 - e) * 255); const h = Math.floor(i * (1 - o * e) * 255); const l = Math.floor(i * (1 - (1 - o) * e) * 255); let u = i = Math.floor(i *= 255); let c = i; let d = i; const f = r % 6; return f === 0 ? (c = l, d = a) : f === 1 ? (u = h, d = a) : f === 2 ? (u = a, d = l) : f === 3 ? (u = a, c = h) : f === 4 ? (u = l, c = a) : f === 5 && (c = a, d = h), s ? s.setTo ? s.setTo(u, c, d, s.alpha, !1) : (s.r = u, s.g = c, s.b = d, s.color = n(u, c, d), s) : {
      r: u, g: c, b: d, color: n(u, c, d),
    };
  };
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  let i; let n = ''; t.exports = {
    disable(t) { return n === '' && (n = i(t)), n && (t[n] = !1), t; }, enable(t) { return n === '' && (n = i(t)), n && (t[n] = !0), t; }, getPrefix: i = function (t) { for (let e = ['i', 'webkitI', 'msI', 'mozI', 'oI'], i = 0; i < e.length; i++) { const n = `${e[i]}mageSmoothingEnabled`; if (n in t) return n; } return null; }, isEnabled(t) { return n !== null ? t[n] : null; },
  };
}, function (t, e) { t.exports = function (t, e, i) { return t.x = e - t.width / 2, t.y = i - t.height / 2, t; }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(127); const s = i(128); const r = i(30); const o = {
    canvas: !1, canvasBitBltShift: null, file: !1, fileSystem: !1, getUserMedia: !0, littleEndian: !1, localStorage: !1, pointerLock: !1, support32bit: !1, vibration: !1, webGL: !1, worker: !1,
  }; t.exports = (function () { o.canvas = !!window.CanvasRenderingContext2D; try { o.localStorage = !!localStorage.getItem; } catch (t) { o.localStorage = !1; }o.file = !!(window.File && window.FileReader && window.FileList && window.Blob), o.fileSystem = !!window.requestFileSystem; let t; let e; let i; let a = !1; return o.webGL = (function () { if (window.WebGLRenderingContext) try { const t = r.createWebGL(this); const e = t.getContext('webgl') || t.getContext('experimental-webgl'); const i = r.create2D(this); const n = i.getContext('2d').createImageData(1, 1); return a = n.data instanceof Uint8ClampedArray, r.remove(t), r.remove(i), !!e; } catch (t) { return !1; } return !1; }()), o.worker = !!window.Worker, o.pointerLock = 'pointerLockElement' in document || 'mozPointerLockElement' in document || 'webkitPointerLockElement' in document, navigator.getUserMedia = navigator.getUserMedia || navigator.webkitGetUserMedia || navigator.mozGetUserMedia || navigator.msGetUserMedia || navigator.oGetUserMedia, window.URL = window.URL || window.webkitURL || window.mozURL || window.msURL, o.getUserMedia = o.getUserMedia && !!navigator.getUserMedia && !!window.URL, s.firefox && s.firefoxVersion < 21 && (o.getUserMedia = !1), !n.iOS && (s.ie || s.firefox || s.chrome) && (o.canvasBitBltShift = !0), (s.safari || s.mobileSafari) && (o.canvasBitBltShift = !1), navigator.vibrate = navigator.vibrate || navigator.webkitVibrate || navigator.mozVibrate || navigator.msVibrate, navigator.vibrate && (o.vibration = !0), typeof ArrayBuffer !== 'undefined' && typeof Uint8Array !== 'undefined' && typeof Uint32Array !== 'undefined' && (o.littleEndian = (t = new ArrayBuffer(4), e = new Uint8Array(t), i = new Uint32Array(t), e[0] = 161, e[1] = 178, e[2] = 195, e[3] = 212, i[0] === 3569595041 || i[0] !== 2712847316 && null)), o.support32bit = typeof ArrayBuffer !== 'undefined' && typeof Uint8ClampedArray !== 'undefined' && typeof Int32Array !== 'undefined' && o.littleEndian !== null && a, o; }());
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(16); const s = i(19); let r = {
    Angle: i(763), Distance: i(773), Easing: i(778), Fuzzy: i(779), Interpolation: i(782), Pow2: i(787), Snap: i(789), RandomDataGenerator: i(791), Average: i(792), Bernstein: i(347), Between: i(187), CatmullRom: i(186), CeilTo: i(793), Clamp: i(20), DegToRad: i(41), Difference: i(794), Factorial: i(348), FloatBetween: i(129), FloorTo: i(795), FromPercent: i(97), GetSpeed: i(796), IsEven: i(797), IsEvenStrict: i(798), Linear: i(126), MaxAdd: i(799), MinSub: i(800), Percent: i(801), RadToDeg: i(188), RandomXY: i(802), RandomXYZ: i(354), RandomXYZW: i(355), Rotate: i(356), RotateAround: i(300), RotateAroundDistance: i(174), RoundAwayFromZero: i(357), RoundTo: i(803), SinCosTableGenerator: i(804), SmootherStep: i(175), SmoothStep: i(176), ToXY: i(805), TransformXY: i(358), Within: i(806), Wrap: i(64), Vector2: i(3), Vector3: i(87), Vector4: i(131), Matrix3: i(359), Matrix4: i(189), Quaternion: i(360), RotateVec3: i(361),
  }; r = s(!1, r, n), t.exports = r;
}, function (t, e) { t.exports = function (t, e, i, n, s) { const r = 0.5 * (n - e); const o = 0.5 * (s - i); const a = t * t; return (2 * i - 2 * n + r + o) * (t * a) + (-3 * i + 3 * n - 2 * r - o) * a + r * t + i; }; }, function (t, e) { t.exports = function (t, e) { return Math.floor(Math.random() * (e - t + 1) + t); }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(16); t.exports = function (t) { return t * n.RAD_TO_DEG; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); var s = new n({
    initialize(t) { this.val = new Float32Array(16), t ? this.copy(t) : this.identity(); }, clone() { return new s(this); }, set(t) { return this.copy(t); }, copy(t) { const e = this.val; const i = t.val; return e[0] = i[0], e[1] = i[1], e[2] = i[2], e[3] = i[3], e[4] = i[4], e[5] = i[5], e[6] = i[6], e[7] = i[7], e[8] = i[8], e[9] = i[9], e[10] = i[10], e[11] = i[11], e[12] = i[12], e[13] = i[13], e[14] = i[14], e[15] = i[15], this; }, fromArray(t) { const e = this.val; return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], this; }, zero() { const t = this.val; return t[0] = 0, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 0, this; }, xyz(t, e, i) { this.identity(); const n = this.val; return n[12] = t, n[13] = e, n[14] = i, this; }, scaling(t, e, i) { this.zero(); const n = this.val; return n[0] = t, n[5] = e, n[10] = i, n[15] = 1, this; }, identity() { const t = this.val; return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this; }, transpose() { const t = this.val; const e = t[1]; const i = t[2]; const n = t[3]; const s = t[6]; const r = t[7]; const o = t[11]; return t[1] = t[4], t[2] = t[8], t[3] = t[12], t[4] = e, t[6] = t[9], t[7] = t[13], t[8] = i, t[9] = s, t[11] = t[14], t[12] = n, t[13] = r, t[14] = o, this; }, invert() { const t = this.val; const e = t[0]; const i = t[1]; const n = t[2]; const s = t[3]; const r = t[4]; const o = t[5]; const a = t[6]; const h = t[7]; const l = t[8]; const u = t[9]; const c = t[10]; const d = t[11]; const f = t[12]; const p = t[13]; const g = t[14]; const v = t[15]; const m = e * o - i * r; const y = e * a - n * r; const x = e * h - s * r; const T = i * a - n * o; const w = i * h - s * o; const b = n * h - s * a; const E = l * p - u * f; const S = l * g - c * f; const A = l * v - d * f; const _ = u * g - c * p; const C = u * v - d * p; const M = c * v - d * g; let P = m * M - y * C + x * _ + T * A - w * S + b * E; return P ? (P = 1 / P, t[0] = (o * M - a * C + h * _) * P, t[1] = (n * C - i * M - s * _) * P, t[2] = (p * b - g * w + v * T) * P, t[3] = (c * w - u * b - d * T) * P, t[4] = (a * A - r * M - h * S) * P, t[5] = (e * M - n * A + s * S) * P, t[6] = (g * x - f * b - v * y) * P, t[7] = (l * b - c * x + d * y) * P, t[8] = (r * C - o * A + h * E) * P, t[9] = (i * A - e * C - s * E) * P, t[10] = (f * w - p * x + v * m) * P, t[11] = (u * x - l * w - d * m) * P, t[12] = (o * S - r * _ - a * E) * P, t[13] = (e * _ - i * S + n * E) * P, t[14] = (p * y - f * T - g * m) * P, t[15] = (l * T - u * y + c * m) * P, this) : null; }, adjoint() { const t = this.val; const e = t[0]; const i = t[1]; const n = t[2]; const s = t[3]; const r = t[4]; const o = t[5]; const a = t[6]; const h = t[7]; const l = t[8]; const u = t[9]; const c = t[10]; const d = t[11]; const f = t[12]; const p = t[13]; const g = t[14]; const v = t[15]; return t[0] = o * (c * v - d * g) - u * (a * v - h * g) + p * (a * d - h * c), t[1] = -(i * (c * v - d * g) - u * (n * v - s * g) + p * (n * d - s * c)), t[2] = i * (a * v - h * g) - o * (n * v - s * g) + p * (n * h - s * a), t[3] = -(i * (a * d - h * c) - o * (n * d - s * c) + u * (n * h - s * a)), t[4] = -(r * (c * v - d * g) - l * (a * v - h * g) + f * (a * d - h * c)), t[5] = e * (c * v - d * g) - l * (n * v - s * g) + f * (n * d - s * c), t[6] = -(e * (a * v - h * g) - r * (n * v - s * g) + f * (n * h - s * a)), t[7] = e * (a * d - h * c) - r * (n * d - s * c) + l * (n * h - s * a), t[8] = r * (u * v - d * p) - l * (o * v - h * p) + f * (o * d - h * u), t[9] = -(e * (u * v - d * p) - l * (i * v - s * p) + f * (i * d - s * u)), t[10] = e * (o * v - h * p) - r * (i * v - s * p) + f * (i * h - s * o), t[11] = -(e * (o * d - h * u) - r * (i * d - s * u) + l * (i * h - s * o)), t[12] = -(r * (u * g - c * p) - l * (o * g - a * p) + f * (o * c - a * u)), t[13] = e * (u * g - c * p) - l * (i * g - n * p) + f * (i * c - n * u), t[14] = -(e * (o * g - a * p) - r * (i * g - n * p) + f * (i * a - n * o)), t[15] = e * (o * c - a * u) - r * (i * c - n * u) + l * (i * a - n * o), this; }, determinant() { const t = this.val; const e = t[0]; const i = t[1]; const n = t[2]; const s = t[3]; const r = t[4]; const o = t[5]; const a = t[6]; const h = t[7]; const l = t[8]; const u = t[9]; const c = t[10]; const d = t[11]; const f = t[12]; const p = t[13]; const g = t[14]; const v = t[15]; return (e * o - i * r) * (c * v - d * g) - (e * a - n * r) * (u * v - d * p) + (e * h - s * r) * (u * g - c * p) + (i * a - n * o) * (l * v - d * f) - (i * h - s * o) * (l * g - c * f) + (n * h - s * a) * (l * p - u * f); }, multiply(t) { const e = this.val; const i = e[0]; const n = e[1]; const s = e[2]; const r = e[3]; const o = e[4]; const a = e[5]; const h = e[6]; const l = e[7]; const u = e[8]; const c = e[9]; const d = e[10]; const f = e[11]; const p = e[12]; const g = e[13]; const v = e[14]; const m = e[15]; const y = t.val; let x = y[0]; let T = y[1]; let w = y[2]; let b = y[3]; return e[0] = x * i + T * o + w * u + b * p, e[1] = x * n + T * a + w * c + b * g, e[2] = x * s + T * h + w * d + b * v, e[3] = x * r + T * l + w * f + b * m, x = y[4], T = y[5], w = y[6], b = y[7], e[4] = x * i + T * o + w * u + b * p, e[5] = x * n + T * a + w * c + b * g, e[6] = x * s + T * h + w * d + b * v, e[7] = x * r + T * l + w * f + b * m, x = y[8], T = y[9], w = y[10], b = y[11], e[8] = x * i + T * o + w * u + b * p, e[9] = x * n + T * a + w * c + b * g, e[10] = x * s + T * h + w * d + b * v, e[11] = x * r + T * l + w * f + b * m, x = y[12], T = y[13], w = y[14], b = y[15], e[12] = x * i + T * o + w * u + b * p, e[13] = x * n + T * a + w * c + b * g, e[14] = x * s + T * h + w * d + b * v, e[15] = x * r + T * l + w * f + b * m, this; }, multiplyLocal(t) { const e = []; const i = this.val; const n = t.val; return e[0] = i[0] * n[0] + i[1] * n[4] + i[2] * n[8] + i[3] * n[12], e[1] = i[0] * n[1] + i[1] * n[5] + i[2] * n[9] + i[3] * n[13], e[2] = i[0] * n[2] + i[1] * n[6] + i[2] * n[10] + i[3] * n[14], e[3] = i[0] * n[3] + i[1] * n[7] + i[2] * n[11] + i[3] * n[15], e[4] = i[4] * n[0] + i[5] * n[4] + i[6] * n[8] + i[7] * n[12], e[5] = i[4] * n[1] + i[5] * n[5] + i[6] * n[9] + i[7] * n[13], e[6] = i[4] * n[2] + i[5] * n[6] + i[6] * n[10] + i[7] * n[14], e[7] = i[4] * n[3] + i[5] * n[7] + i[6] * n[11] + i[7] * n[15], e[8] = i[8] * n[0] + i[9] * n[4] + i[10] * n[8] + i[11] * n[12], e[9] = i[8] * n[1] + i[9] * n[5] + i[10] * n[9] + i[11] * n[13], e[10] = i[8] * n[2] + i[9] * n[6] + i[10] * n[10] + i[11] * n[14], e[11] = i[8] * n[3] + i[9] * n[7] + i[10] * n[11] + i[11] * n[15], e[12] = i[12] * n[0] + i[13] * n[4] + i[14] * n[8] + i[15] * n[12], e[13] = i[12] * n[1] + i[13] * n[5] + i[14] * n[9] + i[15] * n[13], e[14] = i[12] * n[2] + i[13] * n[6] + i[14] * n[10] + i[15] * n[14], e[15] = i[12] * n[3] + i[13] * n[7] + i[14] * n[11] + i[15] * n[15], this.fromArray(e); }, translate(t) { const e = t.x; const i = t.y; const n = t.z; const s = this.val; return s[12] = s[0] * e + s[4] * i + s[8] * n + s[12], s[13] = s[1] * e + s[5] * i + s[9] * n + s[13], s[14] = s[2] * e + s[6] * i + s[10] * n + s[14], s[15] = s[3] * e + s[7] * i + s[11] * n + s[15], this; }, translateXYZ(t, e, i) { const n = this.val; return n[12] = n[0] * t + n[4] * e + n[8] * i + n[12], n[13] = n[1] * t + n[5] * e + n[9] * i + n[13], n[14] = n[2] * t + n[6] * e + n[10] * i + n[14], n[15] = n[3] * t + n[7] * e + n[11] * i + n[15], this; }, scale(t) { const e = t.x; const i = t.y; const n = t.z; const s = this.val; return s[0] *= e, s[1] *= e, s[2] *= e, s[3] *= e, s[4] *= i, s[5] *= i, s[6] *= i, s[7] *= i, s[8] *= n, s[9] *= n, s[10] *= n, s[11] *= n, this; }, scaleXYZ(t, e, i) { const n = this.val; return n[0] *= t, n[1] *= t, n[2] *= t, n[3] *= t, n[4] *= e, n[5] *= e, n[6] *= e, n[7] *= e, n[8] *= i, n[9] *= i, n[10] *= i, n[11] *= i, this; }, makeRotationAxis(t, e) { const i = Math.cos(e); const n = Math.sin(e); const s = 1 - i; const r = t.x; const o = t.y; const a = t.z; const h = s * r; const l = s * o; return this.fromArray([h * r + i, h * o - n * a, h * a + n * o, 0, h * o + n * a, l * o + i, l * a - n * r, 0, h * a - n * o, l * a + n * r, s * a * a + i, 0, 0, 0, 0, 1]), this; }, rotate(t, e) { const i = this.val; let n = e.x; let s = e.y; let r = e.z; let o = Math.sqrt(n * n + s * s + r * r); if (Math.abs(o) < 1e-6) return null; n *= o = 1 / o, s *= o, r *= o; const a = Math.sin(t); const h = Math.cos(t); const l = 1 - h; const u = i[0]; const c = i[1]; const d = i[2]; const f = i[3]; const p = i[4]; const g = i[5]; const v = i[6]; const m = i[7]; const y = i[8]; const x = i[9]; const T = i[10]; const w = i[11]; const b = n * n * l + h; const E = s * n * l + r * a; const S = r * n * l - s * a; const A = n * s * l - r * a; const _ = s * s * l + h; const C = r * s * l + n * a; const M = n * r * l + s * a; const P = s * r * l - n * a; const O = r * r * l + h; return i[0] = u * b + p * E + y * S, i[1] = c * b + g * E + x * S, i[2] = d * b + v * E + T * S, i[3] = f * b + m * E + w * S, i[4] = u * A + p * _ + y * C, i[5] = c * A + g * _ + x * C, i[6] = d * A + v * _ + T * C, i[7] = f * A + m * _ + w * C, i[8] = u * M + p * P + y * O, i[9] = c * M + g * P + x * O, i[10] = d * M + v * P + T * O, i[11] = f * M + m * P + w * O, this; }, rotateX(t) { const e = this.val; const i = Math.sin(t); const n = Math.cos(t); const s = e[4]; const r = e[5]; const o = e[6]; const a = e[7]; const h = e[8]; const l = e[9]; const u = e[10]; const c = e[11]; return e[4] = s * n + h * i, e[5] = r * n + l * i, e[6] = o * n + u * i, e[7] = a * n + c * i, e[8] = h * n - s * i, e[9] = l * n - r * i, e[10] = u * n - o * i, e[11] = c * n - a * i, this; }, rotateY(t) { const e = this.val; const i = Math.sin(t); const n = Math.cos(t); const s = e[0]; const r = e[1]; const o = e[2]; const a = e[3]; const h = e[8]; const l = e[9]; const u = e[10]; const c = e[11]; return e[0] = s * n - h * i, e[1] = r * n - l * i, e[2] = o * n - u * i, e[3] = a * n - c * i, e[8] = s * i + h * n, e[9] = r * i + l * n, e[10] = o * i + u * n, e[11] = a * i + c * n, this; }, rotateZ(t) { const e = this.val; const i = Math.sin(t); const n = Math.cos(t); const s = e[0]; const r = e[1]; const o = e[2]; const a = e[3]; const h = e[4]; const l = e[5]; const u = e[6]; const c = e[7]; return e[0] = s * n + h * i, e[1] = r * n + l * i, e[2] = o * n + u * i, e[3] = a * n + c * i, e[4] = h * n - s * i, e[5] = l * n - r * i, e[6] = u * n - o * i, e[7] = c * n - a * i, this; }, fromRotationTranslation(t, e) { const i = this.val; const n = t.x; const s = t.y; const r = t.z; const o = t.w; const a = n + n; const h = s + s; const l = r + r; const u = n * a; const c = n * h; const d = n * l; const f = s * h; const p = s * l; const g = r * l; const v = o * a; const m = o * h; const y = o * l; return i[0] = 1 - (f + g), i[1] = c + y, i[2] = d - m, i[3] = 0, i[4] = c - y, i[5] = 1 - (u + g), i[6] = p + v, i[7] = 0, i[8] = d + m, i[9] = p - v, i[10] = 1 - (u + f), i[11] = 0, i[12] = e.x, i[13] = e.y, i[14] = e.z, i[15] = 1, this; }, fromQuat(t) { const e = this.val; const i = t.x; const n = t.y; const s = t.z; const r = t.w; const o = i + i; const a = n + n; const h = s + s; const l = i * o; const u = i * a; const c = i * h; const d = n * a; const f = n * h; const p = s * h; const g = r * o; const v = r * a; const m = r * h; return e[0] = 1 - (d + p), e[1] = u + m, e[2] = c - v, e[3] = 0, e[4] = u - m, e[5] = 1 - (l + p), e[6] = f + g, e[7] = 0, e[8] = c + v, e[9] = f - g, e[10] = 1 - (l + d), e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this; }, frustum(t, e, i, n, s, r) { const o = this.val; const a = 1 / (e - t); const h = 1 / (n - i); const l = 1 / (s - r); return o[0] = 2 * s * a, o[1] = 0, o[2] = 0, o[3] = 0, o[4] = 0, o[5] = 2 * s * h, o[6] = 0, o[7] = 0, o[8] = (e + t) * a, o[9] = (n + i) * h, o[10] = (r + s) * l, o[11] = -1, o[12] = 0, o[13] = 0, o[14] = r * s * 2 * l, o[15] = 0, this; }, perspective(t, e, i, n) { const s = this.val; const r = 1 / Math.tan(t / 2); const o = 1 / (i - n); return s[0] = r / e, s[1] = 0, s[2] = 0, s[3] = 0, s[4] = 0, s[5] = r, s[6] = 0, s[7] = 0, s[8] = 0, s[9] = 0, s[10] = (n + i) * o, s[11] = -1, s[12] = 0, s[13] = 0, s[14] = 2 * n * i * o, s[15] = 0, this; }, perspectiveLH(t, e, i, n) { const s = this.val; return s[0] = 2 * i / t, s[1] = 0, s[2] = 0, s[3] = 0, s[4] = 0, s[5] = 2 * i / e, s[6] = 0, s[7] = 0, s[8] = 0, s[9] = 0, s[10] = -n / (i - n), s[11] = 1, s[12] = 0, s[13] = 0, s[14] = i * n / (i - n), s[15] = 0, this; }, ortho(t, e, i, n, s, r) { const o = this.val; let a = t - e; let h = i - n; let l = s - r; return a = a === 0 ? a : 1 / a, h = h === 0 ? h : 1 / h, l = l === 0 ? l : 1 / l, o[0] = -2 * a, o[1] = 0, o[2] = 0, o[3] = 0, o[4] = 0, o[5] = -2 * h, o[6] = 0, o[7] = 0, o[8] = 0, o[9] = 0, o[10] = 2 * l, o[11] = 0, o[12] = (t + e) * a, o[13] = (n + i) * h, o[14] = (r + s) * l, o[15] = 1, this; }, lookAt(t, e, i) { const n = this.val; const s = t.x; const r = t.y; const o = t.z; const a = i.x; const h = i.y; const l = i.z; const u = e.x; const c = e.y; const d = e.z; if (Math.abs(s - u) < 1e-6 && Math.abs(r - c) < 1e-6 && Math.abs(o - d) < 1e-6) return this.identity(); let f = s - u; let p = r - c; let g = o - d; let v = 1 / Math.sqrt(f * f + p * p + g * g); let m = h * (g *= v) - l * (p *= v); let y = l * (f *= v) - a * g; let x = a * p - h * f; (v = Math.sqrt(m * m + y * y + x * x)) ? (m *= v = 1 / v, y *= v, x *= v) : (m = 0, y = 0, x = 0); let T = p * x - g * y; let w = g * m - f * x; let b = f * y - p * m; return (v = Math.sqrt(T * T + w * w + b * b)) ? (T *= v = 1 / v, w *= v, b *= v) : (T = 0, w = 0, b = 0), n[0] = m, n[1] = T, n[2] = f, n[3] = 0, n[4] = y, n[5] = w, n[6] = p, n[7] = 0, n[8] = x, n[9] = b, n[10] = g, n[11] = 0, n[12] = -(m * s + y * r + x * o), n[13] = -(T * s + w * r + b * o), n[14] = -(f * s + p * r + g * o), n[15] = 1, this; }, yawPitchRoll(t, e, i) { this.zero(), r.zero(), o.zero(); const n = this.val; const s = r.val; const a = o.val; let h = Math.sin(i); let l = Math.cos(i); return n[10] = 1, n[15] = 1, n[0] = l, n[1] = h, n[4] = -h, n[5] = l, h = Math.sin(e), l = Math.cos(e), s[0] = 1, s[15] = 1, s[5] = l, s[10] = l, s[9] = -h, s[6] = h, h = Math.sin(t), l = Math.cos(t), a[5] = 1, a[15] = 1, a[0] = l, a[2] = -h, a[8] = h, a[10] = l, this.multiplyLocal(r), this.multiplyLocal(o), this; }, setWorldMatrix(t, e, i, n, s) { return this.yawPitchRoll(t.y, t.x, t.z), r.scaling(i.x, i.y, i.z), o.xyz(e.x, e.y, e.z), this.multiplyLocal(r), this.multiplyLocal(o), void 0 !== n && this.multiplyLocal(n), void 0 !== s && this.multiplyLocal(s), this; },
  }); var r = new s(); var o = new s(); t.exports = s;
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const i = { Global: ['game', 'anims', 'cache', 'plugins', 'registry', 'scale', 'sound', 'textures'], CoreScene: ['EventEmitter', 'CameraManager', 'GameObjectCreator', 'GameObjectFactory', 'ScenePlugin', 'DisplayList', 'UpdateList'], DefaultScene: ['Clock', 'DataManagerPlugin', 'InputPlugin', 'Loader', 'TweenManager', 'LightsPlugin'] }; i.DefaultScene.push('CameraManager3D'), i.Global.push('facebook'), t.exports = i;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Felipe Alfonso <@bitnenfer>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(73); const r = i(2); const o = i(192); const a = i(371); const h = i(372); const l = i(33); const u = i(11); const c = i(133); const d = new n({
    Extends: c,
    Mixins: [o],
    initialize(t) {
      const e = t.renderer.config; c.call(this, {
        game: t.game,
        renderer: t.renderer,
        gl: t.renderer.gl,
        topology: r(t, 'topology', t.renderer.gl.TRIANGLES),
        vertShader: r(t, 'vertShader', h),
        fragShader: r(t, 'fragShader', a),
        vertexCapacity: r(t, 'vertexCapacity', 6 * e.batchSize),
        vertexSize: r(t, 'vertexSize', 5 * Float32Array.BYTES_PER_ELEMENT + 4 * Uint8Array.BYTES_PER_ELEMENT),
        attributes: [{
          name: 'inPosition', size: 2, type: t.renderer.gl.FLOAT, normalized: !1, offset: 0,
        }, {
          name: 'inTexCoord', size: 2, type: t.renderer.gl.FLOAT, normalized: !1, offset: 2 * Float32Array.BYTES_PER_ELEMENT,
        }, {
          name: 'inTintEffect', size: 1, type: t.renderer.gl.FLOAT, normalized: !1, offset: 4 * Float32Array.BYTES_PER_ELEMENT,
        }, {
          name: 'inTint', size: 4, type: t.renderer.gl.UNSIGNED_BYTE, normalized: !0, offset: 5 * Float32Array.BYTES_PER_ELEMENT,
        }],
      }), this.vertexViewF32 = new Float32Array(this.vertexData), this.vertexViewU32 = new Uint32Array(this.vertexData), this.maxQuads = e.batchSize, this.batches = [], this._tempMatrix1 = new l(), this._tempMatrix2 = new l(), this._tempMatrix3 = new l(), this._tempMatrix4 = new l(), this.tempTriangle = [{ x: 0, y: 0, width: 0 }, { x: 0, y: 0, width: 0 }, { x: 0, y: 0, width: 0 }, { x: 0, y: 0, width: 0 }], this.tintEffect = 2, this.strokeTint = {
        TL: 0, TR: 0, BL: 0, BR: 0,
      }, this.fillTint = {
        TL: 0, TR: 0, BL: 0, BR: 0,
      }, this.currentFrame = {
        u0: 0, v0: 0, u1: 1, v1: 1,
      }, this.firstQuad = [0, 0, 0, 0, 0], this.prevQuad = [0, 0, 0, 0, 0], this.polygonCache = [], this.mvpInit();
    },
    onBind() { return c.prototype.onBind.call(this), this.mvpUpdate(), this; },
    resize(t, e, i) { return c.prototype.resize.call(this, t, e, i), this.projOrtho(0, this.width, this.height, 0, -1e3, 1e3), this; },
    setTexture2D(t, e) { return void 0 === t && (t = this.renderer.blankTexture.glTexture), void 0 === e && (e = 0), this.requireTextureBatch(t, e) && this.pushBatch(t, e), this; },
    requireTextureBatch(t, e) { const i = this.batches; const n = i.length; return !(n > 0) || !((e > 0 ? i[n - 1].textures[e - 1] : i[n - 1].texture) === t); },
    pushBatch(t, e) { if (e === 0) this.batches.push({ first: this.vertexCount, texture: t, textures: [] }); else { const i = []; i[e - 1] = t, this.batches.push({ first: this.vertexCount, texture: null, textures: i }); } },
    flush() { if (this.flushLocked) return this; this.flushLocked = !0; let t; let e; let i; const n = this.gl; const s = this.vertexCount; const r = this.topology; const o = this.vertexSize; const a = this.renderer; const h = this.batches; const l = h.length; let u = 0; let c = null; if (l === 0 || s === 0) return this.flushLocked = !1, this; n.bufferSubData(n.ARRAY_BUFFER, 0, this.bytes.subarray(0, s * o)); for (let d = 0; d < l - 1; d++) { if (c = h[d], t = h[d + 1], c.textures.length > 0) { for (e = 0; e < c.textures.length; ++e)(i = c.textures[e]) && a.setTexture2D(i, 1 + e, !1); n.activeTexture(n.TEXTURE0); }u = t.first - c.first, c.texture === null || u <= 0 || (a.setTexture2D(c.texture, 0, !1), n.drawArrays(r, c.first, u)); } if ((c = h[l - 1]).textures.length > 0) { for (e = 0; e < c.textures.length; ++e)(i = c.textures[e]) && a.setTexture2D(i, 1 + e, !1); n.activeTexture(n.TEXTURE0); } return u = s - c.first, c.texture && u > 0 && (a.setTexture2D(c.texture, 0, !1), n.drawArrays(r, c.first, u)), this.vertexCount = 0, h.length = 0, this.flushLocked = !1, this; },
    batchSprite(t, e, i) { this.renderer.setPipeline(this); const n = this._tempMatrix1; const s = this._tempMatrix2; const r = this._tempMatrix3; const o = t.frame; const a = o.glTexture; let h = o.u0; let l = o.v0; let c = o.u1; let d = o.v1; let f = o.x; let p = o.y; let g = o.cutWidth; let v = o.cutHeight; const m = o.customPivot; const y = t.displayOriginX; const x = t.displayOriginY; let T = -y + f; let w = -x + p; if (t.isCropped) { const b = t._crop; b.flipX === t.flipX && b.flipY === t.flipY || o.updateCropUVs(b, t.flipX, t.flipY), h = b.u0, l = b.v0, c = b.u1, d = b.v1, g = b.width, v = b.height, T = -y + (f = b.x), w = -x + (p = b.y); } let E = 1; let S = 1; t.flipX && (m || (T += -o.realWidth + 2 * y), E = -1), (t.flipY || o.source.isGLTexture && !a.flipY) && (m || (w += -o.realHeight + 2 * x), S = -1), s.applyITRS(t.x, t.y, t.rotation, t.scaleX * E, t.scaleY * S), n.copyFrom(e.matrix), i ? (n.multiplyWithOffset(i, -e.scrollX * t.scrollFactorX, -e.scrollY * t.scrollFactorY), s.e = t.x, s.f = t.y, n.multiply(s, r)) : (s.e -= e.scrollX * t.scrollFactorX, s.f -= e.scrollY * t.scrollFactorY, n.multiply(s, r)); const A = T + g; const _ = w + v; let C = r.getX(T, w); let M = r.getY(T, w); let P = r.getX(T, _); let O = r.getY(T, _); let R = r.getX(A, _); let L = r.getY(A, _); let D = r.getX(A, w); let k = r.getY(A, w); const F = u.getTintAppendFloatAlpha(t._tintTL, e.alpha * t._alphaTL); const I = u.getTintAppendFloatAlpha(t._tintTR, e.alpha * t._alphaTR); const B = u.getTintAppendFloatAlpha(t._tintBL, e.alpha * t._alphaBL); const N = u.getTintAppendFloatAlpha(t._tintBR, e.alpha * t._alphaBR); e.roundPixels && (C = Math.round(C), M = Math.round(M), P = Math.round(P), O = Math.round(O), R = Math.round(R), L = Math.round(L), D = Math.round(D), k = Math.round(k)), this.setTexture2D(a, 0); const Y = t._isTinted && t.tintFill; this.batchQuad(C, M, P, O, R, L, D, k, h, l, c, d, F, I, B, N, Y, a, 0); },
    batchQuad(t, e, i, n, s, r, o, a, h, l, u, c, d, f, p, g, v, m, y) { let x = !1; this.vertexCount + 6 > this.vertexCapacity && (this.flush(), x = !0, this.setTexture2D(m, y)); const T = this.vertexViewF32; const w = this.vertexViewU32; let b = this.vertexCount * this.vertexComponentCount - 1; return T[++b] = t, T[++b] = e, T[++b] = h, T[++b] = l, T[++b] = v, w[++b] = d, T[++b] = i, T[++b] = n, T[++b] = h, T[++b] = c, T[++b] = v, w[++b] = p, T[++b] = s, T[++b] = r, T[++b] = u, T[++b] = c, T[++b] = v, w[++b] = g, T[++b] = t, T[++b] = e, T[++b] = h, T[++b] = l, T[++b] = v, w[++b] = d, T[++b] = s, T[++b] = r, T[++b] = u, T[++b] = c, T[++b] = v, w[++b] = g, T[++b] = o, T[++b] = a, T[++b] = u, T[++b] = l, T[++b] = v, w[++b] = f, this.vertexCount += 6, x; },
    batchTri(t, e, i, n, s, r, o, a, h, l, u, c, d, f, p, g) { let v = !1; this.vertexCount + 3 > this.vertexCapacity && (this.flush(), this.setTexture2D(p, g), v = !0); const m = this.vertexViewF32; const y = this.vertexViewU32; let x = this.vertexCount * this.vertexComponentCount - 1; return m[++x] = t, m[++x] = e, m[++x] = o, m[++x] = a, m[++x] = f, y[++x] = u, m[++x] = i, m[++x] = n, m[++x] = o, m[++x] = l, m[++x] = f, y[++x] = c, m[++x] = s, m[++x] = r, m[++x] = h, m[++x] = l, m[++x] = f, y[++x] = d, this.vertexCount += 3, v; },
    batchTexture(t, e, i, n, s, r, o, a, h, l, u, c, d, f, p, g, v, m, y, x, T, w, b, E, S, A, _, C, M, P, O) { this.renderer.setPipeline(this, t); const R = this._tempMatrix1; const L = this._tempMatrix2; const D = this._tempMatrix3; let k = m / i + _; let F = y / n + C; let I = (m + x) / i + _; let B = (y + T) / n + C; let N = o; let Y = a; let X = -g; let z = -v; if (t.isCropped) { const U = t._crop; N = U.width, Y = U.height, o = U.width, a = U.height; let G = m = U.x; let W = y = U.y; c && (G = x - U.x - U.width), d && !e.isRenderTexture && (W = T - U.y - U.height), k = G / i + _, F = W / n + C, I = (G + U.width) / i + _, B = (W + U.height) / n + C, X = -g + m, z = -v + y; }c && (N *= -1, X += o), (d ^= !O && e.isRenderTexture ? 1 : 0) && (Y *= -1, z += a); const V = X + N; const H = z + Y; L.applyITRS(s, r, u, h, l), R.copyFrom(M.matrix), P ? (R.multiplyWithOffset(P, -M.scrollX * f, -M.scrollY * p), L.e = s, L.f = r, R.multiply(L, D)) : (L.e -= M.scrollX * f, L.f -= M.scrollY * p, R.multiply(L, D)); let j = D.getX(X, z); let q = D.getY(X, z); let K = D.getX(X, H); let J = D.getY(X, H); let Z = D.getX(V, H); let Q = D.getY(V, H); let $ = D.getX(V, z); let tt = D.getY(V, z); M.roundPixels && (j = Math.round(j), q = Math.round(q), K = Math.round(K), J = Math.round(J), Z = Math.round(Z), Q = Math.round(Q), $ = Math.round($), tt = Math.round(tt)), this.setTexture2D(e, 0), this.batchQuad(j, q, K, J, Z, Q, $, tt, k, F, I, B, w, b, E, S, A, e, 0); },
    batchTextureFrame(t, e, i, n, s, r, o) { this.renderer.setPipeline(this); const a = this._tempMatrix1.copyFrom(r); let h = this._tempMatrix2; const l = e + t.width; const c = i + t.height; o ? a.multiply(o, h) : h = a; const d = h.getX(e, i); const f = h.getY(e, i); const p = h.getX(e, c); const g = h.getY(e, c); const v = h.getX(l, c); const m = h.getY(l, c); const y = h.getX(l, i); const x = h.getY(l, i); this.setTexture2D(t.glTexture, 0), n = u.getTintAppendFloatAlpha(n, s), this.batchQuad(d, f, p, g, v, m, y, x, t.u0, t.v0, t.u1, t.v1, n, n, n, n, 0, t.glTexture, 0); },
    drawFillRect(t, e, i, n, s, r) { const o = t + i; const a = e + n; this.setTexture2D(); const h = u.getTintAppendFloatAlphaAndSwap(s, r); this.batchQuad(t, e, t, a, o, a, o, e, 0, 0, 1, 1, h, h, h, h, 2); },
    batchFillRect(t, e, i, n, s, r) { this.renderer.setPipeline(this); const o = this._tempMatrix3; r && r.multiply(s, o); const a = t + i; const h = e + n; const l = o.getX(t, e); const u = o.getY(t, e); const c = o.getX(t, h); const d = o.getY(t, h); const f = o.getX(a, h); const p = o.getY(a, h); const g = o.getX(a, e); const v = o.getY(a, e); const m = this.currentFrame; const y = m.u0; const x = m.v0; const T = m.u1; const w = m.v1; this.batchQuad(l, u, c, d, f, p, g, v, y, x, T, w, this.fillTint.TL, this.fillTint.TR, this.fillTint.BL, this.fillTint.BR, this.tintEffect); },
    batchFillTriangle(t, e, i, n, s, r, o, a) { this.renderer.setPipeline(this); const h = this._tempMatrix3; a && a.multiply(o, h); const l = h.getX(t, e); const u = h.getY(t, e); const c = h.getX(i, n); const d = h.getY(i, n); const f = h.getX(s, r); const p = h.getY(s, r); const g = this.currentFrame; const v = g.u0; const m = g.v0; const y = g.u1; const x = g.v1; this.batchTri(l, u, c, d, f, p, v, m, y, x, this.fillTint.TL, this.fillTint.TR, this.fillTint.BL, this.tintEffect); },
    batchStrokeTriangle(t, e, i, n, s, r, o, a, h) { const l = this.tempTriangle; l[0].x = t, l[0].y = e, l[0].width = o, l[1].x = i, l[1].y = n, l[1].width = o, l[2].x = s, l[2].y = r, l[2].width = o, l[3].x = t, l[3].y = e, l[3].width = o, this.batchStrokePath(l, o, !1, a, h); },
    batchFillPath(t, e, i) { this.renderer.setPipeline(this); const n = this._tempMatrix3; i && i.multiply(e, n); for (var r, o, a = t.length, h = this.polygonCache, l = this.fillTint.TL, u = this.fillTint.TR, c = this.fillTint.BL, d = this.tintEffect, f = 0; f < a; ++f)o = t[f], h.push(o.x, o.y); a = (r = s(h)).length; for (let p = this.currentFrame, g = 0; g < a; g += 3) { const v = 2 * r[g + 0]; const m = 2 * r[g + 1]; const y = 2 * r[g + 2]; const x = h[v + 0]; const T = h[v + 1]; const w = h[m + 0]; const b = h[m + 1]; const E = h[y + 0]; const S = h[y + 1]; const A = n.getX(x, T); const _ = n.getY(x, T); const C = n.getX(w, b); const M = n.getY(w, b); const P = n.getX(E, S); const O = n.getY(E, S); const R = p.u0; const L = p.v0; const D = p.u1; const k = p.v1; this.batchTri(A, _, C, M, P, O, R, L, D, k, l, u, c, d); }h.length = 0; },
    batchStrokePath(t, e, i, n, s) { this.renderer.setPipeline(this), this.prevQuad[4] = 0, this.firstQuad[4] = 0; for (let r = t.length - 1, o = 0; o < r; o++) { const a = t[o]; const h = t[o + 1]; this.batchLine(a.x, a.y, h.x, h.y, a.width / 2, h.width / 2, e, o, !i && o === r - 1, n, s); } },
    batchLine(t, e, i, n, s, r, o, a, h, l, u) { this.renderer.setPipeline(this); const c = this._tempMatrix3; u && u.multiply(l, c); const d = i - t; const f = n - e; const p = Math.sqrt(d * d + f * f); const g = s * (n - e) / p; const v = s * (t - i) / p; const m = r * (n - e) / p; const y = r * (t - i) / p; const x = i - m; const T = n - y; const w = t - g; const b = e - v; const E = i + m; const S = n + y; const A = t + g; const _ = e + v; const C = c.getX(x, T); const M = c.getY(x, T); const P = c.getX(w, b); const O = c.getY(w, b); const R = c.getX(E, S); const L = c.getY(E, S); const D = c.getX(A, _); const k = c.getY(A, _); const F = this.strokeTint; const I = this.tintEffect; const B = F.TL; const N = F.TR; const Y = F.BL; const X = F.BR; const z = this.currentFrame; const U = z.u0; const G = z.v0; const W = z.u1; const V = z.v1; if (this.batchQuad(D, k, P, O, C, M, R, L, U, G, W, V, B, N, Y, X, I), !(o <= 2)) { const H = this.prevQuad; const j = this.firstQuad; a > 0 && H[4] ? this.batchQuad(D, k, P, O, H[0], H[1], H[2], H[3], U, G, W, V, B, N, Y, X, I) : (j[0] = D, j[1] = k, j[2] = P, j[3] = O, j[4] = 1), h && j[4] ? this.batchQuad(C, M, R, L, j[0], j[1], j[2], j[3], U, G, W, V, B, N, Y, X, I) : (H[0] = C, H[1] = M, H[2] = R, H[3] = L, H[4] = 1); } },
  }); t.exports = d;
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const i = {
    modelMatrixDirty: !1, viewMatrixDirty: !1, projectionMatrixDirty: !1, modelMatrix: null, viewMatrix: null, projectionMatrix: null, mvpInit() { return this.modelMatrixDirty = !0, this.viewMatrixDirty = !0, this.projectionMatrixDirty = !0, this.modelMatrix = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]), this.viewMatrix = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]), this.projectionMatrix = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]), this; }, mvpUpdate() { const t = this.program; return this.modelMatrixDirty && (this.renderer.setMatrix4(t, 'uModelMatrix', !1, this.modelMatrix), this.modelMatrixDirty = !1), this.viewMatrixDirty && (this.renderer.setMatrix4(t, 'uViewMatrix', !1, this.viewMatrix), this.viewMatrixDirty = !1), this.projectionMatrixDirty && (this.renderer.setMatrix4(t, 'uProjectionMatrix', !1, this.projectionMatrix), this.projectionMatrixDirty = !1), this; }, modelIdentity() { const t = this.modelMatrix; return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this.modelMatrixDirty = !0, this; }, modelScale(t, e, i) { const n = this.modelMatrix; return n[0] *= t, n[1] *= t, n[2] *= t, n[3] *= t, n[4] *= e, n[5] *= e, n[6] *= e, n[7] *= e, n[8] *= i, n[9] *= i, n[10] *= i, n[11] *= i, this.modelMatrixDirty = !0, this; }, modelTranslate(t, e, i) { const n = this.modelMatrix; return n[12] = n[0] * t + n[4] * e + n[8] * i + n[12], n[13] = n[1] * t + n[5] * e + n[9] * i + n[13], n[14] = n[2] * t + n[6] * e + n[10] * i + n[14], n[15] = n[3] * t + n[7] * e + n[11] * i + n[15], this.modelMatrixDirty = !0, this; }, modelRotateX(t) { const e = this.modelMatrix; const i = Math.sin(t); const n = Math.cos(t); const s = e[4]; const r = e[5]; const o = e[6]; const a = e[7]; const h = e[8]; const l = e[9]; const u = e[10]; const c = e[11]; return e[4] = s * n + h * i, e[5] = r * n + l * i, e[6] = o * n + u * i, e[7] = a * n + c * i, e[8] = h * n - s * i, e[9] = l * n - r * i, e[10] = u * n - o * i, e[11] = c * n - a * i, this.modelMatrixDirty = !0, this; }, modelRotateY(t) { const e = this.modelMatrix; const i = Math.sin(t); const n = Math.cos(t); const s = e[0]; const r = e[1]; const o = e[2]; const a = e[3]; const h = e[8]; const l = e[9]; const u = e[10]; const c = e[11]; return e[0] = s * n - h * i, e[1] = r * n - l * i, e[2] = o * n - u * i, e[3] = a * n - c * i, e[8] = s * i + h * n, e[9] = r * i + l * n, e[10] = o * i + u * n, e[11] = a * i + c * n, this.modelMatrixDirty = !0, this; }, modelRotateZ(t) { const e = this.modelMatrix; const i = Math.sin(t); const n = Math.cos(t); const s = e[0]; const r = e[1]; const o = e[2]; const a = e[3]; const h = e[4]; const l = e[5]; const u = e[6]; const c = e[7]; return e[0] = s * n + h * i, e[1] = r * n + l * i, e[2] = o * n + u * i, e[3] = a * n + c * i, e[4] = h * n - s * i, e[5] = l * n - r * i, e[6] = u * n - o * i, e[7] = c * n - a * i, this.modelMatrixDirty = !0, this; }, viewIdentity() { const t = this.viewMatrix; return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this.viewMatrixDirty = !0, this; }, viewScale(t, e, i) { const n = this.viewMatrix; return n[0] *= t, n[1] *= t, n[2] *= t, n[3] *= t, n[4] *= e, n[5] *= e, n[6] *= e, n[7] *= e, n[8] *= i, n[9] *= i, n[10] *= i, n[11] *= i, this.viewMatrixDirty = !0, this; }, viewTranslate(t, e, i) { const n = this.viewMatrix; return n[12] = n[0] * t + n[4] * e + n[8] * i + n[12], n[13] = n[1] * t + n[5] * e + n[9] * i + n[13], n[14] = n[2] * t + n[6] * e + n[10] * i + n[14], n[15] = n[3] * t + n[7] * e + n[11] * i + n[15], this.viewMatrixDirty = !0, this; }, viewRotateX(t) { const e = this.viewMatrix; const i = Math.sin(t); const n = Math.cos(t); const s = e[4]; const r = e[5]; const o = e[6]; const a = e[7]; const h = e[8]; const l = e[9]; const u = e[10]; const c = e[11]; return e[4] = s * n + h * i, e[5] = r * n + l * i, e[6] = o * n + u * i, e[7] = a * n + c * i, e[8] = h * n - s * i, e[9] = l * n - r * i, e[10] = u * n - o * i, e[11] = c * n - a * i, this.viewMatrixDirty = !0, this; }, viewRotateY(t) { const e = this.viewMatrix; const i = Math.sin(t); const n = Math.cos(t); const s = e[0]; const r = e[1]; const o = e[2]; const a = e[3]; const h = e[8]; const l = e[9]; const u = e[10]; const c = e[11]; return e[0] = s * n - h * i, e[1] = r * n - l * i, e[2] = o * n - u * i, e[3] = a * n - c * i, e[8] = s * i + h * n, e[9] = r * i + l * n, e[10] = o * i + u * n, e[11] = a * i + c * n, this.viewMatrixDirty = !0, this; }, viewRotateZ(t) { const e = this.viewMatrix; const i = Math.sin(t); const n = Math.cos(t); const s = e[0]; const r = e[1]; const o = e[2]; const a = e[3]; const h = e[4]; const l = e[5]; const u = e[6]; const c = e[7]; return e[0] = s * n + h * i, e[1] = r * n + l * i, e[2] = o * n + u * i, e[3] = a * n + c * i, e[4] = h * n - s * i, e[5] = l * n - r * i, e[6] = u * n - o * i, e[7] = c * n - a * i, this.viewMatrixDirty = !0, this; }, viewLoad2D(t) { const e = this.viewMatrix; return e[0] = t[0], e[1] = t[1], e[2] = 0, e[3] = 0, e[4] = t[2], e[5] = t[3], e[6] = 0, e[7] = 0, e[8] = t[4], e[9] = t[5], e[10] = 1, e[11] = 0, e[12] = 0, e[13] = 0, e[14] = 0, e[15] = 1, this.viewMatrixDirty = !0, this; }, viewLoad(t) { const e = this.viewMatrix; return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], e[9] = t[9], e[10] = t[10], e[11] = t[11], e[12] = t[12], e[13] = t[13], e[14] = t[14], e[15] = t[15], this.viewMatrixDirty = !0, this; }, projIdentity() { const t = this.projectionMatrix; return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 0, t[5] = 1, t[6] = 0, t[7] = 0, t[8] = 0, t[9] = 0, t[10] = 1, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this.projectionMatrixDirty = !0, this; }, projOrtho(t, e, i, n, s, r) { const o = this.projectionMatrix; const a = 1 / (t - e); const h = 1 / (i - n); const l = 1 / (s - r); return o[0] = -2 * a, o[1] = 0, o[2] = 0, o[3] = 0, o[4] = 0, o[5] = -2 * h, o[6] = 0, o[7] = 0, o[8] = 0, o[9] = 0, o[10] = 2 * l, o[11] = 0, o[12] = (t + e) * a, o[13] = (n + i) * h, o[14] = (r + s) * l, o[15] = 1, this.projectionMatrixDirty = !0, this; }, projPersp(t, e, i, n) { const s = this.projectionMatrix; const r = 1 / Math.tan(t / 2); const o = 1 / (i - n); return s[0] = r / e, s[1] = 0, s[2] = 0, s[3] = 0, s[4] = 0, s[5] = r, s[6] = 0, s[7] = 0, s[8] = 0, s[9] = 0, s[10] = (n + i) * o, s[11] = -1, s[12] = 0, s[13] = 0, s[14] = 2 * n * i * o, s[15] = 0, this.projectionMatrixDirty = !0, this; },
  }; t.exports = i;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(12); const s = i(16); t.exports = function (t, e) { if (void 0 === e && (e = new n()), t.length === 0) return e; for (var i, r, o, a = Number.MAX_VALUE, h = Number.MAX_VALUE, l = s.MIN_SAFE_INTEGER, u = s.MIN_SAFE_INTEGER, c = 0; c < t.length; c++)i = t[c], Array.isArray(i) ? (r = i[0], o = i[1]) : (r = i.x, o = i.y), a = Math.min(a, r), h = Math.min(h, o), l = Math.max(l, r), u = Math.max(u, o); return e.x = a, e.y = h, e.width = l - a, e.height = u - h, e; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = {
    CENTER: i(391), ORIENTATION: i(392), SCALE_MODE: i(393), ZOOM: i(394),
  }; t.exports = n;
}, function (t, e) { t.exports = function (t) { t.parentNode && t.parentNode.removeChild(t); }; }, function (t, e) {
  t.exports = {
    MOUSE_DOWN: 0, MOUSE_MOVE: 1, MOUSE_UP: 2, TOUCH_START: 3, TOUCH_MOVE: 4, TOUCH_END: 5, POINTER_LOCK_CHANGE: 6, TOUCH_CANCEL: 7, MOUSE_WHEEL: 8,
  };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(137); const r = i(190); const o = i(24); const a = i(905); const h = i(906); const l = i(1); const u = i(407); const c = new n({
    initialize(t, e) { this.scene = t, this.game, this.renderer, this.facebook, this.config = e, this.settings = u.create(e), this.canvas, this.context, this.anims, this.cache, this.plugins, this.registry, this.scale, this.sound, this.textures, this.add, this.cameras, this.displayList, this.events, this.make, this.scenePlugin, this.updateList, this.sceneUpdate = l; }, init(t) { this.settings.status = s.INIT, this.sceneUpdate = l, this.game = t, this.renderer = t.renderer, this.canvas = t.canvas, this.context = t.context; const e = t.plugins; this.plugins = e, e.addToScene(this, r.Global, [r.CoreScene, h(this), a(this)]), this.events.emit(o.BOOT, this), this.settings.isBooted = !0; }, install(t) { Array.isArray(t) || (t = [t]), this.plugins.installLocal(this, t); }, step(t, e) { this.events.emit(o.PRE_UPDATE, t, e), this.events.emit(o.UPDATE, t, e), this.sceneUpdate.call(this.scene, t, e), this.events.emit(o.POST_UPDATE, t, e); }, render(t) { const e = this.displayList; e.depthSort(), this.cameras.render(t, e), this.events.emit(o.RENDER, t); }, queueDepthSort() { this.displayList.queueDepthSort(); }, depthSort() { this.displayList.depthSort(); }, pause(t) { return this.settings.active && (this.settings.status = s.PAUSED, this.settings.active = !1, this.events.emit(o.PAUSE, this, t)), this; }, resume(t) { return this.settings.active || (this.settings.status = s.RUNNING, this.settings.active = !0, this.events.emit(o.RESUME, this, t)), this; }, sleep(t) { return this.settings.status = s.SLEEPING, this.settings.active = !1, this.settings.visible = !1, this.events.emit(o.SLEEP, this, t), this; }, wake(t) { const e = this.settings; return e.status = s.RUNNING, e.active = !0, e.visible = !0, this.events.emit(o.WAKE, this, t), e.isTransition && this.events.emit(o.TRANSITION_WAKE, e.transitionFrom, e.transitionDuration), this; }, getData() { return this.settings.data; }, isSleeping() { return this.settings.status === s.SLEEPING; }, isActive() { return this.settings.status === s.RUNNING; }, isPaused() { return this.settings.status === s.PAUSED; }, isTransitioning() { return this.settings.isTransition || this.scenePlugin._target !== null; }, isTransitionOut() { return this.scenePlugin._target !== null && this.scenePlugin._duration > 0; }, isTransitionIn() { return this.settings.isTransition; }, isVisible() { return this.settings.visible; }, setVisible(t) { return this.settings.visible = t, this; }, setActive(t, e) { return t ? this.resume(e) : this.pause(e); }, start(t) { t && (this.settings.data = t), this.settings.status = s.START, this.settings.active = !0, this.settings.visible = !0, this.events.emit(o.START, this), this.events.emit(o.READY, this, t); }, shutdown(t) { this.events.off(o.TRANSITION_INIT), this.events.off(o.TRANSITION_START), this.events.off(o.TRANSITION_COMPLETE), this.events.off(o.TRANSITION_OUT), this.settings.status = s.SHUTDOWN, this.settings.active = !1, this.settings.visible = !1, this.events.emit(o.SHUTDOWN, this, t); }, destroy() { this.settings.status = s.DESTROYED, this.settings.active = !1, this.settings.visible = !1, this.events.emit(o.DESTROY, this), this.events.removeAllListeners(); for (let t = ['scene', 'game', 'anims', 'cache', 'plugins', 'registry', 'sound', 'textures', 'add', 'camera', 'displayList', 'events', 'make', 'scenePlugin', 'updateList'], e = 0; e < t.length; e++) this[t[e]] = null; },
  }); t.exports = c;
}, function (t, e) { t.exports = function (t) { return t && t[0].toUpperCase() + t.slice(1); }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(107); const r = i(410); const o = new n({
    initialize(t, e, i, n, s) { Array.isArray(i) || (i = [i]), this.manager = t, this.key = e, this.source = [], this.dataSource = [], this.frames = {}, this.customData = {}, this.firstFrame = '__BASE', this.frameTotal = 0; for (let o = 0; o < i.length; o++) this.source.push(new r(this, i[o], n, s)); }, add(t, e, i, n, r, o) { if (this.has(t)) return null; const a = new s(this, t, e, i, n, r, o); return this.frames[t] = a, this.firstFrame === '__BASE' && (this.firstFrame = t), this.frameTotal++, a; }, remove(t) { return !!this.has(t) && (this.get(t).destroy(), delete this.frames[t], !0); }, has(t) { return this.frames[t]; }, get(t) { t || (t = this.firstFrame); let e = this.frames[t]; return e || (console.warn(`Texture.frame missing: ${t}`), e = this.frames[this.firstFrame]), e; }, getTextureSourceIndex(t) { for (let e = 0; e < this.source.length; e++) if (this.source[e] === t) return e; return -1; }, getFramesFromTextureSource(t, e) { void 0 === e && (e = !1); const i = []; for (const n in this.frames) if (n !== '__BASE' || e) { const s = this.frames[n]; s.sourceIndex === t && i.push(s); } return i; }, getFrameNames(t) { void 0 === t && (t = !1); const e = Object.keys(this.frames); if (!t) { const i = e.indexOf('__BASE'); i !== -1 && e.splice(i, 1); } return e; }, getSourceImage(t) { t != null && this.frameTotal !== 1 || (t = '__BASE'); const e = this.frames[t]; return e ? e.source.image : (console.warn(`Texture.frame missing: ${t}`), this.frames.__BASE.source.image); }, getDataSourceImage(t) { t != null && this.frameTotal !== 1 || (t = '__BASE'); let e; const i = this.frames[t]; return i ? e = i.sourceIndex : (console.warn(`Texture.frame missing: ${t}`), e = this.frames.__BASE.sourceIndex), this.dataSource[e].image; }, setDataSource(t) { Array.isArray(t) || (t = [t]); for (let e = 0; e < t.length; e++) { const i = this.source[e]; this.dataSource.push(new r(this, t[e], i.width, i.height)); } }, setFilter(t) { let e; for (e = 0; e < this.source.length; e++) this.source[e].setFilter(t); for (e = 0; e < this.dataSource.length; e++) this.dataSource[e].setFilter(t); }, destroy() { let t; for (t = 0; t < this.source.length; t++) this.source[t].destroy(); for (t = 0; t < this.dataSource.length; t++) this.dataSource[t].destroy(); for (const e in this.frames) { this.frames[e].destroy(); } this.source = [], this.dataSource = [], this.frames = {}, this.manager.removeKey(this.key), this.manager = null; },
  }); t.exports = o;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = {
    Matrix: i(946), Add: i(953), AddAt: i(954), BringToTop: i(955), CountAllMatching: i(956), Each: i(957), EachInRange: i(958), FindClosestInSorted: i(294), GetAll: i(414), GetFirst: i(415), GetRandom: i(202), MoveDown: i(959), MoveTo: i(960), MoveUp: i(961), NumberArray: i(962), NumberArrayStep: i(963), QuickSelect: i(424), Range: i(425), Remove: i(135), RemoveAt: i(964), RemoveBetween: i(965), RemoveRandomElement: i(966), Replace: i(967), RotateLeft: i(310), RotateRight: i(311), SafeRange: i(75), SendToBack: i(968), SetAll: i(969), Shuffle: i(124), SpliceOne: i(88), StableSort: i(142), Swap: i(970),
  };
}, function (t, e) { t.exports = function (t) { if (!Array.isArray(t) || t.length < 2 || !Array.isArray(t[0])) return !1; for (let e = t[0].length, i = 1; i < t.length; i++) if (t[i].length !== e) return !1; return !0; }; }, function (t, e) { t.exports = function (t, e, i) { void 0 === e && (e = 0), void 0 === i && (i = t.length); const n = e + Math.floor(Math.random() * i); return void 0 === t[n] ? null : t[n]; }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(10); const r = i(972); const o = new n({
    Extends: s, initialize() { s.call(this), this._pending = [], this._active = [], this._destroy = [], this._toProcess = 0; }, add(t) { return this._pending.push(t), this._toProcess++, t; }, remove(t) { return this._destroy.push(t), this._toProcess++, t; }, removeAll() { for (let t = this._active, e = this._destroy, i = t.length; i--;)e.push(t[i]), this._toProcess++; return this; }, update() { if (this._toProcess === 0) return this._active; let t; let e; let i = this._destroy; const n = this._active; for (t = 0; t < i.length; t++) { e = i[t]; const s = n.indexOf(e); s !== -1 && (n.splice(s, 1), this.emit(r.REMOVE, e)); } for (i.length = 0, i = this._pending, t = 0; t < i.length; t++)e = i[t], this._active.push(e), this.emit(r.ADD, e); return i.length = 0, this._toProcess = 0, this._active; }, getActive() { return this._active; }, length: { get() { return this._active.length; } }, destroy() { this._toProcess = 0, this._pending = [], this._active = [], this._destroy = []; },
  }); t.exports = o;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(15); t.exports = function (t, e) { const i = n(e, 'anims', null); if (i === null) return t; if (typeof i === 'string')t.anims.play(i); else if (typeof i === 'object') { const s = t.anims; const r = n(i, 'key', void 0); const o = n(i, 'startFrame', void 0); const a = n(i, 'delay', 0); const h = n(i, 'repeat', 0); const l = n(i, 'repeatDelay', 0); const u = n(i, 'yoyo', !1); const c = n(i, 'play', !1); const d = n(i, 'delayedPlay', 0); s.setDelay(a), s.setRepeat(h), s.setRepeatDelay(l), s.setYoyo(u), c ? s.play(r, o) : d > 0 ? s.delayedPlay(d, r, o) : s.load(r); } return t; };
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  function i(t, e) { return parseInt(t.getAttribute(e), 10); }t.exports = function (t, e, n, s) {
    void 0 === e && (e = 0), void 0 === n && (n = 0); const r = {}; const o = t.getElementsByTagName('info')[0]; const a = t.getElementsByTagName('common')[0]; r.font = o.getAttribute('face'), r.size = i(o, 'size'), r.lineHeight = i(a, 'lineHeight') + n, r.chars = {}; const h = t.getElementsByTagName('char'); const l = void 0 !== s && s.trimmed; if (l) var u = s.height; let c = s.width; for (var d = 0; d < h.length; d++) {
      const f = h[d]; const p = i(f, 'id'); const g = i(f, 'x'); const v = i(f, 'y'); const m = i(f, 'width'); const y = i(f, 'height'); l && (g < c && (c = g), v < u && (u = v)), r.chars[p] = {
        x: g, y: v, width: m, height: y, centerX: Math.floor(m / 2), centerY: Math.floor(y / 2), xOffset: i(f, 'xoffset'), yOffset: i(f, 'yoffset'), xAdvance: i(f, 'xadvance') + e, data: {}, kerning: {},
      };
    } if (l && u !== 0 && c !== 0) for (const x in r.chars) { const T = r.chars[x]; T.x -= s.x, T.y -= s.y; } const w = t.getElementsByTagName('kerning'); for (d = 0; d < w.length; d++) { const b = w[d]; const E = i(b, 'first'); const S = i(b, 'second'); const A = i(b, 'amount'); r.chars[S].kerning[E] = A; } return r;
  };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(980); const s = i(983); const r = i(0); const o = i(13); const a = i(107); const h = i(14); const l = i(140); const u = new r({
    Extends: h, Mixins: [o.Alpha, o.BlendMode, o.Depth, o.Mask, o.Pipeline, o.ScrollFactor, o.Size, o.Texture, o.Transform, o.Visible, n], initialize(t, e, i, n, s) { h.call(this, t, 'Blitter'), this.setTexture(n, s), this.setPosition(e, i), this.initPipeline(), this.children = new l(), this.renderList = [], this.dirty = !1; }, create(t, e, i, n, r) { void 0 === n && (n = !0), void 0 === r && (r = this.children.length), void 0 === i ? i = this.frame : i instanceof a || (i = this.texture.get(i)); const o = new s(this, t, e, i, n); return this.children.addAt(o, r, !1), this.dirty = !0, o; }, createFromCallback(t, e, i, n) { for (var s = this.createMultiple(e, i, n), r = 0; r < s.length; r++) { const o = s[r]; t.call(this, o, r); } return s; }, createMultiple(t, e, i) { void 0 === e && (e = this.frame.name), void 0 === i && (i = !0), Array.isArray(e) || (e = [e]); const n = []; const s = this; return e.forEach(((e) => { for (let r = 0; r < t; r++)n.push(s.create(0, 0, e, i)); })), n; }, childCanRender(t) { return t.visible && t.alpha > 0; }, getRenderList() { return this.dirty && (this.renderList = this.children.list.filter(this.childCanRender, this), this.dirty = !1), this.renderList; }, clear() { this.children.removeAll(), this.dirty = !0; }, preDestroy() { this.children.destroy(), this.renderList = []; },
  }); t.exports = u;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Felipe Alfonso <@bitnenfer>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(200); const s = i(45); const r = i(0); const o = i(13); const a = i(102); const h = i(14); const l = i(12); const u = i(984); const c = i(426); const d = i(3); const f = new r({
    Extends: h, Mixins: [o.AlphaSingle, o.BlendMode, o.ComputedSize, o.Depth, o.Mask, o.Transform, o.Visible, u], initialize(t, e, i, n) { h.call(this, t, 'Container'), this.list = [], this.exclusive = !0, this.maxSize = -1, this.position = 0, this.localTransform = new o.TransformMatrix(), this.tempTransformMatrix = new o.TransformMatrix(), this._displayList = t.sys.displayList, this._sortKey = '', this._sysEvents = t.sys.events, this.scrollFactorX = 1, this.scrollFactorY = 1, this.setPosition(e, i), this.clearAlpha(), this.setBlendMode(s.SKIP_CHECK), n && this.add(n); }, originX: { get() { return 0.5; } }, originY: { get() { return 0.5; } }, displayOriginX: { get() { return 0.5 * this.width; } }, displayOriginY: { get() { return 0.5 * this.height; } }, setExclusive(t) { return void 0 === t && (t = !0), this.exclusive = t, this; }, getBounds(t) { if (void 0 === t && (t = new l()), t.setTo(this.x, this.y, 0, 0), this.parentContainer) { const e = this.parentContainer.getBoundsTransformMatrix().transformPoint(this.x, this.y); t.setTo(e.x, e.y, 0, 0); } if (this.list.length > 0) { const i = this.list; const n = new l(); const s = i[0].getBounds(); t.setTo(s.x, s.y, s.width, s.height); for (let r = 1; r < i.length; r++) { const o = i[r]; o.getBounds && (o.getBounds(n), c(n, t, t)); } } return t; }, addHandler(t) { t.once(a.DESTROY, this.remove, this), this.exclusive && (this._displayList.remove(t), t.parentContainer && t.parentContainer.remove(t), t.parentContainer = this); }, removeHandler(t) { t.off(a.DESTROY, this.remove), this.exclusive && (t.parentContainer = null); }, pointToContainer(t, e) { void 0 === e && (e = new d()), this.parentContainer ? this.parentContainer.pointToContainer(t, e) : e = new d(t.x, t.y); const i = this.tempTransformMatrix; return i.applyITRS(this.x, this.y, this.rotation, this.scaleX, this.scaleY), i.invert(), i.transformPoint(t.x, t.y, e), e; }, getBoundsTransformMatrix() { return this.getWorldTransformMatrix(this.tempTransformMatrix, this.localTransform); }, add(t) { return n.Add(this.list, t, this.maxSize, this.addHandler, this), this; }, addAt(t, e) { return n.AddAt(this.list, t, e, this.maxSize, this.addHandler, this), this; }, getAt(t) { return this.list[t]; }, getIndex(t) { return this.list.indexOf(t); }, sort(t, e) { return t ? (void 0 === e && (e = function (e, i) { return e[t] - i[t]; }), n.StableSort.inplace(this.list, e), this) : this; }, getByName(t) { return n.GetFirst(this.list, 'name', t); }, getRandom(t, e) { return n.GetRandom(this.list, t, e); }, getFirst(t, e, i, s) { return n.GetFirst(this.list, t, e, i, s); }, getAll(t, e, i, s) { return n.GetAll(this.list, t, e, i, s); }, count(t, e, i, s) { return n.CountAllMatching(this.list, t, e, i, s); }, swap(t, e) { return n.Swap(this.list, t, e), this; }, moveTo(t, e) { return n.MoveTo(this.list, t, e), this; }, remove(t, e) { let i = n.Remove(this.list, t, this.removeHandler, this); if (e && i) { Array.isArray(i) || (i = [i]); for (let s = 0; s < i.length; s++)i[s].destroy(); } return this; }, removeAt(t, e) { const i = n.RemoveAt(this.list, t, this.removeHandler, this); return e && i && i.destroy(), this; }, removeBetween(t, e, i) { const s = n.RemoveBetween(this.list, t, e, this.removeHandler, this); if (i) for (let r = 0; r < s.length; r++)s[r].destroy(); return this; }, removeAll(t) { const e = n.RemoveBetween(this.list, 0, this.list.length, this.removeHandler, this); if (t) for (let i = 0; i < e.length; i++)e[i].destroy(); return this; }, bringToTop(t) { return n.BringToTop(this.list, t), this; }, sendToBack(t) { return n.SendToBack(this.list, t), this; }, moveUp(t) { return n.MoveUp(this.list, t), this; }, moveDown(t) { return n.MoveDown(this.list, t), this; }, reverse() { return this.list.reverse(), this; }, shuffle() { return n.Shuffle(this.list), this; }, replace(t, e, i) { return n.Replace(this.list, t, e) && (this.addHandler(e), this.removeHandler(t), i && t.destroy()), this; }, exists(t) { return this.list.indexOf(t) > -1; }, setAll(t, e, i, s) { return n.SetAll(this.list, t, e, i, s), this; }, each(t, e) { let i; const n = [null]; const s = this.list.slice(); const r = s.length; for (i = 2; i < arguments.length; i++)n.push(arguments[i]); for (i = 0; i < r; i++)n[0] = s[i], t.apply(e, n); return this; }, iterate(t, e) { let i; const n = [null]; for (i = 2; i < arguments.length; i++)n.push(arguments[i]); for (i = 0; i < this.list.length; i++)n[0] = this.list[i], t.apply(e, n); return this; }, setScrollFactor(t, e, i) { return void 0 === e && (e = t), void 0 === i && (i = !1), this.scrollFactorX = t, this.scrollFactorY = e, i && (n.SetAll(this.list, 'scrollFactorX', t), n.SetAll(this.list, 'scrollFactorY', e)), this; }, length: { get() { return this.list.length; } }, first: { get() { return this.position = 0, this.list.length > 0 ? this.list[0] : null; } }, last: { get() { return this.list.length > 0 ? (this.position = this.list.length - 1, this.list[this.position]) : null; } }, next: { get() { return this.position < this.list.length ? (this.position++, this.list[this.position]) : null; } }, previous: { get() { return this.position > 0 ? (this.position--, this.list[this.position]) : null; } }, preDestroy() { this.removeAll(!!this.exclusive), this.localTransform.destroy(), this.tempTransformMatrix.destroy(), this.list = [], this._displayList = null; },
  }); t.exports = f;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(143); const s = i(0); const r = i(989); const o = new s({
    Extends: n,
    Mixins: [r],
    initialize(t, e, i, s, r, o, a) {
      n.call(this, t, e, i, s, r, o, a), this.type = 'DynamicBitmapText', this.scrollX = 0, this.scrollY = 0, this.cropWidth = 0, this.cropHeight = 0, this.displayCallback, this.callbackData = {
        parent: this,
        color: 0,
        tint: {
          topLeft: 0, topRight: 0, bottomLeft: 0, bottomRight: 0,
        },
        index: 0,
        charCode: 0,
        x: 0,
        y: 0,
        scale: 0,
        rotation: 0,
        data: 0,
      };
    },
    setSize(t, e) { return this.cropWidth = t, this.cropHeight = e, this; },
    setDisplayCallback(t) { return this.displayCallback = t, this; },
    setScrollX(t) { return this.scrollX = t, this; },
    setScrollY(t) { return this.scrollY = t, this; },
  }); t.exports = o;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(103); const s = i(0); const r = i(210); const o = i(292); const a = i(296); const h = i(297); const l = i(301); const u = i(123); const c = i(306); const d = i(307); const f = i(304); const p = i(33); const g = i(108); const v = i(14); const m = i(2); const y = i(6); const x = i(16); const T = i(995); var w = new s({
    Extends: v, Mixins: [o, a, h, l, u, c, d, f, T], initialize(t, e) { const i = y(e, 'x', 0); const n = y(e, 'y', 0); v.call(this, t, 'Graphics'), this.setPosition(i, n), this.initPipeline(), this.displayOriginX = 0, this.displayOriginY = 0, this.commandBuffer = [], this.defaultFillColor = -1, this.defaultFillAlpha = 1, this.defaultStrokeWidth = 1, this.defaultStrokeColor = -1, this.defaultStrokeAlpha = 1, this._lineWidth = 1, this._tempMatrix1 = new p(), this._tempMatrix2 = new p(), this._tempMatrix3 = new p(), this.setDefaultStyles(e); }, setDefaultStyles(t) { return y(t, 'lineStyle', null) && (this.defaultStrokeWidth = y(t, 'lineStyle.width', 1), this.defaultStrokeColor = y(t, 'lineStyle.color', 16777215), this.defaultStrokeAlpha = y(t, 'lineStyle.alpha', 1), this.lineStyle(this.defaultStrokeWidth, this.defaultStrokeColor, this.defaultStrokeAlpha)), y(t, 'fillStyle', null) && (this.defaultFillColor = y(t, 'fillStyle.color', 16777215), this.defaultFillAlpha = y(t, 'fillStyle.alpha', 1), this.fillStyle(this.defaultFillColor, this.defaultFillAlpha)), this; }, lineStyle(t, e, i) { return void 0 === i && (i = 1), this.commandBuffer.push(r.LINE_STYLE, t, e, i), this._lineWidth = t, this; }, fillStyle(t, e) { return void 0 === e && (e = 1), this.commandBuffer.push(r.FILL_STYLE, t, e), this; }, fillGradientStyle(t, e, i, n, s) { return void 0 === s && (s = 1), this.commandBuffer.push(r.GRADIENT_FILL_STYLE, s, t, e, i, n), this; }, lineGradientStyle(t, e, i, n, s, o) { return void 0 === o && (o = 1), this.commandBuffer.push(r.GRADIENT_LINE_STYLE, t, o, e, i, n, s), this; }, setTexture(t, e, i) { if (void 0 === i && (i = 0), void 0 === t) this.commandBuffer.push(r.CLEAR_TEXTURE); else { const n = this.scene.sys.textures.getFrame(t, e); n && (i === 2 && (i = 3), this.commandBuffer.push(r.SET_TEXTURE, n, i)); } return this; }, beginPath() { return this.commandBuffer.push(r.BEGIN_PATH), this; }, closePath() { return this.commandBuffer.push(r.CLOSE_PATH), this; }, fillPath() { return this.commandBuffer.push(r.FILL_PATH), this; }, fill() { return this.commandBuffer.push(r.FILL_PATH), this; }, strokePath() { return this.commandBuffer.push(r.STROKE_PATH), this; }, stroke() { return this.commandBuffer.push(r.STROKE_PATH), this; }, fillCircleShape(t) { return this.fillCircle(t.x, t.y, t.radius); }, strokeCircleShape(t) { return this.strokeCircle(t.x, t.y, t.radius); }, fillCircle(t, e, i) { return this.beginPath(), this.arc(t, e, i, 0, x.PI2), this.fillPath(), this; }, strokeCircle(t, e, i) { return this.beginPath(), this.arc(t, e, i, 0, x.PI2), this.strokePath(), this; }, fillRectShape(t) { return this.fillRect(t.x, t.y, t.width, t.height); }, strokeRectShape(t) { return this.strokeRect(t.x, t.y, t.width, t.height); }, fillRect(t, e, i, n) { return this.commandBuffer.push(r.FILL_RECT, t, e, i, n), this; }, strokeRect(t, e, i, n) { const s = this._lineWidth / 2; const r = t - s; const o = t + s; return this.beginPath(), this.moveTo(t, e), this.lineTo(t, e + n), this.strokePath(), this.beginPath(), this.moveTo(t + i, e), this.lineTo(t + i, e + n), this.strokePath(), this.beginPath(), this.moveTo(r, e), this.lineTo(o + i, e), this.strokePath(), this.beginPath(), this.moveTo(r, e + n), this.lineTo(o + i, e + n), this.strokePath(), this; }, fillRoundedRect(t, e, i, n, s) { void 0 === s && (s = 20); let r = s; let o = s; let a = s; let h = s; return typeof s !== 'number' && (r = m(s, 'tl', 20), o = m(s, 'tr', 20), a = m(s, 'bl', 20), h = m(s, 'br', 20)), this.beginPath(), this.moveTo(t + r, e), this.lineTo(t + i - o, e), this.arc(t + i - o, e + o, o, -x.TAU, 0), this.lineTo(t + i, e + n - h), this.arc(t + i - h, e + n - h, h, 0, x.TAU), this.lineTo(t + a, e + n), this.arc(t + a, e + n - a, a, x.TAU, Math.PI), this.lineTo(t, e + r), this.arc(t + r, e + r, r, -Math.PI, -x.TAU), this.fillPath(), this; }, strokeRoundedRect(t, e, i, n, s) { void 0 === s && (s = 20); let r = s; let o = s; let a = s; let h = s; return typeof s !== 'number' && (r = m(s, 'tl', 20), o = m(s, 'tr', 20), a = m(s, 'bl', 20), h = m(s, 'br', 20)), this.beginPath(), this.moveTo(t + r, e), this.lineTo(t + i - o, e), this.arc(t + i - o, e + o, o, -x.TAU, 0), this.lineTo(t + i, e + n - h), this.arc(t + i - h, e + n - h, h, 0, x.TAU), this.lineTo(t + a, e + n), this.arc(t + a, e + n - a, a, x.TAU, Math.PI), this.lineTo(t, e + r), this.arc(t + r, e + r, r, -Math.PI, -x.TAU), this.strokePath(), this; }, fillPointShape(t, e) { return this.fillPoint(t.x, t.y, e); }, fillPoint(t, e, i) { return !i || i < 1 ? i = 1 : (t -= i / 2, e -= i / 2), this.commandBuffer.push(r.FILL_RECT, t, e, i, i), this; }, fillTriangleShape(t) { return this.fillTriangle(t.x1, t.y1, t.x2, t.y2, t.x3, t.y3); }, strokeTriangleShape(t) { return this.strokeTriangle(t.x1, t.y1, t.x2, t.y2, t.x3, t.y3); }, fillTriangle(t, e, i, n, s, o) { return this.commandBuffer.push(r.FILL_TRIANGLE, t, e, i, n, s, o), this; }, strokeTriangle(t, e, i, n, s, o) { return this.commandBuffer.push(r.STROKE_TRIANGLE, t, e, i, n, s, o), this; }, strokeLineShape(t) { return this.lineBetween(t.x1, t.y1, t.x2, t.y2); }, lineBetween(t, e, i, n) { return this.beginPath(), this.moveTo(t, e), this.lineTo(i, n), this.strokePath(), this; }, lineTo(t, e) { return this.commandBuffer.push(r.LINE_TO, t, e), this; }, moveTo(t, e) { return this.commandBuffer.push(r.MOVE_TO, t, e), this; }, strokePoints(t, e, i, n) { void 0 === e && (e = !1), void 0 === i && (i = !1), void 0 === n && (n = t.length), this.beginPath(), this.moveTo(t[0].x, t[0].y); for (let s = 1; s < n; s++) this.lineTo(t[s].x, t[s].y); return e && this.lineTo(t[0].x, t[0].y), i && this.closePath(), this.strokePath(), this; }, fillPoints(t, e, i, n) { void 0 === e && (e = !1), void 0 === i && (i = !1), void 0 === n && (n = t.length), this.beginPath(), this.moveTo(t[0].x, t[0].y); for (let s = 1; s < n; s++) this.lineTo(t[s].x, t[s].y); return e && this.lineTo(t[0].x, t[0].y), i && this.closePath(), this.fillPath(), this; }, strokeEllipseShape(t, e) { void 0 === e && (e = 32); const i = t.getPoints(e); return this.strokePoints(i, !0); }, strokeEllipse(t, e, i, n, s) { void 0 === s && (s = 32); const r = new g(t, e, i, n).getPoints(s); return this.strokePoints(r, !0); }, fillEllipseShape(t, e) { void 0 === e && (e = 32); const i = t.getPoints(e); return this.fillPoints(i, !0); }, fillEllipse(t, e, i, n, s) { void 0 === s && (s = 32); const r = new g(t, e, i, n).getPoints(s); return this.fillPoints(r, !0); }, arc(t, e, i, n, s, o, a) { return void 0 === o && (o = !1), void 0 === a && (a = 0), this.commandBuffer.push(r.ARC, t, e, i, n, s, o, a), this; }, slice(t, e, i, n, s, o, a) { return void 0 === o && (o = !1), void 0 === a && (a = 0), this.commandBuffer.push(r.BEGIN_PATH), this.commandBuffer.push(r.MOVE_TO, t, e), this.commandBuffer.push(r.ARC, t, e, i, n, s, o, a), this.commandBuffer.push(r.CLOSE_PATH), this; }, save() { return this.commandBuffer.push(r.SAVE), this; }, restore() { return this.commandBuffer.push(r.RESTORE), this; }, translateCanvas(t, e) { return this.commandBuffer.push(r.TRANSLATE, t, e), this; }, scaleCanvas(t, e) { return this.commandBuffer.push(r.SCALE, t, e), this; }, rotateCanvas(t) { return this.commandBuffer.push(r.ROTATE, t), this; }, clear() { return this.commandBuffer.length = 0, this.defaultFillColor > -1 && this.fillStyle(this.defaultFillColor, this.defaultFillAlpha), this.defaultStrokeColor > -1 && this.lineStyle(this.defaultStrokeWidth, this.defaultStrokeColor, this.defaultStrokeAlpha), this; }, generateTexture(t, e, i) { let n; let s; const r = this.scene.sys; const o = r.game.renderer; if (void 0 === e && (e = r.scale.width), void 0 === i && (i = r.scale.height), w.TargetCamera.setScene(this.scene), w.TargetCamera.setViewport(0, 0, e, i), w.TargetCamera.scrollX = this.x, w.TargetCamera.scrollY = this.y, typeof t === 'string') if (r.textures.exists(t)) { const a = (n = r.textures.get(t)).getSourceImage(); a instanceof HTMLCanvasElement && (s = a.getContext('2d')); } else s = (n = r.textures.createCanvas(t, e, i)).getSourceImage().getContext('2d'); else t instanceof HTMLCanvasElement && (s = t.getContext('2d')); return s && (this.renderCanvas(o, this, 0, w.TargetCamera, null, s, !1), n && n.refresh()), this; }, preDestroy() { this.commandBuffer = []; },
  }); w.TargetCamera = new n(), t.exports = w;
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = {
    ARC: 0, BEGIN_PATH: 1, CLOSE_PATH: 2, FILL_RECT: 3, LINE_TO: 4, MOVE_TO: 5, LINE_STYLE: 6, FILL_STYLE: 7, FILL_PATH: 8, STROKE_PATH: 9, FILL_TRIANGLE: 10, STROKE_TRIANGLE: 11, SAVE: 14, RESTORE: 15, TRANSLATE: 16, SCALE: 17, ROTATE: 18, SET_TEXTURE: 19, CLEAR_TEXTURE: 20, GRADIENT_FILL_STYLE: 21, GRADIENT_LINE_STYLE: 22,
  };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(4); t.exports = function (t, e, i) { void 0 === i && (i = new n()); const s = t.width / 2; const r = t.height / 2; return i.x = t.x + s * Math.cos(e), i.y = t.y + r * Math.sin(e), i; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(13); const r = i(14); const o = i(434); const a = i(140); const h = i(436); const l = i(1005); const u = new n({
    Extends: r, Mixins: [s.Depth, s.Mask, s.Pipeline, s.Transform, s.Visible, l], initialize(t, e, i, n) { if (r.call(this, t, 'ParticleEmitterManager'), this.blendMode = -1, this.timeScale = 1, this.texture = null, this.frame = null, this.frameNames = [], i === null || typeof i !== 'object' && !Array.isArray(i) || (n = i, i = null), this.setTexture(e, i), this.initPipeline(), this.emitters = new a(this), this.wells = new a(this), n) { Array.isArray(n) || (n = [n]); for (let s = 0; s < n.length; s++) this.createEmitter(n[s]); } }, setTexture(t, e) { return this.texture = this.scene.sys.textures.get(t), this.setFrame(e); }, setFrame(t) { this.frame = this.texture.get(t); const e = this.texture.getFramesFromTextureSource(this.frame.sourceIndex); const i = []; return e.forEach(((t) => { i.push(t.name); })), this.frameNames = i, this.defaultFrame = this.frame, this; }, setEmitterFrames(t, e) { Array.isArray(t) || (t = [t]); const i = e.frames; i.length = 0; for (let n = 0; n < t.length; n++) { const s = t[n]; this.frameNames.indexOf(s) !== -1 && i.push(this.texture.get(s)); } return i.length > 0 ? e.defaultFrame = i[0] : e.defaultFrame = this.defaultFrame, this; }, addEmitter(t) { return this.emitters.add(t); }, createEmitter(t) { return this.addEmitter(new h(this, t)); }, removeEmitter(t) { return this.emitters.remove(t, !0); }, addGravityWell(t) { return this.wells.add(t); }, createGravityWell(t) { return this.addGravityWell(new o(t)); }, emitParticle(t, e, i) { for (let n = this.emitters.list, s = 0; s < n.length; s++) { const r = n[s]; r.active && r.emitParticle(t, e, i); } return this; }, emitParticleAt(t, e, i) { return this.emitParticle(i, t, e); }, pause() { return this.active = !1, this; }, resume() { return this.active = !0, this; }, getProcessors() { return this.wells.getAll('active', !0); }, preUpdate(t, e) { e *= this.timeScale; for (let i = this.emitters.list, n = 0; n < i.length; n++) { const s = i[n]; s.active && s.preUpdate(t, e); } }, setAlpha() {}, setScrollFactor() {}, setBlendMode() {},
  }); t.exports = u;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(45); const s = i(103); const r = i(30); const o = i(0); const a = i(13); const h = i(39); const l = i(107); const u = i(14); const c = i(1009); const d = i(11); const f = i(214); const p = new o({
    Extends: u, Mixins: [a.Alpha, a.BlendMode, a.ComputedSize, a.Crop, a.Depth, a.Flip, a.GetBounds, a.Mask, a.Origin, a.Pipeline, a.ScrollFactor, a.Tint, a.Transform, a.Visible, c], initialize(t, e, i, n, o, a, l) { void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 32), void 0 === o && (o = 32), u.call(this, t, 'RenderTexture'), this.renderer = t.sys.game.renderer, this.textureManager = t.sys.textures, this.globalTint = 16777215, this.globalAlpha = 1, this.canvas = null, this.framebuffer = null, this.dirty = !1, this._crop = this.resetCropObject(), this.texture = null, this.frame = null, this._saved = !1, void 0 === a ? (this.canvas = r.create2D(this, n, o), this.texture = t.sys.textures.addCanvas(f(), this.canvas), this.frame = this.texture.get()) : (this.texture = t.sys.textures.get(a), this.frame = this.texture.get(l), this.canvas = this.frame.source.image, this._saved = !0, this.dirty = !0, this.width = this.frame.cutWidth, this.height = this.frame.cutHeight), this.context = this.canvas.getContext('2d'), this._eraseMode = !1, this.camera = new s(0, 0, n, o), this.gl = null, this.glTexture = null; const c = this.renderer; if (c.type === h.WEBGL) { const d = c.gl; this.gl = d, this.glTexture = this.frame.source.glTexture, this.drawGameObject = this.batchGameObjectWebGL, this.framebuffer = c.createFramebuffer(n, o, this.glTexture, !1); } else c.type === h.CANVAS && (this.drawGameObject = this.batchGameObjectCanvas); this.camera.setScene(t), this.setPosition(e, i), void 0 === a && this.setSize(n, o), this.setOrigin(0, 0), this.initPipeline(); }, setSize(t, e) { return this.resize(t, e); }, resize(t, e) { if (void 0 === e && (e = t), t !== this.width || e !== this.height) { if (this.frame.name === '__BASE') { if (this.canvas.width = t, this.canvas.height = e, this.texture.width = t, this.texture.height = e, this.gl) { const i = this.gl; this.renderer.deleteTexture(this.frame.source.glTexture), this.renderer.deleteFramebuffer(this.framebuffer); const n = this.renderer.createTexture2D(0, i.NEAREST, i.NEAREST, i.CLAMP_TO_EDGE, i.CLAMP_TO_EDGE, i.RGBA, null, t, e, !1); this.framebuffer = this.renderer.createFramebuffer(t, e, n, !1), this.frame.source.isRenderTexture = !0, this.frame.glTexture = n, this.glTexture = n; } this.frame.source.width = t, this.frame.source.height = e, this.camera.setSize(t, e), this.frame.setSize(t, e), this.width = t, this.height = e; } } else { const s = this.texture.getSourceImage(); this.frame.cutX + t > s.width && (t = s.width - this.frame.cutX), this.frame.cutY + e > s.height && (e = s.height - this.frame.cutY), this.frame.setSize(t, e, this.frame.cutX, this.frame.cutY); } this.updateDisplayOrigin(); const r = this.input; return r && !r.customHitArea && (r.hitArea.width = t, r.hitArea.height = e), this; }, setGlobalTint(t) { return this.globalTint = t, this; }, setGlobalAlpha(t) { return this.globalAlpha = t, this; }, saveTexture(t) { return this.textureManager.renameTexture(this.texture.key, t), this._saved = !0, this.texture; }, fill(t, e, i, n, s, r) { void 0 === e && (e = 1), void 0 === i && (i = 0), void 0 === n && (n = 0), void 0 === s && (s = this.frame.cutWidth), void 0 === r && (r = this.frame.cutHeight); const o = 255 & (t >> 16 | 0); const a = 255 & (t >> 8 | 0); const h = 255 & (0 | t); const l = this.gl; const u = this.frame; if (this.camera.preRender(1, 1), l) { const c = this.camera._cx; const f = this.camera._cy; const p = this.camera._cw; const g = this.camera._ch; this.renderer.setFramebuffer(this.framebuffer, !1), this.renderer.pushScissor(c, f, p, g, g); const v = this.pipeline; v.projOrtho(0, this.texture.width, 0, this.texture.height, -1e3, 1e3), v.drawFillRect(i, n, s, r, d.getTintFromFloats(o / 255, a / 255, h / 255, 1), e), this.renderer.setFramebuffer(null, !1), this.renderer.popScissor(), v.projOrtho(0, v.width, v.height, 0, -1e3, 1e3); } else this.renderer.setContext(this.context), this.context.fillStyle = `rgba(${o},${a},${h},${e})`, this.context.fillRect(i + u.cutX, n + u.cutY, s, r), this.renderer.setContext(); return this.dirty = !0, this; }, clear() { if (this.dirty) { const t = this.gl; if (t) { const e = this.renderer; e.setFramebuffer(this.framebuffer, !0), this.frame.cutWidth === this.canvas.width && this.frame.cutHeight === this.canvas.height || t.scissor(this.frame.cutX, this.frame.cutY, this.frame.cutWidth, this.frame.cutHeight), t.clearColor(0, 0, 0, 0), t.clear(t.COLOR_BUFFER_BIT), e.setFramebuffer(null, !0); } else { const i = this.context; i.save(), i.setTransform(1, 0, 0, 1, 0, 0), i.clearRect(this.frame.cutX, this.frame.cutY, this.frame.cutWidth, this.frame.cutHeight), i.restore(); } this.dirty = !1; } return this; }, erase(t, e, i) { this._eraseMode = !0; const s = this.renderer.currentBlendMode; return this.renderer.setBlendMode(n.ERASE), this.draw(t, e, i, 1, 16777215), this.renderer.setBlendMode(s), this._eraseMode = !1, this; }, draw(t, e, i, n, s) { void 0 === n && (n = this.globalAlpha), s = void 0 === s ? (this.globalTint >> 16) + (65280 & this.globalTint) + ((255 & this.globalTint) << 16) : (s >> 16) + (65280 & s) + ((255 & s) << 16), Array.isArray(t) || (t = [t]); const r = this.gl; if (this.camera.preRender(1, 1), r) { const o = this.camera._cx; const a = this.camera._cy; const h = this.camera._cw; const l = this.camera._ch; this.renderer.setFramebuffer(this.framebuffer, !1), this.renderer.pushScissor(o, a, h, l, l); const u = this.pipeline; u.projOrtho(0, this.texture.width, 0, this.texture.height, -1e3, 1e3), this.batchList(t, e, i, n, s), u.flush(), this.renderer.setFramebuffer(null, !1), this.renderer.popScissor(), u.projOrtho(0, u.width, u.height, 0, -1e3, 1e3); } else this.renderer.setContext(this.context), this.batchList(t, e, i, n, s), this.renderer.setContext(); return this.dirty = !0, this; }, drawFrame(t, e, i, n, s, r) { void 0 === i && (i = 0), void 0 === n && (n = 0), void 0 === s && (s = this.globalAlpha), r = void 0 === r ? (this.globalTint >> 16) + (65280 & this.globalTint) + ((255 & this.globalTint) << 16) : (r >> 16) + (65280 & r) + ((255 & r) << 16); const o = this.gl; const a = this.textureManager.getFrame(t, e); if (a) { if (this.camera.preRender(1, 1), o) { const h = this.camera._cx; const l = this.camera._cy; const u = this.camera._cw; const c = this.camera._ch; this.renderer.setFramebuffer(this.framebuffer, !1), this.renderer.pushScissor(h, l, u, c, c); const d = this.pipeline; d.projOrtho(0, this.texture.width, 0, this.texture.height, -1e3, 1e3), d.batchTextureFrame(a, i + this.frame.cutX, n + this.frame.cutY, r, s, this.camera.matrix, null), d.flush(), this.renderer.setFramebuffer(null, !1), this.renderer.popScissor(), d.projOrtho(0, d.width, d.height, 0, -1e3, 1e3); } else this.batchTextureFrame(a, i + this.frame.cutX, n + this.frame.cutY, s, r); this.dirty = !0; } return this; }, batchList(t, e, i, n, s) { for (let r = 0; r < t.length; r++) { const o = t[r]; o && o !== this && (o.renderWebGL || o.renderCanvas ? this.drawGameObject(o, e, i) : o.isParent || o.list ? this.batchGroup(o.getChildren(), e, i) : typeof o === 'string' ? this.batchTextureFrameKey(o, null, e, i, n, s) : o instanceof l ? this.batchTextureFrame(o, e, i, n, s) : Array.isArray(o) && this.batchList(o, e, i, n, s)); } }, batchGroup(t, e, i) { void 0 === e && (e = 0), void 0 === i && (i = 0), e += this.frame.cutX, i += this.frame.cutY; for (let n = 0; n < t.length; n++) { const s = t[n]; if (s.willRender()) { const r = s.x + e; const o = s.y + i; this.drawGameObject(s, r, o); } } }, batchGameObjectWebGL(t, e, i) { void 0 === e && (e = t.x), void 0 === i && (i = t.y); const n = t.x; const s = t.y; this._eraseMode || this.renderer.setBlendMode(t.blendMode), t.setPosition(e + this.frame.cutX, i + this.frame.cutY), t.renderWebGL(this.renderer, t, 0, this.camera, null), t.setPosition(n, s); }, batchGameObjectCanvas(t, e, i) { void 0 === e && (e = t.x), void 0 === i && (i = t.y); const s = t.x; const r = t.y; if (this._eraseMode) { var o = t.blendMode; t.blendMode = n.ERASE; }t.setPosition(e + this.frame.cutX, i + this.frame.cutY), t.renderCanvas(this.renderer, t, 0, this.camera, null), t.setPosition(s, r), this._eraseMode && (t.blendMode = o); }, batchTextureFrameKey(t, e, i, n, s, r) { const o = this.textureManager.getFrame(t, e); o && this.batchTextureFrame(o, i, n, s, r); }, batchTextureFrame(t, e, i, n, s) { if (void 0 === e && (e = 0), void 0 === i && (i = 0), e += this.frame.cutX, i += this.frame.cutY, this.gl) this.pipeline.batchTextureFrame(t, e, i, s, n, this.camera.matrix, null); else { const r = this.context; const o = t.canvasData; const a = t.source.image; const h = this.camera.matrix; r.globalAlpha = this.globalAlpha, r.setTransform(h[0], h[1], h[2], h[3], h[4], h[5]), r.drawImage(a, o.x, o.y, o.width, o.height, e, i, o.width, o.height); } }, snapshotArea(t, e, i, n, s, r, o) { return this.gl ? this.renderer.snapshotFramebuffer(this.framebuffer, this.width, this.height, s, !1, t, e, i, n, r, o) : this.renderer.snapshotCanvas(this.canvas, s, !1, t, e, i, n, r, o), this; }, snapshot(t, e, i) { return this.gl ? this.renderer.snapshotFramebuffer(this.framebuffer, this.width, this.height, t, !1, 0, 0, this.width, this.height, e, i) : this.renderer.snapshotCanvas(this.canvas, t, !1, 0, 0, this.width, this.height, e, i), this; }, snapshotPixel(t, e, i) { return this.gl ? this.renderer.snapshotFramebuffer(this.framebuffer, this.width, this.height, i, !0, t, e) : this.renderer.snapshotCanvas(this.canvas, i, !0, t, e), this; }, preDestroy() { this._saved || (r.remove(this.canvas), this.gl && this.renderer.deleteFramebuffer(this.framebuffer), this.texture.destroy(), this.camera.destroy(), this.canvas = null, this.context = null, this.framebuffer = null, this.texture = null, this.glTexture = null); },
  }); t.exports = p;
}, function (t, e) { t.exports = function () { return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, ((t) => { const e = 16 * Math.random() | 0; return (t === 'x' ? e : 3 & e | 8).toString(16); })); }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(13); const r = i(14); const o = i(1015); const a = i(3); const h = new n({
    Extends: r, Mixins: [s.AlphaSingle, s.BlendMode, s.Depth, s.Flip, s.Mask, s.Pipeline, s.Size, s.Texture, s.Transform, s.Visible, s.ScrollFactor, o], initialize(t, e, i, n, o, h, l, u, c) { void 0 === n && (n = '__DEFAULT'), void 0 === h && (h = 2), void 0 === l && (l = !0), r.call(this, t, 'Rope'), this.anims = new s.Animation(this), this.points = h, this.vertices, this.uv, this.colors, this.alphas, this.tintFill = n === '__DEFAULT' ? 2 : 0, this.dirty = !1, this.horizontal = l, this._flipX = !1, this._flipY = !1, this._perp = new a(), this.debugCallback = null, this.debugGraphic = null, this.setTexture(n, o), this.setPosition(e, i), this.setSizeToFrame(), this.initPipeline('TextureTintStripPipeline'), Array.isArray(h) && this.resizeArrays(h.length), this.setPoints(h, u, c), this.updateVertices(); }, preUpdate(t, e) { const i = this.anims.currentFrame; this.anims.update(t, e), this.anims.currentFrame !== i && (this.updateUVs(), this.updateVertices()); }, play(t, e, i) { return this.anims.play(t, e, i), this; }, setDirty() { return this.dirty = !0, this; }, setHorizontal(t, e, i) { return void 0 === t && (t = this.points.length), this.horizontal ? this : (this.horizontal = !0, this.setPoints(t, e, i)); }, setVertical(t, e, i) { return void 0 === t && (t = this.points.length), this.horizontal ? (this.horizontal = !1, this.setPoints(t, e, i)) : this; }, setTintFill(t) { return void 0 === t && (t = 0), this.tintFill = t, this; }, setAlphas(t, e) { const i = this.points.length; if (i < 1) return this; let n; const s = this.alphas; void 0 === t ? t = [1] : Array.isArray(t) || void 0 !== e || (t = [t]); let r = 0; if (void 0 !== e) for (n = 0; n < i; n++)s[r = 2 * n] = t, s[r + 1] = e; else if (t.length === i) for (n = 0; n < i; n++)s[r = 2 * n] = t[n], s[r + 1] = t[n]; else { let o = t[0]; for (n = 0; n < i; n++)r = 2 * n, t.length > r && (o = t[r]), s[r] = o, t.length > r + 1 && (o = t[r + 1]), s[r + 1] = o; } return this; }, setColors(t) { const e = this.points.length; if (e < 1) return this; let i; const n = this.colors; void 0 === t ? t = [16777215] : Array.isArray(t) || (t = [t]); let s = 0; if (t.length === e) for (i = 0; i < e; i++)n[s = 2 * i] = t[i], n[s + 1] = t[i]; else { let r = t[0]; for (i = 0; i < e; i++)s = 2 * i, t.length > s && (r = t[s]), n[s] = r, t.length > s + 1 && (r = t[s + 1]), n[s + 1] = r; } return this; }, setPoints(t, e, i) { if (void 0 === t && (t = 2), typeof t === 'number') { let n; let s; let r; let o = t; if (o < 2 && (o = 2), t = [], this.horizontal) for (r = -this.frame.halfWidth, s = this.frame.width / (o - 1), n = 0; n < o; n++)t.push({ x: r + n * s, y: 0 }); else for (r = -this.frame.halfHeight, s = this.frame.height / (o - 1), n = 0; n < o; n++)t.push({ x: 0, y: r + n * s }); } let a = t.length; const h = this.points.length; return a < 1 ? (console.warn('Rope: Not enough points given'), this) : (a === 1 && (t.unshift({ x: 0, y: 0 }), a++), h !== a && this.resizeArrays(a), this.points = t, this.updateUVs(), e != null && this.setColors(e), i != null && this.setAlphas(i), this); }, updateUVs() { for (let t = this.uv, e = this.points.length, i = this.frame.u0, n = this.frame.v0, s = this.frame.u1, r = this.frame.v1, o = (s - i) / (e - 1), a = (r - n) / (e - 1), h = 0; h < e; h++) { var l; var u; var c; var d; const f = 4 * h; this.horizontal ? (this._flipX ? (l = s - h * o, c = s - h * o) : (l = i + h * o, c = i + h * o), this._flipY ? (u = r, d = n) : (u = n, d = r)) : (this._flipX ? (l = i, c = s) : (l = s, c = i), this._flipY ? (u = r - h * a, d = r - h * a) : (u = n + h * a, d = n + h * a)), t[f + 0] = l, t[f + 1] = u, t[f + 2] = c, t[f + 3] = d; } return this; }, resizeArrays(t) { let e = this.colors; let i = this.alphas; this.vertices = new Float32Array(4 * t), this.uv = new Float32Array(4 * t), e = new Uint32Array(2 * t), i = new Float32Array(2 * t); for (let n = 0; n < 2 * t; n++)e[n] = 16777215, i[n] = 1; return this.colors = e, this.alphas = i, this.dirty = !0, this; }, updateVertices() { const t = this._perp; const e = this.points; const i = this.vertices; const n = e.length; if (this.dirty = !1, !(n < 1)) { for (var s, r = e[0], o = this.horizontal ? this.frame.halfHeight : this.frame.halfWidth, a = 0; a < n; a++) { const h = e[a]; const l = 4 * a; s = a < n - 1 ? e[a + 1] : h, t.x = s.y - r.y, t.y = -(s.x - r.x); const u = t.length(); t.x /= u, t.y /= u, t.x *= o, t.y *= o, i[l] = h.x + t.x, i[l + 1] = h.y + t.y, i[l + 2] = h.x - t.x, i[l + 3] = h.y - t.y, r = h; } return this; } }, setDebug(t, e) { return this.debugGraphic = t, this.debugCallback = t || e ? e || this.renderDebugVerts : null, this; }, renderDebugVerts(t, e, i) { const n = t.debugGraphic; let s = i[0]; let r = i[1]; let o = i[2]; let a = i[3]; n.lineBetween(s, r, o, a); for (let h = 4; h < e; h += 4) { const l = i[h + 0]; const u = i[h + 1]; const c = i[h + 2]; const d = i[h + 3]; n.lineBetween(s, r, l, u), n.lineBetween(o, a, c, d), n.lineBetween(o, a, l, u), n.lineBetween(l, u, c, d), s = l, r = u, o = c, a = d; } }, preDestroy() { this.anims.destroy(), this.anims = void 0, this.points = null, this.vertices = null, this.uv = null, this.colors = null, this.alphas = null, this.debugCallback = null, this.debugGraphic = null; }, flipX: { get() { return this._flipX; }, set(t) { return this._flipX = t, this.updateUVs(); } }, flipY: { get() { return this._flipY; }, set(t) { return this._flipY = t, this.updateUVs(); } },
  }); t.exports = h;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(134); const s = i(30); const r = i(0); const o = i(13); const a = i(22); const h = i(14); const l = i(1018); const u = i(6); const c = i(195); const d = i(1019); const f = i(1022); const p = new r({
    Extends: h,
    Mixins: [o.Alpha, o.BlendMode, o.ComputedSize, o.Crop, o.Depth, o.Flip, o.GetBounds, o.Mask, o.Origin, o.Pipeline, o.ScrollFactor, o.Tint, o.Transform, o.Visible, d],
    initialize(t, e, i, n, r) {
      void 0 === e && (e = 0), void 0 === i && (i = 0), h.call(this, t, 'Text'), this.renderer = t.sys.game.renderer, this.setPosition(e, i), this.setOrigin(0, 0), this.initPipeline(), this.canvas = s.create(this), this.context = this.canvas.getContext('2d'), this.style = new f(this, r), this.autoRound = !0, this.splitRegExp = /(?:\r\n|\r|\n)/, this._text = void 0, this.padding = {
        left: 0, right: 0, top: 0, bottom: 0,
      }, this.width = 1, this.height = 1, this.lineSpacing = 0, this.dirty = !1, this.style.resolution === 0 && (this.style.resolution = t.sys.game.config.resolution), this._crop = this.resetCropObject(), this.texture = t.sys.textures.addCanvas(null, this.canvas, !0), this.frame = this.texture.get(), this.frame.source.resolution = this.style.resolution, this.renderer && this.renderer.gl && (this.renderer.deleteTexture(this.frame.source.glTexture), this.frame.source.glTexture = null), this.initRTL(), this.setText(n), r && r.padding && this.setPadding(r.padding), r && r.lineSpacing && this.setLineSpacing(r.lineSpacing), t.sys.game.events.on(a.CONTEXT_RESTORED, (function () { this.dirty = !0; }), this);
    },
    initRTL() { this.style.rtl && (this.canvas.dir = 'rtl', this.context.direction = 'rtl', this.canvas.style.display = 'none', n(this.canvas, this.scene.sys.canvas), this.originX = 1); },
    runWordWrap(t) { const e = this.style; if (e.wordWrapCallback) { let i = e.wordWrapCallback.call(e.wordWrapCallbackScope, t, this); return Array.isArray(i) && (i = i.join('\n')), i; } return e.wordWrapWidth ? e.wordWrapUseAdvanced ? this.advancedWordWrap(t, this.context, this.style.wordWrapWidth) : this.basicWordWrap(t, this.context, this.style.wordWrapWidth) : t; },
    advancedWordWrap(t, e, i) { for (var n = '', s = t.replace(/ +/gi, ' ').split(this.splitRegExp), r = s.length, o = 0; o < r; o++) { let a = s[o]; let h = ''; if (a = a.replace(/^ *|\s*$/gi, ''), e.measureText(a).width < i)n += `${a}\n`; else { for (let l = i, u = a.split(' '), c = 0; c < u.length; c++) { const d = u[c]; const f = `${d} `; let p = e.measureText(f).width; if (p > l) { if (c === 0) { for (var g = f; g.length && (g = g.slice(0, -1), !((p = e.measureText(g).width) <= l)););if (!g.length) throw new Error("This text's wordWrapWidth setting is less than a single character!"); const v = d.substr(g.length); u[c] = v, h += g; } const m = u[c].length ? c : c + 1; const y = u.slice(m).join(' ').replace(/[ \n]*$/gi, ''); s[o + 1] = `${y} ${s[o + 1] || ''}`, r = s.length; break; }h += f, l -= p; }n += `${h.replace(/[ \n]*$/gi, '')}\n`; } } return n = n.replace(/[\s|\n]*$/gi, ''); },
    basicWordWrap(t, e, i) { for (var n = '', s = t.split(this.splitRegExp), r = s.length - 1, o = e.measureText(' ').width, a = 0; a <= r; a++) { for (let h = i, l = s[a].split(' '), u = l.length - 1, c = 0; c <= u; c++) { const d = l[c]; const f = e.measureText(d).width; const p = f + o; p > h && c > 0 && (n += '\n', h = i), n += d, c < u ? (n += ' ', h -= p) : h -= f; }a < r && (n += '\n'); } return n; },
    getWrappedText(t) { return void 0 === t && (t = this._text), this.style.syncFont(this.canvas, this.context), this.runWordWrap(t).split(this.splitRegExp); },
    setText(t) { return t || t === 0 || (t = ''), Array.isArray(t) && (t = t.join('\n')), t !== this._text && (this._text = t.toString(), this.updateText()), this; },
    setStyle(t) { return this.style.setStyle(t); },
    setFont(t) { return this.style.setFont(t); },
    setFontFamily(t) { return this.style.setFontFamily(t); },
    setFontSize(t) { return this.style.setFontSize(t); },
    setFontStyle(t) { return this.style.setFontStyle(t); },
    setFixedSize(t, e) { return this.style.setFixedSize(t, e); },
    setBackgroundColor(t) { return this.style.setBackgroundColor(t); },
    setFill(t) { return this.style.setFill(t); },
    setColor(t) { return this.style.setColor(t); },
    setStroke(t, e) { return this.style.setStroke(t, e); },
    setShadow(t, e, i, n, s, r) { return this.style.setShadow(t, e, i, n, s, r); },
    setShadowOffset(t, e) { return this.style.setShadowOffset(t, e); },
    setShadowColor(t) { return this.style.setShadowColor(t); },
    setShadowBlur(t) { return this.style.setShadowBlur(t); },
    setShadowStroke(t) { return this.style.setShadowStroke(t); },
    setShadowFill(t) { return this.style.setShadowFill(t); },
    setWordWrapWidth(t, e) { return this.style.setWordWrapWidth(t, e); },
    setWordWrapCallback(t, e) { return this.style.setWordWrapCallback(t, e); },
    setAlign(t) { return this.style.setAlign(t); },
    setResolution(t) { return this.style.setResolution(t); },
    setLineSpacing(t) { return this.lineSpacing = t, this.updateText(); },
    setPadding(t, e, i, n) { if (typeof t === 'object') { const s = t; const r = u(s, 'x', null); r !== null ? (t = r, i = r) : (t = u(s, 'left', 0), i = u(s, 'right', t)); const o = u(s, 'y', null); o !== null ? (e = o, n = o) : (e = u(s, 'top', 0), n = u(s, 'bottom', e)); } else void 0 === t && (t = 0), void 0 === e && (e = t), void 0 === i && (i = t), void 0 === n && (n = e); return this.padding.left = t, this.padding.top = e, this.padding.right = i, this.padding.bottom = n, this.updateText(); },
    setMaxLines(t) { return this.style.setMaxLines(t); },
    updateText() { const t = this.canvas; const e = this.context; const i = this.style; const n = i.resolution; const s = i.metrics; i.syncFont(t, e); let r = this._text; (i.wordWrapWidth || i.wordWrapCallback) && (r = this.runWordWrap(this._text)); let o; const a = r.split(this.splitRegExp); const h = l(this, s, a); const u = this.padding; i.fixedWidth === 0 ? (this.width = h.width + u.left + u.right, o = h.width) : (this.width = i.fixedWidth, (o = this.width - u.left - u.right) < h.width && (o = h.width)), i.fixedHeight === 0 ? this.height = h.height + u.top + u.bottom : this.height = i.fixedHeight; let c; let d; let f = this.width; let p = this.height; this.updateDisplayOrigin(), f *= n, p *= n, f = Math.max(f, 1), p = Math.max(p, 1), t.width !== f || t.height !== p ? (t.width = f, t.height = p, this.frame.setSize(f, p), i.syncFont(t, e)) : e.clearRect(0, 0, f, p), e.save(), e.scale(n, n), i.backgroundColor && (e.fillStyle = i.backgroundColor, e.fillRect(0, 0, f, p)), i.syncStyle(t, e), e.textBaseline = 'alphabetic', e.translate(u.left, u.top); for (let g = 0; g < h.lines; g++) { if (c = i.strokeThickness / 2, d = i.strokeThickness / 2 + g * h.lineHeight + s.ascent, g > 0 && (d += h.lineSpacing * g), i.rtl)c = f - c; else if (i.align === 'right')c += o - h.lineWidths[g]; else if (i.align === 'center')c += (o - h.lineWidths[g]) / 2; else if (i.align === 'justify') { if (h.lineWidths[g] / h.width >= 0.85) { let v = h.width - h.lineWidths[g]; const m = e.measureText(' ').width; const y = a[g].trim(); const x = y.split(' '); v += (a[g].length - y.length) * m; for (let T = Math.floor(v / m), w = 0; T > 0;)x[w] += ' ', w = (w + 1) % (x.length - 1 || 1), --T; a[g] = x.join(' '); } } this.autoRound && (c = Math.round(c), d = Math.round(d)), i.strokeThickness && (this.style.syncShadow(e, i.shadowStroke), e.strokeText(a[g], c, d)), i.color && (this.style.syncShadow(e, i.shadowFill), e.fillText(a[g], c, d)); }e.restore(), this.renderer && this.renderer.gl && (this.frame.source.glTexture = this.renderer.canvasToTexture(t, this.frame.source.glTexture, !0), this.frame.glTexture = this.frame.source.glTexture), this.dirty = !0; const b = this.input; return b && !b.customHitArea && (b.hitArea.width = this.width, b.hitArea.height = this.height), this; },
    getTextMetrics() { return this.style.getTextMetrics(); },
    text: { get() { return this._text; }, set(t) { this.setText(t); } },
    toJSON() {
      const t = o.ToJSON(this); const e = {
        autoRound: this.autoRound,
        text: this._text,
        style: this.style.toJSON(),
        padding: {
          left: this.padding.left, right: this.padding.right, top: this.padding.top, bottom: this.padding.bottom,
        },
      }; return t.data = e, t;
    },
    preDestroy() { this.style.rtl && c(this.canvas), s.remove(this.canvas), this.texture.destroy(); },
  }); t.exports = p;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(30); const s = i(0); const r = i(13); const o = i(22); const a = i(14); const h = i(352); const l = i(182); const u = i(1024); const c = i(3); const d = new s({
    Extends: a, Mixins: [r.Alpha, r.BlendMode, r.ComputedSize, r.Crop, r.Depth, r.Flip, r.GetBounds, r.Mask, r.Origin, r.Pipeline, r.ScrollFactor, r.Tint, r.Transform, r.Visible, u], initialize(t, e, i, s, r, l, u) { const d = t.sys.game.renderer; a.call(this, t, 'TileSprite'); const f = t.sys.textures.get(l); const p = f.get(u); s && r ? (s = Math.floor(s), r = Math.floor(r)) : (s = p.width, r = p.height), this._tilePosition = new c(), this._tileScale = new c(1, 1), this.dirty = !1, this.renderer = d, this.canvas = n.create(this, s, r), this.context = this.canvas.getContext('2d'), this.displayTexture = f, this.displayFrame = p, this._crop = this.resetCropObject(), this.texture = t.sys.textures.addCanvas(null, this.canvas, !0), this.frame = this.texture.get(), this.potWidth = h(p.width), this.potHeight = h(p.height), this.fillCanvas = n.create2D(this, this.potWidth, this.potHeight), this.fillContext = this.fillCanvas.getContext('2d'), this.fillPattern = null, this.setPosition(e, i), this.setSize(s, r), this.setFrame(u), this.setOriginFromFrame(), this.initPipeline(), t.sys.game.events.on(o.CONTEXT_RESTORED, (function (t) { const e = t.gl; this.dirty = !0, this.fillPattern = null, this.fillPattern = t.createTexture2D(0, e.LINEAR, e.LINEAR, e.REPEAT, e.REPEAT, e.RGBA, this.fillCanvas, this.potWidth, this.potHeight); }), this); }, setTexture(t, e) { return this.displayTexture = this.scene.sys.textures.get(t), this.setFrame(e); }, setFrame(t) { const e = this.displayTexture.get(t); return this.potWidth = h(e.width), this.potHeight = h(e.height), this.canvas.width = 0, e.cutWidth && e.cutHeight ? this.renderFlags |= 8 : this.renderFlags &= -9, this.displayFrame = e, this.dirty = !0, this.updateTileTexture(), this; }, setTilePosition(t, e) { return void 0 !== t && (this.tilePositionX = t), void 0 !== e && (this.tilePositionY = e), this; }, setTileScale(t, e) { return void 0 === t && (t = this.tileScaleX), void 0 === e && (e = t), this.tileScaleX = t, this.tileScaleY = e, this; }, updateTileTexture() { if (this.dirty && this.renderer) { const t = this.displayFrame; if (t.source.isRenderTexture || t.source.isGLTexture) return console.warn('TileSprites can only use Image or Canvas based textures'), void (this.dirty = !1); const e = this.fillContext; const i = this.fillCanvas; let n = this.potWidth; let s = this.potHeight; this.renderer.gl || (n = t.cutWidth, s = t.cutHeight), e.clearRect(0, 0, n, s), i.width = n, i.height = s, e.drawImage(t.source.image, t.cutX, t.cutY, t.cutWidth, t.cutHeight, 0, 0, n, s), this.renderer.gl ? this.fillPattern = this.renderer.canvasToTexture(i, this.fillPattern) : this.fillPattern = e.createPattern(i, 'repeat'), this.updateCanvas(), this.dirty = !1; } }, updateCanvas() { const t = this.canvas; if (t.width === this.width && t.height === this.height || (t.width = this.width, t.height = this.height, this.frame.setSize(this.width, this.height), this.updateDisplayOrigin(), this.dirty = !0), !this.dirty || this.renderer && this.renderer.gl) this.dirty = !1; else { const e = this.context; this.scene.sys.game.config.antialias || l.disable(e); const i = this._tileScale.x; const n = this._tileScale.y; const s = this._tilePosition.x; const r = this._tilePosition.y; e.clearRect(0, 0, this.width, this.height), e.save(), e.scale(i, n), e.translate(-s, -r), e.fillStyle = this.fillPattern, e.fillRect(s, r, this.width / i, this.height / n), e.restore(), this.dirty = !1; } }, preDestroy() { this.renderer && this.renderer.gl && this.renderer.deleteTexture(this.fillPattern), n.remove(this.canvas), n.remove(this.fillCanvas), this.fillPattern = null, this.fillContext = null, this.fillCanvas = null, this.displayTexture = null, this.displayFrame = null, this.texture.destroy(), this.renderer = null; }, tilePositionX: { get() { return this._tilePosition.x; }, set(t) { this._tilePosition.x = t, this.dirty = !0; } }, tilePositionY: { get() { return this._tilePosition.y; }, set(t) { this._tilePosition.y = t, this.dirty = !0; } }, tileScaleX: { get() { return this._tileScale.x; }, set(t) { this._tileScale.x = t, this.dirty = !0; } }, tileScaleY: { get() { return this._tileScale.y; }, set(t) { this._tileScale.y = t, this.dirty = !0; } },
  }); t.exports = d;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(20); const r = i(13); const o = i(102); const a = i(22); const h = i(14); const l = i(65); const u = i(214); const c = i(1027); const d = i(16); const f = new n({
    Extends: h,
    Mixins: [r.Alpha, r.BlendMode, r.Depth, r.Flip, r.GetBounds, r.Mask, r.Origin, r.Pipeline, r.ScrollFactor, r.Size, r.TextureCrop, r.Tint, r.Transform, r.Visible, c],
    initialize(t, e, i, n) {
      h.call(this, t, 'Video'), this.video = null, this.videoTexture = null, this.videoTextureSource = null, this.snapshotTexture = null, this.flipY = !1, this._key = u(), this.touchLocked = !0, this.playWhenUnlocked = !1, this.retryLimit = 20, this.retry = 0, this.retryInterval = 500, this._retryID = null, this._systemMuted = !1, this._codeMuted = !1, this._systemPaused = !1, this._codePaused = !1, this._callbacks = {
        play: this.playHandler.bind(this), error: this.loadErrorHandler.bind(this), end: this.completeHandler.bind(this), time: this.timeUpdateHandler.bind(this), seeking: this.seekingHandler.bind(this), seeked: this.seekedHandler.bind(this),
      }, this._crop = this.resetCropObject(), this.markers = {}, this._markerIn = -1, this._markerOut = d.MAX_SAFE_INTEGER, this._lastUpdate = 0, this._cacheKey = '', this._isSeeking = !1, this.removeVideoElementOnDestroy = !1, this.setPosition(e, i), this.initPipeline(), n && this.changeSource(n, !1); const s = t.sys.game.events; s.on(a.PAUSE, this.globalPause, this), s.on(a.RESUME, this.globalResume, this); const r = t.sys.sound; r && r.on(l.GLOBAL_MUTE, this.globalMute, this);
    },
    play(t, e, i) { if (this.touchLocked && this.playWhenUnlocked || this.isPlaying()) return this; const n = this.video; if (!n) return console.warn('Video not loaded'), this; void 0 === t && (t = n.loop); const s = this.scene.sys.sound; s && s.mute && this.setMute(!0), isNaN(e) || (this._markerIn = e), !isNaN(i) && i > e && (this._markerOut = i), n.loop = t; const r = this._callbacks; const o = n.play(); return void 0 !== o ? o.then(this.playPromiseSuccessHandler.bind(this)).catch(this.playPromiseErrorHandler.bind(this)) : (n.addEventListener('playing', r.play, !0), n.readyState < 2 && (this.retry = this.retryLimit, this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval))), n.addEventListener('ended', r.end, !0), n.addEventListener('timeupdate', r.time, !0), n.addEventListener('seeking', r.seeking, !0), n.addEventListener('seeked', r.seeked, !0), this; },
    changeSource(t, e, i, n, s) { void 0 === e && (e = !0), this.video && this.stop(); const r = this.scene.sys.cache.video.get(t); return r ? (this.video = r, this._cacheKey = t, this._codePaused = r.paused, this._codeMuted = r.muted, this.videoTexture ? (this.scene.sys.textures.remove(this._key), this.videoTexture = this.scene.sys.textures.create(this._key, r, r.videoWidth, r.videoHeight), this.videoTextureSource = this.videoTexture.source[0], this.videoTexture.add('__BASE', 0, 0, 0, r.videoWidth, r.videoHeight), this.setTexture(this.videoTexture), this.setSizeToFrame(), this.updateDisplayOrigin(), this.emit(o.VIDEO_CREATED, this, r.videoWidth, r.videoHeight)) : this.updateTexture(), r.currentTime = 0, this._lastUpdate = 0, e && this.play(i, n, s)) : this.video = null, this; },
    addMarker(t, e, i) { return !isNaN(e) && e >= 0 && !isNaN(i) && (this.markers[t] = [e, i]), this; },
    playMarker(t, e) { const i = this.markers[t]; return i && this.play(e, i[0], i[1]), this; },
    removeMarker(t) { return delete this.markers[t], this; },
    snapshot(t, e) { return void 0 === t && (t = this.width), void 0 === e && (e = this.height), this.snapshotArea(0, 0, this.width, this.height, t, e); },
    snapshotArea(t, e, i, n, s, r) { void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = this.width), void 0 === n && (n = this.height), void 0 === s && (s = i), void 0 === r && (r = n); const o = this.video; let a = this.snapshotTexture; return a ? (a.setSize(s, r), o && a.context.drawImage(o, t, e, i, n, 0, 0, s, r)) : (a = this.scene.sys.textures.createCanvas(u(), s, r), this.snapshotTexture = a, o && a.context.drawImage(o, t, e, i, n, 0, 0, s, r)), a.update(); },
    saveSnapshotTexture(t) { return this.snapshotTexture ? this.scene.sys.textures.renameTexture(this.snapshotTexture.key, t) : this.snapshotTexture = this.scene.sys.textures.createCanvas(t, this.width, this.height), this.snapshotTexture; },
    loadURL(t, e, i) { void 0 === e && (e = 'loadeddata'), void 0 === i && (i = !1), this.video && this.stop(), this.videoTexture && this.scene.sys.textures.remove(this._key); const n = document.createElement('video'); return n.controls = !1, i && (n.muted = !0, n.defaultMuted = !0, n.setAttribute('autoplay', 'autoplay')), n.setAttribute('playsinline', 'playsinline'), n.setAttribute('preload', 'auto'), n.addEventListener('error', this._callbacks.error, !0), n.src = t, n.load(), this.video = n, this; },
    playPromiseSuccessHandler() { this.touchLocked = !1, this.emit(o.VIDEO_PLAY, this), this._markerIn > -1 && (this.video.currentTime = this._markerIn); },
    playPromiseErrorHandler(t) { this.scene.sys.input.once('pointerdown', this.unlockHandler, this), this.touchLocked = !0, this.playWhenUnlocked = !0, this.emit(o.VIDEO_ERROR, this, t); },
    playHandler() { this.touchLocked = !1, this.emit(o.VIDEO_PLAY, this), this.video.removeEventListener('playing', this._callbacks.play, !0); },
    loadErrorHandler(t) { this.stop(), this.emit(o.VIDEO_ERROR, this, t); },
    unlockHandler() { this.touchLocked = !1, this.playWhenUnlocked = !1, this.emit(o.VIDEO_UNLOCKED, this), this._markerIn > -1 && (this.video.currentTime = this._markerIn), this.video.play(), this.emit(o.VIDEO_PLAY, this); },
    completeHandler() { this.emit(o.VIDEO_COMPLETE, this); },
    timeUpdateHandler() { this.video && this.video.currentTime < this._lastUpdate && (this.emit(o.VIDEO_LOOP, this), this._lastUpdate = 0); },
    preUpdate() { const t = this.video; if (t) { const e = t.currentTime; e !== this._lastUpdate && (this._lastUpdate = e, this.updateTexture(), e >= this._markerOut && (t.loop ? (t.currentTime = this._markerIn, this.updateTexture(), this._lastUpdate = e, this.emit(o.VIDEO_LOOP, this)) : (this.emit(o.VIDEO_COMPLETE, this), this.stop()))); } },
    checkVideoProgress() { this.video.readyState >= 2 ? this.updateTexture() : (this.retry--, this.retry > 0 ? this._retryID = window.setTimeout(this.checkVideoProgress.bind(this), this.retryInterval) : this.emit(o.VIDEO_TIMEOUT, this)); },
    updateTexture() { const t = this.video; const e = t.videoWidth; const i = t.videoHeight; if (this.videoTexture) { const n = this.videoTextureSource; n.source !== t && (n.source = t, n.width = e, n.height = i), n.update(); } else this.videoTexture = this.scene.sys.textures.create(this._key, t, e, i), this.videoTextureSource = this.videoTexture.source[0], this.videoTexture.add('__BASE', 0, 0, 0, e, i), this.setTexture(this.videoTexture), this.setSizeToFrame(), this.updateDisplayOrigin(), this.emit(o.VIDEO_CREATED, this, e, i); },
    getVideoKey() { return this._cacheKey; },
    seekTo(t) { const e = this.video; if (e) { const i = e.duration; if (i !== 1 / 0 && !isNaN(i)) { const n = i * t; this.setCurrentTime(n); } } return this; },
    getCurrentTime() { return this.video ? this.video.currentTime : 0; },
    setCurrentTime(t) { const e = this.video; if (e) { if (typeof t === 'string') { const i = t[0]; const n = parseFloat(t.substr(1)); i === '+' ? t = e.currentTime + n : i === '-' && (t = e.currentTime - n); }e.currentTime = t, this._lastUpdate = t; } return this; },
    isSeeking() { return this._isSeeking; },
    seekingHandler() { this._isSeeking = !0, this.emit(o.VIDEO_SEEKING, this); },
    seekedHandler() { this._isSeeking = !1, this.emit(o.VIDEO_SEEKED, this), this.video && this.updateTexture(); },
    getProgress() { const t = this.video; if (t) { const e = t.currentTime; const i = t.duration; if (i !== 1 / 0 && !isNaN(i)) return e / i; } return 0; },
    getDuration() { return this.video ? this.video.duration : 0; },
    setMute(t) { void 0 === t && (t = !0), this._codeMuted = t; const e = this.video; return e && (e.muted = !!this._systemMuted || t), this; },
    isMuted() { return this._codeMuted; },
    globalMute(t, e) { this._systemMuted = e; const i = this.video; i && (i.muted = !!this._codeMuted || e); },
    globalPause() { this._systemPaused = !0, this.video && this.video.pause(); },
    globalResume() { this._systemPaused = !1, this.video && !this._codePaused && this.video.play(); },
    setPaused(t) { void 0 === t && (t = !0); const e = this.video; return this._codePaused = t, e && (t ? e.paused || e.pause() : t || e.paused && !this._systemPaused && e.play()), this; },
    getVolume() { return this.video ? this.video.volume : 1; },
    setVolume(t) { return void 0 === t && (t = 1), this.video && (this.video.volume = s(t, 0, 1)), this; },
    getPlaybackRate() { return this.video ? this.video.playbackRate : 1; },
    setPlaybackRate(t) { return this.video && (this.video.playbackRate = t), this; },
    getLoop() { return !!this.video && this.video.loop; },
    setLoop(t) { return void 0 === t && (t = !0), this.video && (this.video.loop = t), this; },
    isPlaying() { return !!this.video && !(this.video.paused || this.video.ended); },
    isPaused() { return this.video && this.video.paused || this._codePaused || this._systemPaused; },
    saveTexture(t, e) { return void 0 === e && (e = !1), this.videoTexture && this.scene.sys.textures.renameTexture(this._key, t), this._key = t, this.flipY = e, this.videoTextureSource && this.videoTextureSource.setFlipY(e), this.videoTexture; },
    stop() { const t = this.video; if (t) { const e = this._callbacks; for (const i in e)t.removeEventListener(i, e[i], !0); t.pause(); } return this._retryID && window.clearTimeout(this._retryID), this.emit(o.VIDEO_STOP, this), this; },
    removeVideoElement() { const t = this.video; if (t) { for (t.parentNode && t.parentNode.removeChild(t); t.hasChildNodes();)t.removeChild(t.firstChild); t.removeAttribute('autoplay'), t.removeAttribute('src'), this.video = null; } },
    preDestroy() { this.stop(), this.removeVideoElementOnDestroy && this.removeVideoElement(); const t = this.scene.sys.game.events; t.off(a.PAUSE, this.globalPause, this), t.off(a.RESUME, this.globalResume, this); const e = this.scene.sys.sound; e && e.off(l.GLOBAL_MUTE, this.globalMute, this), this._retryID && window.clearTimeout(this._retryID); },
  }); t.exports = f;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(220); const r = i(451); const o = i(54); const a = new n({
    initialize(t) { this.type = o.POLYGON, this.area = 0, this.points = [], t && this.setTo(t); }, contains(t, e) { return s(this, t, e); }, setTo(t) { if (this.area = 0, this.points = [], typeof t === 'string' && (t = t.split(' ')), !Array.isArray(t)) return this; for (var e, i = Number.MAX_VALUE, n = 0; n < t.length; n++)e = { x: 0, y: 0 }, typeof t[n] === 'number' || typeof t[n] === 'string' ? (e.x = parseFloat(t[n]), e.y = parseFloat(t[n + 1]), n++) : Array.isArray(t[n]) ? (e.x = t[n][0], e.y = t[n][1]) : (e.x = t[n].x, e.y = t[n].y), this.points.push(e), e.y < i && (i = e.y); return this.calculateArea(i), this; }, calculateArea() { if (this.points.length < 3) return this.area = 0, this.area; for (var t, e, i = 0, n = 0; n < this.points.length - 1; n++)t = this.points[n], i += ((e = this.points[n + 1]).x - t.x) * (t.y + e.y); return t = this.points[0], e = this.points[this.points.length - 1], i += (t.x - e.x) * (e.y + t.y), this.area = 0.5 * -i, this.area; }, getPoints(t, e, i) { return r(this, t, e, i); },
  }); t.exports = a;
}, function (t, e) { t.exports = function (t, e, i) { for (var n = !1, s = -1, r = t.points.length - 1; ++s < t.points.length; r = s) { const o = t.points[s].x; const a = t.points[s].y; const h = t.points[r].x; const l = t.points[r].y; (a <= i && i < l || l <= i && i < a) && e < (h - o) * (i - a) / (l - a) + o && (n = !n); } return n; }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(144); const r = new n({
    Extends: s, initialize(t, e, i, n, r) { s.call(this, t, e, i, [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0], [16777215, 16777215, 16777215, 16777215, 16777215, 16777215], [1, 1, 1, 1, 1, 1], n, r), this.resetPosition(); }, setFrame(t) { return this.frame = this.texture.get(t), this.frame.cutWidth && this.frame.cutHeight ? this.renderFlags |= 8 : this.renderFlags &= -9, t = this.frame, this.uv[0] = t.u0, this.uv[1] = t.v0, this.uv[2] = t.u0, this.uv[3] = t.v1, this.uv[4] = t.u1, this.uv[5] = t.v1, this.uv[6] = t.u0, this.uv[7] = t.v0, this.uv[8] = t.u1, this.uv[9] = t.v1, this.uv[10] = t.u1, this.uv[11] = t.v0, this; }, topLeftX: { get() { return this.x + this.vertices[0]; }, set(t) { this.vertices[0] = t - this.x, this.vertices[6] = t - this.x; } }, topLeftY: { get() { return this.y + this.vertices[1]; }, set(t) { this.vertices[1] = t - this.y, this.vertices[7] = t - this.y; } }, topRightX: { get() { return this.x + this.vertices[10]; }, set(t) { this.vertices[10] = t - this.x; } }, topRightY: { get() { return this.y + this.vertices[11]; }, set(t) { this.vertices[11] = t - this.y; } }, bottomLeftX: { get() { return this.x + this.vertices[2]; }, set(t) { this.vertices[2] = t - this.x; } }, bottomLeftY: { get() { return this.y + this.vertices[3]; }, set(t) { this.vertices[3] = t - this.y; } }, bottomRightX: { get() { return this.x + this.vertices[4]; }, set(t) { this.vertices[4] = t - this.x, this.vertices[8] = t - this.x; } }, bottomRightY: { get() { return this.y + this.vertices[5]; }, set(t) { this.vertices[5] = t - this.y, this.vertices[9] = t - this.y; } }, topLeftAlpha: { get() { return this.alphas[0]; }, set(t) { this.alphas[0] = t, this.alphas[3] = t; } }, topRightAlpha: { get() { return this.alphas[5]; }, set(t) { this.alphas[5] = t; } }, bottomLeftAlpha: { get() { return this.alphas[1]; }, set(t) { this.alphas[1] = t; } }, bottomRightAlpha: { get() { return this.alphas[2]; }, set(t) { this.alphas[2] = t, this.alphas[4] = t; } }, topLeftColor: { get() { return this.colors[0]; }, set(t) { this.colors[0] = t, this.colors[3] = t; } }, topRightColor: { get() { return this.colors[5]; }, set(t) { this.colors[5] = t; } }, bottomLeftColor: { get() { return this.colors[1]; }, set(t) { this.colors[1] = t; } }, bottomRightColor: { get() { return this.colors[2]; }, set(t) { this.colors[2] = t, this.colors[4] = t; } }, setTopLeft(t, e) { return this.topLeftX = t, this.topLeftY = e, this; }, setTopRight(t, e) { return this.topRightX = t, this.topRightY = e, this; }, setBottomLeft(t, e) { return this.bottomLeftX = t, this.bottomLeftY = e, this; }, setBottomRight(t, e) { return this.bottomRightX = t, this.bottomRightY = e, this; }, resetPosition() { const t = this.x; const e = this.y; const i = Math.floor(this.width / 2); const n = Math.floor(this.height / 2); return this.setTopLeft(t - i, e - n), this.setTopRight(t + i, e - n), this.setBottomLeft(t - i, e + n), this.setBottomRight(t + i, e + n), this; }, resetAlpha() { const t = this.alphas; return t[0] = 1, t[1] = 1, t[2] = 1, t[3] = 1, t[4] = 1, t[5] = 1, this; }, resetColors() { const t = this.colors; return t[0] = 16777215, t[1] = 16777215, t[2] = 16777215, t[3] = 16777215, t[4] = 16777215, t[5] = 16777215, this; }, reset() { return this.resetPosition(), this.resetAlpha(), this.resetColors(); },
  }); t.exports = r;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(13); const r = i(14); const o = i(2); const a = i(19); const h = i(459); const l = i(1110); const u = i(33); const c = new n({
    Extends: r,
    Mixins: [s.ComputedSize, s.Depth, s.GetBounds, s.Mask, s.Origin, s.ScrollFactor, s.Transform, s.Visible, l],
    initialize(t, e, i, n, s, o, a, h) { void 0 === i && (i = 0), void 0 === n && (n = 0), void 0 === s && (s = 128), void 0 === o && (o = 128), r.call(this, t, 'Shader'), this.blendMode = -1, this.shader; const l = t.sys.renderer; this.renderer = l, this.gl = l.gl, this.vertexData = new ArrayBuffer(2 * Float32Array.BYTES_PER_ELEMENT * 6), this.vertexBuffer = l.createVertexBuffer(this.vertexData.byteLength, this.gl.STREAM_DRAW), this.program = null, this.bytes = new Uint8Array(this.vertexData), this.vertexViewF32 = new Float32Array(this.vertexData), this._tempMatrix1 = new u(), this._tempMatrix2 = new u(), this._tempMatrix3 = new u(), this.viewMatrix = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]), this.projectionMatrix = new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]), this.uniforms = {}, this.pointer = null, this._rendererWidth = l.width, this._rendererHeight = l.height, this._textureCount = 0, this.framebuffer = null, this.glTexture = null, this.renderToTexture = !1, this.texture = null, this.setPosition(i, n), this.setSize(s, o), this.setOrigin(0.5, 0.5), this.setShader(e, a, h); },
    willRender(t) { return !!this.renderToTexture || !(r.RENDER_MASK !== this.renderFlags || this.cameraFilter !== 0 && this.cameraFilter & t.id); },
    setRenderToTexture(t, e) { if (void 0 === e && (e = !1), !this.renderToTexture) { const i = this.width; const n = this.height; var s = this.renderer; this.glTexture = s.createTextureFromSource(null, i, n, 0), this.glTexture.flipY = e, this.framebuffer = s.createFramebuffer(i, n, this.glTexture, !1), this._rendererWidth = i, this._rendererHeight = n, this.renderToTexture = !0, this.projOrtho(0, this.width, this.height, 0), t && (this.texture = this.scene.sys.textures.addGLTexture(t, this.glTexture, i, n)); } if (this.shader) { const r = s.currentPipeline; s.clearPipeline(), this.load(), this.flush(), s.rebindPipeline(r); } return this; },
    setShader(t, e, i) {
      if (void 0 === e && (e = []), typeof t === 'string') { const n = this.scene.sys.cache.shader; if (!n.has(t)) return console.warn(`Shader missing: ${t}`), this; this.shader = n.get(t); } else this.shader = t; const s = this.gl; const r = this.renderer; this.program && s.deleteProgram(this.program); const o = r.createProgram(this.shader.vertexSrc, this.shader.fragmentSrc); r.setMatrix4(o, 'uViewMatrix', !1, this.viewMatrix), r.setMatrix4(o, 'uProjectionMatrix', !1, this.projectionMatrix), r.setFloat2(o, 'uResolution', this.width, this.height), this.program = o; const h = new Date(); const
        l = {
          resolution: { type: '2f', value: { x: this.width, y: this.height } }, time: { type: '1f', value: 0 }, mouse: { type: '2f', value: { x: this.width / 2, y: this.height / 2 } }, date: { type: '4fv', value: [h.getFullYear(), h.getMonth(), h.getDate(), 60 * h.getHours() * 60 + 60 * h.getMinutes() + h.getSeconds()] }, sampleRate: { type: '1f', value: 44100 }, iChannel0: { type: 'sampler2D', value: null, textureData: { repeat: !0 } }, iChannel1: { type: 'sampler2D', value: null, textureData: { repeat: !0 } }, iChannel2: { type: 'sampler2D', value: null, textureData: { repeat: !0 } }, iChannel3: { type: 'sampler2D', value: null, textureData: { repeat: !0 } },
        }; this.shader.uniforms ? this.uniforms = a(!0, {}, this.shader.uniforms, l) : this.uniforms = l; for (let u = 0; u < 4; u++)e[u] && this.setSampler2D(`iChannel${u}`, e[u], u, i); return this.initUniforms(), this.projOrtho(0, this._rendererWidth, this._rendererHeight, 0), this;
    },
    setPointer(t) { return this.pointer = t, this; },
    projOrtho(t, e, i, n) { const s = 1 / (t - e); const r = 1 / (i - n); const o = this.projectionMatrix; o[0] = -2 * s, o[5] = -2 * r, o[10] = -0.001, o[12] = (t + e) * s, o[13] = (n + i) * r, o[14] = -0; const a = this.program; this.renderer.setMatrix4(a, 'uProjectionMatrix', !1, this.projectionMatrix), this._rendererWidth = e, this._rendererHeight = i; },
    initUniforms() { const t = this.gl; const e = this.renderer.glFuncMap; const i = this.program; for (const n in this._textureCount = 0, this.uniforms) { const s = this.uniforms[n]; const r = s.type; const o = e[r]; s.uniformLocation = t.getUniformLocation(i, n), r !== 'sampler2D' && (s.glMatrix = o.matrix, s.glValueLength = o.length, s.glFunc = o.func); } },
    setSampler2DBuffer(t, e, i, n, s, r) { void 0 === s && (s = 0), void 0 === r && (r = {}); const o = this.uniforms[t]; return o.value = e, r.width = i, r.height = n, o.textureData = r, this._textureCount = s, this.initSampler2D(o), this; },
    setSampler2D(t, e, i, n) { void 0 === i && (i = 0); const s = this.scene.sys.textures; if (s.exists(e)) { const r = s.getFrame(e); const o = this.uniforms[t]; const a = r.source; o.textureKey = e, o.source = a.image, o.value = r.glTexture, a.isGLTexture && (n || (n = {}), n.width = a.width, n.height = a.height), n && (o.textureData = n), this._textureCount = i, this.initSampler2D(o); } return this; },
    setUniform(t, e) { return h(this.uniforms, t, e), this; },
    getUniform(t) { return o(this.uniforms, t, null); },
    setChannel0(t, e) { return this.setSampler2D('iChannel0', t, 0, e); },
    setChannel1(t, e) { return this.setSampler2D('iChannel1', t, 1, e); },
    setChannel2(t, e) { return this.setSampler2D('iChannel2', t, 2, e); },
    setChannel3(t, e) { return this.setSampler2D('iChannel3', t, 3, e); },
    initSampler2D(t) { if (t.value) { const e = this.gl; e.activeTexture(e.TEXTURE0 + this._textureCount), e.bindTexture(e.TEXTURE_2D, t.value); const i = t.textureData; if (i) { const n = e[o(i, 'magFilter', 'linear').toUpperCase()]; const s = e[o(i, 'minFilter', 'linear').toUpperCase()]; let r = e[o(i, 'wrapS', 'repeat').toUpperCase()]; let a = e[o(i, 'wrapT', 'repeat').toUpperCase()]; const h = e[o(i, 'format', 'rgba').toUpperCase()]; if (i.repeat && (r = e.REPEAT, a = e.REPEAT), e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, !!i.flipY), i.width) { const l = o(i, 'width', 512); const u = o(i, 'height', 2); const c = o(i, 'border', 0); e.texImage2D(e.TEXTURE_2D, 0, h, l, u, c, h, e.UNSIGNED_BYTE, null); } else e.texImage2D(e.TEXTURE_2D, 0, h, e.RGBA, e.UNSIGNED_BYTE, t.source); e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MAG_FILTER, n), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_MIN_FILTER, s), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_S, r), e.texParameteri(e.TEXTURE_2D, e.TEXTURE_WRAP_T, a); } this.renderer.setProgram(this.program), e.uniform1i(t.uniformLocation, this._textureCount), this._textureCount++; } },
    syncUniforms() { let t; let e; let i; let n; let s; const r = this.gl; const o = this.uniforms; let a = 0; for (const h in o)i = (t = o[h]).glFunc, e = t.glValueLength, n = t.uniformLocation, (s = t.value) !== null && (e === 1 ? t.glMatrix ? i.call(r, n, t.transpose, s) : i.call(r, n, s) : e === 2 ? i.call(r, n, s.x, s.y) : e === 3 ? i.call(r, n, s.x, s.y, s.z) : e === 4 ? i.call(r, n, s.x, s.y, s.z, s.w) : t.type === 'sampler2D' && (r.activeTexture(r[`TEXTURE${a}`]), r.bindTexture(r.TEXTURE_2D, s), r.uniform1i(n, a), a++)); },
    load(t) { const e = this.gl; const i = this.width; const n = this.height; const s = this.renderer; const r = this.program; const o = this.viewMatrix; if (!this.renderToTexture) { const a = -this._displayOriginX; const h = -this._displayOriginY; o[0] = t[0], o[1] = t[1], o[4] = t[2], o[5] = t[3], o[8] = t[4], o[9] = t[5], o[12] = o[0] * a + o[4] * h, o[13] = o[1] * a + o[5] * h; }e.useProgram(r), e.uniformMatrix4fv(e.getUniformLocation(r, 'uViewMatrix'), !1, o), e.uniform2f(e.getUniformLocation(r, 'uResolution'), this.width, this.height); const l = this.uniforms; const u = l.resolution; u.value.x = i, u.value.y = n, l.time.value = s.game.loop.getDuration(); const c = this.pointer; if (c) { const d = l.mouse; const f = c.x / i; const p = 1 - c.y / n; d.value.x = f.toFixed(2), d.value.y = p.toFixed(2); } this.syncUniforms(); },
    flush() { const t = this.width; const e = this.height; const i = this.program; const n = this.gl; const s = this.vertexBuffer; const r = this.renderer; const o = 2 * Float32Array.BYTES_PER_ELEMENT; this.renderToTexture && (r.setFramebuffer(this.framebuffer), n.clearColor(0, 0, 0, 0), n.clear(n.COLOR_BUFFER_BIT)), n.bindBuffer(n.ARRAY_BUFFER, s); const a = n.getAttribLocation(i, 'inPosition'); a !== -1 && (n.enableVertexAttribArray(a), n.vertexAttribPointer(a, 2, n.FLOAT, !1, o, 0)); const h = this.vertexViewF32; h[3] = e, h[4] = t, h[5] = e, h[8] = t, h[9] = e, h[10] = t; n.bufferSubData(n.ARRAY_BUFFER, 0, this.bytes.subarray(0, 6 * o)), n.drawArrays(n.TRIANGLES, 0, 6), this.renderToTexture && r.setFramebuffer(null, !1); },
    setAlpha() {},
    setBlendMode() {},
    preDestroy() { const t = this.gl; t.deleteProgram(this.program), t.deleteBuffer(this.vertexBuffer), this.renderToTexture && (this.renderer.deleteFramebuffer(this.framebuffer), this.texture.destroy(), this.framebuffer = null, this.glTexture = null, this.texture = null); },
  }); t.exports = c;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(56); t.exports = function (t, e) { return n(t.x, t.y, e.x, e.y) <= t.radius + e.radius; };
}, function (t, e) { t.exports = function (t, e) { const i = e.width / 2; const n = e.height / 2; const s = Math.abs(t.x - e.x - i); const r = Math.abs(t.y - e.y - n); const o = i + t.radius; const a = n + t.radius; if (s > o || r > a) return !1; if (s <= i || r <= n) return !0; const h = s - i; const l = r - n; return h * h + l * l <= t.radius * t.radius; }; }, function (t, e, i) {
/**
 * @author       Florian Vazelle
 * @author       Geoffrey Glaive
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(4); const s = i(226); t.exports = function (t, e, i) { if (void 0 === i && (i = []), s(t, e)) { let r; let o; const a = t.x1; const h = t.y1; const l = t.x2; const u = t.y2; const c = e.x; const d = e.y; const f = e.radius; const p = l - a; const g = u - h; const v = a - c; const m = h - d; const y = p * p + g * g; const x = 2 * (p * v + g * m); const T = x * x - 4 * y * (v * v + m * m - f * f); if (T === 0) { const w = -x / (2 * y); r = a + w * p, o = h + w * g, w >= 0 && w <= 1 && i.push(new n(r, o)); } else if (T > 0) { const b = (-x - Math.sqrt(T)) / (2 * y); r = a + b * p, o = h + b * g, b >= 0 && b <= 1 && i.push(new n(r, o)); const E = (-x + Math.sqrt(T)) / (2 * y); r = a + E * p, o = h + E * g, E >= 0 && E <= 1 && i.push(new n(r, o)); } } return i; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(61); const s = new (i(4))(); t.exports = function (t, e, i) { if (void 0 === i && (i = s), n(e, t.x1, t.y1)) return i.x = t.x1, i.y = t.y1, !0; if (n(e, t.x2, t.y2)) return i.x = t.x2, i.y = t.y2, !0; const r = t.x2 - t.x1; const o = t.y2 - t.y1; const a = e.x - t.x1; const h = e.y - t.y1; const l = r * r + o * o; let u = r; let c = o; if (l > 0) { const d = (a * r + h * o) / l; u *= d, c *= d; } return i.x = t.x1 + u, i.y = t.y1 + c, u * u + c * c <= l && u * r + c * o >= 0 && n(e, i.x, i.y); };
}, function (t, e, i) {
/**
 * @author       Florian Vazelle
 * @author       Geoffrey Glaive
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(4); const s = i(92); const r = i(464); t.exports = function (t, e, i) { if (void 0 === i && (i = []), r(t, e)) for (let o = e.getLineA(), a = e.getLineB(), h = e.getLineC(), l = e.getLineD(), u = [new n(), new n(), new n(), new n()], c = [s(o, t, u[0]), s(a, t, u[1]), s(h, t, u[2]), s(l, t, u[3])], d = 0; d < 4; d++)c[d] && i.push(u[d]); return i; };
}, function (t, e) { t.exports = function (t, e, i, n) { void 0 === i && (i = !1), void 0 === n && (n = []); for (var s, r, o, a, h, l, u = t.x3 - t.x1, c = t.y3 - t.y1, d = t.x2 - t.x1, f = t.y2 - t.y1, p = u * u + c * c, g = u * d + c * f, v = d * d + f * f, m = p * v - g * g, y = m === 0 ? 0 : 1 / m, x = t.x1, T = t.y1, w = 0; w < e.length && (r = (p * (l = d * (o = e[w].x - x) + f * (a = e[w].y - T)) - g * (h = u * o + c * a)) * y, !((s = (v * h - g * l) * y) >= 0 && r >= 0 && s + r < 1 && (n.push({ x: e[w].x, y: e[w].y }), i))); w++);return n; }; }, function (t, e) { t.exports = function (t, e, i, n) { const s = Math.cos(n); const r = Math.sin(n); let o = t.x1 - e; let a = t.y1 - i; return t.x1 = o * s - a * r + e, t.y1 = o * r + a * s + i, o = t.x2 - e, a = t.y2 - i, t.x2 = o * s - a * r + e, t.y2 = o * r + a * s + i, t; }; }, function (t, e) { t.exports = function (t) { return t.height === 0 ? NaN : t.width / t.height; }; }, function (t, e) { t.exports = function (t, e, i, n) { const s = Math.cos(n); const r = Math.sin(n); let o = t.x1 - e; let a = t.y1 - i; return t.x1 = o * s - a * r + e, t.y1 = o * r + a * s + i, o = t.x2 - e, a = t.y2 - i, t.x2 = o * s - a * r + e, t.y2 = o * r + a * s + i, o = t.x3 - e, a = t.y3 - i, t.x3 = o * s - a * r + e, t.y3 = o * r + a * s + i, t; }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = {
    BUTTON_DOWN: i(1233), BUTTON_UP: i(1234), CONNECTED: i(1235), DISCONNECTED: i(1236), GAMEPAD_BUTTON_DOWN: i(1237), GAMEPAD_BUTTON_UP: i(1238),
  };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(19); const s = i(149); t.exports = function (t, e) { const i = void 0 === t ? s() : n({}, t); if (e) for (const r in e) void 0 !== e[r] && (i[r] = e[r]); return i; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(18); const r = i(25); const o = i(9); const a = i(2); const h = i(8); const l = i(396); const u = new n({
    Extends: r,
    initialize(t, e, i, n) {
      let s = 'xml'; if (h(e)) { const o = e; e = a(o, 'key'), i = a(o, 'url'), n = a(o, 'xhrSettings'), s = a(o, 'extension', s); } const l = {
        type: 'xml', cache: t.cacheManager.xml, extension: s, responseType: 'text', key: e, url: i, xhrSettings: n,
      }; r.call(this, t, l);
    },
    onProcess() { this.state = s.FILE_PROCESSING, this.data = l(this.xhrLoader.responseText), this.data ? this.onProcessComplete() : (console.warn(`Invalid XMLFile: ${this.key}`), this.onProcessError()); },
  }); o.register('xml', (function (t, e, i) { if (Array.isArray(t)) for (let n = 0; n < t.length; n++) this.addFile(new u(this, t[n])); else this.addFile(new u(this, t, e, i)); return this; })), t.exports = u;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = {
    Acceleration: i(1294), Angular: i(1295), Bounce: i(1296), Debug: i(1297), Drag: i(1298), Enable: i(1299), Friction: i(1300), Gravity: i(1301), Immovable: i(1302), Mass: i(1303), Size: i(1304), Velocity: i(1305),
  };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = {
    COLLIDE: i(1307), OVERLAP: i(1308), PAUSE: i(1309), RESUME: i(1310), TILE_COLLIDE: i(1311), TILE_OVERLAP: i(1312), WORLD_BOUNDS: i(1313), WORLD_STEP: i(1314),
  };
}, function (t, e, i) {
  const n = {}; t.exports = n; const s = i(69); const r = i(80); const o = i(21); const a = i(26); const h = i(44); n.stack = function (t, e, i, n, r, o, h) { for (var l, u = s.create({ label: 'Stack' }), c = t, d = e, f = 0, p = 0; p < n; p++) { for (var g = 0, v = 0; v < i; v++) { const m = h(c, d, v, p, l, f); if (m) { const y = m.bounds.max.y - m.bounds.min.y; const x = m.bounds.max.x - m.bounds.min.x; y > g && (g = y), a.translate(m, { x: 0.5 * x, y: 0.5 * y }), c = m.bounds.max.x + r, s.addBody(u, m), l = m, f += 1; } else c += r; }d += g + o, c = t; } return u; }, n.chain = function (t, e, i, n, a, h) {
    for (let l = t.bodies, u = 1; u < l.length; u++) {
      const c = l[u - 1]; const d = l[u]; const f = c.bounds.max.y - c.bounds.min.y; const p = c.bounds.max.x - c.bounds.min.x; const g = d.bounds.max.y - d.bounds.min.y; const v = {
        bodyA: c, pointA: { x: p * e, y: f * i }, bodyB: d, pointB: { x: (d.bounds.max.x - d.bounds.min.x) * n, y: g * a },
      }; const m = o.extend(v, h); s.addConstraint(t, r.create(m));
    } return t.label += ' Chain', t;
  }, n.mesh = function (t, e, i, n, a) { let h; let l; let u; let c; let d; const f = t.bodies; for (h = 0; h < i; h++) { for (l = 1; l < e; l++)u = f[l - 1 + h * e], c = f[l + h * e], s.addConstraint(t, r.create(o.extend({ bodyA: u, bodyB: c }, a))); if (h > 0) for (l = 0; l < e; l++)u = f[l + (h - 1) * e], c = f[l + h * e], s.addConstraint(t, r.create(o.extend({ bodyA: u, bodyB: c }, a))), n && l > 0 && (d = f[l - 1 + (h - 1) * e], s.addConstraint(t, r.create(o.extend({ bodyA: d, bodyB: c }, a)))), n && l < e - 1 && (d = f[l + 1 + (h - 1) * e], s.addConstraint(t, r.create(o.extend({ bodyA: d, bodyB: c }, a)))); } return t.label += ' Mesh', t; }, n.pyramid = function (t, e, i, s, r, o, h) { return n.stack(t, e, i, s, r, o, ((e, n, o, l, u, c) => { const d = Math.min(s, Math.ceil(i / 2)); const f = u ? u.bounds.max.x - u.bounds.min.x : 0; if (!(l > d || o < (l = d - l) || o > i - 1 - l)) return c === 1 && a.translate(u, { x: (o + (i % 2 == 1 ? 1 : -1)) * f, y: 0 }), h(t + (u ? o * f : 0) + o * r, n, o, l, u, c); })); }, n.newtonsCradle = function (t, e, i, n, o) {
    for (var a = s.create({ label: 'Newtons Cradle' }), l = 0; l < i; l++) {
      const u = h.circle(t + l * (1.9 * n), e + o, n, {
        inertia: 1 / 0, restitution: 1, friction: 0, frictionAir: 1e-4, slop: 1,
      }); const c = r.create({ pointA: { x: t + l * (1.9 * n), y: e }, bodyB: u }); s.addBody(a, u), s.addConstraint(a, c);
    } return a;
  }, n.car = function (t, e, i, n, o) {
    const l = a.nextGroup(!0); const u = 0.5 * -i + 20; const c = 0.5 * i - 20; const d = s.create({ label: 'Car' }); const f = h.rectangle(t, e, i, n, { collisionFilter: { group: l }, chamfer: { radius: 0.5 * n }, density: 2e-4 }); const p = h.circle(t + u, e + 0, o, { collisionFilter: { group: l }, friction: 0.8 }); const g = h.circle(t + c, e + 0, o, { collisionFilter: { group: l }, friction: 0.8 }); const v = r.create({
      bodyB: f, pointB: { x: u, y: 0 }, bodyA: p, stiffness: 1, length: 0,
    }); const m = r.create({
      bodyB: f, pointB: { x: c, y: 0 }, bodyA: g, stiffness: 1, length: 0,
    }); return s.addBody(d, f), s.addBody(d, p), s.addBody(d, g), s.addConstraint(d, v), s.addConstraint(d, m), d;
  }, n.softBody = function (t, e, i, s, r, a, l, u, c, d) { c = o.extend({ inertia: 1 / 0 }, c), d = o.extend({ stiffness: 0.2, render: { type: 'line', anchors: !1 } }, d); const f = n.stack(t, e, i, s, r, a, ((t, e) => h.circle(t, e, u, c))); return n.mesh(f, i, s, l, d), f.label = 'Soft Body', f; };
}, function (t, e, i) { const n = {}; t.exports = n; i(38); const s = i(21); n.pathToVertices = function (t, e) { typeof window === 'undefined' || 'SVGPathSeg' in window || s.warn('Svg.pathToVertices: SVGPathSeg not defined, a polyfill is required.'); let i; let r; let o; let a; let h; let l; let u; let c; let d; let f; let p; const g = []; let v = 0; let m = 0; let y = 0; e = e || 15; const x = function (t, e, i) { const n = i % 2 == 1 && i > 1; if (!d || t != d.x || e != d.y) { d && n ? (f = d.x, p = d.y) : (f = 0, p = 0); const s = { x: f + t, y: p + e }; !n && d || (d = s), g.push(s), m = f + t, y = p + e; } }; const T = function (t) { const e = t.pathSegTypeAsLetter.toUpperCase(); if (e !== 'Z') { switch (e) { case 'M': case 'L': case 'T': case 'C': case 'S': case 'Q': m = t.x, y = t.y; break; case 'H': m = t.x; break; case 'V': y = t.y; }x(m, y, t.pathSegType); } }; for (n._svgPathToAbsolute(t), o = t.getTotalLength(), l = [], i = 0; i < t.pathSegList.numberOfItems; i += 1)l.push(t.pathSegList.getItem(i)); for (u = l.concat(); v < o;) { if ((h = l[t.getPathSegAtLength(v)]) != c) { for (;u.length && u[0] != h;)T(u.shift()); c = h; } switch (h.pathSegTypeAsLetter.toUpperCase()) { case 'C': case 'T': case 'S': case 'Q': case 'A': a = t.getPointAtLength(v), x(a.x, a.y, 0); }v += e; } for (i = 0, r = u.length; i < r; ++i)T(u[i]); return g; }, n._svgPathToAbsolute = function (t) { for (var e, i, n, s, r, o, a = t.pathSegList, h = 0, l = 0, u = a.numberOfItems, c = 0; c < u; ++c) { const d = a.getItem(c); const f = d.pathSegTypeAsLetter; if (/[MLHVCSQTA]/.test(f))'x' in d && (h = d.x), 'y' in d && (l = d.y); else switch ('x1' in d && (n = h + d.x1), 'x2' in d && (r = h + d.x2), 'y1' in d && (s = l + d.y1), 'y2' in d && (o = l + d.y2), 'x' in d && (h += d.x), 'y' in d && (l += d.y), f) { case 'm': a.replaceItem(t.createSVGPathSegMovetoAbs(h, l), c); break; case 'l': a.replaceItem(t.createSVGPathSegLinetoAbs(h, l), c); break; case 'h': a.replaceItem(t.createSVGPathSegLinetoHorizontalAbs(h), c); break; case 'v': a.replaceItem(t.createSVGPathSegLinetoVerticalAbs(l), c); break; case 'c': a.replaceItem(t.createSVGPathSegCurvetoCubicAbs(h, l, n, s, r, o), c); break; case 's': a.replaceItem(t.createSVGPathSegCurvetoCubicSmoothAbs(h, l, r, o), c); break; case 'q': a.replaceItem(t.createSVGPathSegCurvetoQuadraticAbs(h, l, n, s), c); break; case 't': a.replaceItem(t.createSVGPathSegCurvetoQuadraticSmoothAbs(h, l), c); break; case 'a': a.replaceItem(t.createSVGPathSegArcAbs(h, l, d.r1, d.r2, d.angle, d.largeArcFlag, d.sweepFlag), c); break; case 'z': case 'Z': h = e, l = i; }f != 'M' && f != 'm' || (e = h, i = l); } }; }, function (t, e, i) {
/**
 * @author       Joachim Grill <joachim@codeandweb.com>
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2018 CodeAndWeb GmbH
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(44); const s = i(26); const r = i(21); const o = i(2); const a = i(32); const h = { parseBody(t, e, i, n) { void 0 === n && (n = {}); for (var a = o(i, 'fixtures', []), h = [], l = 0; l < a.length; l++) for (let u = this.parseFixture(a[l]), c = 0; c < u.length; c++)h.push(u[c]); const d = r.clone(i, !0); r.extend(d, n, !0), delete d.fixtures, delete d.type; const f = s.create(d); return s.setParts(f, h), s.setPosition(f, { x: t, y: e }), f; }, parseFixture(t) { let e; const i = r.extend({}, !1, t); if (delete i.circle, delete i.vertices, t.circle) { const s = o(t.circle, 'x'); const a = o(t.circle, 'y'); const h = o(t.circle, 'radius'); e = [n.circle(s, a, h, i)]; } else t.vertices && (e = this.parseVertices(t.vertices, i)); return e; }, parseVertices(t, e) { void 0 === e && (e = {}); for (var i = [], o = 0; o < t.length; o++)a.clockwiseSort(t[o]), i.push(s.create(r.extend({ position: a.centre(t[o]), vertices: t[o] }, e))); return n.flagCoincidentParts(i); } }; t.exports = h;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(44); const s = i(26); const r = { parseBody(t, e, i, r) { let o; void 0 === r && (r = {}); const a = i.vertices; if (a.length === 1)r.vertices = a[0], o = s.create(r), n.flagCoincidentParts(o.parts); else { for (var h = [], l = 0; l < a.length; l++) { const u = s.create({ vertices: a[l] }); h.push(u); }n.flagCoincidentParts(h), r.parts = h, o = s.create(r); } return o.label = i.label, s.setPosition(o, { x: t, y: e }), o; } }; t.exports = r;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = {
    AFTER_ADD: i(1335), AFTER_REMOVE: i(1336), AFTER_UPDATE: i(1337), BEFORE_ADD: i(1338), BEFORE_REMOVE: i(1339), BEFORE_UPDATE: i(1340), COLLISION_ACTIVE: i(1341), COLLISION_END: i(1342), COLLISION_START: i(1343), DRAG_END: i(1344), DRAG: i(1345), DRAG_START: i(1346), PAUSE: i(1347), RESUME: i(1348), SLEEP_END: i(1349), SLEEP_START: i(1350),
  };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(44); const s = i(26); const r = i(0); const o = i(152); const a = i(10); const h = i(2); const l = i(113); const u = i(32); const c = new r({
    Extends: a, Mixins: [o.Bounce, o.Collision, o.Friction, o.Gravity, o.Mass, o.Sensor, o.Sleep, o.Static], initialize(t, e, i) { a.call(this), this.tile = e, this.world = t, e.physics.matterBody && e.physics.matterBody.destroy(), e.physics.matterBody = this; const n = h(i, 'body', null); const s = h(i, 'addToWorld', !0); if (n) this.setBody(n, s); else { const r = e.getCollisionGroup(); h(r, 'objects', []).length > 0 ? this.setFromTileCollision(i) : this.setFromTileRectangle(i); } }, setFromTileRectangle(t) { void 0 === t && (t = {}), l(t, 'isStatic') || (t.isStatic = !0), l(t, 'addToWorld') || (t.addToWorld = !0); const e = this.tile.getBounds(); const i = e.x + e.width / 2; const s = e.y + e.height / 2; const r = n.rectangle(i, s, e.width, e.height, t); return this.setBody(r, t.addToWorld), this; }, setFromTileCollision(t) { void 0 === t && (t = {}), l(t, 'isStatic') || (t.isStatic = !0), l(t, 'addToWorld') || (t.addToWorld = !0); for (var e = this.tile.tilemapLayer.scaleX, i = this.tile.tilemapLayer.scaleY, r = this.tile.getLeft(), o = this.tile.getTop(), a = this.tile.getCollisionGroup(), c = h(a, 'objects', []), d = [], f = 0; f < c.length; f++) { const p = c[f]; let g = r + p.x * e; let v = o + p.y * i; const m = p.width * e; const y = p.height * i; let x = null; if (p.rectangle)x = n.rectangle(g + m / 2, v + y / 2, m, y, t); else if (p.ellipse)x = n.circle(g + m / 2, v + y / 2, m / 2, t); else if (p.polygon || p.polyline) { const T = (p.polygon ? p.polygon : p.polyline).map(((t) => ({ x: t.x * e, y: t.y * i }))); const w = u.create(T); const b = u.centre(w); g += b.x, v += b.y, x = n.fromVertices(g, v, w, t); }x && d.push(x); } return d.length === 1 ? this.setBody(d[0], t.addToWorld) : d.length > 1 && (t.parts = d, this.setBody(s.create(t), t.addToWorld)), this; }, setBody(t, e) { return void 0 === e && (e = !0), this.body && this.removeBody(), this.body = t, this.body.gameObject = this, e && this.world.add(this.body), this; }, removeBody() { return this.body && (this.world.remove(this.body), this.body.gameObject = void 0, this.body = void 0), this; }, destroy() { this.removeBody(), this.tile.physics.matterBody = void 0, this.removeAllListeners(); },
  }); t.exports = c;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(510); n.Body = i(26), n.Composite = i(69), n.World = i(245), n.Detector = i(153), n.Grid = i(246), n.Pairs = i(247), n.Pair = i(115), n.Query = i(511), n.Resolver = i(248), n.SAT = i(154), n.Constraint = i(80), n.Common = i(21), n.Engine = i(512), n.Events = i(95), n.Sleeping = i(94), n.Plugin = i(244), n.Bodies = i(44), n.Composites = i(237), n.Axes = i(151), n.Bounds = i(38), n.Svg = i(238), n.Vector = i(37), n.Vertices = i(32), n.World.add = n.Composite.add, n.World.remove = n.Composite.remove, n.World.addComposite = n.Composite.addComposite, n.World.addBody = n.Composite.addBody, n.World.addConstraint = n.Composite.addConstraint, n.World.clear = n.Composite.clear, t.exports = n;
}, function (t, e, i) {
  const n = {}; t.exports = n; const s = i(21); n._registry = {}, n.register = function (t) { if (n.isPlugin(t) || s.warn('Plugin.register:', n.toString(t), 'does not implement all required fields.'), t.name in n._registry) { const e = n._registry[t.name]; const i = n.versionParse(t.version).number; const r = n.versionParse(e.version).number; i > r ? (s.warn('Plugin.register:', n.toString(e), 'was upgraded to', n.toString(t)), n._registry[t.name] = t) : i < r ? s.warn('Plugin.register:', n.toString(e), 'can not be downgraded to', n.toString(t)) : t !== e && s.warn('Plugin.register:', n.toString(t), 'is already registered to different plugin object'); } else n._registry[t.name] = t; return t; }, n.resolve = function (t) { return n._registry[n.dependencyParse(t).name]; }, n.toString = function (t) { return typeof t === 'string' ? t : `${t.name || 'anonymous'}@${t.version || t.range || '0.0.0'}`; }, n.isPlugin = function (t) { return t && t.name && t.version && t.install; }, n.isUsed = function (t, e) { return t.used.indexOf(e) > -1; }, n.isFor = function (t, e) { const i = t.for && n.dependencyParse(t.for); return !t.for || e.name === i.name && n.versionSatisfies(e.version, i.range); }, n.use = function (t, e) { if (t.uses = (t.uses || []).concat(e || []), t.uses.length !== 0) { for (var i = n.dependencies(t), r = s.topologicalSort(i), o = [], a = 0; a < r.length; a += 1) if (r[a] !== t.name) { var h = n.resolve(r[a]); h ? n.isUsed(t, h.name) || (n.isFor(h, t) || (s.warn('Plugin.use:', n.toString(h), 'is for', h.for, 'but installed on', `${n.toString(t)}.`), h._warned = !0), h.install ? h.install(t) : (s.warn('Plugin.use:', n.toString(h), 'does not specify an install function.'), h._warned = !0), h._warned ? (o.push(` ${n.toString(h)}`), delete h._warned) : o.push(` ${n.toString(h)}`), t.used.push(h.name)) : o.push(` ${r[a]}`); }o.length > 0 && !h.silent && s.info(o.join('  ')); } else s.warn('Plugin.use:', n.toString(t), 'does not specify any dependencies to install.'); }, n.dependencies = function (t, e) { const i = n.dependencyParse(t); const r = i.name; if (!(r in (e = e || {}))) { t = n.resolve(t) || t, e[r] = s.map(t.uses || [], ((e) => { n.isPlugin(e) && n.register(e); const r = n.dependencyParse(e); const o = n.resolve(e); return o && !n.versionSatisfies(o.version, r.range) ? (s.warn('Plugin.dependencies:', n.toString(o), 'does not satisfy', n.toString(r), 'used by', `${n.toString(i)}.`), o._warned = !0, t._warned = !0) : o || (s.warn('Plugin.dependencies:', n.toString(e), 'used by', n.toString(i), 'could not be resolved.'), t._warned = !0), r.name; })); for (let o = 0; o < e[r].length; o += 1)n.dependencies(e[r][o], e); return e; } }, n.dependencyParse = function (t) { return s.isString(t) ? (/^[\w-]+(@(\*|[\^~]?\d+\.\d+\.\d+(-[0-9A-Za-z-]+)?))?$/.test(t) || s.warn('Plugin.dependencyParse:', t, 'is not a valid dependency string.'), { name: t.split('@')[0], range: t.split('@')[1] || '*' }) : { name: t.name, range: t.range || t.version }; }, n.versionParse = function (t) {
    /^\*|[\^~]?\d+\.\d+\.\d+(-[0-9A-Za-z-]+)?$/.test(t) || s.warn('Plugin.versionParse:', t, 'is not a valid version or range.'); const e = t.split('-'); t = e[0]; const i = isNaN(Number(t[0])); const n = i ? t.substr(1) : t; const r = s.map(n.split('.'), ((t) => Number(t))); return {
      isRange: i, version: n, range: t, operator: i ? t[0] : '', parts: r, prerelease: e[1], number: 1e8 * r[0] + 1e4 * r[1] + r[2],
    };
  }, n.versionSatisfies = function (t, e) { e = e || '*'; const i = n.versionParse(e); const s = i.parts; const r = n.versionParse(t); const o = r.parts; if (i.isRange) { if (i.operator === '*' || t === '*') return !0; if (i.operator === '~') return o[0] === s[0] && o[1] === s[1] && o[2] >= s[2]; if (i.operator === '^') return s[0] > 0 ? o[0] === s[0] && r.number >= i.number : s[1] > 0 ? o[1] === s[1] && o[2] >= s[2] : o[2] === s[2]; } return t === e || t === '*'; };
}, function (t, e, i) { const n = {}; t.exports = n; const s = i(69); const r = (i(80), i(21)); n.create = function (t) { const e = s.create(); const i = { label: 'World', gravity: { x: 0, y: 1, scale: 0.001 }, bounds: { min: { x: -1 / 0, y: -1 / 0 }, max: { x: 1 / 0, y: 1 / 0 } } }; return r.extend(e, i, t); }; }, function (t, e, i) {
  const n = {}; t.exports = n; const s = i(115); const r = i(153); const o = i(21); n.create = function (t) {
    const e = {
      controller: n, detector: r.collisions, buckets: {}, pairs: {}, pairsList: [], bucketWidth: 48, bucketHeight: 48,
    }; return o.extend(e, t);
  }, n.update = function (t, e, i, s) { let r; let o; let a; let h; let l; const u = i.world; const c = t.buckets; let d = !1; const f = i.metrics; for (f.broadphaseTests = 0, r = 0; r < e.length; r++) { const p = e[r]; if ((!p.isSleeping || s) && !(p.bounds.max.x < u.bounds.min.x || p.bounds.min.x > u.bounds.max.x || p.bounds.max.y < u.bounds.min.y || p.bounds.min.y > u.bounds.max.y)) { const g = n._getRegion(t, p); if (!p.region || g.id !== p.region.id || s) { f.broadphaseTests += 1, p.region && !s || (p.region = g); const v = n._regionUnion(g, p.region); for (o = v.startCol; o <= v.endCol; o++) for (a = v.startRow; a <= v.endRow; a++) { h = c[l = n._getBucketId(o, a)]; const m = o >= g.startCol && o <= g.endCol && a >= g.startRow && a <= g.endRow; const y = o >= p.region.startCol && o <= p.region.endCol && a >= p.region.startRow && a <= p.region.endRow; !m && y && y && h && n._bucketRemoveBody(t, h, p), (p.region === g || m && !y || s) && (h || (h = n._createBucket(c, l)), n._bucketAddBody(t, h, p)); }p.region = g, d = !0; } } }d && (t.pairsList = n._createActivePairsList(t)); }, n.clear = function (t) { t.buckets = {}, t.pairs = {}, t.pairsList = []; }, n._regionUnion = function (t, e) { const i = Math.min(t.startCol, e.startCol); const s = Math.max(t.endCol, e.endCol); const r = Math.min(t.startRow, e.startRow); const o = Math.max(t.endRow, e.endRow); return n._createRegion(i, s, r, o); }, n._getRegion = function (t, e) { const i = e.bounds; const s = Math.floor(i.min.x / t.bucketWidth); const r = Math.floor(i.max.x / t.bucketWidth); const o = Math.floor(i.min.y / t.bucketHeight); const a = Math.floor(i.max.y / t.bucketHeight); return n._createRegion(s, r, o, a); }, n._createRegion = function (t, e, i, n) {
    return {
      id: `${t},${e},${i},${n}`, startCol: t, endCol: e, startRow: i, endRow: n,
    };
  }, n._getBucketId = function (t, e) { return `C${t}R${e}`; }, n._createBucket = function (t, e) { return t[e] = []; }, n._bucketAddBody = function (t, e, i) { for (let n = 0; n < e.length; n++) { const r = e[n]; if (!(i.id === r.id || i.isStatic && r.isStatic)) { const o = s.id(i, r); const a = t.pairs[o]; a ? a[2] += 1 : t.pairs[o] = [i, r, 1]; } }e.push(i); }, n._bucketRemoveBody = function (t, e, i) { e.splice(e.indexOf(i), 1); for (let n = 0; n < e.length; n++) { const r = e[n]; const o = s.id(i, r); const a = t.pairs[o]; a && (a[2] -= 1); } }, n._createActivePairsList = function (t) { let e; let i; const n = []; e = o.keys(t.pairs); for (let s = 0; s < e.length; s++)(i = t.pairs[e[s]])[2] > 0 ? n.push(i) : delete t.pairs[e[s]]; return n; };
}, function (t, e, i) {
  const n = {}; t.exports = n; const s = i(115); const r = i(21); n._pairMaxIdleLife = 1e3, n.create = function (t) {
    return r.extend({
      table: {}, list: [], collisionStart: [], collisionActive: [], collisionEnd: [],
    }, t);
  }, n.update = function (t, e, i) { let n; let r; let o; let a; const h = t.list; const l = t.table; const u = t.collisionStart; const c = t.collisionEnd; const d = t.collisionActive; for (u.length = 0, c.length = 0, d.length = 0, a = 0; a < h.length; a++)h[a].confirmedActive = !1; for (a = 0; a < e.length; a++)(n = e[a]).collided && ((o = l[r = s.id(n.bodyA, n.bodyB)]) ? (o.isActive ? d.push(o) : u.push(o), s.update(o, n, i), o.confirmedActive = !0) : (o = s.create(n, i), l[r] = o, u.push(o), h.push(o))); for (a = 0; a < h.length; a++)(o = h[a]).isActive && !o.confirmedActive && (s.setActive(o, !1, i), c.push(o)); }, n.removeOld = function (t, e) { let i; let s; let r; let o; const a = t.list; const h = t.table; const l = []; for (o = 0; o < a.length; o++)(s = (i = a[o]).collision).bodyA.isSleeping || s.bodyB.isSleeping ? i.timeUpdated = e : e - i.timeUpdated > n._pairMaxIdleLife && l.push(o); for (o = 0; o < l.length; o++) delete h[(i = a[r = l[o] - o]).id], a.splice(r, 1); }, n.clear = function (t) { return t.table = {}, t.list.length = 0, t.collisionStart.length = 0, t.collisionActive.length = 0, t.collisionEnd.length = 0, t; };
}, function (t, e, i) { const n = {}; t.exports = n; const s = i(32); const r = i(37); const o = i(21); const a = i(38); n._restingThresh = 4, n._restingThreshTangent = 6, n._positionDampen = 0.9, n._positionWarming = 0.8, n._frictionNormalMultiplier = 5, n.preSolvePosition = function (t) { let e; let i; let n; for (e = 0; e < t.length; e++)(i = t[e]).isActive && (n = i.activeContacts.length, i.collision.parentA.totalContacts += n, i.collision.parentB.totalContacts += n); }, n.solvePosition = function (t, e, i) { let s; let r; let o; let a; let h; let l; let u; let c; let d; let f; let p; let g; let v; let m; let y; let x; const T = i * n._positionDampen; for (s = 0; s < e.length; s++) { const w = e[s]; w.previousPositionImpulse.x = w.positionImpulse.x, w.previousPositionImpulse.y = w.positionImpulse.y; } for (s = 0; s < t.length; s++)(a = t[s]).isActive && !a.isSensor && (l = (h = a.collision).parentA, u = h.parentB, c = h.normal, p = l.previousPositionImpulse, g = u.previousPositionImpulse, f = h.penetration, m = g.x - p.x + f.x, y = g.y - p.y + f.y, d = (r = c.x) * m + (o = c.y) * y, a.separation = d, x = (d - a.slop) * T, (l.isStatic || u.isStatic) && (x *= 2), l.isStatic || l.isSleeping || (v = x / l.totalContacts, l.positionImpulse.x += r * v, l.positionImpulse.y += o * v), u.isStatic || u.isSleeping || (v = x / u.totalContacts, u.positionImpulse.x -= r * v, u.positionImpulse.y -= o * v)); }, n.postSolvePosition = function (t) { for (let e = 0; e < t.length; e++) { const i = t[e]; if (i.totalContacts = 0, i.positionImpulse.x !== 0 || i.positionImpulse.y !== 0) { for (let o = 0; o < i.parts.length; o++) { const h = i.parts[o]; s.translate(h.vertices, i.positionImpulse), a.update(h.bounds, h.vertices, i.velocity), h.position.x += i.positionImpulse.x, h.position.y += i.positionImpulse.y; }i.positionPrev.x += i.positionImpulse.x, i.positionPrev.y += i.positionImpulse.y, r.dot(i.positionImpulse, i.velocity) < 0 ? (i.positionImpulse.x = 0, i.positionImpulse.y = 0) : (i.positionImpulse.x *= n._positionWarming, i.positionImpulse.y *= n._positionWarming); } } }, n.preSolveVelocity = function (t) { let e; let i; let n; let s; let o; let a; let h; let l; let u; let c; let d; let f; let p; let g; const v = r._temp[0]; const m = r._temp[1]; for (e = 0; e < t.length; e++) if ((n = t[e]).isActive && !n.isSensor) for (s = n.activeContacts, a = (o = n.collision).parentA, h = o.parentB, l = o.normal, u = o.tangent, i = 0; i < s.length; i++)d = (c = s[i]).vertex, f = c.normalImpulse, p = c.tangentImpulse, f === 0 && p === 0 || (v.x = l.x * f + u.x * p, v.y = l.y * f + u.y * p, a.isStatic || a.isSleeping || (g = r.sub(d, a.position, m), a.positionPrev.x += v.x * a.inverseMass, a.positionPrev.y += v.y * a.inverseMass, a.anglePrev += r.cross(g, v) * a.inverseInertia), h.isStatic || h.isSleeping || (g = r.sub(d, h.position, m), h.positionPrev.x -= v.x * h.inverseMass, h.positionPrev.y -= v.y * h.inverseMass, h.anglePrev -= r.cross(g, v) * h.inverseInertia)); }, n.solveVelocity = function (t, e) { for (let i = e * e, s = r._temp[0], a = r._temp[1], h = r._temp[2], l = r._temp[3], u = r._temp[4], c = r._temp[5], d = 0; d < t.length; d++) { const f = t[d]; if (f.isActive && !f.isSensor) { const p = f.collision; const g = p.parentA; const v = p.parentB; const m = p.normal; const y = p.tangent; const x = f.activeContacts; const T = 1 / x.length; g.velocity.x = g.position.x - g.positionPrev.x, g.velocity.y = g.position.y - g.positionPrev.y, v.velocity.x = v.position.x - v.positionPrev.x, v.velocity.y = v.position.y - v.positionPrev.y, g.angularVelocity = g.angle - g.anglePrev, v.angularVelocity = v.angle - v.anglePrev; for (let w = 0; w < x.length; w++) { const b = x[w]; const E = b.vertex; const S = r.sub(E, g.position, a); const A = r.sub(E, v.position, h); const _ = r.add(g.velocity, r.mult(r.perp(S), g.angularVelocity), l); const C = r.add(v.velocity, r.mult(r.perp(A), v.angularVelocity), u); const M = r.sub(_, C, c); const P = r.dot(m, M); const O = r.dot(y, M); const R = Math.abs(O); const L = o.sign(O); let D = (1 + f.restitution) * P; const k = o.clamp(f.separation + P, 0, 1) * n._frictionNormalMultiplier; let F = O; let I = 1 / 0; R > f.friction * f.frictionStatic * k * i && (I = R, F = o.clamp(f.friction * L * i, -I, I)); const B = r.cross(S, m); const N = r.cross(A, m); const Y = T / (g.inverseMass + v.inverseMass + g.inverseInertia * B * B + v.inverseInertia * N * N); if (D *= Y, F *= Y, P < 0 && P * P > n._restingThresh * i)b.normalImpulse = 0; else { const X = b.normalImpulse; b.normalImpulse = Math.min(b.normalImpulse + D, 0), D = b.normalImpulse - X; } if (O * O > n._restingThreshTangent * i)b.tangentImpulse = 0; else { const z = b.tangentImpulse; b.tangentImpulse = o.clamp(b.tangentImpulse + F, -I, I), F = b.tangentImpulse - z; }s.x = m.x * D + y.x * F, s.y = m.y * D + y.y * F, g.isStatic || g.isSleeping || (g.positionPrev.x += s.x * g.inverseMass, g.positionPrev.y += s.y * g.inverseMass, g.anglePrev += r.cross(S, s) * g.inverseInertia), v.isStatic || v.isSleeping || (v.positionPrev.x -= s.x * v.inverseMass, v.positionPrev.y -= s.y * v.inverseMass, v.anglePrev -= r.cross(A, s) * v.inverseInertia); } } } }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(156); t.exports = function (t, e, i) { const s = n(t, e, !0, i); const r = n(t, e - 1, !0, i); const o = n(t, e + 1, !0, i); const a = n(t - 1, e, !0, i); const h = n(t + 1, e, !0, i); const l = s && s.collides; return l && (s.faceTop = !0, s.faceBottom = !0, s.faceLeft = !0, s.faceRight = !0), r && r.collides && (l && (s.faceTop = !1), r.faceBottom = !l), o && o.collides && (l && (s.faceBottom = !1), o.faceTop = !l), a && a.collides && (l && (s.faceLeft = !1), a.faceRight = !l), h && h.collides && (l && (s.faceRight = !1), h.faceLeft = !l), s && !s.collides && s.resetFaces(), s; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(82); const s = i(116); const r = i(249); const o = i(81); t.exports = function (t, e, i, a, h) { if (!s(e, i, h)) return null; void 0 === a && (a = !0); const l = h.data[i][e]; const u = l && l.collides; if (t instanceof n)h.data[i][e] === null && (h.data[i][e] = new n(h, t.index, e, i, t.width, t.height)), h.data[i][e].copy(t); else { const c = t; h.data[i][e] === null ? h.data[i][e] = new n(h, c, e, i, h.tileWidth, h.tileHeight) : h.data[i][e].index = c; } const d = h.data[i][e]; const f = h.collideIndexes.indexOf(d.index) !== -1; return o(d, f), a && u !== d.collides && r(e, i, h), d; };
}, function (t, e) { t.exports = function (t, e, i) { const n = i.collideIndexes.indexOf(t); e && n === -1 ? i.collideIndexes.push(t) : e || n === -1 || i.collideIndexes.splice(n, 1); }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(36); const s = i(117); const r = i(118); const o = i(82); t.exports = function (t, e, i, a, h) {
    for (var l = new s({ tileWidth: i, tileHeight: a }), u = new r({
        name: t, tileWidth: i, tileHeight: a, format: n.ARRAY_2D, layers: [l],
      }), c = [], d = e.length, f = 0, p = 0; p < e.length; p++) { c[p] = []; for (var g = e[p], v = 0; v < g.length; v++) { const m = parseInt(g[v], 10); isNaN(m) || m === -1 ? c[p][v] = h ? null : new o(l, -1, v, p, i, a) : c[p][v] = new o(l, m, v, p, i, a); }f === 0 && (f = g.length); } return u.width = l.width = f, u.height = l.height = d, u.widthInPixels = l.widthInPixels = f * i, u.heightInPixels = l.heightInPixels = d * a, l.data = c, u;
  };
}, function (t, e) {
  t.exports = function (t) {
    const e = Boolean(2147483648 & t); const i = Boolean(1073741824 & t); const n = Boolean(536870912 & t); t &= 536870911; let s = 0; let r = !1; return e && i && n ? (s = Math.PI / 2, r = !0) : e && i && !n ? (s = Math.PI, r = !1) : e && !i && n ? (s = Math.PI / 2, r = !1) : !e || i || n ? !e && i && n ? (s = 3 * Math.PI / 2, r = !1) : e || !i || n ? e || i || !n ? e || i || n || (s = 0, r = !1) : (s = 3 * Math.PI / 2, r = !0) : (s = Math.PI, r = !0) : (s = 0, r = !0), {
      gid: t, flippedHorizontal: e, flippedVertical: i, flippedAntiDiagonal: n, rotation: s, flipped: r,
    };
  };
}, function (t, e, i) {
/**
 * @author       Seth Berrier <berriers@uwstout.edu>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(2); t.exports = function (t, e, i) {
    if (!e) {
      return {
        i: 0, layers: t.layers, name: '', opacity: 1, visible: !0, x: 0, y: 0,
      };
    } const s = e.x + n(e, 'startx', 0) * t.tilewidth + n(e, 'offsetx', 0); const r = e.y + n(e, 'starty', 0) * t.tileheight + n(e, 'offsety', 0); return {
      i: 0, layers: e.layers, name: `${i.name + e.name}/`, opacity: i.opacity * e.opacity, visible: i.visible && e.visible, x: i.x + s, y: i.y + r,
    };
  };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(526); const s = i(253); const r = function (t) { return { x: t.x, y: t.y }; }; const o = ['id', 'name', 'type', 'rotation', 'properties', 'visible', 'x', 'y', 'width', 'height']; t.exports = function (t, e, i) { void 0 === e && (e = 0), void 0 === i && (i = 0); const a = n(t, o); if (a.x += e, a.y += i, t.gid) { const h = s(t.gid); a.gid = h.gid, a.flippedHorizontal = h.flippedHorizontal, a.flippedVertical = h.flippedVertical, a.flippedAntiDiagonal = h.flippedAntiDiagonal; } else t.polyline ? a.polyline = t.polyline.map(r) : t.polygon ? a.polygon = t.polygon.map(r) : t.ellipse ? a.ellipse = t.ellipse : t.text ? a.text = t.text : t.point ? a.point = !0 : a.rectangle = !0; return a; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(36); const s = i(118); const r = i(518); const o = i(534); t.exports = function (t, e, i, a, h, l, u, c) {
    void 0 === i && (i = 32), void 0 === a && (a = 32), void 0 === h && (h = 10), void 0 === l && (l = 10), void 0 === c && (c = !1); let d = null; if (Array.isArray(u))d = r(void 0 !== e ? e : 'map', n.ARRAY_2D, u, i, a, c); else if (void 0 !== e) { const f = t.cache.tilemap.get(e); f ? d = r(e, f.format, f.data, i, a, c) : console.warn(`No map data found for key ${e}`); } return d === null && (d = new s({
      tileWidth: i, tileHeight: a, width: h, height: l,
    })), new o(t, d);
  };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(6); t.exports = function (t) { let e = n(t, 'targets', null); return e === null || (typeof e === 'function' && (e = e.call()), Array.isArray(e) || (e = [e])), e; };
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  function i(t) { return !!t.getActive && typeof t.getActive === 'function'; } function n(t) { return !!t.getStart && typeof t.getStart === 'function'; } function s(t) { return !!t.getEnd && typeof t.getEnd === 'function'; } var r = function (t, e) { let o; let a; let h = function (t, e, i) { return i; }; let l = function (t, e, i) { return i; }; let u = null; const c = typeof e; if (c === 'number')h = function () { return e; }; else if (c === 'string') { const d = e[0]; const f = parseFloat(e.substr(2)); switch (d) { case '+': h = function (t, e, i) { return i + f; }; break; case '-': h = function (t, e, i) { return i - f; }; break; case '*': h = function (t, e, i) { return i * f; }; break; case '/': h = function (t, e, i) { return i / f; }; break; default: h = function () { return parseFloat(e); }; } } else if (c === 'function')h = e; else if (c === 'object') if (n(a = e) || s(a) || i(a))i(e) && (u = e.getActive), s(e) && (h = e.getEnd), n(e) && (l = e.getStart); else if (e.hasOwnProperty('value'))o = r(t, e.value); else { const p = e.hasOwnProperty('to'); const g = e.hasOwnProperty('from'); const v = e.hasOwnProperty('start'); if (p && (g || v)) { if (o = r(t, e.to), v) { const m = r(t, e.start); o.getActive = m.getEnd; } if (g) { const y = r(t, e.from); o.getStart = y.getEnd; } } } return o || (o = { getActive: u, getEnd: h, getStart: l }), o; }; t.exports = r;
}, function (t, e) {
  t.exports = {
    targets: null, delay: 0, duration: 1e3, ease: 'Power0', easeParams: null, hold: 0, repeat: 0, repeatDelay: 0, yoyo: !1, flipX: !1, flipY: !1,
  };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(10); const r = i(261); const o = i(17); const a = i(5); const h = i(100); const l = i(16); const u = new n({
    Extends: s,
    initialize(t, e, i) {
      s.call(this), this.parent = t, this.parentIsTimeline = t.hasOwnProperty('isTimeline'), this.data = e, this.totalData = e.length, this.targets = i, this.totalTargets = i.length, this.useFrames = !1, this.timeScale = 1, this.loop = 0, this.loopDelay = 0, this.loopCounter = 0, this.startDelay = 0, this.hasStarted = !1, this.isSeeking = !1, this.completeDelay = 0, this.countdown = 0, this.offset = 0, this.calculatedOffset = 0, this.state = h.PENDING_ADD, this._pausedState = h.INIT, this.paused = !1, this.elapsed = 0, this.totalElapsed = 0, this.duration = 0, this.progress = 0, this.totalDuration = 0, this.totalProgress = 0, this.callbacks = {
        onActive: null, onComplete: null, onLoop: null, onRepeat: null, onStart: null, onUpdate: null, onYoyo: null,
      }, this.callbackScope;
    },
    getValue(t) { return void 0 === t && (t = 0), this.data[t].current; },
    setTimeScale(t) { return this.timeScale = t, this; },
    getTimeScale() { return this.timeScale; },
    isPlaying() { return this.state === h.ACTIVE; },
    isPaused() { return this.state === h.PAUSED; },
    hasTarget(t) { return this.targets.indexOf(t) !== -1; },
    updateTo(t, e, i) { void 0 === i && (i = !1); for (let n = 0; n < this.totalData; n++) { const s = this.data[n]; s.key === t && (s.end = e, i && (s.start = s.current)); } return this; },
    restart() { return this.elapsed = 0, this.progress = 0, this.totalElapsed = 0, this.totalProgress = 0, this.state === h.ACTIVE ? this.seek(0) : this.state === h.REMOVED ? (this.seek(0), this.parent.makeActive(this), this) : this.state === h.PENDING_ADD ? this : this.play(); },
    calcDuration() { for (var t = 0, e = l.MAX_SAFE_INTEGER, i = this.data, n = 0; n < this.totalData; n++) { const s = i[n]; s.t1 = s.duration + s.hold, s.yoyo && (s.t1 += s.duration), s.t2 = s.t1 + s.repeatDelay, s.totalDuration = s.delay + s.t1, s.repeat === -1 ? s.totalDuration += 999999999999 * s.t2 : s.repeat > 0 && (s.totalDuration += s.t2 * s.repeat), s.totalDuration > t && (t = s.totalDuration), s.delay < e && (e = s.delay); } this.duration = Math.max(t, 0.001), this.loopCounter = this.loop === -1 ? 999999999999 : this.loop, this.loopCounter > 0 ? this.totalDuration = this.duration + this.completeDelay + (this.duration + this.loopDelay) * this.loopCounter : this.totalDuration = this.duration + this.completeDelay, this.startDelay = e; },
    init() { if (this.paused && !this.parentIsTimeline) return this.state = h.PENDING_ADD, this._pausedState = h.INIT, !1; for (let t = this.data, e = this.totalTargets, i = 0; i < this.totalData; i++) { const n = t[i]; const s = n.target; const r = n.gen; const o = n.key; const a = n.index; n.delay = r.delay(s, o, 0, a, e, this), n.duration = Math.max(r.duration(s, o, 0, a, e, this), 0.001), n.hold = r.hold(s, o, 0, a, e, this), n.repeat = r.repeat(s, o, 0, a, e, this), n.repeatDelay = r.repeatDelay(s, o, 0, a, e, this); } return this.calcDuration(), this.progress = 0, this.totalProgress = 0, this.elapsed = 0, this.totalElapsed = 0, this.state = h.INIT, !0; },
    makeActive() { this.parent.makeActive(this), this.dispatchTweenEvent(r.TWEEN_ACTIVE, this.callbacks.onActive); },
    nextState() { this.loopCounter > 0 ? (this.elapsed = 0, this.progress = 0, this.loopCounter--, this.resetTweenData(!0), this.loopDelay > 0 ? (this.countdown = this.loopDelay, this.state = h.LOOP_DELAY) : (this.state = h.ACTIVE, this.dispatchTweenEvent(r.TWEEN_LOOP, this.callbacks.onLoop))) : this.completeDelay > 0 ? (this.state = h.COMPLETE_DELAY, this.countdown = this.completeDelay) : (this.state = h.PENDING_REMOVE, this.dispatchTweenEvent(r.TWEEN_COMPLETE, this.callbacks.onComplete)); },
    pause() { return this.state === h.PAUSED || (this.paused = !0, this._pausedState = this.state, this.state = h.PAUSED), this; },
    play(t) { void 0 === t && (t = !1); const e = this.state; return e !== h.INIT || this.parentIsTimeline ? e === h.ACTIVE || e === h.PENDING_ADD && this._pausedState === h.PENDING_ADD ? this : this.parentIsTimeline || e !== h.PENDING_REMOVE && e !== h.REMOVED ? (this.parentIsTimeline ? (this.resetTweenData(t), this.calculatedOffset === 0 ? this.state = h.ACTIVE : (this.countdown = this.calculatedOffset, this.state = h.OFFSET_DELAY)) : this.paused ? (this.paused = !1, this.makeActive()) : (this.resetTweenData(t), this.state = h.ACTIVE, this.makeActive()), this) : (this.seek(0), this.parent.makeActive(this), this) : (this.resetTweenData(!1), this.state = h.ACTIVE, this); },
    resetTweenData(t) { for (let e = this.data, i = this.totalData, n = this.totalTargets, s = 0; s < i; s++) { const r = e[s]; const o = r.target; const a = r.key; const l = r.index; r.progress = 0, r.elapsed = 0, r.repeatCounter = r.repeat === -1 ? 999999999999 : r.repeat, t ? (r.start = r.getStartValue(o, a, r.start, l, n, this), r.end = r.getEndValue(o, a, r.end, l, n, this), r.current = r.start, r.state = h.PLAYING_FORWARD) : r.state = h.PENDING_RENDER, r.delay > 0 && (r.elapsed = r.delay, r.state = h.DELAY), r.getActiveValue && (o[a] = r.getActiveValue(r.target, r.key, r.start)); } },
    resume() { return this.state === h.PAUSED ? (this.paused = !1, this.state = this._pausedState) : this.play(), this; },
    seek(t, e) { if (void 0 === e && (e = 16.6), this.totalDuration >= 36e5) return console.warn('Tween.seek duration too long'), this; this.state === h.REMOVED && this.makeActive(), this.elapsed = 0, this.progress = 0, this.totalElapsed = 0, this.totalProgress = 0; for (let i = this.data, n = this.totalTargets, s = 0; s < this.totalData; s++) { const r = i[s]; const o = r.target; const a = r.gen; const l = r.key; const u = r.index; r.progress = 0, r.elapsed = 0, r.repeatCounter = r.repeat === -1 ? 999999999999 : r.repeat, r.delay = a.delay(o, l, 0, u, n, this), r.duration = Math.max(a.duration(o, l, 0, u, n, this), 0.001), r.hold = a.hold(o, l, 0, u, n, this), r.repeat = a.repeat(o, l, 0, u, n, this), r.repeatDelay = a.repeatDelay(o, l, 0, u, n, this), r.current = r.start, r.state = h.PLAYING_FORWARD, this.updateTweenData(this, r, 0, u, n), r.delay > 0 && (r.elapsed = r.delay, r.state = h.DELAY); } this.calcDuration(); let c = !1; this.state === h.PAUSED && (c = !0, this.state = h.ACTIVE), this.isSeeking = !0; do { this.update(0, e); } while (this.totalProgress < t);return this.isSeeking = !1, c && (this.state = h.PAUSED), this; },
    setCallback(t, e, i, n) { return this.callbacks[t] = { func: e, scope: n, params: i }, this; },
    complete(t) { return void 0 === t && (t = 0), t ? (this.state = h.COMPLETE_DELAY, this.countdown = t) : (this.state = h.PENDING_REMOVE, this.dispatchTweenEvent(r.TWEEN_COMPLETE, this.callbacks.onComplete)), this; },
    remove() { return this.parent.remove(this), this; },
    stop(t) { return this.state === h.ACTIVE && void 0 !== t && this.seek(t), this.state !== h.REMOVED && (this.state !== h.PAUSED && this.state !== h.PENDING_ADD || (this.parentIsTimeline ? (this.parent.manager._destroy.push(this), this.parent.manager._toProcess++) : (this.parent._destroy.push(this), this.parent._toProcess++)), this.removeAllListeners(), this.state = h.PENDING_REMOVE), this; },
    update(t, e) { if (this.state === h.PAUSED) return !1; switch (this.useFrames && (e = 1 * this.parent.timeScale), e *= this.timeScale, this.elapsed += e, this.progress = Math.min(this.elapsed / this.duration, 1), this.totalElapsed += e, this.totalProgress = Math.min(this.totalElapsed / this.totalDuration, 1), this.state) { case h.ACTIVE: this.hasStarted || this.isSeeking || (this.startDelay -= e, this.startDelay <= 0 && (this.hasStarted = !0, this.dispatchTweenEvent(r.TWEEN_START, this.callbacks.onStart))); for (var i = !1, n = 0; n < this.totalData; n++) { const s = this.data[n]; this.updateTweenData(this, s, e) && (i = !0); }i || this.nextState(); break; case h.LOOP_DELAY: this.countdown -= e, this.countdown <= 0 && (this.state = h.ACTIVE, this.dispatchTweenEvent(r.TWEEN_LOOP, this.callbacks.onLoop)); break; case h.OFFSET_DELAY: this.countdown -= e, this.countdown <= 0 && (this.state = h.ACTIVE); break; case h.COMPLETE_DELAY: this.countdown -= e, this.countdown <= 0 && (this.state = h.PENDING_REMOVE, this.dispatchTweenEvent(r.TWEEN_COMPLETE, this.callbacks.onComplete)); } return this.state === h.PENDING_REMOVE; },
    dispatchTweenDataEvent(t, e, i) { this.isSeeking || (this.emit(t, this, i.key, i.target, i.current, i.previous), e && (e.params[1] = i.target, e.func.apply(e.scope, e.params))); },
    dispatchTweenEvent(t, e) { this.isSeeking || (this.emit(t, this, this.targets), e && (e.params[1] = this.targets, e.func.apply(e.scope, e.params))); },
    setStateFromEnd(t, e, i) { return e.yoyo ? (e.elapsed = i, e.progress = i / e.duration, e.flipX && e.target.toggleFlipX(), e.flipY && e.target.toggleFlipY(), this.dispatchTweenDataEvent(r.TWEEN_YOYO, t.callbacks.onYoyo, e), e.start = e.getStartValue(e.target, e.key, e.start, e.index, t.totalTargets, t), h.PLAYING_BACKWARD) : e.repeatCounter > 0 ? (e.repeatCounter--, e.elapsed = i, e.progress = i / e.duration, e.flipX && e.target.toggleFlipX(), e.flipY && e.target.toggleFlipY(), e.start = e.getStartValue(e.target, e.key, e.start, e.index, t.totalTargets, t), e.end = e.getEndValue(e.target, e.key, e.start, e.index, t.totalTargets, t), e.repeatDelay > 0 ? (e.elapsed = e.repeatDelay - i, e.current = e.start, e.target[e.key] = e.current, h.REPEAT_DELAY) : (this.dispatchTweenDataEvent(r.TWEEN_REPEAT, t.callbacks.onRepeat, e), h.PLAYING_FORWARD)) : h.COMPLETE; },
    setStateFromStart(t, e, i) { return e.repeatCounter > 0 ? (e.repeatCounter--, e.elapsed = i, e.progress = i / e.duration, e.flipX && e.target.toggleFlipX(), e.flipY && e.target.toggleFlipY(), e.end = e.getEndValue(e.target, e.key, e.start, e.index, t.totalTargets, t), e.repeatDelay > 0 ? (e.elapsed = e.repeatDelay - i, e.current = e.start, e.target[e.key] = e.current, h.REPEAT_DELAY) : (this.dispatchTweenDataEvent(r.TWEEN_REPEAT, t.callbacks.onRepeat, e), h.PLAYING_FORWARD)) : h.COMPLETE; },
    updateTweenData(t, e, i) { const n = e.target; switch (e.state) { case h.PLAYING_FORWARD: case h.PLAYING_BACKWARD: if (!n) { e.state = h.COMPLETE; break; } var s = e.elapsed; var o = e.duration; var a = 0; (s += i) > o && (a = s - o, s = o); var l = e.state === h.PLAYING_FORWARD; var u = s / o; if (e.elapsed = s, e.progress = u, e.previous = e.current, u === 1)l ? (e.current = e.end, n[e.key] = e.end, e.hold > 0 ? (e.elapsed = e.hold - a, e.state = h.HOLD_DELAY) : e.state = this.setStateFromEnd(t, e, a)) : (e.current = e.start, n[e.key] = e.start, e.state = this.setStateFromStart(t, e, a)); else { const c = l ? e.ease(u) : e.ease(1 - u); e.current = e.start + (e.end - e.start) * c, n[e.key] = e.current; } this.dispatchTweenDataEvent(r.TWEEN_UPDATE, t.callbacks.onUpdate, e); break; case h.DELAY: e.elapsed -= i, e.elapsed <= 0 && (e.elapsed = Math.abs(e.elapsed), e.state = h.PENDING_RENDER); break; case h.REPEAT_DELAY: e.elapsed -= i, e.elapsed <= 0 && (e.elapsed = Math.abs(e.elapsed), e.state = h.PLAYING_FORWARD, this.dispatchTweenDataEvent(r.TWEEN_REPEAT, t.callbacks.onRepeat, e)); break; case h.HOLD_DELAY: e.elapsed -= i, e.elapsed <= 0 && (e.state = this.setStateFromEnd(t, e, Math.abs(e.elapsed))); break; case h.PENDING_RENDER: n ? (e.start = e.getStartValue(n, e.key, n[e.key], e.index, t.totalTargets, t), e.end = e.getEndValue(n, e.key, e.start, e.index, t.totalTargets, t), e.current = e.start, n[e.key] = e.start, e.state = h.PLAYING_FORWARD) : e.state = h.COMPLETE; } return e.state !== h.COMPLETE; },
  }); u.TYPES = ['onActive', 'onComplete', 'onLoop', 'onRepeat', 'onStart', 'onUpdate', 'onYoyo'], a.register('tween', (function (t) { return this.scene.sys.tweens.add(t); })), o.register('tween', (function (t) { return this.scene.sys.tweens.create(t); })), t.exports = u;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = {
    TIMELINE_COMPLETE: i(1418), TIMELINE_LOOP: i(1419), TIMELINE_PAUSE: i(1420), TIMELINE_RESUME: i(1421), TIMELINE_START: i(1422), TIMELINE_UPDATE: i(1423), TWEEN_ACTIVE: i(1424), TWEEN_COMPLETE: i(1425), TWEEN_LOOP: i(1426), TWEEN_REPEAT: i(1427), TWEEN_START: i(1428), TWEEN_UPDATE: i(1429), TWEEN_YOYO: i(1430),
  };
}, function (t, e) {
  t.exports = function (t, e, i, n, s, r, o, a, h, l, u, c, d, f, p) {
    return {
      target: t,
      index: e,
      key: i,
      getActiveValue: r,
      getEndValue: n,
      getStartValue: s,
      ease: o,
      duration: 0,
      totalDuration: 0,
      delay: 0,
      yoyo: l,
      hold: 0,
      repeat: 0,
      repeatDelay: 0,
      flipX: f,
      flipY: p,
      progress: 0,
      elapsed: 0,
      repeatCounter: 0,
      start: 0,
      previous: 0,
      current: 0,
      end: 0,
      t1: 0,
      t2: 0,
      gen: {
        delay: a, duration: h, hold: u, repeat: c, repeatDelay: d,
      },
      state: 0,
    };
  };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2018 Photon Storm Ltd.
 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
 */
  const n = i(0); const s = i(189); const r = i(354); const o = i(355); const a = i(361); const h = i(111); const l = i(161); const u = i(3); const c = i(87); const d = i(131); const f = new c(); const p = new d(); const g = new c(); const v = new c(); const m = new s(); var y = new n({
    initialize(t) { this.scene = t, this.displayList = t.sys.displayList, this.updateList = t.sys.updateList, this.name = '', this.direction = new c(0, 0, -1), this.up = new c(0, 1, 0), this.position = new c(), this.pixelScale = 128, this.projection = new s(), this.view = new s(), this.combined = new s(), this.invProjectionView = new s(), this.near = 1, this.far = 100, this.ray = { origin: new c(), direction: new c() }, this.viewportWidth = 0, this.viewportHeight = 0, this.billboardMatrixDirty = !0, this.children = new h(); }, setPosition(t, e, i) { return this.position.set(t, e, i), this.update(); }, setScene(t) { return this.scene = t, this; }, setPixelScale(t) { return this.pixelScale = t, this.update(); }, add(t) { return this.children.set(t), this.displayList.add(t.gameObject), this.updateList.add(t.gameObject), this.updateChildren(), t; }, remove(t) { return this.displayList.remove(t.gameObject), this.updateList.remove(t.gameObject), this.children.delete(t), this; }, clear() { for (let t = this.getChildren(), e = 0; e < t.length; e++) this.remove(t[e]); return this; }, getChildren() { return this.children.entries; }, create(t, e, i, n, s, r) { void 0 === r && (r = !0); const o = new l(this.scene, t, e, i, n, s); return this.displayList.add(o.gameObject), this.updateList.add(o.gameObject), o.visible = r, this.children.set(o), this.updateChildren(), o; }, createMultiple(t, e, i, n) { void 0 === n && (n = !0); for (var s = [], r = 0; r < t; r++) { const o = new l(this.scene, 0, 0, 0, e, i); this.displayList.add(o.gameObject), this.updateList.add(o.gameObject), o.visible = n, this.children.set(o), s.push(o); } return s; }, createRect(t, e, i, n) { typeof t === 'number' && (t = { x: t, y: t, z: t }), typeof e === 'number' && (e = { x: e, y: e, z: e }); for (var s = t.x * t.y * t.z, r = this.createMultiple(s, i, n), o = 0, a = 0.5 - t.z / 2; a < t.z / 2; a++) for (let h = 0.5 - t.y / 2; h < t.y / 2; h++) for (let l = 0.5 - t.x / 2; l < t.x / 2; l++) { const u = l * e.x; const c = h * e.y; const d = a * e.z; r[o].position.set(u, c, d), o++; } return this.update(), r; }, randomSphere(t, e) { void 0 === e && (e = this.getChildren()); for (let i = 0; i < e.length; i++)r(e[i].position, t); return this.update(); }, randomCube(t, e) { void 0 === e && (e = this.getChildren()); for (let i = 0; i < e.length; i++)o(e[i].position, t); return this.update(); }, translateChildren(t, e) { void 0 === e && (e = this.getChildren()); for (let i = 0; i < e.length; i++)e[i].position.add(t); return this.update(); }, transformChildren(t, e) { void 0 === e && (e = this.getChildren()); for (let i = 0; i < e.length; i++)e[i].position.transformMat4(t); return this.update(); }, setViewport(t, e) { return this.viewportWidth = t, this.viewportHeight = e, this.update(); }, translate(t, e, i) { return typeof t === 'object' ? (this.position.x += t.x || 0, this.position.y += t.y || 0, this.position.z += t.z || 0) : (this.position.x += t || 0, this.position.y += e || 0, this.position.z += i || 0), this.update(); }, lookAt(t, e, i) { const n = this.direction; const s = this.up; return typeof t === 'object' ? n.copy(t) : n.set(t, e, i), n.subtract(this.position).normalize(), f.copy(n).cross(s).normalize(), s.copy(f).cross(n).normalize(), this.update(); }, rotate(t, e) { return a(this.direction, e, t), a(this.up, e, t), this.update(); }, rotateAround(t, e, i) { return f.copy(t).subtract(this.position), this.translate(f), this.rotate(e, i), this.translate(f.negate()), this.update(); }, project(t, e) { void 0 === e && (e = new d()); const i = this.viewportWidth; const n = this.viewportHeight; const s = y.NEAR_RANGE; const r = y.FAR_RANGE; return p.set(t.x, t.y, t.z, 1), p.transformMat4(this.combined), p.w === 0 && (p.w = 1), p.x /= p.w, p.y /= p.w, p.z /= p.w, e.x = i / 2 * p.x + (0 + i / 2), e.y = n / 2 * p.y + (0 + n / 2), e.z = (r - s) / 2 * p.z + (r + s) / 2, (e.w === 0 || e.w) && (e.w = 1 / p.w), e; }, unproject(t, e) { void 0 === e && (e = new c()); const i = p.set(0, 0, this.viewportWidth, this.viewportHeight); return e.copy(t).unproject(i, this.invProjectionView); }, getPickRay(t, e) { const i = this.ray.origin.set(t, e, 0); const n = this.ray.direction.set(t, e, 1); const s = p.set(0, 0, this.viewportWidth, this.viewportHeight); const r = this.invProjectionView; return i.unproject(s, r), n.unproject(s, r), n.subtract(i).normalize(), this.ray; }, updateChildren() { for (let t = this.children.entries, e = 0; e < t.length; e++)t[e].project(this); return this; }, update() { return this.updateChildren(); }, updateBillboardMatrix() { const t = g.set(this.direction).negate(); const e = v.set(this.up).cross(t).normalize(); const i = f.set(t).cross(e).normalize(); const n = m.val; n[0] = e.x, n[1] = e.y, n[2] = e.z, n[3] = 0, n[4] = i.x, n[5] = i.y, n[6] = i.z, n[7] = 0, n[8] = t.x, n[9] = t.y, n[10] = t.z, n[11] = 0, n[12] = 0, n[13] = 0, n[14] = 0, n[15] = 1, this.billboardMatrixDirty = !1; }, getPointSize(t, e, i) { void 0 === i && (i = new u()), this.billboardMatrixDirty && this.updateBillboardMatrix(); const n = f; const s = e.x / this.pixelScale / 2; const r = e.y / this.pixelScale / 2; n.set(-s, -r, 0).transformMat4(m).add(t), this.project(n, n); const o = n.x; const a = n.y; n.set(s, r, 0).transformMat4(m).add(t), this.project(n, n); const h = n.x - o; const l = n.y - a; return i.set(h, l); }, destroy() { this.children.clear(), this.scene = void 0, this.children = void 0; }, setX(t) { return this.position.x = t, this.update(); }, setY(t) { return this.position.y = t, this.update(); }, setZ(t) { return this.position.z = t, this.update(); }, x: { get() { return this.position.x; }, set(t) { this.position.x = t, this.update(); } }, y: { get() { return this.position.y; }, set(t) { this.position.y = t, this.update(); } }, z: { get() { return this.position.z; }, set(t) { this.position.z = t, this.update(); } },
  }); y.FAR_RANGE = 1, y.NEAR_RANGE = 0, t.exports = y;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = {
    AlignTo: i(556), Angle: i(557), Call: i(558), GetFirst: i(559), GetLast: i(560), GridAlign: i(561), IncAlpha: i(622), IncX: i(623), IncXY: i(624), IncY: i(625), PlaceOnCircle: i(626), PlaceOnEllipse: i(627), PlaceOnLine: i(628), PlaceOnRectangle: i(629), PlaceOnTriangle: i(630), PlayAnimation: i(631), PropertyValueInc: i(40), PropertyValueSet: i(28), RandomCircle: i(632), RandomEllipse: i(633), RandomLine: i(634), RandomRectangle: i(635), RandomTriangle: i(636), Rotate: i(637), RotateAround: i(638), RotateAroundDistance: i(639), ScaleX: i(640), ScaleXY: i(641), ScaleY: i(642), SetAlpha: i(643), SetBlendMode: i(644), SetDepth: i(645), SetHitArea: i(646), SetOrigin: i(647), SetRotation: i(648), SetScale: i(649), SetScaleX: i(650), SetScaleY: i(651), SetScrollFactor: i(652), SetScrollFactorX: i(653), SetScrollFactorY: i(654), SetTint: i(655), SetVisible: i(656), SetX: i(657), SetXY: i(658), SetY: i(659), ShiftPosition: i(660), Shuffle: i(661), SmootherStep: i(662), SmoothStep: i(663), Spread: i(664), ToggleVisible: i(665), WrapInRectangle: i(666),
  };
}, function (t, e, i) {
/**
 * @author       samme
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(96); const s = []; s[n.BOTTOM_CENTER] = i(266), s[n.BOTTOM_LEFT] = i(267), s[n.BOTTOM_RIGHT] = i(268), s[n.LEFT_BOTTOM] = i(269), s[n.LEFT_CENTER] = i(270), s[n.LEFT_TOP] = i(271), s[n.RIGHT_BOTTOM] = i(272), s[n.RIGHT_CENTER] = i(273), s[n.RIGHT_TOP] = i(274), s[n.TOP_CENTER] = i(275), s[n.TOP_LEFT] = i(276), s[n.TOP_RIGHT] = i(277); t.exports = function (t, e, i, n, r) { return s[i](t, e, n, r); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(46); const s = i(83); const r = i(84); const o = i(47); t.exports = function (t, e, i, a) { return void 0 === i && (i = 0), void 0 === a && (a = 0), r(t, s(e) + i), o(t, n(e) + a), t; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(46); const s = i(48); const r = i(49); const o = i(47); t.exports = function (t, e, i, a) { return void 0 === i && (i = 0), void 0 === a && (a = 0), r(t, s(e) - i), o(t, n(e) + a), t; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(46); const s = i(50); const r = i(51); const o = i(47); t.exports = function (t, e, i, a) { return void 0 === i && (i = 0), void 0 === a && (a = 0), r(t, s(e) + i), o(t, n(e) + a), t; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(46); const s = i(48); const r = i(52); const o = i(51); t.exports = function (t, e, i, a) { return void 0 === i && (i = 0), void 0 === a && (a = 0), o(t, s(e) - i), r(t, n(e) + a), t; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(85); const s = i(48); const r = i(86); const o = i(51); t.exports = function (t, e, i, a) { return void 0 === i && (i = 0), void 0 === a && (a = 0), o(t, s(e) - i), r(t, n(e) + a), t; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(48); const s = i(53); const r = i(51); const o = i(47); t.exports = function (t, e, i, a) { return void 0 === i && (i = 0), void 0 === a && (a = 0), r(t, n(e) - i), o(t, s(e) - a), t; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(46); const s = i(50); const r = i(52); const o = i(49); t.exports = function (t, e, i, a) { return void 0 === i && (i = 0), void 0 === a && (a = 0), o(t, s(e) + i), r(t, n(e) + a), t; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(85); const s = i(50); const r = i(86); const o = i(49); t.exports = function (t, e, i, a) { return void 0 === i && (i = 0), void 0 === a && (a = 0), o(t, s(e) + i), r(t, n(e) + a), t; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(50); const s = i(53); const r = i(49); const o = i(47); t.exports = function (t, e, i, a) { return void 0 === i && (i = 0), void 0 === a && (a = 0), r(t, n(e) + i), o(t, s(e) - a), t; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(83); const s = i(53); const r = i(52); const o = i(84); t.exports = function (t, e, i, a) { return void 0 === i && (i = 0), void 0 === a && (a = 0), o(t, n(e) + i), r(t, s(e) - a), t; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(48); const s = i(53); const r = i(52); const o = i(49); t.exports = function (t, e, i, a) { return void 0 === i && (i = 0), void 0 === a && (a = 0), o(t, n(e) - i), r(t, s(e) - a), t; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(50); const s = i(53); const r = i(52); const o = i(51); t.exports = function (t, e, i, a) { return void 0 === i && (i = 0), void 0 === a && (a = 0), o(t, n(e) + i), r(t, s(e) - a), t; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(96); const s = []; s[n.BOTTOM_CENTER] = i(279), s[n.BOTTOM_LEFT] = i(280), s[n.BOTTOM_RIGHT] = i(281), s[n.CENTER] = i(282), s[n.LEFT_CENTER] = i(284), s[n.RIGHT_CENTER] = i(285), s[n.TOP_CENTER] = i(286), s[n.TOP_LEFT] = i(287), s[n.TOP_RIGHT] = i(288), s[n.LEFT_BOTTOM] = s[n.BOTTOM_LEFT], s[n.LEFT_TOP] = s[n.TOP_LEFT], s[n.RIGHT_BOTTOM] = s[n.BOTTOM_RIGHT], s[n.RIGHT_TOP] = s[n.TOP_RIGHT]; t.exports = function (t, e, i, n, r) { return s[i](t, e, n, r); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(46); const s = i(83); const r = i(52); const o = i(84); t.exports = function (t, e, i, a) { return void 0 === i && (i = 0), void 0 === a && (a = 0), o(t, s(e) + i), r(t, n(e) + a), t; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(46); const s = i(48); const r = i(52); const o = i(49); t.exports = function (t, e, i, a) { return void 0 === i && (i = 0), void 0 === a && (a = 0), o(t, s(e) - i), r(t, n(e) + a), t; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(46); const s = i(50); const r = i(52); const o = i(51); t.exports = function (t, e, i, a) { return void 0 === i && (i = 0), void 0 === a && (a = 0), o(t, s(e) + i), r(t, n(e) + a), t; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(283); const s = i(83); const r = i(85); t.exports = function (t, e, i, o) { return void 0 === i && (i = 0), void 0 === o && (o = 0), n(t, s(e) + i, r(e) + o), t; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(84); const s = i(86); t.exports = function (t, e, i) { return n(t, e), s(t, i); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(85); const s = i(48); const r = i(86); const o = i(49); t.exports = function (t, e, i, a) { return void 0 === i && (i = 0), void 0 === a && (a = 0), o(t, s(e) - i), r(t, n(e) + a), t; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(85); const s = i(50); const r = i(86); const o = i(51); t.exports = function (t, e, i, a) { return void 0 === i && (i = 0), void 0 === a && (a = 0), o(t, s(e) + i), r(t, n(e) + a), t; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(83); const s = i(53); const r = i(84); const o = i(47); t.exports = function (t, e, i, a) { return void 0 === i && (i = 0), void 0 === a && (a = 0), r(t, n(e) + i), o(t, s(e) - a), t; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(48); const s = i(53); const r = i(49); const o = i(47); t.exports = function (t, e, i, a) { return void 0 === i && (i = 0), void 0 === a && (a = 0), r(t, n(e) - i), o(t, s(e) - a), t; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(50); const s = i(53); const r = i(51); const o = i(47); t.exports = function (t, e, i, a) { return void 0 === i && (i = 0), void 0 === a && (a = 0), r(t, n(e) + i), o(t, s(e) - a), t; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(163); const s = i(97); const r = i(16); const o = i(4); t.exports = function (t, e, i) { void 0 === i && (i = new o()); const a = s(e, 0, r.PI2); return n(t, a, i); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(291); const s = i(163); const r = i(97); const o = i(16); t.exports = function (t, e, i, a) { void 0 === a && (a = []), !e && i > 0 && (e = n(t) / i); for (let h = 0; h < e; h++) { const l = r(h / e, 0, o.PI2); a.push(s(t, l)); } return a; };
}, function (t, e) { t.exports = function (t) { return Math.PI * t.radius * 2; }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(20); const s = {
    _alpha: 1, clearAlpha() { return this.setAlpha(1); }, setAlpha(t) { return void 0 === t && (t = 1), this.alpha = t, this; }, alpha: { get() { return this._alpha; }, set(t) { const e = n(t, 0, 1); this._alpha = e, e === 0 ? this.renderFlags &= -3 : this.renderFlags |= 2; } },
  }; t.exports = s;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(165); const s = i(0); const r = i(121); const o = new s({
    initialize(t) { this.parent = t, this.animationManager = t.scene.sys.anims, this.animationManager.once(r.REMOVE_ANIMATION, this.remove, this), this.isPlaying = !1, this.currentAnim = null, this.currentFrame = null, this.nextAnim = null, this._timeScale = 1, this.frameRate = 0, this.duration = 0, this.msPerFrame = 0, this.skipMissedFrames = !0, this._delay = 0, this._repeat = 0, this._repeatDelay = 0, this._yoyo = !1, this.forward = !0, this._reverse = !1, this.accumulator = 0, this.nextTick = 0, this.repeatCounter = 0, this.pendingRepeat = !1, this._paused = !1, this._wasPlaying = !1, this._pendingStop = 0, this._pendingStopValue; }, chain(t) { return t instanceof n && (t = t.key), this.nextAnim = t, this.parent; }, setDelay(t) { return void 0 === t && (t = 0), this._delay = t, this.parent; }, getDelay() { return this._delay; }, delayedPlay(t, e, i) { return this.play(e, !0, i), this.nextTick += t, this.parent; }, getCurrentKey() { if (this.currentAnim) return this.currentAnim.key; }, load(t, e) { return void 0 === e && (e = 0), this.isPlaying && this.stop(), this.animationManager.load(this, t, e), this.parent; }, pause(t) { return this._paused || (this._paused = !0, this._wasPlaying = this.isPlaying, this.isPlaying = !1), void 0 !== t && this.updateFrame(t), this.parent; }, resume(t) { return this._paused && (this._paused = !1, this.isPlaying = this._wasPlaying), void 0 !== t && this.updateFrame(t), this.parent; }, isPaused: { get() { return this._paused; } }, play(t, e, i) { return void 0 === e && (e = !1), void 0 === i && (i = 0), t instanceof n && (t = t.key), e && this.isPlaying && this.currentAnim.key === t ? this.parent : (this.forward = !0, this._reverse = !1, this._paused = !1, this._wasPlaying = !0, this._startAnimation(t, i)); }, playReverse(t, e, i) { return void 0 === e && (e = !1), void 0 === i && (i = 0), t instanceof n && (t = t.key), e && this.isPlaying && this.currentAnim.key === t ? this.parent : (this.forward = !1, this._reverse = !0, this._startAnimation(t, i)); }, _startAnimation(t, e) { this.load(t, e); const i = this.currentAnim; const n = this.parent; if (!i) return n; this.repeatCounter = this._repeat === -1 ? Number.MAX_VALUE : this._repeat, i.getFirstTick(this), this.isPlaying = !0, this.pendingRepeat = !1, i.showOnStart && (n.visible = !0); const s = this.currentFrame; return i.emit(r.ANIMATION_START, i, s, n), n.emit(r.SPRITE_ANIMATION_KEY_START + t, i, s, n), n.emit(r.SPRITE_ANIMATION_START, i, s, n), n; }, reverse() { return this.isPlaying && (this._reverse = !this._reverse, this.forward = !this.forward), this.parent; }, getProgress() { let t = this.currentFrame.progress; return this.forward || (t = 1 - t), t; }, setProgress(t) { return this.forward || (t = 1 - t), this.setCurrentFrame(this.currentAnim.getFrameByProgress(t)), this.parent; }, remove(t, e) { void 0 === e && (e = this.currentAnim), this.isPlaying && e.key === this.currentAnim.key && (this.stop(), this.setCurrentFrame(this.currentAnim.frames[0])); }, getRepeat() { return this._repeat; }, setRepeat(t) { return this._repeat = t, this.repeatCounter = t === -1 ? Number.MAX_VALUE : t, this.parent; }, getRepeatDelay() { return this._repeatDelay; }, setRepeatDelay(t) { return this._repeatDelay = t, this.parent; }, restart(t) { void 0 === t && (t = !1); const e = this.currentAnim; e.getFirstTick(this, t), this.forward = !0, this.isPlaying = !0, this.pendingRepeat = !1, this._paused = !1, this.updateFrame(e.frames[0]); const i = this.parent; const n = this.currentFrame; return e.emit(r.ANIMATION_RESTART, e, n, i), i.emit(r.SPRITE_ANIMATION_KEY_RESTART + e.key, e, n, i), i.emit(r.SPRITE_ANIMATION_RESTART, e, n, i), this.parent; }, stop() { this._pendingStop = 0, this.isPlaying = !1; const t = this.parent; const e = this.currentAnim; const i = this.currentFrame; if (e && (e.emit(r.ANIMATION_COMPLETE, e, i, t), t.emit(r.SPRITE_ANIMATION_KEY_COMPLETE + e.key, e, i, t), t.emit(r.SPRITE_ANIMATION_COMPLETE, e, i, t)), this.nextAnim) { const n = this.nextAnim; this.nextAnim = null, this.play(n); } return t; }, stopAfterDelay(t) { return this._pendingStop = 1, this._pendingStopValue = t, this.parent; }, stopOnRepeat() { return this._pendingStop = 2, this.parent; }, stopOnFrame(t) { return this._pendingStop = 3, this._pendingStopValue = t, this.parent; }, setTimeScale(t) { return void 0 === t && (t = 1), this._timeScale = t, this.parent; }, getTimeScale() { return this._timeScale; }, getTotalFrames() { return this.currentAnim.frames.length; }, update(t, e) { if (this.currentAnim && this.isPlaying && !this.currentAnim.paused) { if (this.accumulator += e * this._timeScale, this._pendingStop === 1 && (this._pendingStopValue -= e, this._pendingStopValue <= 0)) return this.currentAnim.completeAnimation(this); this.accumulator >= this.nextTick && this.currentAnim.setFrame(this); } }, setCurrentFrame(t) { const e = this.parent; return this.currentFrame = t, e.texture = t.frame.texture, e.frame = t.frame, e.isCropped && e.frame.updateCropUVs(e._crop, e.flipX, e.flipY), e.setSizeToFrame(), e._originComponent && (t.frame.customPivot ? e.setOrigin(t.frame.pivotX, t.frame.pivotY) : e.updateDisplayOrigin()), e; }, updateFrame(t) { const e = this.setCurrentFrame(t); if (this.isPlaying) { t.setAlpha && (e.alpha = t.alpha); const i = this.currentAnim; e.emit(r.SPRITE_ANIMATION_KEY_UPDATE + i.key, i, t, e), e.emit(r.SPRITE_ANIMATION_UPDATE, i, t, e), this._pendingStop === 3 && this._pendingStopValue === t && this.currentAnim.completeAnimation(this); } }, nextFrame() { return this.currentAnim && this.currentAnim.nextFrame(this), this.parent; }, previousFrame() { return this.currentAnim && this.currentAnim.previousFrame(this), this.parent; }, setYoyo(t) { return void 0 === t && (t = !1), this._yoyo = t, this.parent; }, getYoyo() { return this._yoyo; }, destroy() { this.animationManager.off(r.REMOVE_ANIMATION, this.remove, this), this.animationManager = null, this.parent = null, this.currentAnim = null, this.currentFrame = null; },
  }); t.exports = o;
}, function (t, e) { t.exports = function (t, e, i) { if (!e.length) return NaN; if (e.length === 1) return e[0]; let n; let s; let r = 1; if (i) { if (t < e[0][i]) return e[0]; for (;e[r][i] < t;)r++; } else for (;e[r] < t;)r++; return r > e.length && (r = e.length), i ? (n = e[r - 1][i], (s = e[r][i]) - t <= t - n ? e[r] : e[r - 1]) : (n = e[r - 1], (s = e[r]) - t <= t - n ? s : n); }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = new (i(0))({ initialize(t, e, i, n) { this.textureKey = t, this.textureFrame = e, this.index = i, this.frame = n, this.isFirst = !1, this.isLast = !1, this.prevFrame = null, this.nextFrame = null, this.duration = 0, this.progress = 0; }, toJSON() { return { key: this.textureKey, frame: this.textureFrame, duration: this.duration }; }, destroy() { this.frame = void 0; } }); t.exports = n;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(45); const s = { _blendMode: n.NORMAL, blendMode: { get() { return this._blendMode; }, set(t) { typeof t === 'string' && (t = n[t]), (t |= 0) >= -1 && (this._blendMode = t); } }, setBlendMode(t) { return this.blendMode = t, this; } }; t.exports = s;
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const i = { _depth: 0, depth: { get() { return this._depth; }, set(t) { this.scene.sys.queueDepthSort(), this._depth = t; } }, setDepth(t) { return void 0 === t && (t = 0), this.depth = t, this; } }; t.exports = i;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(166); const s = i(122); t.exports = function (t, e, i, r) { void 0 === r && (r = []), !e && i > 0 && (e = s(t) / i); for (let o = 0; o < e; o++) { const a = o / e; r.push(n(t, a)); } return r; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(4); t.exports = function (t, e, i) { return void 0 === i && (i = new n()), i.x = t.x1 + (t.x2 - t.x1) * e, i.y = t.y1 + (t.y2 - t.y1) * e, i; };
}, function (t, e) { t.exports = function (t, e, i, n) { const s = Math.cos(n); const r = Math.sin(n); const o = t.x - e; const a = t.y - i; return t.x = o * s - a * r + e, t.y = o * r + a * s + i, t; }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(302); const s = i(303); const r = {
    mask: null, setMask(t) { return this.mask = t, this; }, clearMask(t) { return void 0 === t && (t = !1), t && this.mask && this.mask.destroy(), this.mask = null, this; }, createBitmapMask(t) { return void 0 === t && (this.texture || this.shader) && (t = this), new n(this.scene, t); }, createGeometryMask(t) { return void 0 === t && this.type === 'Graphics' && (t = this), new s(this.scene, t); },
  }; t.exports = r;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(22); const r = new n({
    initialize(t, e) { const i = t.sys.game.renderer; if (this.renderer = i, this.bitmapMask = e, this.maskTexture = null, this.mainTexture = null, this.dirty = !0, this.mainFramebuffer = null, this.maskFramebuffer = null, this.prevFramebuffer = null, this.invertAlpha = !1, this.isStencil = !1, i && i.gl) { const n = i.width; const r = i.height; const o = (n & n - 1) == 0 && (r & r - 1) == 0; const a = i.gl; const h = o ? a.REPEAT : a.CLAMP_TO_EDGE; const l = a.LINEAR; this.mainTexture = i.createTexture2D(0, l, l, h, h, a.RGBA, null, n, r), this.maskTexture = i.createTexture2D(0, l, l, h, h, a.RGBA, null, n, r), this.mainFramebuffer = i.createFramebuffer(n, r, this.mainTexture, !0), this.maskFramebuffer = i.createFramebuffer(n, r, this.maskTexture, !0), t.sys.game.events.on(s.CONTEXT_RESTORED, (function (t) { const e = t.width; const i = t.height; const n = (e & e - 1) == 0 && (i & i - 1) == 0; const s = t.gl; const r = n ? s.REPEAT : s.CLAMP_TO_EDGE; const o = s.LINEAR; this.mainTexture = t.createTexture2D(0, o, o, r, r, s.RGBA, null, e, i), this.maskTexture = t.createTexture2D(0, o, o, r, r, s.RGBA, null, e, i), this.mainFramebuffer = t.createFramebuffer(e, i, this.mainTexture, !0), this.maskFramebuffer = t.createFramebuffer(e, i, this.maskTexture, !0); }), this); } }, setBitmap(t) { this.bitmapMask = t; }, preRenderWebGL(t, e, i) { t.pipelines.BitmapMaskPipeline.beginMask(this, e, i); }, postRenderWebGL(t, e) { t.pipelines.BitmapMaskPipeline.endMask(this, e); }, preRenderCanvas() {}, postRenderCanvas() {}, destroy() { this.bitmapMask = null; const t = this.renderer; t && t.gl && (t.deleteTexture(this.mainTexture), t.deleteTexture(this.maskTexture), t.deleteFramebuffer(this.mainFramebuffer), t.deleteFramebuffer(this.maskFramebuffer)), this.mainTexture = null, this.maskTexture = null, this.mainFramebuffer = null, this.maskFramebuffer = null, this.prevFramebuffer = null, this.renderer = null; },
  }); t.exports = r;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = new (i(0))({
    initialize(t, e) { this.geometryMask = e, this.invertAlpha = !1, this.isStencil = !0, this.level = 0; }, setShape(t) { return this.geometryMask = t, this; }, setInvertAlpha(t) { return void 0 === t && (t = !0), this.invertAlpha = t, this; }, preRenderWebGL(t, e, i) { const n = t.gl; t.flush(), t.maskStack.length === 0 && (n.enable(n.STENCIL_TEST), n.clear(n.STENCIL_BUFFER_BIT), t.maskCount = 0), t.currentCameraMask.mask !== this && (t.currentMask.mask = this), t.maskStack.push({ mask: this, camera: i }), this.applyStencil(t, i, !0), t.maskCount++; }, applyStencil(t, e, i) { const n = t.gl; const s = this.geometryMask; const r = t.maskCount; n.colorMask(!1, !1, !1, !1), i ? (n.stencilFunc(n.EQUAL, r, 255), n.stencilOp(n.KEEP, n.KEEP, n.INCR)) : (n.stencilFunc(n.EQUAL, r + 1, 255), n.stencilOp(n.KEEP, n.KEEP, n.DECR)), s.renderWebGL(t, s, 0, e), t.flush(), n.colorMask(!0, !0, !0, !0), n.stencilOp(n.KEEP, n.KEEP, n.KEEP), i ? this.invertAlpha ? n.stencilFunc(n.NOTEQUAL, r + 1, 255) : n.stencilFunc(n.EQUAL, r + 1, 255) : this.invertAlpha ? n.stencilFunc(n.NOTEQUAL, r, 255) : n.stencilFunc(n.EQUAL, r, 255); }, postRenderWebGL(t) { const e = t.gl; if (t.maskStack.pop(), t.maskCount--, t.maskStack.length === 0)t.flush(), t.currentMask.mask = null, e.disable(e.STENCIL_TEST); else { t.flush(); const i = t.maskStack[t.maskStack.length - 1]; i.mask.applyStencil(t, i.camera, !1), t.currentCameraMask.mask !== i.mask ? (t.currentMask.mask = i.mask, t.currentMask.camera = i.camera) : t.currentMask.mask = null; } }, preRenderCanvas(t, e, i) { const n = this.geometryMask; t.currentContext.save(), n.renderCanvas(t, n, 0, i, null, null, !0), t.currentContext.clip(); }, postRenderCanvas(t) { t.currentContext.restore(); }, destroy() { this.geometryMask = null; },
  }); t.exports = n;
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const i = { scrollFactorX: 1, scrollFactorY: 1, setScrollFactor(t, e) { return void 0 === e && (e = t), this.scrollFactorX = t, this.scrollFactorY = e, this; } }; t.exports = i;
}, function (t, e) {
  t.exports = function (t) {
    const e = {
      name: t.name, type: t.type, x: t.x, y: t.y, depth: t.depth, scale: { x: t.scaleX, y: t.scaleY }, origin: { x: t.originX, y: t.originY }, flipX: t.flipX, flipY: t.flipY, rotation: t.rotation, alpha: t.alpha, visible: t.visible, blendMode: t.blendMode, textureKey: '', frameKey: '', data: {},
    }; return t.texture && (e.textureKey = t.texture.key, e.frameKey = t.frame.name), e;
  };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(16); const s = i(33); const r = i(170); const o = i(171); const a = {
    _scaleX: 1, _scaleY: 1, _rotation: 0, x: 0, y: 0, z: 0, w: 0, scale: { get() { return (this._scaleX + this._scaleY) / 2; }, set(t) { this._scaleX = t, this._scaleY = t, t === 0 ? this.renderFlags &= -5 : this.renderFlags |= 4; } }, scaleX: { get() { return this._scaleX; }, set(t) { this._scaleX = t, t === 0 ? this.renderFlags &= -5 : this.renderFlags |= 4; } }, scaleY: { get() { return this._scaleY; }, set(t) { this._scaleY = t, t === 0 ? this.renderFlags &= -5 : this.renderFlags |= 4; } }, angle: { get() { return o(this._rotation * n.RAD_TO_DEG); }, set(t) { this.rotation = o(t) * n.DEG_TO_RAD; } }, rotation: { get() { return this._rotation; }, set(t) { this._rotation = r(t); } }, setPosition(t, e, i, n) { return void 0 === t && (t = 0), void 0 === e && (e = t), void 0 === i && (i = 0), void 0 === n && (n = 0), this.x = t, this.y = e, this.z = i, this.w = n, this; }, setRandomPosition(t, e, i, n) { return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = this.scene.sys.scale.width), void 0 === n && (n = this.scene.sys.scale.height), this.x = t + Math.random() * i, this.y = e + Math.random() * n, this; }, setRotation(t) { return void 0 === t && (t = 0), this.rotation = t, this; }, setAngle(t) { return void 0 === t && (t = 0), this.angle = t, this; }, setScale(t, e) { return void 0 === t && (t = 1), void 0 === e && (e = t), this.scaleX = t, this.scaleY = e, this; }, setX(t) { return void 0 === t && (t = 0), this.x = t, this; }, setY(t) { return void 0 === t && (t = 0), this.y = t, this; }, setZ(t) { return void 0 === t && (t = 0), this.z = t, this; }, setW(t) { return void 0 === t && (t = 0), this.w = t, this; }, getLocalTransformMatrix(t) { return void 0 === t && (t = new s()), t.applyITRS(this.x, this.y, this._rotation, this._scaleX, this._scaleY); }, getWorldTransformMatrix(t, e) { void 0 === t && (t = new s()), void 0 === e && (e = new s()); let i = this.parentContainer; if (!i) return this.getLocalTransformMatrix(t); for (t.applyITRS(this.x, this.y, this._rotation, this._scaleX, this._scaleY); i;)e.applyITRS(i.x, i.y, i._rotation, i._scaleX, i._scaleY), e.multiply(t, t), i = i.parentContainer; return t; }, getParentRotation() { for (var t = 0, e = this.parentContainer; e;)t += e.rotation, e = e.parentContainer; return t; },
  }; t.exports = a;
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const i = { _visible: !0, visible: { get() { return this._visible; }, set(t) { t ? (this._visible = !0, this.renderFlags |= 1) : (this._visible = !1, this.renderFlags &= -2); } }, setVisible(t) { return this.visible = t, this; } }; t.exports = i;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = {
    CHANGE_DATA: i(607), CHANGE_DATA_KEY: i(608), REMOVE_DATA: i(609), SET_DATA: i(610),
  };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(122); const s = i(4); t.exports = function (t, e, i, r) { if (void 0 === r && (r = []), !e && !i) return r; e ? i = Math.round(n(t) / e) : e = n(t) / i; for (let o = t.x, a = t.y, h = 0, l = 0; l < i; l++) switch (r.push(new s(o, a)), h) { case 0: (o += e) >= t.right && (h = 1, a += o - t.right, o = t.right); break; case 1: (a += e) >= t.bottom && (h = 2, o -= a - t.bottom, a = t.bottom); break; case 2: (o -= e) <= t.left && (h = 3, a -= t.left - o, o = t.left); break; case 3: (a -= e) <= t.top && (h = 0, a = t.top); } return r; };
}, function (t, e) { t.exports = function (t, e) { void 0 === e && (e = 1); for (var i = null, n = 0; n < e; n++)i = t.shift(), t.push(i); return i; }; }, function (t, e) { t.exports = function (t, e) { void 0 === e && (e = 1); for (var i = null, n = 0; n < e; n++)i = t.pop(), t.unshift(i); return i; }; }, function (t, e) { t.exports = function (t, e, i) { void 0 === e && (e = 1), void 0 === i && (i = []); let n = Math.round(t.x1); let s = Math.round(t.y1); const r = Math.round(t.x2); const o = Math.round(t.y2); const a = Math.abs(r - n); const h = Math.abs(o - s); const l = n < r ? 1 : -1; const u = s < o ? 1 : -1; let c = a - h; i.push({ x: n, y: s }); for (let d = 1; n !== r || s !== o;) { const f = c << 1; f > -h && (c -= h, n += l), f < a && (c += a, s += u), d % e == 0 && i.push({ x: n, y: s }), d++; } return i; }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(165); const s = i(0); const r = i(177); const o = i(10); const a = i(121); const h = i(22); const l = i(6); const u = i(178); const c = new s({
    Extends: o, initialize(t) { o.call(this), this.game = t, this.textureManager = null, this.globalTimeScale = 1, this.anims = new r(), this.paused = !1, this.name = 'AnimationManager', t.events.once(h.BOOT, this.boot, this); }, boot() { this.textureManager = this.game.textures, this.game.events.once(h.DESTROY, this.destroy, this); }, add(t, e) { return this.anims.has(t) ? (console.warn(`Animation key exists: ${t}`), this) : (e.key = t, this.anims.set(t, e), this.emit(a.ADD_ANIMATION, t, e), this); }, exists(t) { return this.anims.has(t); }, create(t) { const e = t.key; let i = !1; return e && ((i = this.get(e)) || (i = new n(this, e, t), this.anims.set(e, i), this.emit(a.ADD_ANIMATION, e, i))), i; }, fromJSON(t, e) { void 0 === e && (e = !1), e && this.anims.clear(), typeof t === 'string' && (t = JSON.parse(t)); const i = []; if (t.hasOwnProperty('anims') && Array.isArray(t.anims)) { for (let n = 0; n < t.anims.length; n++)i.push(this.create(t.anims[n])); t.hasOwnProperty('globalTimeScale') && (this.globalTimeScale = t.globalTimeScale); } else t.hasOwnProperty('key') && t.type === 'frame' && i.push(this.create(t)); return i; }, generateFrameNames(t, e) { const i = l(e, 'prefix', ''); const n = l(e, 'start', 0); let s = l(e, 'end', 0); const r = l(e, 'suffix', ''); const o = l(e, 'zeroPad', 0); const a = l(e, 'outputArray', []); let h = l(e, 'frames', !1); const c = this.textureManager.get(t); if (!c) return a; let d; let f; const p = n < s ? 1 : -1; if (s += p, e) if (Array.isArray(h)) for (d = 0; d < h.length; d++)f = i + u(h[d], o, '0', 1) + r, c.has(f) && a.push({ key: t, frame: f }); else for (d = n; d !== s; d += p)f = i + u(d, o, '0', 1) + r, c.has(f) && a.push({ key: t, frame: f }); else for (h = c.getFrameNames(), d = 0; d < h.length; d++)a.push({ key: t, frame: h[d] }); return a; }, generateFrameNumbers(t, e) { let i; const n = l(e, 'start', 0); let s = l(e, 'end', -1); const r = l(e, 'first', !1); const o = l(e, 'outputArray', []); const a = l(e, 'frames', !1); const h = this.textureManager.get(t); if (!h) return o; if (r && h.has(r) && o.push({ key: t, frame: r }), Array.isArray(a)) for (i = 0; i < a.length; i++)h.has(a[i]) && o.push({ key: t, frame: a[i] }); else { s === -1 && (s = h.frameTotal); const u = n < s ? 1 : -1; for (s += u, i = n; i !== s; i += u)h.has(i) && o.push({ key: t, frame: i }); } return o; }, get(t) { return this.anims.get(t); }, load(t, e, i) { const n = this.get(e); return n ? n.load(t, i) : console.warn(`Missing animation: ${e}`), t; }, pauseAll() { return this.paused || (this.paused = !0, this.emit(a.PAUSE_ALL)), this; }, play(t, e) { if (Array.isArray(e) || (e = [e]), !this.get(t)) return this; for (let i = 0; i < e.length; i++)e[i].anims.play(t); return this; }, remove(t) { const e = this.get(t); return e && (this.emit(a.REMOVE_ANIMATION, t, e), this.anims.delete(t)), e; }, resumeAll() { return this.paused && (this.paused = !1, this.emit(a.RESUME_ALL)), this; }, staggerPlay(t, e, i) { if (void 0 === i && (i = 0), Array.isArray(e) || (e = [e]), !this.get(t)) return this; for (let n = 0; n < e.length; n++)e[n].anims.delayedPlay(i * n, t); return this; }, toJSON(t) { const e = { anims: [], globalTimeScale: this.globalTimeScale }; return void 0 !== t && t !== '' ? e.anims.push(this.anims.get(t).toJSON()) : this.anims.each(((t, i) => { e.anims.push(i.toJSON()); })), e; }, destroy() { this.anims.clear(), this.textureManager = null, this.game = null; },
  }); t.exports = c;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(177); const r = i(10); const o = i(315); const a = new n({
    initialize() { this.entries = new s(), this.events = new r(); }, add(t, e) { return this.entries.set(t, e), this.events.emit(o.ADD, this, t, e), this; }, has(t) { return this.entries.has(t); }, exists(t) { return this.entries.has(t); }, get(t) { return this.entries.get(t); }, remove(t) { const e = this.get(t); return e && (this.entries.delete(t), this.events.emit(o.REMOVE, this, t, e.data)), this; }, getKeys() { return this.entries.keys(); }, destroy() { this.entries.clear(), this.events.removeAllListeners(), this.entries = null, this.events = null; },
  }); t.exports = a;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = { ADD: i(669), REMOVE: i(670) };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(314); const s = i(0); const r = i(22); const o = new s({ initialize(t) { this.game = t, this.binary = new n(), this.bitmapFont = new n(), this.json = new n(), this.physics = new n(), this.shader = new n(), this.audio = new n(), this.video = new n(), this.text = new n(), this.html = new n(), this.obj = new n(), this.tilemap = new n(), this.xml = new n(), this.custom = {}, this.game.events.once(r.DESTROY, this.destroy, this); }, addCustom(t) { return this.custom.hasOwnProperty(t) || (this.custom[t] = new n()), this.custom[t]; }, destroy() { for (let t = ['binary', 'bitmapFont', 'json', 'physics', 'shader', 'audio', 'video', 'text', 'html', 'obj', 'tilemap', 'xml'], e = 0; e < t.length; e++) this[t[e]].destroy(), this[t[e]] = null; for (const i in this.custom) this.custom[i].destroy(); this.custom = null, this.game = null; } }); t.exports = o;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(103); const s = i(30); const r = i(183); const o = i(20); const a = i(0); const h = i(13); const l = i(325); const u = i(126); const c = i(12); const d = i(3); const f = new a({
    Extends: n, Mixins: [h.Flip, h.Tint], initialize(t, e, i, s) { n.call(this, t, e, i, s), this.inputEnabled = !0, this.fadeEffect = new l.Fade(this), this.flashEffect = new l.Flash(this), this.shakeEffect = new l.Shake(this), this.panEffect = new l.Pan(this), this.rotateToEffect = new l.RotateTo(this), this.zoomEffect = new l.Zoom(this), this.lerp = new d(1, 1), this.followOffset = new d(), this.deadzone = null, this._follow = null, this.renderToTexture = !1, this.renderToGame = !0, this.canvas = null, this.context = null, this.glTexture = null, this.framebuffer = null, this.pipeline = null; }, setRenderToTexture(t, e) { void 0 === e && (e = !0); const i = this.scene.sys.game.renderer; return i.gl ? (this.glTexture = i.createTextureFromSource(null, this.width, this.height, 0), this.framebuffer = i.createFramebuffer(this.width, this.height, this.glTexture, !1)) : (this.canvas = s.create2D(this, this.width, this.height), this.context = this.canvas.getContext('2d')), this.renderToTexture = !0, this.renderToGame = e, t && this.setPipeline(t), this; }, setPipeline(t) { if (typeof t === 'string') { const e = this.scene.sys.game.renderer; e.gl && e.hasPipeline(t) && (this.pipeline = e.getPipeline(t)); } else this.pipeline = t; return this; }, clearRenderToTexture() { if (this.scene) { const t = this.scene.sys.game.renderer; if (t) return t.gl ? (this.framebuffer && t.deleteFramebuffer(this.framebuffer), this.glTexture && t.deleteTexture(this.glTexture), this.framebuffer = null, this.glTexture = null, this.pipeline = null) : (s.remove(this), this.canvas = null, this.context = null), this.renderToTexture = !1, this; } }, setDeadzone(t, e) { if (void 0 === t) this.deadzone = null; else { if (this.deadzone ? (this.deadzone.width = t, this.deadzone.height = e) : this.deadzone = new c(0, 0, t, e), this._follow) { const i = this.width / 2; const n = this.height / 2; const s = this._follow.x - this.followOffset.x; const o = this._follow.y - this.followOffset.y; this.midPoint.set(s, o), this.scrollX = s - i, this.scrollY = o - n; }r(this.deadzone, this.midPoint.x, this.midPoint.y); } return this; }, fadeIn(t, e, i, n, s, r) { return this.fadeEffect.start(!1, t, e, i, n, !0, s, r); }, fadeOut(t, e, i, n, s, r) { return this.fadeEffect.start(!0, t, e, i, n, !0, s, r); }, fadeFrom(t, e, i, n, s, r, o) { return this.fadeEffect.start(!1, t, e, i, n, s, r, o); }, fade(t, e, i, n, s, r, o) { return this.fadeEffect.start(!0, t, e, i, n, s, r, o); }, flash(t, e, i, n, s, r, o) { return this.flashEffect.start(t, e, i, n, s, r, o); }, shake(t, e, i, n, s) { return this.shakeEffect.start(t, e, i, n, s); }, pan(t, e, i, n, s, r, o) { return this.panEffect.start(t, e, i, n, s, r, o); }, rotateTo(t, e, i, n, s, r, o) { return this.rotateToEffect.start(t, e, i, n, s, r, o); }, zoomTo(t, e, i, n, s, r) { return this.zoomEffect.start(t, e, i, n, s, r); }, preRender(t) { const e = this.width; const i = this.height; const n = 0.5 * e; const s = 0.5 * i; const o = this.zoom * t; const a = this.matrix; let h = e * this.originX; let l = i * this.originY; const c = this._follow; const d = this.deadzone; let f = this.scrollX; let p = this.scrollY; if (d && r(d, this.midPoint.x, this.midPoint.y), c && !this.panEffect.isRunning) { const g = c.x - this.followOffset.x; const v = c.y - this.followOffset.y; d ? (g < d.x ? f = u(f, f - (d.x - g), this.lerp.x) : g > d.right && (f = u(f, f + (g - d.right), this.lerp.x)), v < d.y ? p = u(p, p - (d.y - v), this.lerp.y) : v > d.bottom && (p = u(p, p + (v - d.bottom), this.lerp.y))) : (f = u(f, g - h, this.lerp.x), p = u(p, v - l, this.lerp.y)); } this.useBounds && (f = this.clampX(f), p = this.clampY(p)), this.roundPixels && (h = Math.round(h), l = Math.round(l)), this.scrollX = f, this.scrollY = p; const m = f + n; const y = p + s; this.midPoint.set(m, y); const x = e / o; const T = i / o; this.worldView.setTo(m - x / 2, y - T / 2, x, T), a.applyITRS(this.x + h, this.y + l, this.rotation, o, o), a.translate(-h, -l), this.shakeEffect.preRender(); }, setLerp(t, e) { return void 0 === t && (t = 1), void 0 === e && (e = t), this.lerp.set(t, e), this; }, setFollowOffset(t, e) { return void 0 === t && (t = 0), void 0 === e && (e = 0), this.followOffset.set(t, e), this; }, startFollow(t, e, i, n, s, r) { void 0 === e && (e = !1), void 0 === i && (i = 1), void 0 === n && (n = i), void 0 === s && (s = 0), void 0 === r && (r = s), this._follow = t, this.roundPixels = e, i = o(i, 0, 1), n = o(n, 0, 1), this.lerp.set(i, n), this.followOffset.set(s, r); const a = this.width / 2; const h = this.height / 2; const l = t.x - s; const u = t.y - r; return this.midPoint.set(l, u), this.scrollX = l - a, this.scrollY = u - h, this.useBounds && (this.scrollX = this.clampX(this.scrollX), this.scrollY = this.clampY(this.scrollY)), this; }, stopFollow() { return this._follow = null, this; }, resetFX() { return this.rotateToEffect.reset(), this.panEffect.reset(), this.shakeEffect.reset(), this.flashEffect.reset(), this.fadeEffect.reset(), this; }, update(t, e) { this.visible && (this.rotateToEffect.update(t, e), this.panEffect.update(t, e), this.zoomEffect.update(t, e), this.shakeEffect.update(t, e), this.flashEffect.update(t, e), this.fadeEffect.update(t, e)); }, destroy() { this.clearRenderToTexture(), this.resetFX(), n.prototype.destroy.call(this), this._follow = null, this.deadzone = null; },
  }); t.exports = f;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(35); t.exports = function (t) { const e = new n(); t = t.replace(/^(?:#|0x)?([a-f\d])([a-f\d])([a-f\d])$/i, ((t, e, i, n) => e + e + i + i + n + n)); const i = /^(?:#|0x)?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(t); if (i) { const s = parseInt(i[1], 16); const r = parseInt(i[2], 16); const o = parseInt(i[3], 16); e.setTo(s, r, o); } return e; };
}, function (t, e) { t.exports = function (t, e, i, n) { return n << 24 | t << 16 | e << 8 | i; }; }, function (t, e) { t.exports = function (t, e, i, n) { void 0 === n && (n = { h: 0, s: 0, v: 0 }), t /= 255, e /= 255, i /= 255; const s = Math.min(t, e, i); const r = Math.max(t, e, i); const o = r - s; let a = 0; const h = r === 0 ? 0 : o / r; const l = r; return r !== s && (r === t ? a = (e - i) / o + (e < i ? 6 : 0) : r === e ? a = (i - t) / o + 2 : r === i && (a = (t - e) / o + 4), a /= 6), n.hasOwnProperty('_h') ? (n._h = a, n._s = h, n._v = l) : (n.h = a, n.s = h, n.v = l), n; }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(35); const s = i(322); t.exports = function (t) { const e = s(t); return new n(e.r, e.g, e.b, e.a); };
}, function (t, e) {
  t.exports = function (t) {
    return t > 16777215 ? {
      a: t >>> 24, r: t >> 16 & 255, g: t >> 8 & 255, b: 255 & t,
    } : {
      a: 255, r: t >> 16 & 255, g: t >> 8 & 255, b: 255 & t,
    };
  };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(35); t.exports = function (t) { return new n(t.r, t.g, t.b, t.a); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(35); t.exports = function (t) {
    const e = new n(); const
      i = /^rgba?\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d+(?:\.\d+)?))?\s*\)$/.exec(t.toLowerCase()); if (i) { const s = parseInt(i[1], 10); const r = parseInt(i[2], 10); const o = parseInt(i[3], 10); const a = void 0 !== i[4] ? parseFloat(i[4]) : 1; e.setTo(s, r, o, 255 * a); } return e;
  };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = {
    Fade: i(693), Flash: i(694), Pan: i(695), Shake: i(728), RotateTo: i(729), Zoom: i(730),
  };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = { In: i(696), Out: i(697), InOut: i(698) };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = { In: i(699), Out: i(700), InOut: i(701) };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = { In: i(702), Out: i(703), InOut: i(704) };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = { In: i(705), Out: i(706), InOut: i(707) };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = { In: i(708), Out: i(709), InOut: i(710) };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = { In: i(711), Out: i(712), InOut: i(713) };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = i(714);
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = { In: i(715), Out: i(716), InOut: i(717) };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = { In: i(718), Out: i(719), InOut: i(720) };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = { In: i(721), Out: i(722), InOut: i(723) };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = { In: i(724), Out: i(725), InOut: i(726) };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = i(727);
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(39); const r = i(339); const o = i(2); const a = i(6); const h = i(8); const l = i(185); const u = i(1); const c = i(190); const d = i(179); const f = new n({ initialize(t) { void 0 === t && (t = {}); this.width = a(t, 'width', 1024), this.height = a(t, 'height', 768), this.zoom = a(t, 'zoom', 1), this.resolution = a(t, 'resolution', 1), this.parent = a(t, 'parent', void 0), this.scaleMode = a(t, 'scaleMode', 0), this.expandParent = a(t, 'expandParent', !0), this.autoRound = a(t, 'autoRound', !1), this.autoCenter = a(t, 'autoCenter', 0), this.resizeInterval = a(t, 'resizeInterval', 500), this.fullscreenTarget = a(t, 'fullscreenTarget', null), this.minWidth = a(t, 'minWidth', 0), this.maxWidth = a(t, 'maxWidth', 0), this.minHeight = a(t, 'minHeight', 0), this.maxHeight = a(t, 'maxHeight', 0); const e = a(t, 'scale', null); e && (this.width = a(e, 'width', this.width), this.height = a(e, 'height', this.height), this.zoom = a(e, 'zoom', this.zoom), this.resolution = a(e, 'resolution', this.resolution), this.parent = a(e, 'parent', this.parent), this.scaleMode = a(e, 'mode', this.scaleMode), this.expandParent = a(e, 'expandParent', this.expandParent), this.autoRound = a(e, 'autoRound', this.autoRound), this.autoCenter = a(e, 'autoCenter', this.autoCenter), this.resizeInterval = a(e, 'resizeInterval', this.resizeInterval), this.fullscreenTarget = a(e, 'fullscreenTarget', this.fullscreenTarget), this.minWidth = a(e, 'min.width', this.minWidth), this.maxWidth = a(e, 'max.width', this.maxWidth), this.minHeight = a(e, 'min.height', this.minHeight), this.maxHeight = a(e, 'max.height', this.maxHeight)), this.renderType = a(t, 'type', s.AUTO), this.canvas = a(t, 'canvas', null), this.context = a(t, 'context', null), this.canvasStyle = a(t, 'canvasStyle', null), this.customEnvironment = a(t, 'customEnvironment', !1), this.sceneConfig = a(t, 'scene', null), this.seed = a(t, 'seed', [(Date.now() * Math.random()).toString()]), l.RND = new l.RandomDataGenerator(this.seed), this.gameTitle = a(t, 'title', ''), this.gameURL = a(t, 'url', 'https://phaser.io'), this.gameVersion = a(t, 'version', ''), this.autoFocus = a(t, 'autoFocus', !0), this.domCreateContainer = a(t, 'dom.createContainer', !1), this.domBehindCanvas = a(t, 'dom.behindCanvas', !1), this.inputKeyboard = a(t, 'input.keyboard', !0), this.inputKeyboardEventTarget = a(t, 'input.keyboard.target', window), this.inputKeyboardCapture = a(t, 'input.keyboard.capture', []), this.inputMouse = a(t, 'input.mouse', !0), this.inputMouseEventTarget = a(t, 'input.mouse.target', null), this.inputMouseCapture = a(t, 'input.mouse.capture', !0), this.inputTouch = a(t, 'input.touch', r.input.touch), this.inputTouchEventTarget = a(t, 'input.touch.target', null), this.inputTouchCapture = a(t, 'input.touch.capture', !0), this.inputActivePointers = a(t, 'input.activePointers', 1), this.inputSmoothFactor = a(t, 'input.smoothFactor', 0), this.inputWindowEvents = a(t, 'input.windowEvents', !0), this.inputGamepad = a(t, 'input.gamepad', !1), this.inputGamepadEventTarget = a(t, 'input.gamepad.target', window), this.disableContextMenu = a(t, 'disableContextMenu', !1), this.audio = a(t, 'audio'), this.hideBanner = !1 === a(t, 'banner', null), this.hidePhaser = a(t, 'banner.hidePhaser', !1), this.bannerTextColor = a(t, 'banner.text', '#ffffff'), this.bannerBackgroundColor = a(t, 'banner.background', ['#ff0000', '#ffff00', '#00ff00', '#00ffff', '#000000']), this.gameTitle === '' && this.hidePhaser && (this.hideBanner = !0), this.fps = a(t, 'fps', null); const i = a(t, 'render', t); this.antialias = a(i, 'antialias', !0), this.antialiasGL = a(i, 'antialiasGL', !0), this.mipmapFilter = a(i, 'mipmapFilter', 'LINEAR'), this.desynchronized = a(i, 'desynchronized', !1), this.roundPixels = a(i, 'roundPixels', !1), this.pixelArt = a(i, 'pixelArt', this.zoom !== 1), this.pixelArt && (this.antialias = !1, this.roundPixels = !0), this.transparent = a(i, 'transparent', !1), this.clearBeforeRender = a(i, 'clearBeforeRender', !0), this.premultipliedAlpha = a(i, 'premultipliedAlpha', !0), this.failIfMajorPerformanceCaveat = a(i, 'failIfMajorPerformanceCaveat', !1), this.powerPreference = a(i, 'powerPreference', 'default'), this.batchSize = a(i, 'batchSize', 2e3), this.maxLights = a(i, 'maxLights', 10); const n = a(t, 'backgroundColor', 0); this.backgroundColor = d(n), n === 0 && this.transparent && (this.backgroundColor.alpha = 0), this.preBoot = a(t, 'callbacks.preBoot', u), this.postBoot = a(t, 'callbacks.postBoot', u), this.physics = a(t, 'physics', {}), this.defaultPhysicsSystem = a(this.physics, 'default', !1), this.loaderBaseURL = a(t, 'loader.baseURL', ''), this.loaderPath = a(t, 'loader.path', ''), this.loaderMaxParallelDownloads = a(t, 'loader.maxParallelDownloads', 32), this.loaderCrossOrigin = a(t, 'loader.crossOrigin', void 0), this.loaderResponseType = a(t, 'loader.responseType', ''), this.loaderAsync = a(t, 'loader.async', !0), this.loaderUser = a(t, 'loader.user', ''), this.loaderPassword = a(t, 'loader.password', ''), this.loaderTimeout = a(t, 'loader.timeout', 0), this.loaderWithCredentials = a(t, 'loader.withCredentials', !1), this.installGlobalPlugins = [], this.installScenePlugins = []; const f = a(t, 'plugins', null); let p = c.DefaultScene; f && (Array.isArray(f) ? this.defaultPlugins = f : h(f) && (this.installGlobalPlugins = o(f, 'global', []), this.installScenePlugins = o(f, 'scene', []), Array.isArray(f.default) ? p = f.default : Array.isArray(f.defaultMerge) && (p = p.concat(f.defaultMerge)))), this.defaultPlugins = p; const g = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAg'; this.defaultImage = a(t, 'images.default', `${g}AQMAAABJtOi3AAAAA1BMVEX///+nxBvIAAAAAXRSTlMAQObYZgAAABVJREFUeF7NwIEAAAAAgKD9qdeocAMAoAABm3DkcAAAAABJRU5ErkJggg==`), this.missingImage = a(t, 'images.missing', `${g}CAIAAAD8GO2jAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAJ9JREFUeNq01ssOwyAMRFG46v//Mt1ESmgh+DFmE2GPOBARKb2NVjo+17PXLD8a1+pl5+A+wSgFygymWYHBb0FtsKhJDdZlncG2IzJ4ayoMDv20wTmSMzClEgbWYNTAkQ0Z+OJ+A/eWnAaR9+oxCF4Os0H8htsMUp+pwcgBBiMNnAwF8GqIgL2hAzaGFFgZauDPKABmowZ4GL369/0rwACp2yA/ttmvsQAAAABJRU5ErkJggg==`), window && (window.FORCE_WEBGL ? this.renderType = s.WEBGL : window.FORCE_CANVAS && (this.renderType = s.CANVAS)); } }); t.exports = f;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = {
    os: i(127), browser: i(128), features: i(184), input: i(759), audio: i(760), video: i(761), fullscreen: i(762), canvasFeatures: i(340),
  };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  let n; let s; let r; const o = i(30); const a = { supportInverseAlpha: !1, supportNewBlendModes: !1 }; t.exports = (void 0 !== document && (a.supportNewBlendModes = (n = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAABAQMAAADD8p2OAAAAA1BMVEX/', s = 'AAAACklEQVQI12NgAAAAAgAB4iG8MwAAAABJRU5ErkJggg==', (r = new Image()).onload = function () { const t = new Image(); t.onload = function () { const e = o.create(t, 6, 1).getContext('2d'); if (e.globalCompositeOperation = 'multiply', e.drawImage(r, 0, 0), e.drawImage(t, 2, 0), !e.getImageData(2, 0, 1, 1)) return !1; const i = e.getImageData(2, 0, 1, 1).data; o.remove(t), a.supportNewBlendModes = i[0] === 255 && i[1] === 0 && i[2] === 0; }, t.src = `${n}/wCKxvRF${s}`; }, r.src = `${n}AP804Oa6${s}`, !1), a.supportInverseAlpha = (function () { const t = o.create(this, 2, 1).getContext('2d'); t.fillStyle = 'rgba(10, 20, 30, 0.5)', t.fillRect(0, 0, 1, 1); const e = t.getImageData(0, 0, 1, 1); if (e === null) return !1; t.putImageData(e, 1, 0); const i = t.getImageData(1, 0, 1, 1); return i.data[0] === e.data[0] && i.data[1] === e.data[1] && i.data[2] === e.data[2] && i.data[3] === e.data[3]; }())), a);
}, function (t, e) { t.exports = function (t, e, i, n) { return Math.atan2(n - e, i - t); }; }, function (t, e) { t.exports = function (t) { return (t %= 2 * Math.PI) >= 0 ? t : t + 2 * Math.PI; }; }, function (t, e) { t.exports = function (t, e) { const i = t.x - e.x; const n = t.y - e.y; return Math.sqrt(i * i + n * n); }; }, function (t, e) { t.exports = function (t, e, i, n) { const s = t - i; const r = e - n; return s * s + r * r; }; }, function (t, e) { t.exports = function (t, e, i) { return void 0 === i && (i = 1e-4), t > e - i; }; }, function (t, e) { t.exports = function (t, e, i) { return void 0 === i && (i = 1e-4), t < e + i; }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(348); t.exports = function (t, e) { return n(t) / n(e) / n(t - e); };
}, function (t, e) { t.exports = function (t) { if (t === 0) return 1; for (var e = t; --t;)e *= t; return e; }; }, function (t, e) {
  t.exports = function (t, e, i, n, s) {
    /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
    return (function (t, e) { const i = 1 - t; return i * i * i * e; }(t, e)) + (function (t, e) { const i = 1 - t; return 3 * i * i * t * e; }(t, i)) + (function (t, e) { return 3 * (1 - t) * t * t * e; }(t, n)) + (function (t, e) { return t * t * t * e; }(t, s));
  };
}, function (t, e) {
  t.exports = function (t, e, i, n) {
    /**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
    return (function (t, e) { const i = 1 - t; return i * i * e; }(t, e)) + (function (t, e) { return 2 * (1 - t) * t * e; }(t, i)) + (function (t, e) { return t * t * e; }(t, n));
  };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(176); t.exports = function (t, e, i) { return e + (i - e) * n(t, 0, 1); };
}, function (t, e) { t.exports = function (t) { const e = Math.log(t) / 0.6931471805599453; return 1 << Math.ceil(e); }; }, function (t, e) { t.exports = function (t, e, i, n) { return void 0 === i && (i = 0), e === 0 ? t : (t -= i, t = e * Math.ceil(t / e), n ? (i + t) / e : i + t); }; }, function (t, e) { t.exports = function (t, e) { void 0 === e && (e = 1); const i = 2 * Math.random() * Math.PI; const n = 2 * Math.random() - 1; const s = Math.sqrt(1 - n * n) * e; return t.x = Math.cos(i) * s, t.y = Math.sin(i) * s, t.z = n * e, t; }; }, function (t, e) { t.exports = function (t, e) { return void 0 === e && (e = 1), t.x = (2 * Math.random() - 1) * e, t.y = (2 * Math.random() - 1) * e, t.z = (2 * Math.random() - 1) * e, t.w = (2 * Math.random() - 1) * e, t; }; }, function (t, e) { t.exports = function (t, e) { const i = t.x; const n = t.y; return t.x = i * Math.cos(e) - n * Math.sin(e), t.y = i * Math.sin(e) + n * Math.cos(e), t; }; }, function (t, e) { t.exports = function (t) { return t > 0 ? Math.ceil(t) : Math.floor(t); }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(3); t.exports = function (t, e, i, s, r, o, a, h) { void 0 === h && (h = new n()); const l = Math.sin(r); const u = Math.cos(r); const c = u * o; const d = l * o; const f = -l * a; const p = u * a; const g = 1 / (c * p + f * -d); return h.x = p * g * t + -f * g * e + (s * f - i * p) * g, h.y = c * g * e + -d * g * t + (-s * c + i * d) * g, h; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  var n = new (i(0))({
    initialize(t) { this.val = new Float32Array(9), t ? this.copy(t) : this.identity(); }, clone() { return new n(this); }, set(t) { return this.copy(t); }, copy(t) { const e = this.val; const i = t.val; return e[0] = i[0], e[1] = i[1], e[2] = i[2], e[3] = i[3], e[4] = i[4], e[5] = i[5], e[6] = i[6], e[7] = i[7], e[8] = i[8], this; }, fromMat4(t) { const e = t.val; const i = this.val; return i[0] = e[0], i[1] = e[1], i[2] = e[2], i[3] = e[4], i[4] = e[5], i[5] = e[6], i[6] = e[8], i[7] = e[9], i[8] = e[10], this; }, fromArray(t) { const e = this.val; return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e[6] = t[6], e[7] = t[7], e[8] = t[8], this; }, identity() { const t = this.val; return t[0] = 1, t[1] = 0, t[2] = 0, t[3] = 0, t[4] = 1, t[5] = 0, t[6] = 0, t[7] = 0, t[8] = 1, this; }, transpose() { const t = this.val; const e = t[1]; const i = t[2]; const n = t[5]; return t[1] = t[3], t[2] = t[6], t[3] = e, t[5] = t[7], t[6] = i, t[7] = n, this; }, invert() { const t = this.val; const e = t[0]; const i = t[1]; const n = t[2]; const s = t[3]; const r = t[4]; const o = t[5]; const a = t[6]; const h = t[7]; const l = t[8]; const u = l * r - o * h; const c = -l * s + o * a; const d = h * s - r * a; let f = e * u + i * c + n * d; return f ? (f = 1 / f, t[0] = u * f, t[1] = (-l * i + n * h) * f, t[2] = (o * i - n * r) * f, t[3] = c * f, t[4] = (l * e - n * a) * f, t[5] = (-o * e + n * s) * f, t[6] = d * f, t[7] = (-h * e + i * a) * f, t[8] = (r * e - i * s) * f, this) : null; }, adjoint() { const t = this.val; const e = t[0]; const i = t[1]; const n = t[2]; const s = t[3]; const r = t[4]; const o = t[5]; const a = t[6]; const h = t[7]; const l = t[8]; return t[0] = r * l - o * h, t[1] = n * h - i * l, t[2] = i * o - n * r, t[3] = o * a - s * l, t[4] = e * l - n * a, t[5] = n * s - e * o, t[6] = s * h - r * a, t[7] = i * a - e * h, t[8] = e * r - i * s, this; }, determinant() { const t = this.val; const e = t[0]; const i = t[1]; const n = t[2]; const s = t[3]; const r = t[4]; const o = t[5]; const a = t[6]; const h = t[7]; const l = t[8]; return e * (l * r - o * h) + i * (-l * s + o * a) + n * (h * s - r * a); }, multiply(t) { const e = this.val; const i = e[0]; const n = e[1]; const s = e[2]; const r = e[3]; const o = e[4]; const a = e[5]; const h = e[6]; const l = e[7]; const u = e[8]; const c = t.val; const d = c[0]; const f = c[1]; const p = c[2]; const g = c[3]; const v = c[4]; const m = c[5]; const y = c[6]; const x = c[7]; const T = c[8]; return e[0] = d * i + f * r + p * h, e[1] = d * n + f * o + p * l, e[2] = d * s + f * a + p * u, e[3] = g * i + v * r + m * h, e[4] = g * n + v * o + m * l, e[5] = g * s + v * a + m * u, e[6] = y * i + x * r + T * h, e[7] = y * n + x * o + T * l, e[8] = y * s + x * a + T * u, this; }, translate(t) { const e = this.val; const i = t.x; const n = t.y; return e[6] = i * e[0] + n * e[3] + e[6], e[7] = i * e[1] + n * e[4] + e[7], e[8] = i * e[2] + n * e[5] + e[8], this; }, rotate(t) { const e = this.val; const i = e[0]; const n = e[1]; const s = e[2]; const r = e[3]; const o = e[4]; const a = e[5]; const h = Math.sin(t); const l = Math.cos(t); return e[0] = l * i + h * r, e[1] = l * n + h * o, e[2] = l * s + h * a, e[3] = l * r - h * i, e[4] = l * o - h * n, e[5] = l * a - h * s, this; }, scale(t) { const e = this.val; const i = t.x; const n = t.y; return e[0] = i * e[0], e[1] = i * e[1], e[2] = i * e[2], e[3] = n * e[3], e[4] = n * e[4], e[5] = n * e[5], this; }, fromQuat(t) { const e = t.x; const i = t.y; const n = t.z; const s = t.w; const r = e + e; const o = i + i; const a = n + n; const h = e * r; const l = e * o; const u = e * a; const c = i * o; const d = i * a; const f = n * a; const p = s * r; const g = s * o; const v = s * a; const m = this.val; return m[0] = 1 - (c + f), m[3] = l + v, m[6] = u - g, m[1] = l - v, m[4] = 1 - (h + f), m[7] = d + p, m[2] = u + g, m[5] = d - p, m[8] = 1 - (h + c), this; }, normalFromMat4(t) { const e = t.val; const i = this.val; const n = e[0]; const s = e[1]; const r = e[2]; const o = e[3]; const a = e[4]; const h = e[5]; const l = e[6]; const u = e[7]; const c = e[8]; const d = e[9]; const f = e[10]; const p = e[11]; const g = e[12]; const v = e[13]; const m = e[14]; const y = e[15]; const x = n * h - s * a; const T = n * l - r * a; const w = n * u - o * a; const b = s * l - r * h; const E = s * u - o * h; const S = r * u - o * l; const A = c * v - d * g; const _ = c * m - f * g; const C = c * y - p * g; const M = d * m - f * v; const P = d * y - p * v; const O = f * y - p * m; let R = x * O - T * P + w * M + b * C - E * _ + S * A; return R ? (R = 1 / R, i[0] = (h * O - l * P + u * M) * R, i[1] = (l * C - a * O - u * _) * R, i[2] = (a * P - h * C + u * A) * R, i[3] = (r * P - s * O - o * M) * R, i[4] = (n * O - r * C + o * _) * R, i[5] = (s * C - n * P - o * A) * R, i[6] = (v * S - m * E + y * b) * R, i[7] = (m * w - g * S - y * T) * R, i[8] = (g * E - v * w + y * x) * R, this) : null; },
  }); t.exports = n;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(87); const r = i(359); const o = new Int8Array([1, 2, 0]); const a = new Float32Array([0, 0, 0]); const h = new s(1, 0, 0); const l = new s(0, 1, 0); const u = new s(); const c = new r(); const d = new n({
    initialize(t, e, i, n) { typeof t === 'object' ? (this.x = t.x || 0, this.y = t.y || 0, this.z = t.z || 0, this.w = t.w || 0) : (this.x = t || 0, this.y = e || 0, this.z = i || 0, this.w = n || 0); }, copy(t) { return this.x = t.x, this.y = t.y, this.z = t.z, this.w = t.w, this; }, set(t, e, i, n) { return typeof t === 'object' ? (this.x = t.x || 0, this.y = t.y || 0, this.z = t.z || 0, this.w = t.w || 0) : (this.x = t || 0, this.y = e || 0, this.z = i || 0, this.w = n || 0), this; }, add(t) { return this.x += t.x, this.y += t.y, this.z += t.z, this.w += t.w, this; }, subtract(t) { return this.x -= t.x, this.y -= t.y, this.z -= t.z, this.w -= t.w, this; }, scale(t) { return this.x *= t, this.y *= t, this.z *= t, this.w *= t, this; }, length() { const t = this.x; const e = this.y; const i = this.z; const n = this.w; return Math.sqrt(t * t + e * e + i * i + n * n); }, lengthSq() { const t = this.x; const e = this.y; const i = this.z; const n = this.w; return t * t + e * e + i * i + n * n; }, normalize() { const t = this.x; const e = this.y; const i = this.z; const n = this.w; let s = t * t + e * e + i * i + n * n; return s > 0 && (s = 1 / Math.sqrt(s), this.x = t * s, this.y = e * s, this.z = i * s, this.w = n * s), this; }, dot(t) { return this.x * t.x + this.y * t.y + this.z * t.z + this.w * t.w; }, lerp(t, e) { void 0 === e && (e = 0); const i = this.x; const n = this.y; const s = this.z; const r = this.w; return this.x = i + e * (t.x - i), this.y = n + e * (t.y - n), this.z = s + e * (t.z - s), this.w = r + e * (t.w - r), this; }, rotationTo(t, e) { const i = t.x * e.x + t.y * e.y + t.z * e.z; return i < -0.999999 ? (u.copy(h).cross(t).length() < 1e-6 && u.copy(l).cross(t), u.normalize(), this.setAxisAngle(u, Math.PI)) : i > 0.999999 ? (this.x = 0, this.y = 0, this.z = 0, this.w = 1, this) : (u.copy(t).cross(e), this.x = u.x, this.y = u.y, this.z = u.z, this.w = 1 + i, this.normalize()); }, setAxes(t, e, i) { const n = c.val; return n[0] = e.x, n[3] = e.y, n[6] = e.z, n[1] = i.x, n[4] = i.y, n[7] = i.z, n[2] = -t.x, n[5] = -t.y, n[8] = -t.z, this.fromMat3(c).normalize(); }, identity() { return this.x = 0, this.y = 0, this.z = 0, this.w = 1, this; }, setAxisAngle(t, e) { e *= 0.5; const i = Math.sin(e); return this.x = i * t.x, this.y = i * t.y, this.z = i * t.z, this.w = Math.cos(e), this; }, multiply(t) { const e = this.x; const i = this.y; const n = this.z; const s = this.w; const r = t.x; const o = t.y; const a = t.z; const h = t.w; return this.x = e * h + s * r + i * a - n * o, this.y = i * h + s * o + n * r - e * a, this.z = n * h + s * a + e * o - i * r, this.w = s * h - e * r - i * o - n * a, this; }, slerp(t, e) { const i = this.x; const n = this.y; const s = this.z; const r = this.w; let o = t.x; let a = t.y; let h = t.z; let l = t.w; let u = i * o + n * a + s * h + r * l; u < 0 && (u = -u, o = -o, a = -a, h = -h, l = -l); let c = 1 - e; let d = e; if (1 - u > 1e-6) { const f = Math.acos(u); const p = Math.sin(f); c = Math.sin((1 - e) * f) / p, d = Math.sin(e * f) / p; } return this.x = c * i + d * o, this.y = c * n + d * a, this.z = c * s + d * h, this.w = c * r + d * l, this; }, invert() { const t = this.x; const e = this.y; const i = this.z; const n = this.w; const s = t * t + e * e + i * i + n * n; const r = s ? 1 / s : 0; return this.x = -t * r, this.y = -e * r, this.z = -i * r, this.w = n * r, this; }, conjugate() { return this.x = -this.x, this.y = -this.y, this.z = -this.z, this; }, rotateX(t) { t *= 0.5; const e = this.x; const i = this.y; const n = this.z; const s = this.w; const r = Math.sin(t); const o = Math.cos(t); return this.x = e * o + s * r, this.y = i * o + n * r, this.z = n * o - i * r, this.w = s * o - e * r, this; }, rotateY(t) { t *= 0.5; const e = this.x; const i = this.y; const n = this.z; const s = this.w; const r = Math.sin(t); const o = Math.cos(t); return this.x = e * o - n * r, this.y = i * o + s * r, this.z = n * o + e * r, this.w = s * o - i * r, this; }, rotateZ(t) { t *= 0.5; const e = this.x; const i = this.y; const n = this.z; const s = this.w; const r = Math.sin(t); const o = Math.cos(t); return this.x = e * o + i * r, this.y = i * o - e * r, this.z = n * o + s * r, this.w = s * o - n * r, this; }, calculateW() { const t = this.x; const e = this.y; const i = this.z; return this.w = -Math.sqrt(1 - t * t - e * e - i * i), this; }, fromMat3(t) { let e; const i = t.val; const n = i[0] + i[4] + i[8]; if (n > 0)e = Math.sqrt(n + 1), this.w = 0.5 * e, e = 0.5 / e, this.x = (i[7] - i[5]) * e, this.y = (i[2] - i[6]) * e, this.z = (i[3] - i[1]) * e; else { let s = 0; i[4] > i[0] && (s = 1), i[8] > i[3 * s + s] && (s = 2); const r = o[s]; const h = o[r]; e = Math.sqrt(i[3 * s + s] - i[3 * r + r] - i[3 * h + h] + 1), a[s] = 0.5 * e, e = 0.5 / e, a[r] = (i[3 * r + s] + i[3 * s + r]) * e, a[h] = (i[3 * h + s] + i[3 * s + h]) * e, this.x = a[0], this.y = a[1], this.z = a[2], this.w = (i[3 * h + r] - i[3 * r + h]) * e; } return this; },
  }); t.exports = d;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(87); const s = i(189); const r = i(360); const o = new s(); const a = new r(); const h = new n(); t.exports = function (t, e, i) { return a.setAxisAngle(e, i), o.fromRotationTranslation(a, h.set(0, 0, 0)), t.transformMat4(o); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(363); const s = i(30); const r = i(39); const o = i(184); t.exports = function (t) { const e = t.config; if ((e.customEnvironment || e.canvas) && e.renderType === r.AUTO) throw new Error('Must set explicit renderType in custom environment'); if (!e.customEnvironment && !e.canvas && e.renderType !== r.HEADLESS) if (e.renderType === r.CANVAS || e.renderType !== r.CANVAS && !o.webGL) { if (!o.canvas) throw new Error('Cannot create Canvas or WebGL context, aborting.'); e.renderType = r.CANVAS; } else e.renderType = r.WEBGL; e.antialias || s.disableSmoothing(); let a; let h; const l = t.scale.baseSize; const u = l.width; const c = l.height; (e.canvas ? (t.canvas = e.canvas, t.canvas.width = u, t.canvas.height = c) : t.canvas = s.create(t, u, c, e.renderType), e.canvasStyle && (t.canvas.style = e.canvasStyle), e.antialias || n.setCrisp(t.canvas), e.renderType !== r.HEADLESS) && (a = i(364), h = i(367), e.renderType === r.WEBGL ? t.renderer = new h(t) : (t.renderer = new a(t), t.context = t.renderer.gameContext)); };
}, function (t, e) { t.exports = { setCrisp(t) { return ['optimizeSpeed', '-moz-crisp-edges', '-o-crisp-edges', '-webkit-optimize-contrast', 'optimize-contrast', 'crisp-edges', 'pixelated'].forEach(((e) => { t.style['image-rendering'] = e; })), t.style.msInterpolationMode = 'nearest-neighbor', t; }, setBicubic(t) { return t.style['image-rendering'] = 'auto', t.style.msInterpolationMode = 'bicubic', t; } }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Felipe Alfonso <@bitnenfer>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(365); const s = i(42); const r = i(0); const o = i(39); const a = i(366); const h = i(104); const l = i(33); const u = new r({
    initialize(t) {
      this.game = t, this.type = o.CANVAS, this.drawCount = 0, this.width = 0, this.height = 0, this.config = {
        clearBeforeRender: t.config.clearBeforeRender, backgroundColor: t.config.backgroundColor, resolution: t.config.resolution, antialias: t.config.antialias, roundPixels: t.config.roundPixels,
      }, this.gameCanvas = t.canvas; const e = { alpha: t.config.transparent, desynchronized: t.config.desynchronized }; this.gameContext = this.game.config.context ? this.game.config.context : this.gameCanvas.getContext('2d', e), this.currentContext = this.gameContext, this.antialias = t.config.antialias, this.blendModes = a(), this.snapshotState = {
        x: 0, y: 0, width: 1, height: 1, getPixel: !1, callback: null, type: 'image/png', encoder: 0.92,
      }, this._tempMatrix1 = new l(), this._tempMatrix2 = new l(), this._tempMatrix3 = new l(), this._tempMatrix4 = new l(), this.init();
    },
    init() { this.game.scale.on(h.RESIZE, this.onResize, this); const t = this.game.scale.baseSize; this.resize(t.width, t.height); },
    onResize(t, e) { e.width === this.width && e.height === this.height || this.resize(e.width, e.height); },
    resize(t, e) { this.width = t, this.height = e; },
    resetTransform() { this.currentContext.setTransform(1, 0, 0, 1, 0, 0); },
    setBlendMode(t) { return this.currentContext.globalCompositeOperation = t, this; },
    setContext(t) { return this.currentContext = t || this.gameContext, this; },
    setAlpha(t) { return this.currentContext.globalAlpha = t, this; },
    preRender() { const t = this.gameContext; const e = this.config; const i = this.width; const n = this.height; t.globalAlpha = 1, t.globalCompositeOperation = 'source-over', t.setTransform(1, 0, 0, 1, 0, 0), e.clearBeforeRender && t.clearRect(0, 0, i, n), e.transparent || (t.fillStyle = e.backgroundColor.rgba, t.fillRect(0, 0, i, n)), t.save(), this.drawCount = 0; },
    render(t, e, i, n) { const r = e.list; const o = r.length; const a = n._cx; const h = n._cy; const l = n._cw; const u = n._ch; const c = n.renderToTexture ? n.context : t.sys.context; c.save(), this.game.scene.customViewports && (c.beginPath(), c.rect(a, h, l, u), c.clip()), this.currentContext = c; const d = n.mask; d && d.preRenderCanvas(this, null, n._maskCamera), n.transparent || (c.fillStyle = n.backgroundColor.rgba, c.fillRect(a, h, l, u)), c.globalAlpha = n.alpha, c.globalCompositeOperation = 'source-over', this.drawCount += r.length, n.renderToTexture && n.emit(s.PRE_RENDER, n), n.matrix.copyToContext(c); for (let f = 0; f < o; f++) { const p = r[f]; p.willRender(n) && (p.mask && p.mask.preRenderCanvas(this, p, n), p.renderCanvas(this, p, i, n), p.mask && p.mask.postRenderCanvas(this, p, n)); }c.setTransform(1, 0, 0, 1, 0, 0), c.globalCompositeOperation = 'source-over', c.globalAlpha = 1, n.flashEffect.postRenderCanvas(c), n.fadeEffect.postRenderCanvas(c), n.dirty = !1, d && d.postRenderCanvas(this), c.restore(), n.renderToTexture && (n.emit(s.POST_RENDER, n), n.renderToGame && t.sys.context.drawImage(n.canvas, a, h)); },
    postRender() { this.gameContext.restore(); const t = this.snapshotState; t.callback && (n(this.gameCanvas, t), t.callback = null); },
    snapshotCanvas(t, e, i, s, r, o, a, h, l) { void 0 === i && (i = !1), this.snapshotArea(s, r, o, a, e, h, l); const u = this.snapshotState; return u.getPixel = i, n(this.canvas, u), u.callback = null, this; },
    snapshot(t, e, i) { return this.snapshotArea(0, 0, this.gameCanvas.width, this.gameCanvas.height, t, e, i); },
    snapshotArea(t, e, i, n, s, r, o) { const a = this.snapshotState; return a.callback = s, a.type = r, a.encoder = o, a.getPixel = !1, a.x = t, a.y = e, a.width = Math.min(i, this.gameCanvas.width), a.height = Math.min(n, this.gameCanvas.height), this; },
    snapshotPixel(t, e, i) { return this.snapshotArea(t, e, 1, 1, i), this.snapshotState.getPixel = !0, this; },
    batchSprite(t, e, i, n) { const s = i.alpha * t.alpha; if (s !== 0) { const r = this.currentContext; const o = this._tempMatrix1; const a = this._tempMatrix2; const h = this._tempMatrix3; const l = e.canvasData; let u = l.x; let c = l.y; let d = e.cutWidth; let f = e.cutHeight; const p = e.customPivot; const g = e.source.resolution; const v = t.displayOriginX; const m = t.displayOriginY; let y = -v + e.x; let x = -m + e.y; if (t.isCropped) { const T = t._crop; T.flipX === t.flipX && T.flipY === t.flipY || e.updateCropUVs(T, t.flipX, t.flipY), d = T.cw, f = T.ch, u = T.cx, c = T.cy, y = -v + T.x, x = -m + T.y, t.flipX && (y >= 0 ? y = -(y + d) : y < 0 && (y = Math.abs(y) - d)), t.flipY && (x >= 0 ? x = -(x + f) : x < 0 && (x = Math.abs(x) - f)); } let w = 1; let b = 1; t.flipX && (p || (y += -e.realWidth + 2 * v), w = -1), t.flipY && (p || (x += -e.realHeight + 2 * m), b = -1), a.applyITRS(t.x, t.y, t.rotation, t.scaleX * w, t.scaleY * b), o.copyFrom(i.matrix), n ? (o.multiplyWithOffset(n, -i.scrollX * t.scrollFactorX, -i.scrollY * t.scrollFactorY), a.e = t.x, a.f = t.y, o.multiply(a, h)) : (a.e -= i.scrollX * t.scrollFactorX, a.f -= i.scrollY * t.scrollFactorY, o.multiply(a, h)), r.save(), h.setToContext(r), r.globalCompositeOperation = this.blendModes[t.blendMode], r.globalAlpha = s, r.imageSmoothingEnabled = !(!this.antialias || e.source.scaleMode), r.drawImage(e.source.image, u, c, d, f, y, x, d / g, f / g), r.restore(); } },
    destroy() { this.gameCanvas = null, this.gameContext = null, this.game = null; },
  }); t.exports = u;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(30); const s = i(35); const r = i(2); t.exports = function (t, e) { const i = r(e, 'callback'); const o = r(e, 'type', 'image/png'); const a = r(e, 'encoder', 0.92); const h = Math.abs(Math.round(r(e, 'x', 0))); const l = Math.abs(Math.round(r(e, 'y', 0))); const u = r(e, 'width', t.width); const c = r(e, 'height', t.height); if (r(e, 'getPixel', !1)) { const d = t.getContext('2d').getImageData(h, l, 1, 1).data; i.call(null, new s(d[0], d[1], d[2], d[3] / 255)); } else if (h !== 0 || l !== 0 || u !== t.width || c !== t.height) { const f = n.createWebGL(this, u, c); f.getContext('2d').drawImage(t, h, l, u, c, 0, 0, u, c); const p = new Image(); p.onerror = function () { i.call(null), n.remove(f); }, p.onload = function () { i.call(null, p), n.remove(f); }, p.src = f.toDataURL(o, a); } else { const g = new Image(); g.onerror = function () { i.call(null); }, g.onload = function () { i.call(null, g); }, g.src = t.toDataURL(o, a); } };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(45); const s = i(340); t.exports = function () { const t = []; const e = s.supportNewBlendModes; const i = 'source-over'; return t[n.NORMAL] = i, t[n.ADD] = 'lighter', t[n.MULTIPLY] = e ? 'multiply' : i, t[n.SCREEN] = e ? 'screen' : i, t[n.OVERLAY] = e ? 'overlay' : i, t[n.DARKEN] = e ? 'darken' : i, t[n.LIGHTEN] = e ? 'lighten' : i, t[n.COLOR_DODGE] = e ? 'color-dodge' : i, t[n.COLOR_BURN] = e ? 'color-burn' : i, t[n.HARD_LIGHT] = e ? 'hard-light' : i, t[n.SOFT_LIGHT] = e ? 'soft-light' : i, t[n.DIFFERENCE] = e ? 'difference' : i, t[n.EXCLUSION] = e ? 'exclusion' : i, t[n.HUE] = e ? 'hue' : i, t[n.SATURATION] = e ? 'saturation' : i, t[n.COLOR] = e ? 'color' : i, t[n.LUMINOSITY] = e ? 'luminosity' : i, t[n.ERASE] = 'destination-out', t[n.SOURCE_IN] = 'source-in', t[n.SOURCE_OUT] = 'source-out', t[n.SOURCE_ATOP] = 'source-atop', t[n.DESTINATION_OVER] = 'destination-over', t[n.DESTINATION_IN] = 'destination-in', t[n.DESTINATION_OUT] = 'destination-out', t[n.DESTINATION_ATOP] = 'destination-atop', t[n.LIGHTER] = 'lighter', t[n.COPY] = 'copy', t[n.XOR] = 'xor', t; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Felipe Alfonso <@bitnenfer>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(103); const s = i(42); const r = i(0); const o = i(39); const a = i(22); const h = i(130); const l = i(1); const u = i(104); const c = i(88); const d = i(132); const f = i(33); const p = i(11); const g = i(368); const v = i(369); const m = i(370); const y = i(191); const x = i(373); const T = new r({
    initialize(t) {
      const e = t.config; const i = {
        alpha: e.transparent, desynchronized: e.desynchronized, depth: !1, antialias: e.antialiasGL, premultipliedAlpha: e.premultipliedAlpha, stencil: !0, failIfMajorPerformanceCaveat: e.failIfMajorPerformanceCaveat, powerPreference: e.powerPreference,
      }; this.config = {
        clearBeforeRender: e.clearBeforeRender, antialias: e.antialias, backgroundColor: e.backgroundColor, contextCreation: i, resolution: e.resolution, roundPixels: e.roundPixels, maxTextures: e.maxTextures, maxTextureSize: e.maxTextureSize, batchSize: e.batchSize, maxLights: e.maxLights, mipmapFilter: e.mipmapFilter,
      }, this.game = t, this.type = o.WEBGL, this.width = 0, this.height = 0, this.canvas = t.canvas, this.blendModes = [], this.nativeTextures = [], this.contextLost = !1, this.pipelines = null, this.snapshotState = {
        x: 0, y: 0, width: 1, height: 1, getPixel: !1, callback: null, type: 'image/png', encoder: 0.92, isFramebuffer: !1, bufferWidth: 0, bufferHeight: 0,
      }, this.currentActiveTextureUnit = 0, this.currentTextures = new Array(16), this.currentFramebuffer = null, this.currentPipeline = null, this.currentProgram = null, this.currentVertexBuffer = null, this.currentIndexBuffer = null, this.currentBlendMode = 1 / 0, this.currentScissorEnabled = !1, this.currentScissor = null, this.scissorStack = [], this.contextLostHandler = l, this.contextRestoredHandler = l, this.gl = null, this.supportedExtensions = null, this.extensions = {}, this.glFormats = [], this.compression = { ETC1: !1, PVRTC: !1, S3TC: !1 }, this.drawingBufferHeight = 0, this.blankTexture = null, this.defaultCamera = new n(0, 0, 0, 0), this._tempMatrix1 = new f(), this._tempMatrix2 = new f(), this._tempMatrix3 = new f(), this._tempMatrix4 = new f(), this.maskCount = 0, this.maskStack = [], this.currentMask = { mask: null, camera: null }, this.currentCameraMask = { mask: null, camera: null }, this.glFuncMap = null, this.currentType = '', this.newType = !1, this.nextTypeMatch = !1, this.mipmapFilter = null, this.init(this.config);
    },
    init(t) {
      let e; const i = this.game; const n = this.canvas; const s = t.backgroundColor; if (!(e = i.config.context ? i.config.context : n.getContext('webgl', t.contextCreation) || n.getContext('experimental-webgl', t.contextCreation)) || e.isContextLost()) throw this.contextLost = !0, new Error('WebGL unsupported'); this.gl = e; const r = this; this.contextLostHandler = function (t) { r.contextLost = !0, r.game.events.emit(a.CONTEXT_LOST, r), t.preventDefault(); }, this.contextRestoredHandler = function () { r.contextLost = !1, r.init(r.config), r.game.events.emit(a.CONTEXT_RESTORED, r); }, n.addEventListener('webglcontextlost', this.contextLostHandler, !1), n.addEventListener('webglcontextrestored', this.contextRestoredHandler, !1), i.context = e; for (let h = 0; h <= 27; h++) this.blendModes.push({ func: [e.ONE, e.ONE_MINUS_SRC_ALPHA], equation: e.FUNC_ADD }); this.blendModes[1].func = [e.ONE, e.DST_ALPHA], this.blendModes[2].func = [e.DST_COLOR, e.ONE_MINUS_SRC_ALPHA], this.blendModes[3].func = [e.ONE, e.ONE_MINUS_SRC_COLOR], this.blendModes[17] = { func: [e.ZERO, e.ONE_MINUS_SRC_ALPHA], equation: e.FUNC_REVERSE_SUBTRACT }, this.glFormats[0] = e.BYTE, this.glFormats[1] = e.SHORT, this.glFormats[2] = e.UNSIGNED_BYTE, this.glFormats[3] = e.UNSIGNED_SHORT, this.glFormats[4] = e.FLOAT, this.glFuncMap = {
        mat2: { func: e.uniformMatrix2fv, length: 1, matrix: !0 }, mat3: { func: e.uniformMatrix3fv, length: 1, matrix: !0 }, mat4: { func: e.uniformMatrix4fv, length: 1, matrix: !0 }, '1f': { func: e.uniform1f, length: 1 }, '1fv': { func: e.uniform1fv, length: 1 }, '1i': { func: e.uniform1i, length: 1 }, '1iv': { func: e.uniform1iv, length: 1 }, '2f': { func: e.uniform2f, length: 2 }, '2fv': { func: e.uniform2fv, length: 1 }, '2i': { func: e.uniform2i, length: 2 }, '2iv': { func: e.uniform2iv, length: 1 }, '3f': { func: e.uniform3f, length: 3 }, '3fv': { func: e.uniform3fv, length: 1 }, '3i': { func: e.uniform3i, length: 3 }, '3iv': { func: e.uniform3iv, length: 1 }, '4f': { func: e.uniform4f, length: 4 }, '4fv': { func: e.uniform4fv, length: 1 }, '4i': { func: e.uniform4i, length: 4 }, '4iv': { func: e.uniform4iv, length: 1 },
      }; const l = e.getSupportedExtensions(); t.maxTextures || (t.maxTextures = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS)), t.maxTextureSize || (t.maxTextureSize = e.getParameter(e.MAX_TEXTURE_SIZE)); const u = 'WEBGL_compressed_texture_'; const c = `WEBKIT_${u}`; this.compression.ETC1 = e.getExtension(`${u}etc1`) || e.getExtension(`${c}etc1`), this.compression.PVRTC = e.getExtension(`${u}pvrtc`) || e.getExtension(`${c}pvrtc`), this.compression.S3TC = e.getExtension(`${u}s3tc`) || e.getExtension(`${c}s3tc`), this.supportedExtensions = l, e.disable(e.DEPTH_TEST), e.disable(e.CULL_FACE), e.enable(e.BLEND), e.clearColor(s.redGL, s.greenGL, s.blueGL, s.alphaGL), this.mipmapFilter = e[t.mipmapFilter]; for (let f = 0; f < this.currentTextures.length; ++f) this.currentTextures[f] = null; return this.pipelines = {}, this.addPipeline('TextureTintPipeline', new y({ game: i, renderer: this })), this.addPipeline('TextureTintStripPipeline', new x({ game: i, renderer: this })), this.addPipeline('BitmapMaskPipeline', new v({ game: i, renderer: this })), this.addPipeline('Light2D', new m({ game: i, renderer: this, maxLights: t.maxLights })), this.setBlendMode(o.BlendModes.NORMAL), i.textures.once(d.READY, this.boot, this), this;
    },
    boot() { for (const t in this.pipelines) this.pipelines[t].boot(); const e = this.game.textures.getFrame('__DEFAULT'); this.pipelines.TextureTintPipeline.currentFrame = e, this.blankTexture = e; const i = this.gl; i.bindFramebuffer(i.FRAMEBUFFER, null), i.enable(i.SCISSOR_TEST), this.setPipeline(this.pipelines.TextureTintPipeline), this.game.scale.on(u.RESIZE, this.onResize, this); const n = this.game.scale.baseSize; this.resize(n.width, n.height, this.game.scale.resolution); },
    onResize(t, e, i, n) { e.width === this.width && e.height === this.height && n === this.resolution || this.resize(e.width, e.height, n); },
    resize(t, e, i) { const n = this.gl; const s = this.pipelines; for (const r in this.width = t, this.height = e, this.resolution = i, n.viewport(0, 0, t, e), s)s[r].resize(t, e, i); return this.drawingBufferHeight = n.drawingBufferHeight, n.scissor(0, n.drawingBufferHeight - e, t, e), this.defaultCamera.setSize(t, e), this; },
    hasExtension(t) { return !!this.supportedExtensions && this.supportedExtensions.indexOf(t); },
    getExtension(t) { return this.hasExtension(t) ? (t in this.extensions || (this.extensions[t] = this.gl.getExtension(t)), this.extensions[t]) : null; },
    flush() { this.currentPipeline && this.currentPipeline.flush(); },
    hasPipeline(t) { return t in this.pipelines; },
    getPipeline(t) { return this.hasPipeline(t) ? this.pipelines[t] : null; },
    removePipeline(t) { return delete this.pipelines[t], this; },
    addPipeline(t, e) { return this.hasPipeline(t) ? console.warn(`Pipeline exists: ${t}`) : this.pipelines[t] = e, e.name = t, this.pipelines[t].resize(this.width, this.height, this.config.resolution), e; },
    pushScissor(t, e, i, n, s) { void 0 === s && (s = this.drawingBufferHeight); const r = [t, e, i, n]; return this.scissorStack.push(r), this.setScissor(t, e, i, n, s), this.currentScissor = r, r; },
    setScissor(t, e, i, n, s) { void 0 === s && (s = this.drawingBufferHeight); const r = this.gl; const o = this.currentScissor; let a = i > 0 && n > 0; if (o && a) { const h = o[0]; const l = o[1]; const u = o[2]; const c = o[3]; a = h !== t || l !== e || u !== i || c !== n; }a && (this.flush(), r.scissor(t, s - e - n, i, n)); },
    popScissor() { const t = this.scissorStack; t.pop(); const e = t[t.length - 1]; e && this.setScissor(e[0], e[1], e[2], e[3]), this.currentScissor = e; },
    setPipeline(t, e) { return this.currentPipeline === t && this.currentPipeline.vertexBuffer === this.currentVertexBuffer && this.currentPipeline.program === this.currentProgram || (this.flush(), this.currentPipeline = t, this.currentPipeline.bind()), this.currentPipeline.onBind(e), this.currentPipeline; },
    hasActiveStencilMask() { const t = this.currentMask.mask; const e = this.currentCameraMask.mask; return t && t.isStencil || e && e.isStencil; },
    rebindPipeline(t) { const e = this.gl; e.disable(e.DEPTH_TEST), e.disable(e.CULL_FACE), this.hasActiveStencilMask() ? e.clear(e.DEPTH_BUFFER_BIT) : (e.disable(e.STENCIL_TEST), e.clear(e.DEPTH_BUFFER_BIT | e.STENCIL_BUFFER_BIT)), e.viewport(0, 0, this.width, this.height), this.setBlendMode(0, !0), e.activeTexture(e.TEXTURE0), e.bindTexture(e.TEXTURE_2D, this.blankTexture.glTexture), this.currentActiveTextureUnit = 0, this.currentTextures[0] = this.blankTexture.glTexture, this.currentPipeline = t, this.currentPipeline.bind(), this.currentPipeline.onBind(); },
    clearPipeline() { this.flush(), this.currentPipeline = null, this.currentProgram = null, this.currentVertexBuffer = null, this.currentIndexBuffer = null, this.setBlendMode(0, !0); },
    setBlendMode(t, e) { void 0 === e && (e = !1); const i = this.gl; const n = this.blendModes[t]; return !!(e || t !== o.BlendModes.SKIP_CHECK && this.currentBlendMode !== t) && (this.flush(), i.enable(i.BLEND), i.blendEquation(n.equation), n.func.length > 2 ? i.blendFuncSeparate(n.func[0], n.func[1], n.func[2], n.func[3]) : i.blendFunc(n.func[0], n.func[1]), this.currentBlendMode = t, !0); },
    addBlendMode(t, e) { return this.blendModes.push({ func: t, equation: e }) - 1; },
    updateBlendMode(t, e, i) { return this.blendModes[t] && (this.blendModes[t].func = e, i && (this.blendModes[t].equation = i)), this; },
    removeBlendMode(t) { return t > 17 && this.blendModes[t] && this.blendModes.splice(t, 1), this; },
    setBlankTexture(t) { void 0 === t && (t = !1), !t && this.currentActiveTextureUnit === 0 && this.currentTextures[0] || this.setTexture2D(this.blankTexture.glTexture, 0); },
    setTexture2D(t, e, i) { void 0 === i && (i = !0); const n = this.gl; return t !== this.currentTextures[e] && (i && this.flush(), this.currentActiveTextureUnit !== e && (n.activeTexture(n.TEXTURE0 + e), this.currentActiveTextureUnit = e), n.bindTexture(n.TEXTURE_2D, t), this.currentTextures[e] = t), this; },
    setFramebuffer(t, e) { void 0 === e && (e = !1); const i = this.gl; let n = this.width; let s = this.height; return t !== this.currentFramebuffer && (t && t.renderTexture ? (n = t.renderTexture.width, s = t.renderTexture.height) : this.flush(), i.bindFramebuffer(i.FRAMEBUFFER, t), i.viewport(0, 0, n, s), e && (t ? (this.drawingBufferHeight = s, this.pushScissor(0, 0, n, s)) : (this.drawingBufferHeight = this.height, this.popScissor())), this.currentFramebuffer = t), this; },
    setProgram(t) { const e = this.gl; return t !== this.currentProgram && (this.flush(), e.useProgram(t), this.currentProgram = t), this; },
    setVertexBuffer(t) { const e = this.gl; return t !== this.currentVertexBuffer && (this.flush(), e.bindBuffer(e.ARRAY_BUFFER, t), this.currentVertexBuffer = t), this; },
    setIndexBuffer(t) { const e = this.gl; return t !== this.currentIndexBuffer && (this.flush(), e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, t), this.currentIndexBuffer = t), this; },
    createTextureFromSource(t, e, i, n) { const s = this.gl; let r = s.NEAREST; let a = s.NEAREST; let l = s.CLAMP_TO_EDGE; e = t ? t.width : e, i = t ? t.height : i; const u = h(e, i); return u && (l = s.REPEAT), n === o.ScaleModes.LINEAR && this.config.antialias && (r = u ? this.mipmapFilter : s.LINEAR, a = s.LINEAR), t || typeof e !== 'number' || typeof i !== 'number' ? this.createTexture2D(0, r, a, l, l, s.RGBA, t) : this.createTexture2D(0, r, a, l, l, s.RGBA, null, e, i); },
    createTexture2D(t, e, i, n, s, r, o, a, l, u, c, d) { u = u == null || u, void 0 === c && (c = !1), void 0 === d && (d = !1); const f = this.gl; const p = f.createTexture(); return this.setTexture2D(p, 0), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_MIN_FILTER, e), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_MAG_FILTER, i), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_WRAP_S, s), f.texParameteri(f.TEXTURE_2D, f.TEXTURE_WRAP_T, n), f.pixelStorei(f.UNPACK_PREMULTIPLY_ALPHA_WEBGL, u), f.pixelStorei(f.UNPACK_FLIP_Y_WEBGL, d), o == null ? f.texImage2D(f.TEXTURE_2D, t, r, a, l, 0, r, f.UNSIGNED_BYTE, null) : (c || (a = o.width, l = o.height), f.texImage2D(f.TEXTURE_2D, t, r, r, f.UNSIGNED_BYTE, o)), h(a, l) && f.generateMipmap(f.TEXTURE_2D), this.setTexture2D(null, 0), p.isAlphaPremultiplied = u, p.isRenderTexture = !1, p.width = a, p.height = l, this.nativeTextures.push(p), p; },
    createFramebuffer(t, e, i, n) {
      let s; const r = this.gl; const o = r.createFramebuffer(); if (this.setFramebuffer(o), n) { const a = r.createRenderbuffer(); r.bindRenderbuffer(r.RENDERBUFFER, a), r.renderbufferStorage(r.RENDERBUFFER, r.DEPTH_STENCIL, t, e), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.RENDERBUFFER, a); } if (i.isRenderTexture = !0, i.isAlphaPremultiplied = !1, r.framebufferTexture2D(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, i, 0), (s = r.checkFramebufferStatus(r.FRAMEBUFFER)) !== r.FRAMEBUFFER_COMPLETE) {
        throw new Error(`Framebuffer incomplete. Framebuffer status: ${{
          36054: 'Incomplete Attachment', 36055: 'Missing Attachment', 36057: 'Incomplete Dimensions', 36061: 'Framebuffer Unsupported',
        }[s]}`);
      } return o.renderTexture = i, this.setFramebuffer(null), o;
    },
    createProgram(t, e) { const i = this.gl; const n = i.createProgram(); const s = i.createShader(i.VERTEX_SHADER); const r = i.createShader(i.FRAGMENT_SHADER); if (i.shaderSource(s, t), i.shaderSource(r, e), i.compileShader(s), i.compileShader(r), !i.getShaderParameter(s, i.COMPILE_STATUS)) throw new Error(`Failed to compile Vertex Shader:\n${i.getShaderInfoLog(s)}`); if (!i.getShaderParameter(r, i.COMPILE_STATUS)) throw new Error(`Failed to compile Fragment Shader:\n${i.getShaderInfoLog(r)}`); if (i.attachShader(n, s), i.attachShader(n, r), i.linkProgram(n), !i.getProgramParameter(n, i.LINK_STATUS)) throw new Error(`Failed to link program:\n${i.getProgramInfoLog(n)}`); return n; },
    createVertexBuffer(t, e) { const i = this.gl; const n = i.createBuffer(); return this.setVertexBuffer(n), i.bufferData(i.ARRAY_BUFFER, t, e), this.setVertexBuffer(null), n; },
    createIndexBuffer(t, e) { const i = this.gl; const n = i.createBuffer(); return this.setIndexBuffer(n), i.bufferData(i.ELEMENT_ARRAY_BUFFER, t, e), this.setIndexBuffer(null), n; },
    deleteTexture(t) { const e = this.nativeTextures.indexOf(t); return e !== -1 && c(this.nativeTextures, e), this.gl.deleteTexture(t), this.currentTextures[0] !== t || this.game.pendingDestroy || this.setBlankTexture(!0), this; },
    deleteFramebuffer(t) { return this.gl.deleteFramebuffer(t), this; },
    deleteProgram(t) { return this.gl.deleteProgram(t), this; },
    deleteBuffer(t) { return this.gl.deleteBuffer(t), this; },
    preRenderCamera(t) { const e = t._cx; const i = t._cy; const n = t._cw; const r = t._ch; const o = this.pipelines.TextureTintPipeline; const a = t.backgroundColor; if (t.renderToTexture) { this.flush(), this.pushScissor(e, i, n, -r), this.setFramebuffer(t.framebuffer); const h = this.gl; h.clearColor(0, 0, 0, 0), h.clear(h.COLOR_BUFFER_BIT), o.projOrtho(e, n + e, i, r + i, -1e3, 1e3), t.mask && (this.currentCameraMask.mask = t.mask, this.currentCameraMask.camera = t._maskCamera, t.mask.preRenderWebGL(this, t, t._maskCamera)), a.alphaGL > 0 && o.drawFillRect(e, i, n + e, r + i, p.getTintFromFloats(a.redGL, a.greenGL, a.blueGL, 1), a.alphaGL), t.emit(s.PRE_RENDER, t); } else this.pushScissor(e, i, n, r), t.mask && (this.currentCameraMask.mask = t.mask, this.currentCameraMask.camera = t._maskCamera, t.mask.preRenderWebGL(this, t, t._maskCamera)), a.alphaGL > 0 && o.drawFillRect(e, i, n, r, p.getTintFromFloats(a.redGL, a.greenGL, a.blueGL, 1), a.alphaGL); },
    getCurrentStencilMask() { let t = null; const e = this.maskStack; const i = this.currentCameraMask; return e.length > 0 ? t = e[e.length - 1] : i.mask && i.mask.isStencil && (t = i), t; },
    postRenderCamera(t) { this.setPipeline(this.pipelines.TextureTintPipeline); const e = this.pipelines.TextureTintPipeline; if (t.flashEffect.postRenderWebGL(e, p.getTintFromFloats), t.fadeEffect.postRenderWebGL(e, p.getTintFromFloats), t.dirty = !1, this.popScissor(), t.renderToTexture) { if (e.flush(), this.setFramebuffer(null), t.emit(s.POST_RENDER, t), t.renderToGame) { e.projOrtho(0, e.width, e.height, 0, -1e3, 1e3); const i = p.getTintAppendFloatAlpha; (t.pipeline ? t.pipeline : e).batchTexture(t, t.glTexture, t.width, t.height, t.x, t.y, t.width, t.height, t.zoom, t.zoom, t.rotation, t.flipX, !t.flipY, 1, 1, 0, 0, 0, 0, t.width, t.height, i(t._tintTL, t._alphaTL), i(t._tintTR, t._alphaTR), i(t._tintBL, t._alphaBL), i(t._tintBR, t._alphaBR), t._isTinted && t.tintFill, 0, 0, this.defaultCamera, null); } this.setBlankTexture(!0); }t.mask && (this.currentCameraMask.mask = null, t.mask.postRenderWebGL(this, t._maskCamera)); },
    preRender() { if (!this.contextLost) { const t = this.gl; const e = this.pipelines; if (t.bindFramebuffer(t.FRAMEBUFFER, null), this.config.clearBeforeRender) { const i = this.config.backgroundColor; t.clearColor(i.redGL, i.greenGL, i.blueGL, i.alphaGL), t.clear(t.COLOR_BUFFER_BIT | t.DEPTH_BUFFER_BIT | t.STENCIL_BUFFER_BIT); } for (const n in t.enable(t.SCISSOR_TEST), e)e[n].onPreRender(); this.currentScissor = [0, 0, this.width, this.height], this.scissorStack = [this.currentScissor], this.game.scene.customViewports && t.scissor(0, this.drawingBufferHeight - this.height, this.width, this.height), this.currentMask.mask = null, this.currentCameraMask.mask = null, this.maskStack.length = 0, this.setPipeline(this.pipelines.TextureTintPipeline); } },
    render(t, e, i, n) { if (!this.contextLost) { const s = e.list; const r = s.length; const a = this.pipelines; for (const h in a)a[h].onRender(t, n); if (this.preRenderCamera(n), r === 0) return this.setBlendMode(o.BlendModes.NORMAL), void this.postRenderCamera(n); this.currentType = ''; for (var l = this.currentMask, u = 0; u < r; u++) { const c = s[u]; if (c.willRender(n)) { c.blendMode !== this.currentBlendMode && this.setBlendMode(c.blendMode); const d = c.mask; (l = this.currentMask).mask && l.mask !== d && l.mask.postRenderWebGL(this, l.camera), d && l.mask !== d && d.preRenderWebGL(this, c, n); const f = c.type; f !== this.currentType && (this.newType = !0, this.currentType = f), this.nextTypeMatch = u < r - 1 && s[u + 1].type === this.currentType, c.renderWebGL(this, c, i, n), this.newType = !1; } }(l = this.currentMask).mask && l.mask.postRenderWebGL(this, l.camera), this.setBlendMode(o.BlendModes.NORMAL), this.postRenderCamera(n); } },
    postRender() { if (!this.contextLost) { this.flush(); const t = this.snapshotState; t.callback && (g(this.canvas, t), t.callback = null); const e = this.pipelines; for (const i in e)e[i].onPostRender(); } },
    snapshot(t, e, i) { return this.snapshotArea(0, 0, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight, t, e, i); },
    snapshotArea(t, e, i, n, s, r, o) { const a = this.snapshotState; return a.callback = s, a.type = r, a.encoder = o, a.getPixel = !1, a.x = t, a.y = e, a.width = Math.min(i, this.gl.drawingBufferWidth), a.height = Math.min(n, this.gl.drawingBufferHeight), this; },
    snapshotPixel(t, e, i) { return this.snapshotArea(t, e, 1, 1, i), this.snapshotState.getPixel = !0, this; },
    snapshotFramebuffer(t, e, i, n, s, r, o, a, h, l, u) { void 0 === s && (s = !1), void 0 === r && (r = 0), void 0 === o && (o = 0), void 0 === a && (a = e), void 0 === h && (h = i); const c = this.currentFramebuffer; this.snapshotArea(r, o, a, h, n, l, u); const d = this.snapshotState; return d.getPixel = s, d.isFramebuffer = !0, d.bufferWidth = e, d.bufferHeight = i, this.setFramebuffer(t), g(this.canvas, d), this.setFramebuffer(c), d.callback = null, d.isFramebuffer = !1, this; },
    canvasToTexture(t, e, i, n) { return void 0 === i && (i = !1), void 0 === n && (n = !1), e ? this.updateCanvasTexture(t, e, n) : this.createCanvasTexture(t, i, n); },
    createCanvasTexture(t, e, i) { void 0 === e && (e = !1), void 0 === i && (i = !1); const n = this.gl; let s = n.NEAREST; let r = n.NEAREST; const o = t.width; const a = t.height; let l = n.CLAMP_TO_EDGE; const u = h(o, a); return !e && u && (l = n.REPEAT), this.config.antialias && (s = u ? this.mipmapFilter : n.LINEAR, r = n.LINEAR), this.createTexture2D(0, s, r, l, l, n.RGBA, t, o, a, !0, !1, i); },
    updateCanvasTexture(t, e, i) { void 0 === i && (i = !1); const n = this.gl; const s = t.width; const r = t.height; return s > 0 && r > 0 && (this.setTexture2D(e, 0), n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, i), n.texImage2D(n.TEXTURE_2D, 0, n.RGBA, n.RGBA, n.UNSIGNED_BYTE, t), e.width = s, e.height = r, this.setTexture2D(null, 0)), e; },
    createVideoTexture(t, e, i) { void 0 === e && (e = !1), void 0 === i && (i = !1); const n = this.gl; let s = n.NEAREST; let r = n.NEAREST; const o = t.videoWidth; const a = t.videoHeight; let l = n.CLAMP_TO_EDGE; const u = h(o, a); return !e && u && (l = n.REPEAT), this.config.antialias && (s = u ? this.mipmapFilter : n.LINEAR, r = n.LINEAR), this.createTexture2D(0, s, r, l, l, n.RGBA, t, o, a, !0, !0, i); },
    updateVideoTexture(t, e, i) { void 0 === i && (i = !1); const n = this.gl; const s = t.videoWidth; const r = t.videoHeight; return s > 0 && r > 0 && (this.setTexture2D(e, 0), n.pixelStorei(n.UNPACK_FLIP_Y_WEBGL, i), n.texImage2D(n.TEXTURE_2D, 0, n.RGBA, n.RGBA, n.UNSIGNED_BYTE, t), e.width = s, e.height = r, this.setTexture2D(null, 0)), e; },
    setTextureFilter(t, e) { const i = this.gl; const n = [i.LINEAR, i.NEAREST][e]; return this.setTexture2D(t, 0), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, n), i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MAG_FILTER, n), this.setTexture2D(null, 0), this; },
    setFloat1(t, e, i) { return this.setProgram(t), this.gl.uniform1f(this.gl.getUniformLocation(t, e), i), this; },
    setFloat2(t, e, i, n) { return this.setProgram(t), this.gl.uniform2f(this.gl.getUniformLocation(t, e), i, n), this; },
    setFloat3(t, e, i, n, s) { return this.setProgram(t), this.gl.uniform3f(this.gl.getUniformLocation(t, e), i, n, s), this; },
    setFloat4(t, e, i, n, s, r) { return this.setProgram(t), this.gl.uniform4f(this.gl.getUniformLocation(t, e), i, n, s, r), this; },
    setFloat1v(t, e, i) { return this.setProgram(t), this.gl.uniform1fv(this.gl.getUniformLocation(t, e), i), this; },
    setFloat2v(t, e, i) { return this.setProgram(t), this.gl.uniform2fv(this.gl.getUniformLocation(t, e), i), this; },
    setFloat3v(t, e, i) { return this.setProgram(t), this.gl.uniform3fv(this.gl.getUniformLocation(t, e), i), this; },
    setFloat4v(t, e, i) { return this.setProgram(t), this.gl.uniform4fv(this.gl.getUniformLocation(t, e), i), this; },
    setInt1(t, e, i) { return this.setProgram(t), this.gl.uniform1i(this.gl.getUniformLocation(t, e), i), this; },
    setInt2(t, e, i, n) { return this.setProgram(t), this.gl.uniform2i(this.gl.getUniformLocation(t, e), i, n), this; },
    setInt3(t, e, i, n, s) { return this.setProgram(t), this.gl.uniform3i(this.gl.getUniformLocation(t, e), i, n, s), this; },
    setInt4(t, e, i, n, s, r) { return this.setProgram(t), this.gl.uniform4i(this.gl.getUniformLocation(t, e), i, n, s, r), this; },
    setMatrix2(t, e, i, n) { return this.setProgram(t), this.gl.uniformMatrix2fv(this.gl.getUniformLocation(t, e), i, n), this; },
    setMatrix3(t, e, i, n) { return this.setProgram(t), this.gl.uniformMatrix3fv(this.gl.getUniformLocation(t, e), i, n), this; },
    setMatrix4(t, e, i, n) { return this.setProgram(t), this.gl.uniformMatrix4fv(this.gl.getUniformLocation(t, e), i, n), this; },
    getMaxTextures() { return this.config.maxTextures; },
    getMaxTextureSize() { return this.config.maxTextureSize; },
    destroy() { for (let t = 0; t < this.nativeTextures.length; t++) this.gl.deleteTexture(this.nativeTextures[t]); for (const e in this.nativeTextures = [], this.pipelines) this.pipelines[e].destroy(), delete this.pipelines[e]; this.defaultCamera.destroy(), this.currentMask = null, this.currentCameraMask = null, this.canvas.removeEventListener('webglcontextlost', this.contextLostHandler, !1), this.canvas.removeEventListener('webglcontextrestored', this.contextRestoredHandler, !1), this.game = null, this.gl = null, this.canvas = null, this.maskStack = [], this.contextLost = !0, this.extensions = {}; },
  }); t.exports = T;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(30); const s = i(35); const r = i(2); t.exports = function (t, e) { const i = t.getContext('experimental-webgl'); const o = r(e, 'callback'); const a = r(e, 'type', 'image/png'); const h = r(e, 'encoder', 0.92); const l = r(e, 'x', 0); const u = r(e, 'y', 0); const c = r(e, 'getPixel', !1); const d = r(e, 'isFramebuffer', !1); const f = d ? r(e, 'bufferWidth', 1) : i.drawingBufferWidth; const p = d ? r(e, 'bufferHeight', 1) : i.drawingBufferHeight; if (c) { const g = new Uint8Array(4); const v = d ? u : p - u; i.readPixels(l, v, 1, 1, i.RGBA, i.UNSIGNED_BYTE, g), o.call(null, new s(g[0], g[1], g[2], g[3] / 255)); } else { const m = r(e, 'width', f); const y = r(e, 'height', p); const x = m * y * 4; const T = new Uint8Array(x); i.readPixels(l, p - u - y, m, y, i.RGBA, i.UNSIGNED_BYTE, T); for (var w = n.createWebGL(this, m, y), b = w.getContext('2d'), E = b.getImageData(0, 0, m, y), S = E.data, A = 0; A < y; A++) for (let _ = 0; _ < m; _++) { const C = 4 * ((y - A) * m + _); const M = d ? x - 4 * (A * m + (m - _)) : 4 * (A * m + _); S[M + 0] = T[C + 0], S[M + 1] = T[C + 1], S[M + 2] = T[C + 2], S[M + 3] = T[C + 3]; }b.putImageData(E, 0, 0); const P = new Image(); P.onerror = function () { o.call(null), n.remove(w); }, P.onload = function () { o.call(null, P), n.remove(w); }, P.src = w.toDataURL(a, h); } };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Felipe Alfonso <@bitnenfer>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(812); const r = i(813); const o = i(133); const a = new n({
    Extends: o,
    initialize(t) {
      o.call(this, {
        game: t.game,
        renderer: t.renderer,
        gl: t.renderer.gl,
        topology: t.topology ? t.topology : t.renderer.gl.TRIANGLES,
        vertShader: t.vertShader ? t.vertShader : r,
        fragShader: t.fragShader ? t.fragShader : s,
        vertexCapacity: t.vertexCapacity ? t.vertexCapacity : 3,
        vertexSize: t.vertexSize ? t.vertexSize : 2 * Float32Array.BYTES_PER_ELEMENT,
        vertices: new Float32Array([-1, 1, -1, -7, 7, 1]).buffer,
        attributes: [{
          name: 'inPosition', size: 2, type: t.renderer.gl.FLOAT, normalized: !1, offset: 0,
        }],
      }), this.vertexViewF32 = new Float32Array(this.vertexData), this.maxQuads = 1, this.resolutionDirty = !0;
    },
    onBind() { o.prototype.onBind.call(this); const t = this.renderer; const e = this.program; return this.resolutionDirty && (t.setFloat2(e, 'uResolution', this.width, this.height), t.setInt1(e, 'uMainSampler', 0), t.setInt1(e, 'uMaskSampler', 1), this.resolutionDirty = !1), this; },
    resize(t, e, i) { return o.prototype.resize.call(this, t, e, i), this.resolutionDirty = !0, this; },
    beginMask(t, e, i) { const n = this.renderer; const s = this.gl; t.bitmapMask && s && (n.flush(), t.prevFramebuffer = n.currentFramebuffer, n.setFramebuffer(t.mainFramebuffer), s.disable(s.STENCIL_TEST), s.clearColor(0, 0, 0, 0), s.clear(s.COLOR_BUFFER_BIT), n.currentCameraMask.mask !== t && (n.currentMask.mask = t, n.currentMask.camera = i)); },
    endMask(t, e) { const i = this.gl; const n = this.renderer; const s = t.bitmapMask; if (s && i) { n.flush(), n.setFramebuffer(t.maskFramebuffer), i.clearColor(0, 0, 0, 0), i.clear(i.COLOR_BUFFER_BIT), n.setBlendMode(0, !0), s.renderWebGL(n, s, 0, e), n.flush(), n.setFramebuffer(t.prevFramebuffer); const r = n.getCurrentStencilMask(); r ? (i.enable(i.STENCIL_TEST), r.mask.applyStencil(n, r.camera, !0)) : n.currentMask.mask = null, n.setPipeline(this), i.activeTexture(i.TEXTURE1), i.bindTexture(i.TEXTURE_2D, t.maskTexture), i.activeTexture(i.TEXTURE0), i.bindTexture(i.TEXTURE_2D, t.mainTexture), i.uniform1i(i.getUniformLocation(this.program, 'uInvertMaskAlpha'), t.invertAlpha), i.drawArrays(this.topology, 0, 3); } },
  }); t.exports = a;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Felipe Alfonso <@bitnenfer>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(814); const r = i(191); let o = 10; const a = new n({
    Extends: r, initialize(t) { o = t.maxLights, t.fragShader = s.replace('%LIGHT_COUNT%', o.toString()), r.call(this, t), this.defaultNormalMap, this.inverseRotationMatrix = new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]); }, boot() { this.defaultNormalMap = this.game.textures.getFrame('__DEFAULT'); }, onBind(t) { r.prototype.onBind.call(this); const e = this.renderer; const i = this.program; return this.mvpUpdate(), e.setInt1(i, 'uNormSampler', 1), e.setFloat2(i, 'uResolution', this.width, this.height), t && this.setNormalMap(t), this; }, onRender(t, e) { this.active = !1; const i = t.sys.lights; if (!i || i.lights.length <= 0 || !i.active) return this; const n = i.cull(e); const s = Math.min(n.length, o); if (s === 0) return this; this.active = !0; let r; const a = this.renderer; const h = this.program; const l = e.matrix; const u = { x: 0, y: 0 }; const c = a.height; for (r = 0; r < o; ++r)a.setFloat1(h, `uLights[${r}].radius`, 0); for (a.setFloat4(h, 'uCamera', e.x, e.y, e.rotation, e.zoom), a.setFloat3(h, 'uAmbientLightColor', i.ambientColor.r, i.ambientColor.g, i.ambientColor.b), r = 0; r < s; ++r) { const d = n[r]; const f = `uLights[${r}].`; l.transformPoint(d.x, d.y, u), a.setFloat2(h, `${f}position`, u.x - e.scrollX * d.scrollFactorX * e.zoom, c - (u.y - e.scrollY * d.scrollFactorY * e.zoom)), a.setFloat3(h, `${f}color`, d.r, d.g, d.b), a.setFloat1(h, `${f}intensity`, d.intensity), a.setFloat1(h, `${f}radius`, d.radius); } return this.currentNormalMapRotation = null, this; }, batchTexture(t, e, i, n, s, r, o, a, h, l, u, c, d, f, p, g, v, m, y, x, T, w, b, E, S, A, _, C, M, P) { let O; if (this.active) if (this.renderer.setPipeline(this), t.displayTexture ? O = t.displayTexture.dataSource[t.displayFrame.sourceIndex] : t.texture ? O = t.texture.dataSource[t.frame.sourceIndex] : t.tileset && (O = Array.isArray(t.tileset) ? t.tileset[0].image.dataSource[0] : t.tileset.image.dataSource[0]), O) { this.setTexture2D(O.glTexture, 1), this.setNormalMapRotation(u); const R = this._tempMatrix1; const L = this._tempMatrix2; const D = this._tempMatrix3; let k = m / i + _; let F = y / n + C; let I = (m + x) / i + _; let B = (y + T) / n + C; let N = o; let Y = a; let X = -g; let z = -v; if (t.isCropped) { const U = t._crop; N = U.width, Y = U.height, o = U.width, a = U.height; let G = m = U.x; let W = y = U.y; c && (G = x - U.x - U.width), d && !e.isRenderTexture && (W = T - U.y - U.height), k = G / i + _, F = W / n + C, I = (G + U.width) / i + _, B = (W + U.height) / n + C, X = -g + m, z = -v + y; }c && (N *= -1, X += o), (d ^= e.isRenderTexture ? 1 : 0) && (Y *= -1, z += a); const V = X + N; const H = z + Y; L.applyITRS(s, r, u, h, l), R.copyFrom(M.matrix), P ? (R.multiplyWithOffset(P, -M.scrollX * f, -M.scrollY * p), L.e = s, L.f = r, R.multiply(L, D)) : (L.e -= M.scrollX * f, L.f -= M.scrollY * p, R.multiply(L, D)); let j = D.getX(X, z); let q = D.getY(X, z); let K = D.getX(X, H); let J = D.getY(X, H); let Z = D.getX(V, H); let Q = D.getY(V, H); let $ = D.getX(V, z); let tt = D.getY(V, z); M.roundPixels && (j = Math.round(j), q = Math.round(q), K = Math.round(K), J = Math.round(J), Z = Math.round(Z), Q = Math.round(Q), $ = Math.round($), tt = Math.round(tt)), this.setTexture2D(e, 0), this.batchQuad(j, q, K, J, Z, Q, $, tt, k, F, I, B, w, b, E, S, A, e, 0); } else console.warn('Normal map missing or invalid'); }, setNormalMap(t) { let e; this.active && t && (t.texture && (e = t.texture.dataSource[t.frame.sourceIndex]), e || (e = this.defaultNormalMap), this.setTexture2D(e.glTexture, 1), this.renderer.setPipeline(t.defaultPipeline)); }, setNormalMapRotation(t) { if (t !== this.currentNormalMapRotation || this.batches.length === 0) { this.batches.length > 0 && this.flush(); const e = this.inverseRotationMatrix; if (t) { const i = -t; const n = Math.cos(i); const s = Math.sin(i); e[1] = s, e[3] = -s, e[0] = e[4] = n; } else e[0] = e[4] = 1, e[1] = e[3] = 0; this.renderer.setMatrix3(this.program, 'uInverseRotationMatrix', !1, e), this.currentNormalMapRotation = t; } }, batchSprite(t, e, i) { if (this.active) { const n = t.texture.dataSource[t.frame.sourceIndex]; n && (this.renderer.setPipeline(this), this.setTexture2D(n.glTexture, 1), this.setNormalMapRotation(t.rotation), r.prototype.batchSprite.call(this, t, e, i)); } },
  }); a.LIGHT_COUNT = o, t.exports = a;
}, function (t, e) { t.exports = ['#define SHADER_NAME PHASER_TEXTURE_TINT_FS', '', 'precision mediump float;', '', 'uniform sampler2D uMainSampler;', '', 'varying vec2 outTexCoord;', 'varying float outTintEffect;', 'varying vec4 outTint;', '', 'void main()', '{', '    vec4 texture = texture2D(uMainSampler, outTexCoord);', '    vec4 texel = vec4(outTint.rgb * outTint.a, outTint.a);', '    vec4 color = texture;', '', '    if (outTintEffect == 0.0)', '    {', '        //  Multiply texture tint', '        color = texture * texel;', '    }', '    else if (outTintEffect == 1.0)', '    {', '        //  Solid color + texture alpha', '        color.rgb = mix(texture.rgb, outTint.rgb * outTint.a, texture.a);', '        color.a = texture.a * texel.a;', '    }', '    else if (outTintEffect == 2.0)', '    {', '        //  Solid color, no texture', '        color = texel;', '    }', '', '    gl_FragColor = color;', '}', ''].join('\n'); }, function (t, e) { t.exports = ['#define SHADER_NAME PHASER_TEXTURE_TINT_VS', '', 'precision mediump float;', '', 'uniform mat4 uProjectionMatrix;', 'uniform mat4 uViewMatrix;', 'uniform mat4 uModelMatrix;', '', 'attribute vec2 inPosition;', 'attribute vec2 inTexCoord;', 'attribute float inTintEffect;', 'attribute vec4 inTint;', '', 'varying vec2 outTexCoord;', 'varying float outTintEffect;', 'varying vec4 outTint;', '', 'void main ()', '{', '    gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(inPosition, 1.0, 1.0);', '', '    outTexCoord = inTexCoord;', '    outTint = inTint;', '    outTintEffect = inTintEffect;', '}', '', ''].join('\n'); }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Felipe Alfonso <@bitnenfer>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(2); const r = i(192); const o = i(371); const a = i(372); const h = i(33); const l = i(133); const u = new n({
    Extends: l,
    Mixins: [r],
    initialize(t) {
      const e = t.renderer.config; l.call(this, {
        game: t.game,
        renderer: t.renderer,
        gl: t.renderer.gl,
        topology: t.renderer.gl.TRIANGLE_STRIP,
        vertShader: s(t, 'vertShader', a),
        fragShader: s(t, 'fragShader', o),
        vertexCapacity: s(t, 'vertexCapacity', 6 * e.batchSize),
        vertexSize: s(t, 'vertexSize', 5 * Float32Array.BYTES_PER_ELEMENT + 4 * Uint8Array.BYTES_PER_ELEMENT),
        attributes: [{
          name: 'inPosition', size: 2, type: t.renderer.gl.FLOAT, normalized: !1, offset: 0,
        }, {
          name: 'inTexCoord', size: 2, type: t.renderer.gl.FLOAT, normalized: !1, offset: 2 * Float32Array.BYTES_PER_ELEMENT,
        }, {
          name: 'inTintEffect', size: 1, type: t.renderer.gl.FLOAT, normalized: !1, offset: 4 * Float32Array.BYTES_PER_ELEMENT,
        }, {
          name: 'inTint', size: 4, type: t.renderer.gl.UNSIGNED_BYTE, normalized: !0, offset: 5 * Float32Array.BYTES_PER_ELEMENT,
        }],
      }), this.vertexViewF32 = new Float32Array(this.vertexData), this.vertexViewU32 = new Uint32Array(this.vertexData), this.maxQuads = e.batchSize, this.batches = [], this._tempMatrix1 = new h(), this._tempMatrix2 = new h(), this._tempMatrix3 = new h(), this.mvpInit();
    },
    onBind() { return l.prototype.onBind.call(this), this.mvpUpdate(), this; },
    resize(t, e, i) { return l.prototype.resize.call(this, t, e, i), this.projOrtho(0, this.width, this.height, 0, -1e3, 1e3), this; },
    setTexture2D(t, e) { return void 0 === t && (t = this.renderer.blankTexture.glTexture), void 0 === e && (e = 0), this.requireTextureBatch(t, e) && this.pushBatch(t, e), this; },
    requireTextureBatch(t, e) { const i = this.batches; const n = i.length; return !(n > 0) || !((e > 0 ? i[n - 1].textures[e - 1] : i[n - 1].texture) === t); },
    pushBatch(t, e) { if (e === 0) this.batches.push({ first: this.vertexCount, texture: t, textures: [] }); else { const i = []; i[e - 1] = t, this.batches.push({ first: this.vertexCount, texture: null, textures: i }); } },
    flush() { if (this.flushLocked) return this; this.flushLocked = !0; let t; let e; let i; const n = this.gl; const s = this.vertexCount; const r = this.topology; const o = this.vertexSize; const a = this.renderer; const h = this.batches; const l = h.length; let u = 0; let c = null; if (l === 0 || s === 0) return this.flushLocked = !1, this; n.bufferSubData(n.ARRAY_BUFFER, 0, this.bytes.subarray(0, s * o)); for (let d = 0; d < l - 1; d++) { if (c = h[d], t = h[d + 1], c.textures.length > 0) { for (e = 0; e < c.textures.length; ++e)(i = c.textures[e]) && a.setTexture2D(i, 1 + e, !1); n.activeTexture(n.TEXTURE0); }u = t.first - c.first, c.texture === null || u <= 0 || (a.setTexture2D(c.texture, 0, !1), n.drawArrays(r, c.first, u)); } if ((c = h[l - 1]).textures.length > 0) { for (e = 0; e < c.textures.length; ++e)(i = c.textures[e]) && a.setTexture2D(i, 1 + e, !1); n.activeTexture(n.TEXTURE0); } return u = s - c.first, c.texture && u > 0 && (a.setTexture2D(c.texture, 0, !1), n.drawArrays(r, c.first, u)), this.vertexCount = 0, h.length = 0, this.flushLocked = !1, this; },
  }); t.exports = u;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(39); t.exports = function (t) { const e = t.config; if (!e.hideBanner) { let i = 'WebGL'; e.renderType === n.CANVAS ? i = 'Canvas' : e.renderType === n.HEADLESS && (i = 'Headless'); let s; const r = e.audio; const o = t.device.audio; if (s = !o.webAudio || r && r.disableWebAudio ? r && r.noAudio || !o.webAudio && !o.audioData ? 'No Audio' : 'HTML5 Audio' : 'Web Audio', t.device.browser.ie)window.console && console.log(`Phaser v${n.VERSION} / https://phaser.io`); else { let a; let h = ''; const l = [h]; if (Array.isArray(e.bannerBackgroundColor))e.bannerBackgroundColor.forEach(((t) => { h = h.concat('%c '), l.push(`background: ${t}`), a = t; })), l[l.length - 1] = `color: ${e.bannerTextColor}; background: ${a}`; else h = h.concat('%c '), l.push(`color: ${e.bannerTextColor}; background: ${e.bannerBackgroundColor}`); l.push('background: #fff'), e.gameTitle && (h = h.concat(e.gameTitle), e.gameVersion && (h = h.concat(` v${e.gameVersion}`)), e.hidePhaser || (h = h.concat(' / '))); e.hidePhaser || (h = h.concat(`Phaser v${n.VERSION}-FB (${i} | ${s})`)), h = h.concat(` %c ${e.gameURL}`), l[0] = h, console.log.apply(console, l); } } };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(6); const r = i(1); const o = i(376); const a = new n({
    initialize(t, e) { this.game = t, this.raf = new o(), this.started = !1, this.running = !1, this.minFps = s(e, 'min', 5), this.targetFps = s(e, 'target', 60), this._min = 1e3 / this.minFps, this._target = 1e3 / this.targetFps, this.actualFps = this.targetFps, this.nextFpsUpdate = 0, this.framesThisSecond = 0, this.callback = r, this.forceSetTimeOut = s(e, 'forceSetTimeOut', !1), this.time = 0, this.startTime = 0, this.lastTime = 0, this.frame = 0, this.inFocus = !0, this._pauseTime = 0, this._coolDown = 0, this.delta = 0, this.deltaIndex = 0, this.deltaHistory = [], this.deltaSmoothingMax = s(e, 'deltaHistory', 10), this.panicMax = s(e, 'panicMax', 120), this.rawDelta = 0, this.now = 0, this.smoothStep = s(e, 'smoothStep', !0); }, blur() { this.inFocus = !1; }, focus() { this.inFocus = !0, this.resetDelta(); }, pause() { this._pauseTime = window.performance.now(); }, resume() { this.resetDelta(), this.startTime += this.time - this._pauseTime; }, resetDelta() { const t = window.performance.now(); this.time = t, this.lastTime = t, this.nextFpsUpdate = t + 1e3, this.framesThisSecond = 0; for (let e = 0; e < this.deltaSmoothingMax; e++) this.deltaHistory[e] = Math.min(this._target, this.deltaHistory[e]); this.delta = 0, this.deltaIndex = 0, this._coolDown = this.panicMax; }, start(t) { if (this.started) return this; this.started = !0, this.running = !0; for (let e = 0; e < this.deltaSmoothingMax; e++) this.deltaHistory[e] = this._target; this.resetDelta(), this.startTime = window.performance.now(), this.callback = t, this.raf.start(this.step.bind(this), this.forceSetTimeOut, this._target); }, step() { const t = window.performance.now(); this.now = t; let e = t - this.lastTime; e < 0 && (e = 0), this.rawDelta = e; const i = this.deltaIndex; const n = this.deltaHistory; const s = this.deltaSmoothingMax; let r = e; let o = e; if (this.smoothStep) { (this._coolDown > 0 || !this.inFocus) && (this._coolDown--, r = Math.min(r, this._target)), r > this._min && (r = n[i], r = Math.min(r, this._min)), n[i] = r, this.deltaIndex++, this.deltaIndex > s && (this.deltaIndex = 0), o = 0; for (let a = 0; a < s; a++)o += n[a]; o /= s; } this.delta = o, this.time += this.rawDelta, t > this.nextFpsUpdate && (this.actualFps = 0.25 * this.framesThisSecond + 0.75 * this.actualFps, this.nextFpsUpdate = t + 1e3, this.framesThisSecond = 0), this.framesThisSecond++; const h = o / this._target; this.callback(t, o, h), this.lastTime = t, this.frame++; }, tick() { this.step(); }, sleep() { this.running && (this.raf.stop(), this.running = !1); }, wake(t) { this.running ? this.sleep() : t && (this.startTime += -this.lastTime + (this.lastTime + window.performance.now())), this.raf.start(this.step.bind(this), this.useRAF), this.running = !0, this.step(); }, getDuration() { return Math.round(this.lastTime - this.startTime) / 1e3; }, getDurationMS() { return Math.round(this.lastTime - this.startTime); }, stop() { return this.running = !1, this.started = !1, this.raf.stop(), this; }, destroy() { this.stop(), this.callback = r, this.raf = null, this.game = null; },
  }); t.exports = a;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(1); const r = new n({
    initialize() { this.isRunning = !1, this.callback = s, this.tick = 0, this.isSetTimeOut = !1, this.timeOutID = null, this.lastTime = 0, this.target = 0; const t = this; this.step = function e() { const i = window.performance.now(); t.lastTime = t.tick, t.tick = i, t.callback(i), t.timeOutID = window.requestAnimationFrame(e); }, this.stepTimeout = function e() { const i = Date.now(); const n = Math.min(Math.max(2 * t.target + t.tick - i, 0), t.target); t.lastTime = t.tick, t.tick = i, t.callback(i), t.timeOutID = window.setTimeout(e, n); }; }, start(t, e, i) { this.isRunning || (this.callback = t, this.isSetTimeOut = e, this.target = i, this.isRunning = !0, this.timeOutID = e ? window.setTimeout(this.stepTimeout, 0) : window.requestAnimationFrame(this.step)); }, stop() { this.isRunning = !1, this.isSetTimeOut ? clearTimeout(this.timeOutID) : window.cancelAnimationFrame(this.timeOutID); }, destroy() { this.stop(), this.callback = s; },
  }); t.exports = r;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(22); t.exports = function (t) { let e; const i = t.events; if (void 0 !== document.hidden)e = 'visibilitychange'; else { ['webkit', 'moz', 'ms'].forEach(((t) => { void 0 !== document[`${t}Hidden`] && (document.hidden = function () { return document[`${t}Hidden`]; }, e = `${t}visibilitychange`); })); }e && document.addEventListener(e, ((t) => { document.hidden || t.type === 'pause' ? i.emit(n.HIDDEN) : i.emit(n.VISIBLE); }), !1), window.onblur = function () { i.emit(n.BLUR); }, window.onfocus = function () { i.emit(n.FOCUS); }, window.focus && t.config.autoFocus && window.focus(); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(379); const s = i(30); const r = i(6); t.exports = function (t) { const e = r(t, 'data', []); let i = r(t, 'canvas', null); const o = r(t, 'palette', n); const a = r(t, 'pixelWidth', 1); const h = r(t, 'pixelHeight', a); let l = r(t, 'resizeCanvas', !0); let u = r(t, 'clearCanvas', !0); const c = r(t, 'preRender', null); const d = r(t, 'postRender', null); const f = Math.floor(Math.abs(e[0].length * a)); const p = Math.floor(Math.abs(e.length * h)); i || (i = s.create2D(this, f, p), l = !1, u = !1), l && (i.width = f, i.height = p); const g = i.getContext('2d'); u && g.clearRect(0, 0, f, p), c && c(i, g); for (let v = 0; v < e.length; v++) for (let m = e[v], y = 0; y < m.length; y++) { const x = m[y]; x !== '.' && x !== ' ' && (g.fillStyle = o[x], g.fillRect(y * a, v * h, a, h)); } return d && d(i, g), i; };
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = {
    0: '#000', 1: '#9D9D9D', 2: '#FFF', 3: '#BE2633', 4: '#E06F8B', 5: '#493C2B', 6: '#A46422', 7: '#EB8931', 8: '#F7E26B', 9: '#2F484E', A: '#44891A', B: '#A3CE27', C: '#1B2632', D: '#005784', E: '#31A2F2', F: '#B2DCEF',
  };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(349); const r = i(89); const o = i(3); const a = new n({
    Extends: r, initialize(t, e, i, n) { r.call(this, 'CubicBezierCurve'), Array.isArray(t) && (n = new o(t[6], t[7]), i = new o(t[4], t[5]), e = new o(t[2], t[3]), t = new o(t[0], t[1])), this.p0 = t, this.p1 = e, this.p2 = i, this.p3 = n; }, getStartPoint(t) { return void 0 === t && (t = new o()), t.copy(this.p0); }, getResolution(t) { return t; }, getPoint(t, e) { void 0 === e && (e = new o()); const i = this.p0; const n = this.p1; const r = this.p2; const a = this.p3; return e.set(s(t, i.x, n.x, r.x, a.x), s(t, i.y, n.y, r.y, a.y)); }, draw(t, e) { void 0 === e && (e = 32); const i = this.getPoints(e); t.beginPath(), t.moveTo(this.p0.x, this.p0.y); for (let n = 1; n < i.length; n++)t.lineTo(i[n].x, i[n].y); return t.strokePath(), t; }, toJSON() { return { type: this.type, points: [this.p0.x, this.p0.y, this.p1.x, this.p1.y, this.p2.x, this.p2.y, this.p3.x, this.p3.y] }; },
  }); a.fromJSON = function (t) { const e = t.points; const i = new o(e[0], e[1]); const n = new o(e[2], e[3]); const s = new o(e[4], e[5]); const r = new o(e[6], e[7]); return new a(i, n, s, r); }, t.exports = a;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(89); const r = i(41); const o = i(6); const a = i(188); const h = i(3); const l = new n({
    Extends: s,
    initialize(t, e, i, n, a, l, u, c) { if (typeof t === 'object') { const d = t; t = o(d, 'x', 0), e = o(d, 'y', 0), i = o(d, 'xRadius', 0), n = o(d, 'yRadius', i), a = o(d, 'startAngle', 0), l = o(d, 'endAngle', 360), u = o(d, 'clockwise', !1), c = o(d, 'rotation', 0); } else void 0 === n && (n = i), void 0 === a && (a = 0), void 0 === l && (l = 360), void 0 === u && (u = !1), void 0 === c && (c = 0); s.call(this, 'EllipseCurve'), this.p0 = new h(t, e), this._xRadius = i, this._yRadius = n, this._startAngle = r(a), this._endAngle = r(l), this._clockwise = u, this._rotation = r(c); },
    getStartPoint(t) { return void 0 === t && (t = new h()), this.getPoint(0, t); },
    getResolution(t) { return 2 * t; },
    getPoint(t, e) { void 0 === e && (e = new h()); for (var i = 2 * Math.PI, n = this._endAngle - this._startAngle, s = Math.abs(n) < Number.EPSILON; n < 0;)n += i; for (;n > i;)n -= i; n < Number.EPSILON && (n = s ? 0 : i), this._clockwise && !s && (n === i ? n = -i : n -= i); const r = this._startAngle + t * n; let o = this.p0.x + this._xRadius * Math.cos(r); let a = this.p0.y + this._yRadius * Math.sin(r); if (this._rotation !== 0) { const l = Math.cos(this._rotation); const u = Math.sin(this._rotation); const c = o - this.p0.x; const d = a - this.p0.y; o = c * l - d * u + this.p0.x, a = c * u + d * l + this.p0.y; } return e.set(o, a); },
    setXRadius(t) { return this.xRadius = t, this; },
    setYRadius(t) { return this.yRadius = t, this; },
    setWidth(t) { return this.xRadius = 2 * t, this; },
    setHeight(t) { return this.yRadius = 2 * t, this; },
    setStartAngle(t) { return this.startAngle = t, this; },
    setEndAngle(t) { return this.endAngle = t, this; },
    setClockwise(t) { return this.clockwise = t, this; },
    setRotation(t) { return this.rotation = t, this; },
    x: { get() { return this.p0.x; }, set(t) { this.p0.x = t; } },
    y: { get() { return this.p0.y; }, set(t) { this.p0.y = t; } },
    xRadius: { get() { return this._xRadius; }, set(t) { this._xRadius = t; } },
    yRadius: { get() { return this._yRadius; }, set(t) { this._yRadius = t; } },
    startAngle: { get() { return a(this._startAngle); }, set(t) { this._startAngle = r(t); } },
    endAngle: { get() { return a(this._endAngle); }, set(t) { this._endAngle = r(t); } },
    clockwise: { get() { return this._clockwise; }, set(t) { this._clockwise = t; } },
    angle: { get() { return a(this._rotation); }, set(t) { this._rotation = r(t); } },
    rotation: { get() { return this._rotation; }, set(t) { this._rotation = t; } },
    toJSON() {
      return {
        type: this.type, x: this.p0.x, y: this.p0.y, xRadius: this._xRadius, yRadius: this._yRadius, startAngle: a(this._startAngle), endAngle: a(this._endAngle), clockwise: this._clockwise, rotation: a(this._rotation),
      };
    },
  }); l.fromJSON = function (t) { return new l(t); }, t.exports = l;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(89); const r = i(193); const o = i(12); const a = i(3); const h = new a(); const l = new n({
    Extends: s, initialize(t, e) { s.call(this, 'LineCurve'), Array.isArray(t) && (e = new a(t[2], t[3]), t = new a(t[0], t[1])), this.p0 = t, this.p1 = e, this.arcLengthDivisions = 1; }, getBounds(t) { return void 0 === t && (t = new o()), r([this.p0, this.p1], t); }, getStartPoint(t) { return void 0 === t && (t = new a()), t.copy(this.p0); }, getResolution(t) { return void 0 === t && (t = 1), t; }, getPoint(t, e) { return void 0 === e && (e = new a()), t === 1 ? e.copy(this.p1) : (e.copy(this.p1).subtract(this.p0).scale(t).add(this.p0), e); }, getPointAt(t, e) { return this.getPoint(t, e); }, getTangent() { return h.copy(this.p1).subtract(this.p0).normalize(); }, getUtoTmapping(t, e, i) { let n; if (e) { const s = this.getLengths(i); const r = s[s.length - 1]; n = Math.min(e, r) / r; } else n = t; return n; }, draw(t) { return t.lineBetween(this.p0.x, this.p0.y, this.p1.x, this.p1.y), t; }, toJSON() { return { type: this.type, points: [this.p0.x, this.p0.y, this.p1.x, this.p1.y] }; },
  }); l.fromJSON = function (t) { const e = t.points; const i = new a(e[0], e[1]); const n = new a(e[2], e[3]); return new l(i, n); }, t.exports = l;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(89); const r = i(350); const o = i(3); const a = new n({
    Extends: s, initialize(t, e, i) { s.call(this, 'QuadraticBezier'), Array.isArray(t) && (i = new o(t[4], t[5]), e = new o(t[2], t[3]), t = new o(t[0], t[1])), this.p0 = t, this.p1 = e, this.p2 = i; }, getStartPoint(t) { return void 0 === t && (t = new o()), t.copy(this.p0); }, getResolution(t) { return t; }, getPoint(t, e) { void 0 === e && (e = new o()); const i = this.p0; const n = this.p1; const s = this.p2; return e.set(r(t, i.x, n.x, s.x), r(t, i.y, n.y, s.y)); }, draw(t, e) { void 0 === e && (e = 32); const i = this.getPoints(e); t.beginPath(), t.moveTo(this.p0.x, this.p0.y); for (let n = 1; n < i.length; n++)t.lineTo(i[n].x, i[n].y); return t.strokePath(), t; }, toJSON() { return { type: this.type, points: [this.p0.x, this.p0.y, this.p1.x, this.p1.y, this.p2.x, this.p2.y] }; },
  }); a.fromJSON = function (t) { const e = t.points; const i = new o(e[0], e[1]); const n = new o(e[2], e[3]); const s = new o(e[4], e[5]); return new a(i, n, s); }, t.exports = a;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(186); const s = i(0); const r = i(89); const o = i(3); const a = new s({
    Extends: r, initialize(t) { void 0 === t && (t = []), r.call(this, 'SplineCurve'), this.points = [], this.addPoints(t); }, addPoints(t) { for (let e = 0; e < t.length; e++) { const i = new o(); typeof t[e] === 'number' ? (i.x = t[e], i.y = t[e + 1], e++) : Array.isArray(t[e]) ? (i.x = t[e][0], i.y = t[e][1]) : (i.x = t[e].x, i.y = t[e].y), this.points.push(i); } return this; }, addPoint(t, e) { const i = new o(t, e); return this.points.push(i), i; }, getStartPoint(t) { return void 0 === t && (t = new o()), t.copy(this.points[0]); }, getResolution(t) { return t * this.points.length; }, getPoint(t, e) { void 0 === e && (e = new o()); const i = this.points; const s = (i.length - 1) * t; const r = Math.floor(s); const a = s - r; const h = i[r === 0 ? r : r - 1]; const l = i[r]; const u = i[r > i.length - 2 ? i.length - 1 : r + 1]; const c = i[r > i.length - 3 ? i.length - 1 : r + 2]; return e.set(n(a, h.x, l.x, u.x, c.x), n(a, h.y, l.y, u.y, c.y)); }, toJSON() { for (var t = [], e = 0; e < this.points.length; e++)t.push(this.points[e].x), t.push(this.points[e].y); return { type: this.type, points: t }; },
  }); a.fromJSON = function (t) { return new a(t.points); }, t.exports = a;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = new (i(0))({ initialize(t, e, i, n) { e && e !== '' || (e = ['precision mediump float;', 'uniform vec2 resolution;', 'varying vec2 fragCoord;', 'void main () {', '    vec2 uv = fragCoord / resolution.xy;', '    gl_FragColor = vec4(uv.xyx, 1.0);', '}'].join('\n')), i && i !== '' || (i = ['precision mediump float;', 'uniform mat4 uProjectionMatrix;', 'uniform mat4 uViewMatrix;', 'uniform vec2 uResolution;', 'attribute vec2 inPosition;', 'varying vec2 fragCoord;', 'void main () {', 'gl_Position = uProjectionMatrix * uViewMatrix * vec4(inPosition, 1.0, 1.0);', 'fragCoord = vec2(inPosition.x, uResolution.y - inPosition.y);', '}'].join('\n')), void 0 === n && (n = null), this.key = t, this.fragmentSrc = e, this.vertexSrc = i, this.uniforms = n; } }); t.exports = n;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(35); n.ColorToRGBA = i(836), n.ComponentToHex = i(387), n.GetColor = i(180), n.GetColor32 = i(319), n.HexStringToColor = i(318), n.HSLToColor = i(837), n.HSVColorWheel = i(838), n.HSVToRGB = i(181), n.HueToComponent = i(388), n.IntegerToColor = i(321), n.IntegerToRGB = i(322), n.Interpolate = i(839), n.ObjectToColor = i(323), n.RandomRGB = i(840), n.RGBStringToColor = i(324), n.RGBToHSV = i(320), n.RGBToString = i(841), n.ValueToColor = i(179), t.exports = n;
}, function (t, e) { t.exports = function (t) { const e = t.toString(16); return e.length === 1 ? `0${e}` : e; }; }, function (t, e) { t.exports = function (t, e, i) { return i < 0 && (i += 1), i > 1 && (i -= 1), i < 1 / 6 ? t + 6 * (e - t) * i : i < 0.5 ? e : i < 2 / 3 ? t + (e - t) * (2 / 3 - i) * 6 : t; }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(127); t.exports = function (t) { if (document.readyState !== 'complete' && document.readyState !== 'interactive') { var e = function () { document.removeEventListener('deviceready', e, !0), document.removeEventListener('DOMContentLoaded', e, !0), window.removeEventListener('load', e, !0), t(); }; document.body ? n.cordova ? document.addEventListener('deviceready', e, !1) : (document.addEventListener('DOMContentLoaded', e, !0), window.addEventListener('load', e, !0)) : window.setTimeout(e, 20); } else t(); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(194); t.exports = function (t, e) { const i = window.screen; const s = !!i && (i.orientation || i.mozOrientation || i.msOrientation); if (s && typeof s.type === 'string') return s.type; if (typeof s === 'string') return s; if (i) return i.height > i.width ? n.ORIENTATION.PORTRAIT : n.ORIENTATION.LANDSCAPE; if (typeof window.orientation === 'number') return window.orientation === 0 || window.orientation === 180 ? n.ORIENTATION.PORTRAIT : n.ORIENTATION.LANDSCAPE; if (window.matchMedia) { if (window.matchMedia('(orientation: portrait)').matches) return n.ORIENTATION.PORTRAIT; if (window.matchMedia('(orientation: landscape)').matches) return n.ORIENTATION.LANDSCAPE; } return e > t ? n.ORIENTATION.PORTRAIT : n.ORIENTATION.LANDSCAPE; };
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = {
    NO_CENTER: 0, CENTER_BOTH: 1, CENTER_HORIZONTALLY: 2, CENTER_VERTICALLY: 3,
  };
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = { LANDSCAPE: 'landscape-primary', PORTRAIT: 'portrait-primary' };
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = {
    NONE: 0, WIDTH_CONTROLS_HEIGHT: 1, HEIGHT_CONTROLS_WIDTH: 2, FIT: 3, ENVELOP: 4, RESIZE: 5,
  };
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = {
    NO_ZOOM: 1, ZOOM_2X: 2, ZOOM_4X: 4, MAX_ZOOM: -1,
  };
}, function (t, e) { t.exports = function (t) { let e; return t !== '' && (typeof t === 'string' ? e = document.getElementById(t) : t && t.nodeType === 1 && (e = t)), e || (e = document.body), e; }; }, function (t, e) { t.exports = function (t) { let e = ''; try { if (window.DOMParser)e = (new DOMParser()).parseFromString(t, 'text/xml'); else (e = new ActiveXObject('Microsoft.XMLDOM')).loadXML(t); } catch (t) { e = null; } return e && e.documentElement && !e.getElementsByTagName('parsererror').length ? e : null; }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(196); const r = i(10); const o = i(57); const a = i(22); const h = i(398); const l = i(399); const u = i(400); const c = i(401); const d = i(33); const f = i(358); const p = new n({
    initialize(t, e) { this.game = t, this.scaleManager, this.canvas, this.config = e, this.enabled = !0, this.events = new r(), this.isOver = !0, this.defaultCursor = '', this.keyboard = e.inputKeyboard ? new h(this) : null, this.mouse = e.inputMouse ? new l(this) : null, this.touch = e.inputTouch ? new c(this) : null, this.pointers = [], this.pointersTotal = e.inputActivePointers, e.inputTouch && this.pointersTotal === 1 && (this.pointersTotal = 2); for (let i = 0; i <= this.pointersTotal; i++) { const n = new u(this, i); n.smoothFactor = e.inputSmoothFactor, this.pointers.push(n); } this.mousePointer = e.inputMouse ? this.pointers[0] : null, this.activePointer = this.pointers[0], this.globalTopOnly = !0, this.time = 0, this._tempPoint = { x: 0, y: 0 }, this._tempHitTest = [], this._tempMatrix = new d(), this._tempMatrix2 = new d(), this._tempSkip = !1, this.mousePointerContainer = [this.mousePointer], t.events.once(a.BOOT, this.boot, this); }, boot() { this.canvas = this.game.canvas, this.scaleManager = this.game.scale, this.events.emit(o.MANAGER_BOOT), this.game.events.on(a.PRE_RENDER, this.preRender, this), this.game.events.once(a.DESTROY, this.destroy, this); }, setCanvasOver(t) { this.isOver = !0, this.events.emit(o.GAME_OVER, t); }, setCanvasOut(t) { this.isOver = !1, this.events.emit(o.GAME_OUT, t); }, preRender() { const t = this.game.loop.now; const e = this.game.loop.delta; const i = this.game.scene.getScenes(!0, !0); this.time = t, this.events.emit(o.MANAGER_UPDATE); for (let n = 0; n < i.length; n++) { const s = i[n]; if (s.sys.input && s.sys.input.updatePoll(t, e) && this.globalTopOnly) return; } }, setDefaultCursor(t) { this.defaultCursor = t, this.canvas.style.cursor !== t && (this.canvas.style.cursor = t); }, setCursor(t) { t.cursor && (this.canvas.style.cursor = t.cursor); }, resetCursor(t) { t.cursor && this.canvas && (this.canvas.style.cursor = this.defaultCursor); }, addPointer(t) { void 0 === t && (t = 1); const e = []; this.pointersTotal + t > 10 && (t = 10 - this.pointersTotal); for (let i = 0; i < t; i++) { const n = this.pointers.length; const s = new u(this, n); s.smoothFactor = this.config.inputSmoothFactor, this.pointers.push(s), this.pointersTotal++, e.push(s); } return e; }, updateInputPlugins(t, e) { const i = this.game.scene.getScenes(!0, !0); this._tempSkip = !1; for (let n = 0; n < i.length; n++) { const s = i[n]; if (s.sys.input) if (s.sys.input.update(t, e) && this.globalTopOnly || this._tempSkip) return; } }, onTouchStart(t) { for (var e = this.pointers, i = [], n = 0; n < t.changedTouches.length; n++) for (let r = t.changedTouches[n], o = 1; o < this.pointersTotal; o++) { const a = e[o]; if (!a.active) { a.touchstart(r, t), this.activePointer = a, i.push(a); break; } } this.updateInputPlugins(s.TOUCH_START, i); }, onTouchMove(t) { for (var e = this.pointers, i = [], n = 0; n < t.changedTouches.length; n++) for (let r = t.changedTouches[n], o = 1; o < this.pointersTotal; o++) { const a = e[o]; if (a.active && a.identifier === r.identifier) { a.touchmove(r, t), this.activePointer = a, i.push(a); break; } } this.updateInputPlugins(s.TOUCH_MOVE, i); }, onTouchEnd(t) { for (var e = this.pointers, i = [], n = 0; n < t.changedTouches.length; n++) for (let r = t.changedTouches[n], o = 1; o < this.pointersTotal; o++) { const a = e[o]; if (a.active && a.identifier === r.identifier) { a.touchend(r, t), i.push(a); break; } } this.updateInputPlugins(s.TOUCH_END, i); }, onTouchCancel(t) { for (var e = this.pointers, i = [], n = 0; n < t.changedTouches.length; n++) for (let r = t.changedTouches[n], o = 1; o < this.pointersTotal; o++) { const a = e[o]; if (a.active && a.identifier === r.identifier) { a.touchcancel(r, t), i.push(a); break; } } this.updateInputPlugins(s.TOUCH_CANCEL, i); }, onMouseDown(t) { this.mousePointer.down(t), this.mousePointer.updateMotion(), this.updateInputPlugins(s.MOUSE_DOWN, this.mousePointerContainer); }, onMouseMove(t) { this.mousePointer.move(t), this.mousePointer.updateMotion(), this.updateInputPlugins(s.MOUSE_MOVE, this.mousePointerContainer); }, onMouseUp(t) { this.mousePointer.up(t), this.mousePointer.updateMotion(), this.updateInputPlugins(s.MOUSE_UP, this.mousePointerContainer); }, onMouseWheel(t) { this.mousePointer.wheel(t), this.updateInputPlugins(s.MOUSE_WHEEL, this.mousePointerContainer); }, onPointerLockChange(t) { const e = this.mouse.locked; this.mousePointer.locked = e, this.events.emit(o.POINTERLOCK_CHANGE, t, e); }, inputCandidate(t, e) { const i = t.input; if (!i || !i.enabled || !i.alwaysEnabled && !t.willRender(e)) return !1; let n = !0; let s = t.parentContainer; if (s) do { if (!s.willRender(e)) { n = !1; break; }s = s.parentContainer; } while (s);return n; }, hitTest(t, e, i, n) { void 0 === n && (n = this._tempHitTest); const s = this._tempPoint; const r = i.scrollX; const o = i.scrollY; n.length = 0; let a = t.x; let h = t.y; i.resolution !== 1 && (a += i._x, h += i._y), i.getWorldPoint(a, h, s), t.worldX = s.x, t.worldY = s.y; for (let l = { x: 0, y: 0 }, u = this._tempMatrix, c = this._tempMatrix2, d = 0; d < e.length; d++) { const p = e[d]; if (this.inputCandidate(p, i)) { const g = s.x + r * p.scrollFactorX - r; const v = s.y + o * p.scrollFactorY - o; p.parentContainer ? (p.getWorldTransformMatrix(u, c), u.applyInverse(g, v, l)) : f(g, v, p.x, p.y, p.rotation, p.scaleX, p.scaleY, l), this.pointWithinHitArea(p, l.x, l.y) && n.push(p); } } return n; }, pointWithinHitArea(t, e, i) { e += t.displayOriginX, i += t.displayOriginY; const n = t.input; return !(!n || !n.hitAreaCallback(n.hitArea, e, i, t)) && (n.localX = e, n.localY = i, !0); }, pointWithinInteractiveObject(t, e, i) { return !!t.hitArea && (e += t.gameObject.displayOriginX, i += t.gameObject.displayOriginY, t.localX = e, t.localY = i, t.hitAreaCallback(t.hitArea, e, i, t)); }, transformPointer(t, e, i, n) { const s = t.position; const r = t.prevPosition; r.x = s.x, r.y = s.y; const o = this.scaleManager.transformX(e); const a = this.scaleManager.transformY(i); const h = t.smoothFactor; n && h !== 0 ? (s.x = o * h + r.x * (1 - h), s.y = a * h + r.y * (1 - h)) : (s.x = o, s.y = a); }, destroy() { this.events.removeAllListeners(), this.game.events.off(a.PRE_RENDER), this.keyboard && this.keyboard.destroy(), this.mouse && this.mouse.destroy(), this.touch && this.touch.destroy(); for (let t = 0; t < this.pointers.length; t++) this.pointers[t].destroy(); this.pointers = [], this._tempHitTest = [], this._tempMatrix.destroy(), this.canvas = null, this.game = null; },
  }); t.exports = p;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(135); const s = i(0); const r = i(22); const o = i(57); const a = i(136); const h = i(0); const l = new s({
    initialize(t) { this.manager = t, this.queue = [], this.preventDefault = !0, this.captures = [], this.enabled = !1, this.target, this.onKeyDown = h, this.onKeyUp = h, t.events.once(o.MANAGER_BOOT, this.boot, this); }, boot() { const t = this.manager.config; this.enabled = t.inputKeyboard, this.target = t.inputKeyboardEventTarget, this.addCapture(t.inputKeyboardCapture), !this.target && window && (this.target = window), this.enabled && this.target && this.startListeners(), this.manager.game.events.on(r.POST_STEP, this.postUpdate, this); }, startListeners() { const t = this; this.onKeyDown = function (e) { if (!e.defaultPrevented && t.enabled && t.manager) { t.queue.push(e), t.manager.useQueue || t.manager.events.emit(o.MANAGER_PROCESS); const i = e.altKey || e.ctrlKey || e.shiftKey || e.metaKey; t.preventDefault && !i && t.captures.indexOf(e.keyCode) > -1 && e.preventDefault(); } }, this.onKeyUp = function (e) { if (!e.defaultPrevented && t.enabled && t.manager) { t.queue.push(e), t.manager.useQueue || t.manager.events.emit(o.MANAGER_PROCESS); const i = e.altKey || e.ctrlKey || e.shiftKey || e.metaKey; t.preventDefault && !i && t.captures.indexOf(e.keyCode) > -1 && e.preventDefault(); } }; const e = this.target; e && (e.addEventListener('keydown', this.onKeyDown, !1), e.addEventListener('keyup', this.onKeyUp, !1), this.enabled = !0); }, stopListeners() { const t = this.target; t.removeEventListener('keydown', this.onKeyDown, !1), t.removeEventListener('keyup', this.onKeyUp, !1), this.enabled = !1; }, postUpdate() { this.queue = []; }, addCapture(t) { typeof t === 'string' && (t = t.split(',')), Array.isArray(t) || (t = [t]); for (var e = this.captures, i = 0; i < t.length; i++) { let n = t[i]; typeof n === 'string' && (n = a[n.trim().toUpperCase()]), e.indexOf(n) === -1 && e.push(n); } this.preventDefault = e.length > 0; }, removeCapture(t) { typeof t === 'string' && (t = t.split(',')), Array.isArray(t) || (t = [t]); for (var e = this.captures, i = 0; i < t.length; i++) { let s = t[i]; typeof s === 'string' && (s = a[s.toUpperCase()]), n(e, s); } this.preventDefault = e.length > 0; }, clearCaptures() { this.captures = [], this.preventDefault = !1; }, destroy() { this.stopListeners(), this.clearCaptures(), this.queue = [], this.manager.game.events.off(r.POST_RENDER, this.postUpdate, this), this.target = null, this.enabled = !1, this.manager = null; },
  }); t.exports = l;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(184); const r = i(57); const o = i(0); const a = new n({
    initialize(t) { this.manager = t, this.capture = !0, this.enabled = !1, this.target, this.locked = !1, this.onMouseMove = o, this.onMouseDown = o, this.onMouseUp = o, this.onMouseDownWindow = o, this.onMouseUpWindow = o, this.onMouseOver = o, this.onMouseOut = o, this.onMouseWheel = o, this.pointerLockChange = o, t.events.once(r.MANAGER_BOOT, this.boot, this); }, boot() { const t = this.manager.config; this.enabled = t.inputMouse, this.target = t.inputMouseEventTarget, this.capture = t.inputMouseCapture, this.target ? typeof this.target === 'string' && (this.target = document.getElementById(this.target)) : this.target = this.manager.game.canvas, t.disableContextMenu && this.disableContextMenu(), this.enabled && this.target && this.startListeners(); }, disableContextMenu() { return document.body.addEventListener('contextmenu', ((t) => (t.preventDefault(), !1))), this; }, requestPointerLock() { if (s.pointerLock) { const t = this.target; t.requestPointerLock = t.requestPointerLock || t.mozRequestPointerLock || t.webkitRequestPointerLock, t.requestPointerLock(); } }, releasePointerLock() { s.pointerLock && (document.exitPointerLock = document.exitPointerLock || document.mozExitPointerLock || document.webkitExitPointerLock, document.exitPointerLock()); }, startListeners() { const t = this; const e = this.manager.canvas; const i = window && window.focus && this.manager.game.config.autoFocus; this.onMouseMove = function (e) { !e.defaultPrevented && t.enabled && t.manager && t.manager.enabled && (t.manager.onMouseMove(e), t.capture && e.preventDefault()); }, this.onMouseDown = function (n) { i && window.focus(), !n.defaultPrevented && t.enabled && t.manager && t.manager.enabled && (t.manager.onMouseDown(n), t.capture && n.target === e && n.preventDefault()); }, this.onMouseDownWindow = function (i) { !i.defaultPrevented && t.enabled && t.manager && t.manager.enabled && i.target !== e && t.manager.onMouseDown(i); }, this.onMouseUp = function (i) { !i.defaultPrevented && t.enabled && t.manager && t.manager.enabled && (t.manager.onMouseUp(i), t.capture && i.target === e && i.preventDefault()); }, this.onMouseUpWindow = function (i) { !i.defaultPrevented && t.enabled && t.manager && t.manager.enabled && i.target !== e && t.manager.onMouseUp(i); }, this.onMouseOver = function (e) { !e.defaultPrevented && t.enabled && t.manager && t.manager.enabled && t.manager.setCanvasOver(e); }, this.onMouseOut = function (e) { !e.defaultPrevented && t.enabled && t.manager && t.manager.enabled && t.manager.setCanvasOut(e); }, this.onMouseWheel = function (e) { !e.defaultPrevented && t.enabled && t.manager && t.manager.enabled && t.manager.onMouseWheel(e); }; const n = this.target; if (n) { const r = { passive: !0 }; const o = { passive: !1 }; n.addEventListener('mousemove', this.onMouseMove, this.capture ? o : r), n.addEventListener('mousedown', this.onMouseDown, this.capture ? o : r), n.addEventListener('mouseup', this.onMouseUp, this.capture ? o : r), n.addEventListener('mouseover', this.onMouseOver, this.capture ? o : r), n.addEventListener('mouseout', this.onMouseOut, this.capture ? o : r), n.addEventListener('wheel', this.onMouseWheel, this.capture ? o : r), window && this.manager.game.config.inputWindowEvents && (window.addEventListener('mousedown', this.onMouseDownWindow, o), window.addEventListener('mouseup', this.onMouseUpWindow, o)), s.pointerLock && (this.pointerLockChange = function (e) { const i = t.target; t.locked = document.pointerLockElement === i || document.mozPointerLockElement === i || document.webkitPointerLockElement === i, t.manager.onPointerLockChange(e); }, document.addEventListener('pointerlockchange', this.pointerLockChange, !0), document.addEventListener('mozpointerlockchange', this.pointerLockChange, !0), document.addEventListener('webkitpointerlockchange', this.pointerLockChange, !0)), this.enabled = !0; } }, stopListeners() { const t = this.target; t.removeEventListener('mousemove', this.onMouseMove), t.removeEventListener('mousedown', this.onMouseDown), t.removeEventListener('mouseup', this.onMouseUp), t.removeEventListener('mouseover', this.onMouseOver), t.removeEventListener('mouseout', this.onMouseOut), window && (window.removeEventListener('mousedown', this.onMouseDownWindow), window.removeEventListener('mouseup', this.onMouseUpWindow)), s.pointerLock && (document.removeEventListener('pointerlockchange', this.pointerLockChange, !0), document.removeEventListener('mozpointerlockchange', this.pointerLockChange, !0), document.removeEventListener('webkitpointerlockchange', this.pointerLockChange, !0)); }, destroy() { this.stopListeners(), this.target = null, this.enabled = !1, this.manager = null; },
  }); t.exports = a;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(341); const s = i(0); const r = i(56); const o = i(98); const a = i(351); const h = i(3); const l = new s({
    initialize(t, e) { this.manager = t, this.id = e, this.event, this.downElement, this.upElement, this.camera = null, this.button = 0, this.buttons = 0, this.position = new h(), this.prevPosition = new h(), this.midPoint = new h(-1, -1), this.velocity = new h(), this.angle = 0, this.distance = 0, this.smoothFactor = 0, this.motionFactor = 0.2, this.worldX = 0, this.worldY = 0, this.moveTime = 0, this.downX = 0, this.downY = 0, this.downTime = 0, this.upX = 0, this.upY = 0, this.upTime = 0, this.primaryDown = !1, this.isDown = !1, this.wasTouch = !1, this.wasCanceled = !1, this.movementX = 0, this.movementY = 0, this.identifier = 0, this.pointerId = null, this.active = e === 0, this.locked = !1, this.deltaX = 0, this.deltaY = 0, this.deltaZ = 0; }, updateWorldPoint(t) { let e = this.x; let i = this.y; t.resolution !== 1 && (e += t._x, i += t._y); const n = t.getWorldPoint(e, i); return this.worldX = n.x, this.worldY = n.y, this; }, positionToCamera(t, e) { return t.getWorldPoint(this.x, this.y, e); }, updateMotion() { const t = this.position.x; const e = this.position.y; const i = this.midPoint.x; const s = this.midPoint.y; if (t !== i || e !== s) { let r = a(this.motionFactor, i, t); let h = a(this.motionFactor, s, e); o(r, t, 0.1) && (r = t), o(h, e, 0.1) && (h = e), this.midPoint.set(r, h); const l = t - r; const u = e - h; this.velocity.set(l, u), this.angle = n(r, h, t, e), this.distance = Math.sqrt(l * l + u * u); } }, up(t) { 'buttons' in t && (this.buttons = t.buttons), this.event = t, this.button = t.button, this.upElement = t.target, this.manager.transformPointer(this, t.pageX, t.pageY, !1), t.button === 0 && (this.primaryDown = !1, this.upX = this.x, this.upY = this.y, this.upTime = t.timeStamp), this.isDown = !1, this.wasTouch = !1; }, down(t) { 'buttons' in t && (this.buttons = t.buttons), this.event = t, this.button = t.button, this.downElement = t.target, this.manager.transformPointer(this, t.pageX, t.pageY, !1), t.button === 0 && (this.primaryDown = !0, this.downX = this.x, this.downY = this.y, this.downTime = t.timeStamp), this.isDown = !0, this.wasTouch = !1; }, move(t) { 'buttons' in t && (this.buttons = t.buttons), this.event = t, this.manager.transformPointer(this, t.pageX, t.pageY, !0), this.locked && (this.movementX = t.movementX || t.mozMovementX || t.webkitMovementX || 0, this.movementY = t.movementY || t.mozMovementY || t.webkitMovementY || 0), this.moveTime = t.timeStamp, this.wasTouch = !1; }, wheel(t) { 'buttons' in t && (this.buttons = t.buttons), this.event = t, this.manager.transformPointer(this, t.pageX, t.pageY, !1), this.deltaX = t.deltaX, this.deltaY = t.deltaY, this.deltaZ = t.deltaZ, this.wasTouch = !1; }, touchstart(t, e) { t.pointerId && (this.pointerId = t.pointerId), this.identifier = t.identifier, this.target = t.target, this.active = !0, this.buttons = 1, this.event = e, this.downElement = t.target, this.manager.transformPointer(this, t.pageX, t.pageY, !1), this.primaryDown = !0, this.downX = this.x, this.downY = this.y, this.downTime = e.timeStamp, this.isDown = !0, this.wasTouch = !0, this.wasCanceled = !1, this.updateMotion(); }, touchmove(t, e) { this.event = e, this.manager.transformPointer(this, t.pageX, t.pageY, !0), this.moveTime = e.timeStamp, this.wasTouch = !0, this.updateMotion(); }, touchend(t, e) { this.buttons = 0, this.event = e, this.upElement = t.target, this.manager.transformPointer(this, t.pageX, t.pageY, !1), this.primaryDown = !1, this.upX = this.x, this.upY = this.y, this.upTime = e.timeStamp, this.isDown = !1, this.wasTouch = !0, this.wasCanceled = !1, this.active = !1, this.updateMotion(); }, touchcancel(t, e) { this.buttons = 0, this.event = e, this.upElement = t.target, this.manager.transformPointer(this, t.pageX, t.pageY, !1), this.primaryDown = !1, this.upX = this.x, this.upY = this.y, this.upTime = e.timeStamp, this.isDown = !1, this.wasTouch = !0, this.wasCanceled = !0, this.active = !1; }, noButtonDown() { return this.buttons === 0; }, leftButtonDown() { return !!(1 & this.buttons); }, rightButtonDown() { return !!(2 & this.buttons); }, middleButtonDown() { return !!(4 & this.buttons); }, backButtonDown() { return !!(8 & this.buttons); }, forwardButtonDown() { return !!(16 & this.buttons); }, leftButtonReleased() { return this.button === 0 && !this.isDown; }, rightButtonReleased() { return this.button === 2 && !this.isDown; }, middleButtonReleased() { return this.button === 1 && !this.isDown; }, backButtonReleased() { return this.button === 3 && !this.isDown; }, forwardButtonReleased() { return this.button === 4 && !this.isDown; }, getDistance() { return this.isDown ? r(this.downX, this.downY, this.x, this.y) : r(this.downX, this.downY, this.upX, this.upY); }, getDistanceX() { return this.isDown ? Math.abs(this.downX - this.x) : Math.abs(this.downX - this.upX); }, getDistanceY() { return this.isDown ? Math.abs(this.downY - this.y) : Math.abs(this.downY - this.upY); }, getDuration() { return this.isDown ? this.manager.time - this.downTime : this.upTime - this.downTime; }, getAngle() { return this.isDown ? n(this.downX, this.downY, this.x, this.y) : n(this.downX, this.downY, this.upX, this.upY); }, getInterpolatedPosition(t, e) { void 0 === t && (t = 10), void 0 === e && (e = []); for (let i = this.prevPosition.x, n = this.prevPosition.y, s = this.position.x, r = this.position.y, o = 0; o < t; o++) { const h = 1 / t * o; e[o] = { x: a(h, i, s), y: a(h, n, r) }; } return e; }, destroy() { this.camera = null, this.manager = null, this.position = null; }, x: { get() { return this.position.x; }, set(t) { this.position.x = t; } }, y: { get() { return this.position.y; }, set(t) { this.position.y = t; } }, time: { get() { return this.event ? this.event.timeStamp : 0; } },
  }); t.exports = l;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(57); const r = i(1); const o = new n({
    initialize(t) { this.manager = t, this.capture = !0, this.enabled = !1, this.target, this.onTouchStart = r, this.onTouchStartWindow = r, this.onTouchMove = r, this.onTouchEnd = r, this.onTouchEndWindow = r, this.onTouchCancel = r, this.onTouchCancelWindow = r, this.onTouchOver = r, this.onTouchOut = r, t.events.once(s.MANAGER_BOOT, this.boot, this); }, boot() { const t = this.manager.config; this.enabled = t.inputTouch, this.target = t.inputTouchEventTarget, this.capture = t.inputTouchCapture, this.target || (this.target = this.manager.game.canvas), t.disableContextMenu && this.disableContextMenu(), this.enabled && this.target && this.startListeners(); }, disableContextMenu() { return document.body.addEventListener('contextmenu', ((t) => (t.preventDefault(), !1))), this; }, startListeners() { const t = this; const e = this.manager.canvas; const i = window && window.focus && this.manager.game.config.autoFocus; this.onTouchStart = function (n) { i && window.focus(), !n.defaultPrevented && t.enabled && t.manager && t.manager.enabled && (t.manager.onTouchStart(n), t.capture && n.cancelable && n.target === e && n.preventDefault()); }, this.onTouchStartWindow = function (i) { !i.defaultPrevented && t.enabled && t.manager && t.manager.enabled && i.target !== e && t.manager.onTouchStart(i); }, this.onTouchMove = function (e) { !e.defaultPrevented && t.enabled && t.manager && t.manager.enabled && (t.manager.onTouchMove(e), t.capture && e.cancelable && e.preventDefault()); }, this.onTouchEnd = function (i) { !i.defaultPrevented && t.enabled && t.manager && t.manager.enabled && (t.manager.onTouchEnd(i), t.capture && i.cancelable && i.target === e && i.preventDefault()); }, this.onTouchEndWindow = function (i) { !i.defaultPrevented && t.enabled && t.manager && t.manager.enabled && i.target !== e && t.manager.onTouchEnd(i); }, this.onTouchCancel = function (e) { !e.defaultPrevented && t.enabled && t.manager && t.manager.enabled && (t.manager.onTouchCancel(e), t.capture && e.preventDefault()); }, this.onTouchCancelWindow = function (e) { !e.defaultPrevented && t.enabled && t.manager && t.manager.enabled && t.manager.onTouchCancel(e); }, this.onTouchOver = function (e) { !e.defaultPrevented && t.enabled && t.manager && t.manager.enabled && t.manager.setCanvasOver(e); }, this.onTouchOut = function (e) { !e.defaultPrevented && t.enabled && t.manager && t.manager.enabled && t.manager.setCanvasOut(e); }; const n = this.target; if (n) { const s = { passive: !0 }; const r = { passive: !1 }; n.addEventListener('touchstart', this.onTouchStart, this.capture ? r : s), n.addEventListener('touchmove', this.onTouchMove, this.capture ? r : s), n.addEventListener('touchend', this.onTouchEnd, this.capture ? r : s), n.addEventListener('touchcancel', this.onTouchCancel, this.capture ? r : s), n.addEventListener('touchover', this.onTouchOver, this.capture ? r : s), n.addEventListener('touchout', this.onTouchOut, this.capture ? r : s), window && this.manager.game.config.inputWindowEvents && (window.addEventListener('touchstart', this.onTouchStartWindow, r), window.addEventListener('touchend', this.onTouchEndWindow, r), window.addEventListener('touchcancel', this.onTouchCancelWindow, r)), this.enabled = !0; } }, stopListeners() { const t = this.target; t.removeEventListener('touchstart', this.onTouchStart), t.removeEventListener('touchmove', this.onTouchMove), t.removeEventListener('touchend', this.onTouchEnd), t.removeEventListener('touchcancel', this.onTouchCancel), t.removeEventListener('touchover', this.onTouchOver), t.removeEventListener('touchout', this.onTouchOut), window && (window.removeEventListener('touchstart', this.onTouchStartWindow), window.removeEventListener('touchend', this.onTouchEndWindow)); }, destroy() { this.stopListeners(), this.target = null, this.enabled = !1, this.manager = null; },
  }); t.exports = o;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(22); const r = i(10); const o = i(9); const a = i(17); const h = i(5); const l = i(2); const u = i(23); const c = i(135); const d = new n({
    Extends: r,
    initialize(t) { r.call(this), this.game = t, this.plugins = [], this.scenePlugins = [], this._pendingGlobal = [], this._pendingScene = [], t.isBooted ? this.boot() : t.events.once(s.BOOT, this.boot, this); },
    boot() { let t; let e; let i; let n; let r; let o; let a; const h = this.game.config; let u = h.installGlobalPlugins; for (u = u.concat(this._pendingGlobal), t = 0; t < u.length; t++)e = u[t], i = l(e, 'key', null), n = l(e, 'plugin', null), r = l(e, 'start', !1), o = l(e, 'mapping', null), a = l(e, 'data', null), i && (n ? this.install(i, n, r, o, a) : console.warn(`Missing \`plugin\` for key: ${i}`)); for (u = (u = h.installScenePlugins).concat(this._pendingScene), t = 0; t < u.length; t++)e = u[t], i = l(e, 'key', null), n = l(e, 'plugin', null), o = l(e, 'mapping', null), i && (n ? this.installScenePlugin(i, n, o) : console.warn(`Missing \`plugin\` for key: ${i}`)); this._pendingGlobal = [], this._pendingScene = [], this.game.events.once(s.DESTROY, this.destroy, this); },
    addToScene(t, e, i) { let n; let s; let r; const o = this.game; const a = t.scene; const h = t.settings.map; const l = t.settings.isBooted; for (n = 0; n < e.length; n++)o[s = e[n]] ? (t[s] = o[s], h.hasOwnProperty(s) && (a[h[s]] = t[s])) : s === 'game' && h.hasOwnProperty(s) && (a[h[s]] = o); for (let c = 0; c < i.length; c++) for (r = i[c], n = 0; n < r.length; n++) if (s = r[n], u.hasCore(s)) { const d = u.getCore(s); const f = new d.plugin(a, this); t[d.mapping] = f, d.custom ? a[d.mapping] = f : h.hasOwnProperty(d.mapping) && (a[h[d.mapping]] = f), l && f.boot(); } for (r = this.plugins, n = 0; n < r.length; n++) { const p = r[n]; p.mapping && (a[p.mapping] = p.plugin); } },
    getDefaultScenePlugins() { let t = this.game.config.defaultPlugins; return t = t.concat(this.scenePlugins); },
    installScenePlugin(t, e, i, n, s) { if (void 0 === s && (s = !1), typeof e === 'function') { if (u.hasCore(t)) { if (!s && u.hasCore(t)) return void console.warn(`Scene Plugin key in use: ${t}`); } else u.register(t, e, i, !0), this.scenePlugins.push(t); if (n) { const r = new e(n, this); n.sys[t] = r, i && i !== '' && (n[i] = r), r.boot(); } } else console.warn(`Invalid Scene Plugin: ${t}`); },
    install(t, e, i, n, s) {
      if (void 0 === i && (i = !1), void 0 === n && (n = null), void 0 === s && (s = null), typeof e !== 'function') return console.warn(`Invalid Plugin: ${t}`), null; if (u.hasCustom(t)) return console.warn(`Plugin key in use: ${t}`), null; if (n !== null && (i = !0), this.game.isBooted) { if (u.registerCustom(t, e, n, s), i) return this.start(t); } else {
        this._pendingGlobal.push({
          key: t, plugin: e, start: i, mapping: n, data: s,
        });
      } return null;
    },
    getIndex(t) { for (let e = this.plugins, i = 0; i < e.length; i++) { if (e[i].key === t) return i; } return -1; },
    getEntry(t) { const e = this.getIndex(t); if (e !== -1) return this.plugins[e]; },
    isActive(t) { const e = this.getEntry(t); return e && e.active; },
    start(t, e) { void 0 === e && (e = t); let i = this.getEntry(e); return i && !i.active ? (i.active = !0, i.plugin.start()) : i || (i = this.createEntry(t, e)), i ? i.plugin : null; },
    createEntry(t, e) {
      let i = u.getCustom(t); if (i) {
        const n = new i.plugin(this); i = {
          key: e, plugin: n, active: !0, mapping: i.mapping, data: i.data,
        }, this.plugins.push(i), n.init(i.data), n.start();
      } return i;
    },
    stop(t) { const e = this.getEntry(t); return e && e.active && (e.active = !1, e.plugin.stop()), this; },
    get(t, e) { void 0 === e && (e = !0); let i = this.getEntry(t); if (i) return i.plugin; const n = this.getClass(t); return n && e ? (i = this.createEntry(t, t)) ? i.plugin : null : n || null; },
    getClass(t) { return u.getCustomClass(t); },
    removeGlobalPlugin(t) { const e = this.getEntry(t); e && c(this.plugins, e), u.removeCustom(t); },
    removeScenePlugin(t) { c(this.scenePlugins, t), u.remove(t); },
    registerGameObject(t, e, i) { return e && h.register(t, e), i && a.register(t, i), this; },
    removeGameObject(t, e, i) { return void 0 === e && (e = !0), void 0 === i && (i = !0), e && h.remove(t), i && a.remove(t), this; },
    registerFileType(t, e, i) { o.register(t, e), i && i.sys.load && (i.sys.load[t] = e); },
    destroy() { for (let t = 0; t < this.plugins.length; t++) this.plugins[t].plugin.destroy(); u.destroyCustomPlugins(), this.game.noReturn && u.destroyCorePlugins(), this.game = null, this.plugins = [], this.scenePlugins = []; },
  }); t.exports = d;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(194); const s = i(0); const r = i(10); const o = i(104); const a = i(22); const h = i(894); const l = i(395); const u = i(390); const c = i(1); const d = i(12); const f = i(404); const p = i(105); const g = i(3); const v = new s({
    Extends: r,
    initialize(t) {
      r.call(this), this.game = t, this.canvas, this.canvasBounds = new d(), this.parent = null, this.parentIsWindow = !1, this.parentSize = new f(), this.gameSize = new f(), this.baseSize = new f(), this.displaySize = new f(), this.scaleMode = n.SCALE_MODE.NONE, this.resolution = 1, this.zoom = 1, this._resetZoom = !1, this.displayScale = new g(1, 1), this.autoRound = !1, this.autoCenter = n.CENTER.NO_CENTER, this.orientation = n.ORIENTATION.LANDSCAPE, this.fullscreen, this.fullscreenTarget = null, this._createdFullscreenTarget = !1, this.dirty = !1, this.resizeInterval = 500, this._lastCheck = 0, this._checkOrientation = !1, this.listeners = {
        orientationChange: c, windowResize: c, fullScreenChange: c, fullScreenError: c,
      };
    },
    preBoot() { this.parseConfig(this.game.config), this.game.events.once('boot', this.boot, this); },
    boot() { const t = this.game; this.canvas = t.canvas, this.fullscreen = t.device.fullscreen, this.scaleMode !== n.SCALE_MODE.RESIZE && this.displaySize.setAspectMode(this.scaleMode), this.scaleMode === n.SCALE_MODE.NONE ? this.resize(this.width, this.height) : (this.getParentBounds(), this.parentSize.width > 0 && this.parentSize.height > 0 && this.displaySize.setParent(this.parentSize), this.refresh()), t.events.on(a.PRE_STEP, this.step, this), t.events.once(a.DESTROY, this.destroy, this), this.startListeners(); },
    parseConfig(t) { this.getParent(t), this.getParentBounds(); let e = t.width; let i = t.height; const s = t.scaleMode; const r = t.resolution; let o = t.zoom; const a = t.autoRound; if (typeof e === 'string') { let h = this.parentSize.width; h === 0 && (h = window.innerWidth); const l = parseInt(e, 10) / 100; e = Math.floor(h * l); } if (typeof i === 'string') { let c = this.parentSize.height; c === 0 && (c = window.innerHeight); const d = parseInt(i, 10) / 100; i = Math.floor(c * d); } this.resolution = 1, this.scaleMode = s, this.autoRound = a, this.autoCenter = t.autoCenter, this.resizeInterval = t.resizeInterval, a && (e = Math.floor(e), i = Math.floor(i)), this.gameSize.setSize(e, i), o === n.ZOOM.MAX_ZOOM && (o = this.getMaxZoom()), this.zoom = o, o !== 1 && (this._resetZoom = !0), this.baseSize.setSize(e * r, i * r), a && (this.baseSize.width = Math.floor(this.baseSize.width), this.baseSize.height = Math.floor(this.baseSize.height)), t.minWidth > 0 && this.displaySize.setMin(t.minWidth * o, t.minHeight * o), t.maxWidth > 0 && this.displaySize.setMax(t.maxWidth * o, t.maxHeight * o), this.displaySize.setSize(e, i), this.orientation = u(e, i); },
    getParent(t) { const e = t.parent; if (e !== null) { if (this.parent = l(e), this.parentIsWindow = this.parent === document.body, t.expandParent && t.scaleMode !== n.SCALE_MODE.NONE) { let i = this.parent.getBoundingClientRect(); (this.parentIsWindow || i.height === 0) && (document.documentElement.style.height = '100%', document.body.style.height = '100%', i = this.parent.getBoundingClientRect(), this.parentIsWindow || i.height !== 0 || (this.parent.style.overflow = 'hidden', this.parent.style.width = '100%', this.parent.style.height = '100%')); }t.fullscreenTarget && !this.fullscreenTarget && (this.fullscreenTarget = l(t.fullscreenTarget)); } },
    getParentBounds() { if (!this.parent) return !1; const t = this.parentSize; const e = this.parent.getBoundingClientRect(); this.parentIsWindow && this.game.device.os.iOS && (e.height = h(!0)); const i = this.resolution; const n = e.width * i; const s = e.height * i; return (t.width !== n || t.height !== s) && (t.setSize(n, s), !0); },
    lockOrientation(t) { const e = screen.lockOrientation || screen.mozLockOrientation || screen.msLockOrientation; return !!e && e.call(screen, t); },
    setParentSize(t, e) { return this.parentSize.setSize(t, e), this.refresh(); },
    setGameSize(t, e) { const i = this.autoRound; const n = this.resolution; i && (t = Math.floor(t), e = Math.floor(e)); const s = this.width; const r = this.height; return this.gameSize.resize(t, e), this.baseSize.resize(t * n, e * n), i && (this.baseSize.width = Math.floor(this.baseSize.width), this.baseSize.height = Math.floor(this.baseSize.height)), this.displaySize.setAspectRatio(t / e), this.canvas.width = this.baseSize.width, this.canvas.height = this.baseSize.height, this.refresh(s, r); },
    resize(t, e) { const i = this.zoom; const n = this.resolution; const s = this.autoRound; s && (t = Math.floor(t), e = Math.floor(e)); const r = this.width; const o = this.height; this.gameSize.resize(t, e), this.baseSize.resize(t * n, e * n), s && (this.baseSize.width = Math.floor(this.baseSize.width), this.baseSize.height = Math.floor(this.baseSize.height)), this.displaySize.setSize(t * i * n, e * i * n), this.canvas.width = this.baseSize.width, this.canvas.height = this.baseSize.height; const a = this.canvas.style; let h = t * i; let l = e * i; return s && (h = Math.floor(h), l = Math.floor(l)), h === t && l === e || (a.width = `${h}px`, a.height = `${l}px`), this.refresh(r, o); },
    setZoom(t) { return this.zoom = t, this._resetZoom = !0, this.refresh(); },
    setMaxZoom() { return this.zoom = this.getMaxZoom(), this._resetZoom = !0, this.refresh(); },
    refresh(t, e) { void 0 === t && (t = this.width), void 0 === e && (e = this.height), this.updateScale(), this.updateBounds(), this.updateOrientation(), this.displayScale.set(this.baseSize.width / this.canvasBounds.width, this.baseSize.height / this.canvasBounds.height); const i = this.game.domContainer; if (i) { this.baseSize.setCSS(i); const n = this.canvas.style; const s = i.style; s.transform = `scale(${this.displaySize.width / this.baseSize.width},${this.displaySize.height / this.baseSize.height})`, s.marginLeft = n.marginLeft, s.marginTop = n.marginTop; } return this.emit(o.RESIZE, this.gameSize, this.baseSize, this.displaySize, this.resolution, t, e), this; },
    updateOrientation() { if (this._checkOrientation) { this._checkOrientation = !1; const t = u(this.width, this.height); t !== this.orientation && (this.orientation = t, this.emit(o.ORIENTATION_CHANGE, t)); } },
    updateScale() { let t; let e; const i = this.canvas.style; const s = this.gameSize.width; const r = this.gameSize.height; const o = this.zoom; const a = this.autoRound; this.scaleMode === n.SCALE_MODE.NONE ? (this.displaySize.setSize(s * o * 1, r * o * 1), t = this.displaySize.width / 1, e = this.displaySize.height / 1, a && (t = Math.floor(t), e = Math.floor(e)), this._resetZoom && (i.width = `${t}px`, i.height = `${e}px`, this._resetZoom = !1)) : this.scaleMode === n.SCALE_MODE.RESIZE ? (this.displaySize.setSize(this.parentSize.width, this.parentSize.height), this.gameSize.setSize(this.displaySize.width, this.displaySize.height), this.baseSize.setSize(1 * this.displaySize.width, 1 * this.displaySize.height), t = this.displaySize.width / 1, e = this.displaySize.height / 1, a && (t = Math.floor(t), e = Math.floor(e)), this.canvas.width = t, this.canvas.height = e) : (this.displaySize.setSize(this.parentSize.width, this.parentSize.height), t = this.displaySize.width / 1, e = this.displaySize.height / 1, a && (t = Math.floor(t), e = Math.floor(e)), i.width = `${t}px`, i.height = `${e}px`), this.getParentBounds(), this.updateCenter(); },
    getMaxZoom() { const t = p(this.parentSize.width, this.gameSize.width, 0, !0); const e = p(this.parentSize.height, this.gameSize.height, 0, !0); return Math.max(Math.min(t, e), 1); },
    updateCenter() { const t = this.autoCenter; if (t !== n.CENTER.NO_CENTER) { const e = this.canvas; const i = e.style; const s = e.getBoundingClientRect(); const r = s.width; const o = s.height; let a = Math.floor((this.parentSize.width - r) / 2); let h = Math.floor((this.parentSize.height - o) / 2); t === n.CENTER.CENTER_HORIZONTALLY ? h = 0 : t === n.CENTER.CENTER_VERTICALLY && (a = 0), i.marginLeft = `${a}px`, i.marginTop = `${h}px`; } },
    updateBounds() { const t = this.canvasBounds; const e = this.canvas.getBoundingClientRect(); t.x = e.left + (window.pageXOffset || 0) - (document.documentElement.clientLeft || 0), t.y = e.top + (window.pageYOffset || 0) - (document.documentElement.clientTop || 0), t.width = e.width, t.height = e.height; },
    transformX(t) { return (t - this.canvasBounds.left) * this.displayScale.x; },
    transformY(t) { return (t - this.canvasBounds.top) * this.displayScale.y; },
    startFullscreen(t) { void 0 === t && (t = { navigationUI: 'hide' }); const e = this.fullscreen; if (e.available) { if (!e.active) { let i; const n = this.getFullscreenTarget(); (i = e.keyboard ? n[e.request](Element.ALLOW_KEYBOARD_INPUT) : n[e.request](t)) ? i.then(this.fullscreenSuccessHandler.bind(this)).catch(this.fullscreenErrorHandler.bind(this)) : e.active ? this.fullscreenSuccessHandler() : this.fullscreenErrorHandler(); } } else this.emit(o.FULLSCREEN_UNSUPPORTED); },
    fullscreenSuccessHandler() { this.getParentBounds(), this.refresh(), this.emit(o.ENTER_FULLSCREEN); },
    fullscreenErrorHandler(t) { this.removeFullscreenTarget(), this.emit(o.FULLSCREEN_FAILED, t); },
    getFullscreenTarget() { if (!this.fullscreenTarget) { const t = document.createElement('div'); t.style.margin = '0', t.style.padding = '0', t.style.width = '100%', t.style.height = '100%', this.fullscreenTarget = t, this._createdFullscreenTarget = !0; } this._createdFullscreenTarget && (this.canvas.parentNode.insertBefore(this.fullscreenTarget, this.canvas), this.fullscreenTarget.appendChild(this.canvas)); return this.fullscreenTarget; },
    removeFullscreenTarget() { if (this._createdFullscreenTarget) { const t = this.fullscreenTarget; if (t && t.parentNode) { const e = t.parentNode; e.insertBefore(this.canvas, t), e.removeChild(t); } } },
    stopFullscreen() { const t = this.fullscreen; if (!t.available) return this.emit(o.FULLSCREEN_UNSUPPORTED), !1; t.active && document[t.cancel](), this.removeFullscreenTarget(), this.getParentBounds(), this.emit(o.LEAVE_FULLSCREEN), this.refresh(); },
    toggleFullscreen(t) { this.fullscreen.active ? this.stopFullscreen() : this.startFullscreen(t); },
    startListeners() { const t = this; const e = this.listeners; if (e.orientationChange = function () { t._checkOrientation = !0, t.dirty = !0; }, e.windowResize = function () { t.dirty = !0; }, window.addEventListener('orientationchange', e.orientationChange, !1), window.addEventListener('resize', e.windowResize, !1), this.fullscreen.available) { e.fullScreenChange = function (e) { return t.onFullScreenChange(e); }, e.fullScreenError = function (e) { return t.onFullScreenError(e); }; ['webkit', 'moz', ''].forEach(((t) => { document.addEventListener(`${t}fullscreenchange`, e.fullScreenChange, !1), document.addEventListener(`${t}fullscreenerror`, e.fullScreenError, !1); })), document.addEventListener('MSFullscreenChange', e.fullScreenChange, !1), document.addEventListener('MSFullscreenError', e.fullScreenError, !1); } },
    onFullScreenChange() { document.fullscreenElement || document.webkitFullscreenElement || document.msFullscreenElement || document.mozFullScreenElement || this.stopFullscreen(); },
    onFullScreenError() { this.removeFullscreenTarget(); },
    step(t, e) { this.parent && (this._lastCheck += e, (this.dirty || this._lastCheck > this.resizeInterval) && (this.getParentBounds() && this.refresh(), this.dirty = !1, this._lastCheck = 0)); },
    stopListeners() { const t = this.listeners; window.removeEventListener('orientationchange', t.orientationChange, !1), window.removeEventListener('resize', t.windowResize, !1); ['webkit', 'moz', ''].forEach(((e) => { document.removeEventListener(`${e}fullscreenchange`, t.fullScreenChange, !1), document.removeEventListener(`${e}fullscreenerror`, t.fullScreenError, !1); })), document.removeEventListener('MSFullscreenChange', t.fullScreenChange, !1), document.removeEventListener('MSFullscreenError', t.fullScreenError, !1); },
    destroy() { this.removeAllListeners(), this.stopListeners(), this.game = null, this.canvas = null, this.canvasBounds = null, this.parent = null, this.fullscreenTarget = null, this.parentSize.destroy(), this.gameSize.destroy(), this.baseSize.destroy(), this.displaySize.destroy(); },
    isFullscreen: { get() { return this.fullscreen.active; } },
    width: { get() { return this.gameSize.width; } },
    height: { get() { return this.gameSize.height; } },
    isPortrait: { get() { return this.orientation === n.ORIENTATION.PORTRAIT; } },
    isLandscape: { get() { return this.orientation === n.ORIENTATION.LANDSCAPE; } },
    isGamePortrait: { get() { return this.height > this.width; } },
    isGameLandscape: { get() { return this.width > this.height; } },
  }); t.exports = v;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(20); const s = i(0); const r = i(105); const o = i(3); var a = new s({
    initialize(t, e, i, n) { void 0 === t && (t = 0), void 0 === e && (e = t), void 0 === i && (i = 0), void 0 === n && (n = null), this._width = t, this._height = e, this._parent = n, this.aspectMode = i, this.aspectRatio = e === 0 ? 1 : t / e, this.minWidth = 0, this.minHeight = 0, this.maxWidth = Number.MAX_VALUE, this.maxHeight = Number.MAX_VALUE, this.snapTo = new o(); }, setAspectMode(t) { return void 0 === t && (t = 0), this.aspectMode = t, this.setSize(this._width, this._height); }, setSnap(t, e) { return void 0 === t && (t = 0), void 0 === e && (e = t), this.snapTo.set(t, e), this.setSize(this._width, this._height); }, setParent(t) { return this._parent = t, this.setSize(this._width, this._height); }, setMin(t, e) { return void 0 === t && (t = 0), void 0 === e && (e = t), this.minWidth = n(t, 0, this.maxWidth), this.minHeight = n(e, 0, this.maxHeight), this.setSize(this._width, this._height); }, setMax(t, e) { return void 0 === t && (t = Number.MAX_VALUE), void 0 === e && (e = t), this.maxWidth = n(t, this.minWidth, Number.MAX_VALUE), this.maxHeight = n(e, this.minHeight, Number.MAX_VALUE), this.setSize(this._width, this._height); }, setSize(t, e) { switch (void 0 === t && (t = 0), void 0 === e && (e = t), this.aspectMode) { case a.NONE: this._width = this.getNewWidth(r(t, this.snapTo.x)), this._height = this.getNewHeight(r(e, this.snapTo.y)), this.aspectRatio = this._height === 0 ? 1 : this._width / this._height; break; case a.WIDTH_CONTROLS_HEIGHT: this._width = this.getNewWidth(r(t, this.snapTo.x)), this._height = this.getNewHeight(this._width * (1 / this.aspectRatio), !1); break; case a.HEIGHT_CONTROLS_WIDTH: this._height = this.getNewHeight(r(e, this.snapTo.y)), this._width = this.getNewWidth(this._height * this.aspectRatio, !1); break; case a.FIT: this.constrain(t, e, !0); break; case a.ENVELOP: this.constrain(t, e, !1); } return this; }, setAspectRatio(t) { return this.aspectRatio = t, this.setSize(this._width, this._height); }, resize(t, e) { return this._width = this.getNewWidth(r(t, this.snapTo.x)), this._height = this.getNewHeight(r(e, this.snapTo.y)), this.aspectRatio = this._height === 0 ? 1 : this._width / this._height, this; }, getNewWidth(t, e) { return void 0 === e && (e = !0), t = n(t, this.minWidth, this.maxWidth), e && this._parent && t > this._parent.width && (t = Math.max(this.minWidth, this._parent.width)), t; }, getNewHeight(t, e) { return void 0 === e && (e = !0), t = n(t, this.minHeight, this.maxHeight), e && this._parent && t > this._parent.height && (t = Math.max(this.minHeight, this._parent.height)), t; }, constrain(t, e, i) { void 0 === t && (t = 0), void 0 === e && (e = t), void 0 === i && (i = !0), t = this.getNewWidth(t), e = this.getNewHeight(e); const n = this.snapTo; const s = e === 0 ? 1 : t / e; return i && this.aspectRatio > s || !i && this.aspectRatio < s ? (e = (t = r(t, n.x)) / this.aspectRatio, n.y > 0 && (t = (e = r(e, n.y)) * this.aspectRatio)) : (i && this.aspectRatio < s || !i && this.aspectRatio > s) && (t = (e = r(e, n.y)) * this.aspectRatio, n.x > 0 && (e = (t = r(t, n.x)) * (1 / this.aspectRatio))), this._width = t, this._height = e, this; }, fitTo(t, e) { return this.constrain(t, e, !0); }, envelop(t, e) { return this.constrain(t, e, !1); }, setWidth(t) { return this.setSize(t, this._height); }, setHeight(t) { return this.setSize(this._width, t); }, toString() { return `[{ Size (width=${this._width} height=${this._height} aspectRatio=${this.aspectRatio} aspectMode=${this.aspectMode}) }]`; }, setCSS(t) { t && t.style && (t.style.width = `${this._width}px`, t.style.height = `${this._height}px`); }, copy(t) { return t.setAspectMode(this.aspectMode), t.aspectRatio = this.aspectRatio, t.setSize(this.width, this.height); }, destroy() { this._parent = null, this.snapTo = null; }, width: { get() { return this._width; }, set(t) { this.setSize(t, this._height); } }, height: { get() { return this._height; }, set(t) { this.setSize(this._width, t); } },
  }); a.NONE = 0, a.WIDTH_CONTROLS_HEIGHT = 1, a.HEIGHT_CONTROLS_WIDTH = 2, a.FIT = 3, a.ENVELOP = 4, t.exports = a;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(137); const r = i(24); const o = i(22); const a = i(6); const h = i(90); const l = i(1); const u = i(406); const c = i(197); const d = new n({
    initialize(t, e) {
      if (this.game = t, this.keys = {}, this.scenes = [], this._pending = [], this._start = [], this._queue = [], this._data = {}, this.isProcessing = !1, this.isBooted = !1, this.customViewports = 0, e) {
        Array.isArray(e) || (e = [e]); for (let i = 0; i < e.length; i++) {
          this._pending.push({
            key: 'default', scene: e[i], autoStart: i === 0, data: {},
          });
        }
      }t.events.once(o.READY, this.bootQueue, this);
    },
    bootQueue() { if (!this.isBooted) { let t; let e; let i; let n; for (t = 0; t < this._pending.length; t++) { var s; i = (e = this._pending[t]).key, (n = e.scene) instanceof u ? s = this.createSceneFromInstance(i, n) : typeof n === 'object' ? s = this.createSceneFromObject(i, n) : typeof n === 'function' && (s = this.createSceneFromFunction(i, n)), i = s.sys.settings.key, this.keys[i] = s, this.scenes.push(s), this._data[i] && (s.sys.settings.data = this._data[i].data, this._data[i].autoStart && (e.autoStart = !0)), (e.autoStart || s.sys.settings.active) && this._start.push(i); } for (this._pending.length = 0, this._data = {}, this.isBooted = !0, t = 0; t < this._start.length; t++)e = this._start[t], this.start(e); this._start.length = 0; } },
    processQueue() { const t = this._pending.length; const e = this._queue.length; if (t !== 0 || e !== 0) { let i; let n; if (t) { for (i = 0; i < t; i++)n = this._pending[i], this.add(n.key, n.scene, n.autoStart, n.data); for (i = 0; i < this._start.length; i++)n = this._start[i], this.start(n); return this._start.length = 0, void (this._pending.length = 0); } for (i = 0; i < this._queue.length; i++) this[(n = this._queue[i]).op](n.keyA, n.keyB); this._queue.length = 0; } },
    add(t, e, i, n) {
      return void 0 === i && (i = !1), void 0 === n && (n = {}), this.isProcessing || !this.isBooted ? (this._pending.push({
        key: t, scene: e, autoStart: i, data: n,
      }), this.isBooted || (this._data[t] = { data: n }), null) : (t = this.getKey(t, e), e instanceof u ? s = this.createSceneFromInstance(t, e) : typeof e === 'object' ? (e.key = t, s = this.createSceneFromObject(t, e)) : typeof e === 'function' && (s = this.createSceneFromFunction(t, e)), s.sys.settings.data = n, t = s.sys.settings.key, this.keys[t] = s, this.scenes.push(s), (i || s.sys.settings.active) && (this._pending.length ? this._start.push(t) : this.start(t)), s); let s;
    },
    remove(t) { if (this.isProcessing) this._queue.push({ op: 'remove', keyA: t, keyB: null }); else { const e = this.getScene(t); if (!e || e.sys.isTransitioning()) return this; let i = this.scenes.indexOf(e); const n = e.sys.settings.key; i > -1 && (delete this.keys[n], this.scenes.splice(i, 1), this._start.indexOf(n) > -1 && (i = this._start.indexOf(n), this._start.splice(i, 1)), e.sys.destroy()); } return this; },
    bootScene(t) { let e; const i = t.sys; const n = i.settings; i.sceneUpdate = l, t.init && (t.init.call(t, n.data), n.status = s.INIT, n.isTransition && i.events.emit(r.TRANSITION_INIT, n.transitionFrom, n.transitionDuration)), i.load && (e = i.load).reset(), e && t.preload ? (t.preload.call(t), e.list.size === 0 ? this.create(t) : (n.status = s.LOADING, e.once(h.COMPLETE, this.loadComplete, this), e.start())) : this.create(t); },
    loadComplete(t) { const e = t.scene; this.game.sound && this.game.sound.onBlurPausedSounds && this.game.sound.unlock(), this.create(e); },
    payloadComplete(t) { this.bootScene(t.scene); },
    update(t, e) { this.processQueue(), this.isProcessing = !0; for (let i = this.scenes.length - 1; i >= 0; i--) { const n = this.scenes[i].sys; n.settings.status > s.START && n.settings.status <= s.RUNNING && n.step(t, e); } },
    render(t) { for (let e = 0; e < this.scenes.length; e++) { const i = this.scenes[e].sys; i.settings.visible && i.settings.status >= s.LOADING && i.settings.status < s.SLEEPING && i.render(t); } this.isProcessing = !1; },
    create(t) { const e = t.sys; const i = e.settings; t.create && (i.status = s.CREATING, t.create.call(t, i.data), i.status === s.DESTROYED) || (i.isTransition && e.events.emit(r.TRANSITION_START, i.transitionFrom, i.transitionDuration), t.update && (e.sceneUpdate = t.update), i.status = s.RUNNING, e.events.emit(r.CREATE, t)); },
    createSceneFromFunction(t, e) { const i = new e(); if (i instanceof u) { const n = i.sys.settings.key; if (n !== '' && (t = n), this.keys.hasOwnProperty(t)) throw new Error(`Cannot add a Scene with duplicate key: ${t}`); return this.createSceneFromInstance(t, i); } return i.sys = new c(i), i.sys.settings.key = t, i.sys.init(this.game), i; },
    createSceneFromInstance(t, e) { const i = e.sys.settings.key; return i !== '' ? t = i : e.sys.settings.key = t, e.sys.init(this.game), e; },
    createSceneFromObject(t, e) { const i = new u(e); const n = i.sys.settings.key; n !== '' ? t = n : i.sys.settings.key = t, i.sys.init(this.game); for (let s = ['init', 'preload', 'create', 'update', 'render'], r = 0; r < s.length; r++) { const o = a(e, s[r], null); o && (i[s[r]] = o); } if (e.hasOwnProperty('extend')) for (const h in e.extend) if (e.extend.hasOwnProperty(h)) { const l = e.extend[h]; h === 'data' && i.hasOwnProperty('data') && typeof l === 'object' ? i.data.merge(l) : h !== 'sys' && (i[h] = l); } return i; },
    getKey(t, e) { if (t || (t = 'default'), typeof e === 'function') return t; if (e instanceof u ? t = e.sys.settings.key : typeof e === 'object' && e.hasOwnProperty('key') && (t = e.key), this.keys.hasOwnProperty(t)) throw new Error(`Cannot add a Scene with duplicate key: ${t}`); return t; },
    getScenes(t, e) { void 0 === t && (t = !0), void 0 === e && (e = !1); for (var i = [], n = this.scenes, s = 0; s < n.length; s++) { const r = n[s]; r && (!t || t && r.sys.isActive()) && i.push(r); } return e ? i.reverse() : i; },
    getScene(t) { if (typeof t === 'string') { if (this.keys[t]) return this.keys[t]; } else for (let e = 0; e < this.scenes.length; e++) if (t === this.scenes[e]) return t; return null; },
    isActive(t) { const e = this.getScene(t); return e ? e.sys.isActive() : null; },
    isPaused(t) { const e = this.getScene(t); return e ? e.sys.isPaused() : null; },
    isVisible(t) { const e = this.getScene(t); return e ? e.sys.isVisible() : null; },
    isSleeping(t) { const e = this.getScene(t); return e ? e.sys.isSleeping() : null; },
    pause(t, e) { const i = this.getScene(t); return i && i.sys.pause(e), this; },
    resume(t, e) { const i = this.getScene(t); return i && i.sys.resume(e), this; },
    sleep(t, e) { const i = this.getScene(t); return i && !i.sys.isTransitioning() && i.sys.sleep(e), this; },
    wake(t, e) { const i = this.getScene(t); return i && i.sys.wake(e), this; },
    run(t, e) { const i = this.getScene(t); if (!i) { for (let n = 0; n < this._pending.length; n++) if (this._pending[n].key === t) { this.queueOp('start', t, e); break; } return this; }i.sys.isSleeping() ? i.sys.wake(e) : i.sys.isPaused() ? i.sys.resume(e) : this.start(t, e); },
    start(t, e) { if (!this.isBooted) return this._data[t] = { autoStart: !0, data: e }, this; const i = this.getScene(t); if (i) { let n; if (i.sys.isActive() || i.sys.isPaused())i.sys.shutdown(), i.sys.start(e); else if (i.sys.start(e), i.sys.load && (n = i.sys.load), n && i.sys.settings.hasOwnProperty('pack') && (n.reset(), n.addPack({ payload: i.sys.settings.pack }))) return i.sys.settings.status = s.LOADING, n.once(h.COMPLETE, this.payloadComplete, this), n.start(), this; this.bootScene(i); } return this; },
    stop(t, e) { const i = this.getScene(t); return i && !i.sys.isTransitioning() && i.sys.shutdown(e), this; },
    switch(t, e) { const i = this.getScene(t); const n = this.getScene(e); return i && n && i !== n && (this.sleep(t), this.isSleeping(e) ? this.wake(e) : this.start(e)), this; },
    getAt(t) { return this.scenes[t]; },
    getIndex(t) { const e = this.getScene(t); return this.scenes.indexOf(e); },
    bringToTop(t) { if (this.isProcessing) this._queue.push({ op: 'bringToTop', keyA: t, keyB: null }); else { const e = this.getIndex(t); if (e !== -1 && e < this.scenes.length) { const i = this.getScene(t); this.scenes.splice(e, 1), this.scenes.push(i); } } return this; },
    sendToBack(t) { if (this.isProcessing) this._queue.push({ op: 'sendToBack', keyA: t, keyB: null }); else { const e = this.getIndex(t); if (e !== -1 && e > 0) { const i = this.getScene(t); this.scenes.splice(e, 1), this.scenes.unshift(i); } } return this; },
    moveDown(t) { if (this.isProcessing) this._queue.push({ op: 'moveDown', keyA: t, keyB: null }); else { const e = this.getIndex(t); if (e > 0) { const i = e - 1; const n = this.getScene(t); const s = this.getAt(i); this.scenes[e] = s, this.scenes[i] = n; } } return this; },
    moveUp(t) { if (this.isProcessing) this._queue.push({ op: 'moveUp', keyA: t, keyB: null }); else { const e = this.getIndex(t); if (e < this.scenes.length - 1) { const i = e + 1; const n = this.getScene(t); const s = this.getAt(i); this.scenes[e] = s, this.scenes[i] = n; } } return this; },
    moveAbove(t, e) { if (t === e) return this; if (this.isProcessing) this._queue.push({ op: 'moveAbove', keyA: t, keyB: e }); else { const i = this.getIndex(t); const n = this.getIndex(e); if (i !== -1 && n !== -1) { const s = this.getAt(n); this.scenes.splice(n, 1), this.scenes.splice(i + 1, 0, s); } } return this; },
    moveBelow(t, e) { if (t === e) return this; if (this.isProcessing) this._queue.push({ op: 'moveBelow', keyA: t, keyB: e }); else { const i = this.getIndex(t); const n = this.getIndex(e); if (i !== -1 && n !== -1) { const s = this.getAt(n); this.scenes.splice(n, 1), i === 0 ? this.scenes.unshift(s) : this.scenes.splice(i, 0, s); } } return this; },
    queueOp(t, e, i) { return this._queue.push({ op: t, keyA: e, keyB: i }), this; },
    swapPosition(t, e) { if (t === e) return this; if (this.isProcessing) this._queue.push({ op: 'swapPosition', keyA: t, keyB: e }); else { const i = this.getIndex(t); const n = this.getIndex(e); if (i !== n && i !== -1 && n !== -1) { const s = this.getAt(i); this.scenes[i] = this.scenes[n], this.scenes[n] = s; } } return this; },
    dump() { for (var t = [], e = ['pending', 'init', 'start', 'loading', 'creating', 'running', 'paused', 'sleeping', 'shutdown', 'destroyed'], i = 0; i < this.scenes.length; i++) { const n = this.scenes[i].sys; let r = !n.settings.visible || n.settings.status !== s.RUNNING && n.settings.status !== s.PAUSED ? '[-] ' : '[*] '; r += `${n.settings.key} (${e[n.settings.status]})`, t.push(r); }console.log(t.join('\n')); },
    destroy() { for (let t = 0; t < this.scenes.length; t++) { this.scenes[t].sys.destroy(); } this.update = l, this.scenes = [], this._pending = [], this._start = [], this._queue = [], this.game = null; },
  }); t.exports = d;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(197); const r = new n({ initialize(t) { this.sys = new s(this, t), this.game, this.anims, this.cache, this.registry, this.sound, this.textures, this.events, this.cameras, this.add, this.make, this.scene, this.children, this.lights, this.data, this.input, this.load, this.time, this.tweens, this.physics, this.matter, this.facebook, this.scale, this.plugins; }, update() {} }); t.exports = r;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(137); const s = i(6); const r = i(106); const o = i(907); const a = {
    create(t) {
      return typeof t === 'string' ? t = { key: t } : void 0 === t && (t = {}), {
        status: n.PENDING, key: s(t, 'key', ''), active: s(t, 'active', !1), visible: s(t, 'visible', !0), isBooted: !1, isTransition: !1, transitionFrom: null, transitionDuration: 0, transitionAllowInput: !0, data: {}, pack: s(t, 'pack', !1), cameras: s(t, 'cameras', null), map: s(t, 'map', r(o, s(t, 'mapAdd', {}))), physics: s(t, 'physics', {}), loader: s(t, 'loader', {}), plugins: s(t, 'plugins', !1), input: s(t, 'input', {}),
      };
    },
  }; t.exports = a;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(30); const s = i(409); const r = i(0); const o = i(35); const a = i(39); const h = i(10); const l = i(132); const u = i(22); const c = i(378); const d = i(6); const f = i(411); const p = i(199); const g = new r({
    Extends: h, initialize(t) { h.call(this), this.game = t, this.name = 'TextureManager', this.list = {}, this._tempCanvas = n.create2D(this, 1, 1), this._tempContext = this._tempCanvas.getContext('2d'), this._pending = 0, t.events.once(u.BOOT, this.boot, this); }, boot() { this._pending = 2, this.on(l.LOAD, this.updatePending, this), this.on(l.ERROR, this.updatePending, this), this.addBase64('__DEFAULT', this.game.config.defaultImage), this.addBase64('__MISSING', this.game.config.missingImage), this.game.events.once(u.DESTROY, this.destroy, this); }, updatePending() { this._pending--, this._pending === 0 && (this.off(l.LOAD), this.off(l.ERROR), this.emit(l.READY)); }, checkKey(t) { return !this.exists(t) || (console.error(`Texture key already in use: ${t}`), !1); }, remove(t) { if (typeof t === 'string') { if (!this.exists(t)) return console.warn(`No texture found matching key: ${t}`), this; t = this.get(t); } return this.list.hasOwnProperty(t.key) && (t.destroy(), this.emit(l.REMOVE, t.key)), this; }, removeKey(t) { return this.list.hasOwnProperty(t) && delete this.list[t], this; }, addBase64(t, e) { if (this.checkKey(t)) { const i = this; const n = new Image(); n.onerror = function () { i.emit(l.ERROR, t); }, n.onload = function () { const e = i.create(t, n); f.Image(e, 0), i.emit(l.ADD, t, e), i.emit(l.LOAD, t, e); }, n.src = e; } return this; }, getBase64(t, e, i, s) { void 0 === i && (i = 'image/png'), void 0 === s && (s = 0.92); let r = ''; const o = this.getFrame(t, e); if (o && (o.source.isRenderTexture || o.source.isGLTexture))console.warn('Cannot getBase64 from WebGL Texture'); else if (o) { const a = o.canvasData; const h = n.create2D(this, a.width, a.height); h.getContext('2d').drawImage(o.source.image, a.x, a.y, a.width, a.height, 0, 0, a.width, a.height), r = h.toDataURL(i, s), n.remove(h); } return r; }, addImage(t, e, i) { let n = null; return this.checkKey(t) && (n = this.create(t, e), f.Image(n, 0), i && n.setDataSource(i), this.emit(l.ADD, t, n)), n; }, addGLTexture(t, e, i, n) { let s = null; return this.checkKey(t) && ((s = this.create(t, e, i, n)).add('__BASE', 0, 0, 0, i, n), this.emit(l.ADD, t, s)), s; }, addRenderTexture(t, e) { let i = null; return this.checkKey(t) && ((i = this.create(t, e)).add('__BASE', 0, 0, 0, e.width, e.height), this.emit(l.ADD, t, i)), i; }, generate(t, e) { if (this.checkKey(t)) { const i = n.create(this, 1, 1); return e.canvas = i, c(e), this.addCanvas(t, i); } return null; }, createCanvas(t, e, i) { if (void 0 === e && (e = 256), void 0 === i && (i = 256), this.checkKey(t)) { const s = n.create(this, e, i, a.CANVAS, !0); return this.addCanvas(t, s); } return null; }, addCanvas(t, e, i) { void 0 === i && (i = !1); let n = null; return i ? n = new s(this, t, e, e.width, e.height) : this.checkKey(t) && (n = new s(this, t, e, e.width, e.height), this.list[t] = n, this.emit(l.ADD, t, n)), n; }, addAtlas(t, e, i, n) { return Array.isArray(i.textures) || Array.isArray(i.frames) ? this.addAtlasJSONArray(t, e, i, n) : this.addAtlasJSONHash(t, e, i, n); }, addAtlasJSONArray(t, e, i, n) { let s = null; if (this.checkKey(t)) { if (s = this.create(t, e), Array.isArray(i)) for (let r = i.length === 1, o = 0; o < s.source.length; o++) { const a = r ? i[0] : i[o]; f.JSONArray(s, o, a); } else f.JSONArray(s, 0, i); n && s.setDataSource(n), this.emit(l.ADD, t, s); } return s; }, addAtlasJSONHash(t, e, i, n) { let s = null; if (this.checkKey(t)) { if (s = this.create(t, e), Array.isArray(i)) for (let r = 0; r < i.length; r++)f.JSONHash(s, r, i[r]); else f.JSONHash(s, 0, i); n && s.setDataSource(n), this.emit(l.ADD, t, s); } return s; }, addAtlasXML(t, e, i, n) { let s = null; return this.checkKey(t) && (s = this.create(t, e), f.AtlasXML(s, 0, i), n && s.setDataSource(n), this.emit(l.ADD, t, s)), s; }, addUnityAtlas(t, e, i, n) { let s = null; return this.checkKey(t) && (s = this.create(t, e), f.UnityYAML(s, 0, i), n && s.setDataSource(n), this.emit(l.ADD, t, s)), s; }, addSpriteSheet(t, e, i) { let n = null; if (this.checkKey(t)) { const s = (n = this.create(t, e)).source[0].width; const r = n.source[0].height; f.SpriteSheet(n, 0, 0, 0, s, r, i), this.emit(l.ADD, t, n); } return n; }, addSpriteSheetFromAtlas(t, e) { if (!this.checkKey(t)) return null; const i = d(e, 'atlas', null); const n = d(e, 'frame', null); if (i && n) { const s = this.get(i).get(n); if (s) { const r = this.create(t, s.source.image); return s.trimmed ? f.SpriteSheetFromAtlas(r, s, e) : f.SpriteSheet(r, 0, s.cutX, s.cutY, s.cutWidth, s.cutHeight, e), this.emit(l.ADD, t, r), r; } } }, create(t, e, i, n) { let s = null; return this.checkKey(t) && (s = new p(this, t, e, i, n), this.list[t] = s), s; }, exists(t) { return this.list.hasOwnProperty(t); }, get(t) { return void 0 === t && (t = '__DEFAULT'), this.list[t] ? this.list[t] : t instanceof p ? t : this.list.__MISSING; }, cloneFrame(t, e) { if (this.list[t]) return this.list[t].get(e).clone(); }, getFrame(t, e) { if (this.list[t]) return this.list[t].get(e); }, getTextureKeys() { const t = []; for (const e in this.list)e !== '__DEFAULT' && e !== '__MISSING' && t.push(e); return t; }, getPixel(t, e, i, n) { const s = this.getFrame(i, n); if (s) { t -= s.x, e -= s.y; const r = s.data.cut; if (t += r.x, e += r.y, t >= r.x && t < r.r && e >= r.y && e < r.b) { const a = this._tempContext; a.clearRect(0, 0, 1, 1), a.drawImage(s.source.image, t, e, 1, 1, 0, 0, 1, 1); const h = a.getImageData(0, 0, 1, 1); return new o(h.data[0], h.data[1], h.data[2], h.data[3]); } } return null; }, getPixelAlpha(t, e, i, n) { const s = this.getFrame(i, n); if (s) { t -= s.x, e -= s.y; const r = s.data.cut; if (t += r.x, e += r.y, t >= r.x && t < r.r && e >= r.y && e < r.b) { const o = this._tempContext; return o.clearRect(0, 0, 1, 1), o.drawImage(s.source.image, t, e, 1, 1, 0, 0, 1, 1), o.getImageData(0, 0, 1, 1).data[3]; } } return null; }, setTexture(t, e, i) { return this.list[e] && (t.texture = this.list[e], t.frame = t.texture.get(i)), t; }, renameTexture(t, e) { const i = this.get(t); return !(!i || t === e) && (i.key = e, this.list[e] = i, delete this.list[t], !0); }, each(t, e) { for (var i = [null], n = 1; n < arguments.length; n++)i.push(arguments[n]); for (const s in this.list)i[0] = this.list[s], t.apply(e, i); }, destroy() { for (const t in this.list) this.list[t].destroy(); this.list = {}, this.game = null, n.remove(this._tempCanvas); },
  }); t.exports = g;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(20); const r = i(35); const o = i(39); const a = i(130); const h = i(199); const l = new n({
    Extends: h,
    initialize(t, e, i, n, s) { h.call(this, t, e, i, n, s), this.add('__BASE', 0, 0, 0, n, s), this._source = this.frames.__BASE.source, this.canvas = this._source.image, this.context = this.canvas.getContext('2d'), this.width = n, this.height = s, this.imageData = this.context.getImageData(0, 0, n, s), this.data = null, this.imageData && (this.data = this.imageData.data), this.pixels = null, this.buffer, this.data && (this.imageData.data.buffer ? (this.buffer = this.imageData.data.buffer, this.pixels = new Uint32Array(this.buffer)) : window.ArrayBuffer ? (this.buffer = new ArrayBuffer(this.imageData.data.length), this.pixels = new Uint32Array(this.buffer)) : this.pixels = this.imageData.data); },
    update() { return this.imageData = this.context.getImageData(0, 0, this.width, this.height), this.data = this.imageData.data, this.imageData.data.buffer ? (this.buffer = this.imageData.data.buffer, this.pixels = new Uint32Array(this.buffer)) : window.ArrayBuffer ? (this.buffer = new ArrayBuffer(this.imageData.data.length), this.pixels = new Uint32Array(this.buffer)) : this.pixels = this.imageData.data, this.manager.game.config.renderType === o.WEBGL && this.refresh(), this; },
    draw(t, e, i) { return this.context.drawImage(i, t, e), this.update(); },
    drawFrame(t, e, i, n) { void 0 === i && (i = 0), void 0 === n && (n = 0); const s = this.manager.getFrame(t, e); if (s) { const r = s.canvasData; const o = s.cutWidth; const a = s.cutHeight; const h = s.source.resolution; return this.context.drawImage(s.source.image, r.x, r.y, o, a, i, n, o / h, a / h), this.update(); } return this; },
    setPixel(t, e, i, n, s, r) { if (void 0 === r && (r = 255), t = Math.abs(Math.floor(t)), e = Math.abs(Math.floor(e)), this.getIndex(t, e) > -1) { const o = this.context.getImageData(t, e, 1, 1); o.data[0] = i, o.data[1] = n, o.data[2] = s, o.data[3] = r, this.context.putImageData(o, t, e); } return this; },
    putData(t, e, i, n, s, r, o) { return void 0 === n && (n = 0), void 0 === s && (s = 0), void 0 === r && (r = t.width), void 0 === o && (o = t.height), this.context.putImageData(t, e, i, n, s, r, o), this; },
    getData(t, e, i, n) { return t = s(Math.floor(t), 0, this.width - 1), e = s(Math.floor(e), 0, this.height - 1), i = s(i, 1, this.width - t), n = s(n, 1, this.height - e), this.context.getImageData(t, e, i, n); },
    getPixel(t, e, i) { i || (i = new r()); const n = this.getIndex(t, e); if (n > -1) { const s = this.data; const o = s[n + 0]; const a = s[n + 1]; const h = s[n + 2]; const l = s[n + 3]; i.setTo(o, a, h, l); } return i; },
    getPixels(t, e, i, n) {
      void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = this.width), void 0 === n && (n = i), t = Math.abs(Math.round(t)), e = Math.abs(Math.round(e)); for (var o = s(t, 0, this.width), a = s(t + i, 0, this.width), h = s(e, 0, this.height), l = s(e + n, 0, this.height), u = new r(), c = [], d = h; d < l; d++) {
        for (var f = [], p = o; p < a; p++) {
          u = this.getPixel(p, d, u), f.push({
            x: p, y: d, color: u.color, alpha: u.alphaGL,
          });
        } c.push(f);
      } return c;
    },
    getIndex(t, e) { return t = Math.abs(Math.round(t)), e = Math.abs(Math.round(e)), t < this.width && e < this.height ? 4 * (t + e * this.width) : -1; },
    refresh() { return this._source.update(), this; },
    getCanvas() { return this.canvas; },
    getContext() { return this.context; },
    clear(t, e, i, n) { return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = this.width), void 0 === n && (n = this.height), this.context.clearRect(t, e, i, n), this.update(); },
    setSize(t, e) { return void 0 === e && (e = t), t === this.width && e === this.height || (this.canvas.width = t, this.canvas.height = e, this._source.width = t, this._source.height = e, this._source.isPowerOf2 = a(t, e), this.frames.__BASE.setSize(t, e, 0, 0), this.width = t, this.height = e, this.refresh()), this; },
    destroy() { h.prototype.destroy.call(this), this._source = null, this.canvas = null, this.context = null, this.imageData = null, this.data = null, this.pixels = null, this.buffer = null; },
  }); t.exports = l;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(30); const s = i(0); const r = i(130); const o = i(162); const a = new s({
    initialize(t, e, i, n, s) { void 0 === s && (s = !1); const a = t.manager.game; this.renderer = a.renderer, this.texture = t, this.source = e, this.image = e, this.compressionAlgorithm = null, this.resolution = 1, this.width = i || e.naturalWidth || e.videoWidth || e.width || 0, this.height = n || e.naturalHeight || e.videoHeight || e.height || 0, this.scaleMode = o.DEFAULT, this.isCanvas = e instanceof HTMLCanvasElement, this.isVideo = window.hasOwnProperty('HTMLVideoElement') && e instanceof HTMLVideoElement, this.isRenderTexture = e.type === 'RenderTexture', this.isGLTexture = window.hasOwnProperty('WebGLTexture') && e instanceof WebGLTexture, this.isPowerOf2 = r(this.width, this.height), this.glTexture = null, this.flipY = s, this.init(a); }, init(t) { this.renderer && (this.renderer.gl ? this.isCanvas ? this.glTexture = this.renderer.createCanvasTexture(this.image, !1, this.flipY) : this.isVideo ? this.glTexture = this.renderer.createVideoTexture(this.image, !1, this.flipY) : this.isRenderTexture ? (this.image = this.source.canvas, this.glTexture = this.renderer.createTextureFromSource(null, this.width, this.height, this.scaleMode)) : this.isGLTexture ? this.glTexture = this.source : this.glTexture = this.renderer.createTextureFromSource(this.image, this.width, this.height, this.scaleMode) : this.isRenderTexture && (this.image = this.source.canvas)), t.config.antialias || this.setFilter(1); }, setFilter(t) { this.renderer.gl && this.renderer.setTextureFilter(this.glTexture, t), this.scaleMode = t; }, setFlipY(t) { return void 0 === t && (t = !0), this.flipY = t, this; }, update() { const t = this.renderer.gl; t && this.isCanvas ? this.glTexture = this.renderer.updateCanvasTexture(this.image, this.glTexture, this.flipY) : t && this.isVideo && (this.glTexture = this.renderer.updateVideoTexture(this.image, this.glTexture, this.flipY)); }, destroy() { this.glTexture && this.renderer.deleteTexture(this.glTexture), this.isCanvas && n.remove(this.image), this.renderer = null, this.texture = null, this.source = null, this.image = null, this.glTexture = null; },
  }); t.exports = a;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = {
    AtlasXML: i(908), Canvas: i(909), Image: i(910), JSONArray: i(911), JSONHash: i(912), SpriteSheet: i(913), SpriteSheetFromAtlas: i(914), UnityYAML: i(915),
  };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Pavle Goloskokovic <pgoloskokovic@gmail.com> (http://prunegames.com)
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(413); const s = i(417); const r = i(419); const o = { create(t) { const e = t.config.audio; const i = t.device.audio; return e && e.noAudio || !i.webAudio && !i.audioData ? new s(t) : !i.webAudio || e && e.disableWebAudio ? new n(t) : new r(t); } }; t.exports = o;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Pavle Goloskokovic <pgoloskokovic@gmail.com> (http://prunegames.com)
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(138); const s = i(0); const r = i(65); const o = i(416); const a = new s({
    Extends: n, initialize(t) { this.override = !0, this.audioPlayDelay = 0.1, this.loopEndOffset = 0.05, this.onBlurPausedSounds = [], this.locked = 'ontouchstart' in window, this.lockedActionsQueue = this.locked ? [] : null, this._mute = !1, this._volume = 1, n.call(this, t); }, add(t, e) { const i = new o(this, t, e); return this.sounds.push(i), i; }, unlock() { this.locked = !1; const t = this; if (this.game.cache.audio.entries.each(((e, i) => { for (let n = 0; n < i.length; n++) if (i[n].dataset.locked === 'true') return t.locked = !0, !1; return !0; })), this.locked) { let e = !1; const i = function () { e = !0; }; var n = function () { if (e)e = !1; else { document.body.removeEventListener('touchmove', i), document.body.removeEventListener('touchend', n); const s = []; if (t.game.cache.audio.entries.each(((t, e) => { for (let i = 0; i < e.length; i++) { const n = e[i]; n.dataset.locked === 'true' && s.push(n); } return !0; })), s.length !== 0) { const r = s[s.length - 1]; r.oncanplaythrough = function () { r.oncanplaythrough = null, s.forEach(((t) => { t.dataset.locked = 'false'; })), t.unlocked = !0; }, s.forEach(((t) => { t.load(); })); } } }; this.once(r.UNLOCKED, (function () { for (this.forEachActiveSound(((t) => { t.currentMarker === null && t.duration === 0 && (t.duration = t.tags[0].duration), t.totalDuration = t.tags[0].duration; })); this.lockedActionsQueue.length;) { const t = this.lockedActionsQueue.shift(); t.sound[t.prop].apply ? t.sound[t.prop].apply(t.sound, t.value || []) : t.sound[t.prop] = t.value; } }), this), document.body.addEventListener('touchmove', i, !1), document.body.addEventListener('touchend', n, !1); } }, onBlur() { this.forEachActiveSound((function (t) { t.isPlaying && (this.onBlurPausedSounds.push(t), t.onBlur()); })); }, onFocus() { this.onBlurPausedSounds.forEach(((t) => { t.onFocus(); })), this.onBlurPausedSounds.length = 0; }, destroy() { n.prototype.destroy.call(this), this.onBlurPausedSounds.length = 0, this.onBlurPausedSounds = null; }, isLocked(t, e, i) { return t.tags[0].dataset.locked === 'true' && (this.lockedActionsQueue.push({ sound: t, prop: e, value: i }), !0); }, setMute(t) { return this.mute = t, this; }, mute: { get() { return this._mute; }, set(t) { this._mute = t, this.forEachActiveSound(((t) => { t.updateMute(); })), this.emit(r.GLOBAL_MUTE, this, t); } }, setVolume(t) { return this.volume = t, this; }, volume: { get() { return this._volume; }, set(t) { this._volume = t, this.forEachActiveSound(((t) => { t.updateVolume(); })), this.emit(r.GLOBAL_VOLUME, this, t); } },
  }); t.exports = a;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(75); t.exports = function (t, e, i, s, r) { void 0 === s && (s = 0), void 0 === r && (r = t.length); const o = []; if (n(t, s, r)) for (let a = s; a < r; a++) { const h = t[a]; (!e || e && void 0 === i && h.hasOwnProperty(e) || e && void 0 !== i && h[e] === i) && o.push(h); } return o; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(75); t.exports = function (t, e, i, s, r) { if (void 0 === s && (s = 0), void 0 === r && (r = t.length), n(t, s, r)) for (let o = s; o < r; o++) { const a = t[o]; if (!e || e && void 0 === i && a.hasOwnProperty(e) || e && void 0 !== i && a[e] === i) return a; } return null; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Pavle Goloskokovic <pgoloskokovic@gmail.com> (http://prunegames.com)
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(139); const s = i(0); const r = i(65); const o = i(20); const a = new s({
    Extends: n, initialize(t, e, i) { if (void 0 === i && (i = {}), this.tags = t.game.cache.audio.get(e), !this.tags) throw new Error(`There is no audio asset with key "${e}" in the audio cache`); this.audio = null, this.startTime = 0, this.previousTime = 0, this.duration = this.tags[0].duration, this.totalDuration = this.tags[0].duration, n.call(this, t, e, i); }, play(t, e) { return !this.manager.isLocked(this, 'play', [t, e]) && (!!n.prototype.play.call(this, t, e) && (!!this.pickAndPlayAudioTag() && (this.emit(r.PLAY, this), !0))); }, pause() { return !this.manager.isLocked(this, 'pause') && (!(this.startTime > 0) && (!!n.prototype.pause.call(this) && (this.currentConfig.seek = this.audio.currentTime - (this.currentMarker ? this.currentMarker.start : 0), this.stopAndReleaseAudioTag(), this.emit(r.PAUSE, this), !0))); }, resume() { return !this.manager.isLocked(this, 'resume') && (!(this.startTime > 0) && (!!n.prototype.resume.call(this) && (!!this.pickAndPlayAudioTag() && (this.emit(r.RESUME, this), !0)))); }, stop() { return !this.manager.isLocked(this, 'stop') && (!!n.prototype.stop.call(this) && (this.stopAndReleaseAudioTag(), this.emit(r.STOP, this), !0)); }, pickAndPlayAudioTag() { if (!this.pickAudioTag()) return this.reset(), !1; const t = this.currentConfig.seek; const e = this.currentConfig.delay; const i = (this.currentMarker ? this.currentMarker.start : 0) + t; return this.previousTime = i, this.audio.currentTime = i, this.applyConfig(), e === 0 ? (this.startTime = 0, this.audio.paused && this.playCatchPromise()) : (this.startTime = window.performance.now() + 1e3 * e, this.audio.paused || this.audio.pause()), this.resetConfig(), !0; }, pickAudioTag() { if (this.audio) return !0; for (let t = 0; t < this.tags.length; t++) { const e = this.tags[t]; if (e.dataset.used === 'false') return e.dataset.used = 'true', this.audio = e, !0; } if (!this.manager.override) return !1; const i = []; this.manager.forEachActiveSound((function (t) { t.key === this.key && t.audio && i.push(t); }), this), i.sort(((t, e) => (t.loop === e.loop ? e.seek / e.duration - t.seek / t.duration : t.loop ? 1 : -1))); const n = i[0]; return this.audio = n.audio, n.reset(), n.audio = null, n.startTime = 0, n.previousTime = 0, !0; }, playCatchPromise() { const t = this.audio.play(); t && t.catch(((t) => { console.warn(t); })); }, stopAndReleaseAudioTag() { this.audio.pause(), this.audio.dataset.used = 'false', this.audio = null, this.startTime = 0, this.previousTime = 0; }, reset() { n.prototype.stop.call(this); }, onBlur() { this.isPlaying = !1, this.isPaused = !0, this.currentConfig.seek = this.audio.currentTime - (this.currentMarker ? this.currentMarker.start : 0), this.currentConfig.delay = Math.max(0, (this.startTime - window.performance.now()) / 1e3), this.stopAndReleaseAudioTag(); }, onFocus() { this.isPlaying = !0, this.isPaused = !1, this.pickAndPlayAudioTag(); }, update(t, e) { if (this.isPlaying) if (this.startTime > 0) this.startTime < t - this.manager.audioPlayDelay && (this.audio.currentTime += Math.max(0, t - this.startTime) / 1e3, this.startTime = 0, this.previousTime = this.audio.currentTime, this.playCatchPromise()); else { const i = this.currentMarker ? this.currentMarker.start : 0; const n = i + this.duration; let s = this.audio.currentTime; if (this.currentConfig.loop)s >= n - this.manager.loopEndOffset ? (this.audio.currentTime = i + Math.max(0, s - n), s = this.audio.currentTime) : s < i && (this.audio.currentTime += i, s = this.audio.currentTime), s < this.previousTime && this.emit(r.LOOPED, this); else if (s >= n) return this.reset(), this.stopAndReleaseAudioTag(), void this.emit(r.COMPLETE, this); this.previousTime = s; } }, destroy() { n.prototype.destroy.call(this), this.tags = null, this.audio && this.stopAndReleaseAudioTag(); }, updateMute() { this.audio && (this.audio.muted = this.currentConfig.mute || this.manager.mute); }, updateVolume() { this.audio && (this.audio.volume = o(this.currentConfig.volume * this.manager.volume, 0, 1)); }, calculateRate() { n.prototype.calculateRate.call(this), this.audio && (this.audio.playbackRate = this.totalRate); }, mute: { get() { return this.currentConfig.mute; }, set(t) { this.currentConfig.mute = t, this.manager.isLocked(this, 'mute', t) || (this.updateMute(), this.emit(r.MUTE, this, t)); } }, setMute(t) { return this.mute = t, this; }, volume: { get() { return this.currentConfig.volume; }, set(t) { this.currentConfig.volume = t, this.manager.isLocked(this, 'volume', t) || (this.updateVolume(), this.emit(r.VOLUME, this, t)); } }, setVolume(t) { return this.volume = t, this; }, rate: { get() { return this.currentConfig.rate; }, set(t) { this.currentConfig.rate = t, this.manager.isLocked(this, r.RATE, t) || (this.calculateRate(), this.emit(r.RATE, this, t)); } }, setRate(t) { return this.rate = t, this; }, detune: { get() { return this.currentConfig.detune; }, set(t) { this.currentConfig.detune = t, this.manager.isLocked(this, r.DETUNE, t) || (this.calculateRate(), this.emit(r.DETUNE, this, t)); } }, setDetune(t) { return this.detune = t, this; }, seek: { get() { return this.isPlaying ? this.audio.currentTime - (this.currentMarker ? this.currentMarker.start : 0) : this.isPaused ? this.currentConfig.seek : 0; }, set(t) { this.manager.isLocked(this, 'seek', t) || this.startTime > 0 || (this.isPlaying || this.isPaused) && (t = Math.min(Math.max(0, t), this.duration), this.isPlaying ? (this.previousTime = t, this.audio.currentTime = t) : this.isPaused && (this.currentConfig.seek = t), this.emit(r.SEEK, this, t)); } }, setSeek(t) { return this.seek = t, this; }, loop: { get() { return this.currentConfig.loop; }, set(t) { this.currentConfig.loop = t, this.manager.isLocked(this, 'loop', t) || (this.audio && (this.audio.loop = t), this.emit(r.LOOP, this, t)); } }, setLoop(t) { return this.loop = t, this; },
  }); t.exports = a;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Pavle Goloskokovic <pgoloskokovic@gmail.com> (http://prunegames.com)
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(138); const s = i(0); const r = i(10); const o = i(418); const a = i(1); const h = new s({
    Extends: r, initialize(t) { r.call(this), this.game = t, this.sounds = [], this.mute = !1, this.volume = 1, this.rate = 1, this.detune = 0, this.pauseOnBlur = !0, this.locked = !1; }, add(t, e) { const i = new o(this, t, e); return this.sounds.push(i), i; }, addAudioSprite(t, e) { const i = this.add(t, e); return i.spritemap = {}, i; }, play(t, e) { return !1; }, playAudioSprite(t, e, i) { return !1; }, remove(t) { return n.prototype.remove.call(this, t); }, removeByKey(t) { return n.prototype.removeByKey.call(this, t); }, pauseAll: a, resumeAll: a, stopAll: a, update: a, setRate: a, setDetune: a, setMute: a, setVolume: a, forEachActiveSound(t, e) { n.prototype.forEachActiveSound.call(this, t, e); }, destroy() { n.prototype.destroy.call(this); },
  }); t.exports = h;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Pavle Goloskokovic <pgoloskokovic@gmail.com> (http://prunegames.com)
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(139); const s = i(0); const r = i(10); const o = i(19); const a = function () { return !1; }; const h = function () { return this; }; const l = new s({
    Extends: r,
    initialize(t, e, i) {
      void 0 === i && (i = {}), r.call(this), this.manager = t, this.key = e, this.isPlaying = !1, this.isPaused = !1, this.totalRate = 1, this.duration = 0, this.totalDuration = 0, this.config = o({
        mute: !1, volume: 1, rate: 1, detune: 0, seek: 0, loop: !1, delay: 0,
      }, i), this.currentConfig = this.config, this.mute = !1, this.volume = 1, this.rate = 1, this.detune = 0, this.seek = 0, this.loop = !1, this.markers = {}, this.currentMarker = null, this.pendingRemove = !1;
    },
    addMarker: a,
    updateMarker: a,
    removeMarker() { return null; },
    play: a,
    pause: a,
    resume: a,
    stop: a,
    destroy() { n.prototype.destroy.call(this); },
    setMute: h,
    setVolume: h,
    setRate: h,
    setDetune: h,
    setSeek: h,
    setLoop: h,
  }); t.exports = l;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Pavle Goloskokovic <pgoloskokovic@gmail.com> (http://prunegames.com)
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(420); const s = i(138); const r = i(0); const o = i(65); const a = i(421); const h = new r({
    Extends: s, initialize(t) { this.context = this.createAudioContext(t), this.masterMuteNode = this.context.createGain(), this.masterVolumeNode = this.context.createGain(), this.masterMuteNode.connect(this.masterVolumeNode), this.masterVolumeNode.connect(this.context.destination), this.destination = this.masterMuteNode, this.locked = this.context.state === 'suspended' && ('ontouchstart' in window || 'onclick' in window), s.call(this, t), this.locked && this.unlock(); }, createAudioContext(t) { const e = t.config.audio; return e && e.context ? (e.context.resume(), e.context) : new AudioContext(); }, setAudioContext(t) { return this.context && this.context.close(), this.masterMuteNode && this.masterMuteNode.disconnect(), this.masterVolumeNode && this.masterVolumeNode.disconnect(), this.context = t, this.masterMuteNode = t.createGain(), this.masterVolumeNode = t.createGain(), this.masterMuteNode.connect(this.masterVolumeNode), this.masterVolumeNode.connect(t.destination), this.destination = this.masterMuteNode, this; }, add(t, e) { const i = new a(this, t, e); return this.sounds.push(i), i; }, decodeAudio(t, e) { let i; i = Array.isArray(t) ? t : [{ key: t, data: e }]; for (var s = this.game.cache.audio, r = i.length, a = 0; a < i.length; a++) { const h = i[a]; const l = h.key; let u = h.data; typeof u === 'string' && (u = n(u)); const c = function (t, e) { s.add(t, e), this.emit(o.DECODED, t), --r === 0 && this.emit(o.DECODED_ALL); }.bind(this, l); const d = function (t, e) { console.error(`Error decoding audio: ${t} - `, e ? e.message : ''), --r === 0 && this.emit(o.DECODED_ALL); }.bind(this, l); this.context.decodeAudioData(u, c, d); } }, unlock() { const t = this; const e = document.body; const i = function i() { t.context && t.context.resume().then((() => { e.removeEventListener('touchstart', i), e.removeEventListener('touchend', i), e.removeEventListener('click', i), e.removeEventListener('keydown', i), t.unlocked = !0; }), (() => { e.removeEventListener('touchstart', i), e.removeEventListener('touchend', i), e.removeEventListener('click', i), e.removeEventListener('keydown', i); })); }; e && (e.addEventListener('touchstart', i, !1), e.addEventListener('touchend', i, !1), e.addEventListener('click', i, !1), e.addEventListener('keydown', i, !1)); }, onBlur() { this.locked || this.context.suspend(); }, onFocus() { this.locked || this.context.resume(); }, destroy() { if (this.destination = null, this.masterVolumeNode.disconnect(), this.masterVolumeNode = null, this.masterMuteNode.disconnect(), this.masterMuteNode = null, this.game.config.audio && this.game.config.audio.context) this.context.suspend(); else { const t = this; this.context.close().then((() => { t.context = null; })); }s.prototype.destroy.call(this); }, setMute(t) { return this.mute = t, this; }, mute: { get() { return this.masterMuteNode.gain.value === 0; }, set(t) { this.masterMuteNode.gain.setValueAtTime(t ? 0 : 1, 0), this.emit(o.GLOBAL_MUTE, this, t); } }, setVolume(t) { return this.volume = t, this; }, volume: { get() { return this.masterVolumeNode.gain.value; }, set(t) { this.masterVolumeNode.gain.setValueAtTime(t, 0), this.emit(o.GLOBAL_VOLUME, this, t); } },
  }); t.exports = h;
}, function (t, e) {
  for (
  /**
 * @author       Niklas von Hertzen (https://github.com/niklasvh/base64-arraybuffer)
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
    var i = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/', n = new Uint8Array(256), s = 0; s < i.length; s++)n[i.charCodeAt(s)] = s; t.exports = function (t) { let e; let i; let s; let r; const o = (t = t.substr(t.indexOf(',') + 1)).length; let a = 0.75 * o; let h = 0; t[o - 1] === '=' && (a--, t[o - 2] === '=' && a--); for (var l = new ArrayBuffer(a), u = new Uint8Array(l), c = 0; c < o; c += 4)e = n[t.charCodeAt(c)], i = n[t.charCodeAt(c + 1)], s = n[t.charCodeAt(c + 2)], r = n[t.charCodeAt(c + 3)], u[h++] = e << 2 | i >> 4, u[h++] = (15 & i) << 4 | s >> 2, u[h++] = (3 & s) << 6 | 63 & r; return l; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Pavle Goloskokovic <pgoloskokovic@gmail.com> (http://prunegames.com)
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(139); const s = i(0); const r = i(65); const o = new s({
    Extends: n, initialize(t, e, i) { if (void 0 === i && (i = {}), this.audioBuffer = t.game.cache.audio.get(e), !this.audioBuffer) throw new Error(`There is no audio asset with key "${e}" in the audio cache`); this.source = null, this.loopSource = null, this.muteNode = t.context.createGain(), this.volumeNode = t.context.createGain(), this.playTime = 0, this.startTime = 0, this.loopTime = 0, this.rateUpdates = [], this.hasEnded = !1, this.hasLooped = !1, this.muteNode.connect(this.volumeNode), this.volumeNode.connect(t.destination), this.duration = this.audioBuffer.duration, this.totalDuration = this.audioBuffer.duration, n.call(this, t, e, i); }, play(t, e) { return !!n.prototype.play.call(this, t, e) && (this.stopAndRemoveBufferSource(), this.createAndStartBufferSource(), this.emit(r.PLAY, this), !0); }, pause() { return !(this.manager.context.currentTime < this.startTime) && (!!n.prototype.pause.call(this) && (this.currentConfig.seek = this.getCurrentTime(), this.stopAndRemoveBufferSource(), this.emit(r.PAUSE, this), !0)); }, resume() { return !(this.manager.context.currentTime < this.startTime) && (!!n.prototype.resume.call(this) && (this.createAndStartBufferSource(), this.emit(r.RESUME, this), !0)); }, stop() { return !!n.prototype.stop.call(this) && (this.stopAndRemoveBufferSource(), this.emit(r.STOP, this), !0); }, createAndStartBufferSource() { const t = this.currentConfig.seek; const e = this.currentConfig.delay; const i = this.manager.context.currentTime + e; const n = (this.currentMarker ? this.currentMarker.start : 0) + t; const s = this.duration - t; this.playTime = i - t, this.startTime = i, this.source = this.createBufferSource(), this.applyConfig(), this.source.start(Math.max(0, i), Math.max(0, n), Math.max(0, s)), this.resetConfig(); }, createAndStartLoopBufferSource() { const t = this.getLoopTime(); const e = this.currentMarker ? this.currentMarker.start : 0; const i = this.duration; this.loopTime = t, this.loopSource = this.createBufferSource(), this.loopSource.playbackRate.setValueAtTime(this.totalRate, 0), this.loopSource.start(Math.max(0, t), Math.max(0, e), Math.max(0, i)); }, createBufferSource() { const t = this; const e = this.manager.context.createBufferSource(); return e.buffer = this.audioBuffer, e.connect(this.muteNode), e.onended = function (e) { e.target === t.source && (t.currentConfig.loop ? t.hasLooped = !0 : t.hasEnded = !0); }, e; }, stopAndRemoveBufferSource() { this.source && (this.source.stop(), this.source.disconnect(), this.source = null), this.playTime = 0, this.startTime = 0, this.stopAndRemoveLoopBufferSource(); }, stopAndRemoveLoopBufferSource() { this.loopSource && (this.loopSource.stop(), this.loopSource.disconnect(), this.loopSource = null), this.loopTime = 0; }, applyConfig() { this.rateUpdates.length = 0, this.rateUpdates.push({ time: 0, rate: 1 }), n.prototype.applyConfig.call(this); }, update(t, e) { this.hasEnded ? (this.hasEnded = !1, n.prototype.stop.call(this), this.stopAndRemoveBufferSource(), this.emit(r.COMPLETE, this)) : this.hasLooped && (this.hasLooped = !1, this.source = this.loopSource, this.loopSource = null, this.playTime = this.startTime = this.loopTime, this.rateUpdates.length = 0, this.rateUpdates.push({ time: 0, rate: this.totalRate }), this.createAndStartLoopBufferSource(), this.emit(r.LOOPED, this)); }, destroy() { n.prototype.destroy.call(this), this.audioBuffer = null, this.stopAndRemoveBufferSource(), this.muteNode.disconnect(), this.muteNode = null, this.volumeNode.disconnect(), this.volumeNode = null, this.rateUpdates.length = 0, this.rateUpdates = null; }, calculateRate() { n.prototype.calculateRate.call(this); const t = this.manager.context.currentTime; this.source && typeof this.totalRate === 'number' && this.source.playbackRate.setValueAtTime(this.totalRate, t), this.isPlaying && (this.rateUpdates.push({ time: Math.max(this.startTime, t) - this.playTime, rate: this.totalRate }), this.loopSource && (this.stopAndRemoveLoopBufferSource(), this.createAndStartLoopBufferSource())); }, getCurrentTime() { for (var t = 0, e = 0; e < this.rateUpdates.length; e++) { t += ((e < this.rateUpdates.length - 1 ? this.rateUpdates[e + 1].time : this.manager.context.currentTime - this.playTime) - this.rateUpdates[e].time) * this.rateUpdates[e].rate; } return t; }, getLoopTime() { for (var t = 0, e = 0; e < this.rateUpdates.length - 1; e++)t += (this.rateUpdates[e + 1].time - this.rateUpdates[e].time) * this.rateUpdates[e].rate; const i = this.rateUpdates[this.rateUpdates.length - 1]; return this.playTime + i.time + (this.duration - t) / i.rate; }, rate: { get() { return this.currentConfig.rate; }, set(t) { this.currentConfig.rate = t, this.calculateRate(), this.emit(r.RATE, this, t); } }, setRate(t) { return this.rate = t, this; }, detune: { get() { return this.currentConfig.detune; }, set(t) { this.currentConfig.detune = t, this.calculateRate(), this.emit(r.DETUNE, this, t); } }, setDetune(t) { return this.detune = t, this; }, mute: { get() { return this.muteNode.gain.value === 0; }, set(t) { this.currentConfig.mute = t, this.muteNode.gain.setValueAtTime(t ? 0 : 1, 0), this.emit(r.MUTE, this, t); } }, setMute(t) { return this.mute = t, this; }, volume: { get() { return this.volumeNode.gain.value; }, set(t) { this.currentConfig.volume = t, this.volumeNode.gain.setValueAtTime(t, 0), this.emit(r.VOLUME, this, t); } }, setVolume(t) { return this.volume = t, this; }, seek: { get() { return this.isPlaying ? this.manager.context.currentTime < this.startTime ? this.startTime - this.playTime : this.getCurrentTime() : this.isPaused ? this.currentConfig.seek : 0; }, set(t) { this.manager.context.currentTime < this.startTime || (this.isPlaying || this.isPaused) && (t = Math.min(Math.max(0, t), this.duration), this.currentConfig.seek = t, this.isPlaying && (this.stopAndRemoveBufferSource(), this.createAndStartBufferSource()), this.emit(r.SEEK, this, t)); } }, setSeek(t) { return this.seek = t, this; }, loop: { get() { return this.currentConfig.loop; }, set(t) { this.currentConfig.loop = t, this.isPlaying && (this.stopAndRemoveLoopBufferSource(), t && this.createAndStartLoopBufferSource()), this.emit(r.LOOP, this, t); } }, setLoop(t) { return this.loop = t, this; },
  }); t.exports = o;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2018 Photon Storm Ltd.
 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
 */
  const n = i(939); const s = i(0); const r = i(101); const o = i(10); const a = i(940); const h = i(942); const l = i(943); const u = new s({
    Extends: o,
    initialize(t) { o.call(this), this.game = t, this.data = new r(this), this.on('setdata', this.setDataHandler, this), this.on('changedata', this.changeDataHandler, this), this.hasLoaded = !1, this.dataLocked = !1, this.supportedAPIs = [], this.entryPoint = '', this.entryPointData = null, this.contextID = null, this.contextType = null, this.locale = null, this.platform = null, this.version = null, this.playerID = null, this.playerName = null, this.playerPhotoURL = null, this.playerCanSubscribeBot = !1, this.paymentsReady = !1, this.catalog = [], this.purchases = [], this.leaderboards = {}, this.ads = []; },
    setDataHandler(t, e, i) { if (!this.dataLocked) { const n = {}; n[e] = i; const s = this; FBInstant.player.setDataAsync(n).then((() => { s.emit('savedata', n); })); } },
    changeDataHandler(t, e, i) { if (!this.dataLocked) { const n = {}; n[e] = i; const s = this; FBInstant.player.setDataAsync(n).then((() => { s.emit('savedata', n); })); } },
    showLoadProgress(t) { return t.load.on('progress', (function (t) { this.hasLoaded || FBInstant.setLoadingProgress(100 * t); }), this), t.load.on('complete', (function () { this.hasLoaded || (this.hasLoaded = !0, FBInstant.startGameAsync().then(this.gameStartedHandler.bind(this))); }), this), this; },
    gameStarted() { this.hasLoaded ? this.gameStartedHandler() : (this.hasLoaded = !0, FBInstant.startGameAsync().then(this.gameStartedHandler.bind(this))); },
    gameStartedHandler() { const t = FBInstant.getSupportedAPIs(); const e = {}; const i = function (t) { return t[1].toUpperCase(); }; t.forEach(((t) => { t = t.replace(/\../g, i), e[t] = !0; })), this.supportedAPIs = e, this.getID(), this.getType(), this.getLocale(), this.getPlatform(), this.getSDKVersion(), this.getPlayerID(), this.getPlayerName(), this.getPlayerPhotoURL(); const n = this; FBInstant.onPause((() => { n.emit('pause'); })), FBInstant.getEntryPointAsync().then(((t) => { n.entryPoint = t, n.entryPointData = FBInstant.getEntryPointData(), n.emit('startgame'); })).catch(((t) => { console.warn(t); })), this.supportedAPIs.paymentsPurchaseAsync && FBInstant.payments.onReady((() => { n.paymentsReady = !0; })).catch(((t) => { console.warn(t); })); },
    checkAPI(t) { return !!this.supportedAPIs[t]; },
    getID() { return !this.contextID && this.supportedAPIs.contextGetID && (this.contextID = FBInstant.context.getID()), this.contextID; },
    getType() { return !this.contextType && this.supportedAPIs.contextGetType && (this.contextType = FBInstant.context.getType()), this.contextType; },
    getLocale() { return !this.locale && this.supportedAPIs.getLocale && (this.locale = FBInstant.getLocale()), this.locale; },
    getPlatform() { return !this.platform && this.supportedAPIs.getPlatform && (this.platform = FBInstant.getPlatform()), this.platform; },
    getSDKVersion() { return !this.version && this.supportedAPIs.getSDKVersion && (this.version = FBInstant.getSDKVersion()), this.version; },
    getPlayerID() { return !this.playerID && this.supportedAPIs.playerGetID && (this.playerID = FBInstant.player.getID()), this.playerID; },
    getPlayerName() { return !this.playerName && this.supportedAPIs.playerGetName && (this.playerName = FBInstant.player.getName()), this.playerName; },
    getPlayerPhotoURL() { return !this.playerPhotoURL && this.supportedAPIs.playerGetPhoto && (this.playerPhotoURL = FBInstant.player.getPhoto()), this.playerPhotoURL; },
    loadPlayerPhoto(t, e) { return this.playerPhotoURL && (t.load.setCORS('anonymous'), t.load.image(e, this.playerPhotoURL), t.load.once(`filecomplete-image-${e}`, (function () { this.emit('photocomplete', e); }), this), t.load.start()), this; },
    canSubscribeBot() { if (this.supportedAPIs.playerCanSubscribeBotAsync) { const t = this; FBInstant.player.canSubscribeBotAsync().then((() => { t.playerCanSubscribeBot = !0, t.emit('cansubscribebot'); })).catch(((e) => { t.emit('cansubscribebotfail', e); })); } else this.emit('cansubscribebotfail'); return this; },
    subscribeBot() { if (this.playerCanSubscribeBot) { const t = this; FBInstant.player.subscribeBotAsync().then((() => { t.emit('subscribebot'); })).catch(((e) => { t.emit('subscribebotfail', e); })); } else this.emit('subscribebotfail'); return this; },
    getData(t) { if (!this.checkAPI('playerGetDataAsync')) return this; Array.isArray(t) || (t = [t]); const e = this; return FBInstant.player.getDataAsync(t).then(((t) => { for (const i in e.dataLocked = !0, t)e.data.set(i, t[i]); e.dataLocked = !1, e.emit('getdata', t); })), this; },
    saveData(t) { if (!this.checkAPI('playerSetDataAsync')) return this; const e = this; return FBInstant.player.setDataAsync(t).then((() => { e.emit('savedata', t); })).catch(((t) => { e.emit('savedatafail', t); })), this; },
    flushData() { if (!this.checkAPI('playerFlushDataAsync')) return this; const t = this; return FBInstant.player.flushDataAsync().then((() => { t.emit('flushdata'); })).catch(((e) => { t.emit('flushdatafail', e); })), this; },
    getStats(t) { if (!this.checkAPI('playerGetStatsAsync')) return this; const e = this; return FBInstant.player.getStatsAsync(t).then(((t) => { e.emit('getstats', t); })).catch(((t) => { e.emit('getstatsfail', t); })), this; },
    saveStats(t) { if (!this.checkAPI('playerSetStatsAsync')) return this; const e = {}; for (const i in t) typeof t[i] === 'number' && (e[i] = t[i]); const n = this; return FBInstant.player.setStatsAsync(e).then((() => { n.emit('savestats', e); })).catch(((t) => { n.emit('savestatsfail', t); })), this; },
    incStats(t) { if (!this.checkAPI('playerIncrementStatsAsync')) return this; const e = {}; for (const i in t) typeof t[i] === 'number' && (e[i] = t[i]); const n = this; return FBInstant.player.incrementStatsAsync(e).then(((t) => { n.emit('incstats', t); })).catch(((t) => { n.emit('incstatsfail', t); })), this; },
    saveSession(t) { return this.checkAPI('setSessionData') ? (JSON.stringify(t).length <= 1e3 ? FBInstant.setSessionData(t) : console.warn('Session data too long. Max 1000 chars.'), this) : this; },
    openShare(t, e, i, n) { return this._share('SHARE', t, e, i, n); },
    openInvite(t, e, i, n) { return this._share('INVITE', t, e, i, n); },
    openRequest(t, e, i, n) { return this._share('REQUEST', t, e, i, n); },
    openChallenge(t, e, i, n) { return this._share('CHALLENGE', t, e, i, n); },
    _share(t, e, i, n, s) {
      if (!this.checkAPI('shareAsync')) return this; if (void 0 === s && (s = {}), i) var r = this.game.textures.getBase64(i, n); const o = {
        intent: t, image: r, text: e, data: s,
      }; const a = this; return FBInstant.shareAsync(o).then((() => { a.emit('resume'); })), this;
    },
    isSizeBetween(t, e) { return this.checkAPI('contextIsSizeBetween') ? FBInstant.context.isSizeBetween(t, e) : this; },
    switchContext(t) { if (!this.checkAPI('contextSwitchAsync')) return this; if (t !== this.contextID) { const e = this; FBInstant.context.switchAsync(t).then((() => { e.contextID = FBInstant.context.getID(), e.emit('switch', e.contextID); })).catch(((t) => { e.emit('switchfail', t); })); } return this; },
    chooseContext(t) { if (!this.checkAPI('contextChooseAsync')) return this; const e = this; return FBInstant.context.chooseAsync(t).then((() => { e.contextID = FBInstant.context.getID(), e.emit('choose', e.contextID); })).catch(((t) => { e.emit('choosefail', t); })), this; },
    createContext(t) { if (!this.checkAPI('contextCreateAsync')) return this; const e = this; return FBInstant.context.createAsync(t).then((() => { e.contextID = FBInstant.context.getID(), e.emit('create', e.contextID); })).catch(((t) => { e.emit('createfail', t); })), this; },
    getPlayers() { if (!this.checkAPI('playerGetConnectedPlayersAsync')) return this; const t = this; return FBInstant.player.getConnectedPlayersAsync().then(((e) => { t.emit('players', e); })).catch(((e) => { t.emit('playersfail', e); })), this; },
    getCatalog() { if (!this.paymentsReady) return this; const t = this; let e = this.catalog; return FBInstant.payments.getCatalogAsync().then(((i) => { e = [], i.forEach(((t) => { e.push(h(t)); })), t.emit('getcatalog', e); })).catch(((e) => { t.emit('getcatalogfail', e); })), this; },
    getProduct(t) { for (let e = 0; e < this.catalog.length; e++) if (this.catalog[e].productID === t) return this.catalog[e]; return null; },
    purchase(t, e) { if (!this.paymentsReady) return this; const i = { productID: t }; e && (i.developerPayload = e); const n = this; return FBInstant.payments.purchaseAsync(i).then(((t) => { const e = l(t); n.emit('purchase', e); })).catch(((t) => { n.emit('purchasefail', t); })), this; },
    getPurchases() { if (!this.paymentsReady) return this; const t = this; let e = this.purchases; return FBInstant.payments.getPurchasesAsync().then(((i) => { e = [], i.forEach(((t) => { e.push(l(t)); })), t.emit('getpurchases', e); })).catch(((e) => { t.emit('getpurchasesfail', e); })), this; },
    consumePurchase(t) { if (!this.paymentsReady) return this; const e = this; return FBInstant.payments.consumePurchaseAsync(t).then((() => { e.emit('consumepurchase', t); })).catch(((t) => { e.emit('consumepurchasefail', t); })), this; },
    update(t, e, i, n, s, r) { return this._update('CUSTOM', t, e, i, n, s, r); },
    updateLeaderboard(t, e, i, n, s, r) { return this._update('LEADERBOARD', t, e, i, n, s, r); },
    _update(t, e, i, n, s, r, o) {
      if (!this.checkAPI('shareAsync')) return this; if (void 0 === e && (e = ''), typeof i === 'string' && (i = { default: i }), void 0 === o && (o = {}), n) var a = this.game.textures.getBase64(n, s); const h = {
        action: t, cta: e, image: a, text: i, template: r, data: o, strategy: 'IMMEDIATE', notification: 'NO_PUSH',
      }; const l = this; return FBInstant.updateAsync(h).then((() => { l.emit('update'); })).catch(((t) => { l.emit('updatefail', t); })), this;
    },
    switchGame(t, e) { if (!this.checkAPI('switchGameAsync')) return this; if (e && JSON.stringify(e).length > 1e3) return console.warn('Switch Game data too long. Max 1000 chars.'), this; const i = this; return FBInstant.switchGameAsync(t, e).then((() => { i.emit('switchgame', t); })).catch(((t) => { i.emit('switchgamefail', t); })), this; },
    createShortcut() { const t = this; return FBInstant.canCreateShortcutAsync().then(((e) => { e && FBInstant.createShortcutAsync().then((() => { t.emit('shortcutcreated'); })).catch(((e) => { t.emit('shortcutfailed', e); })); })), this; },
    quit() { FBInstant.quit(); },
    log(t, e, i) { return this.checkAPI('logEvent') ? (void 0 === i && (i = {}), t.length >= 2 && t.length <= 40 && FBInstant.logEvent(t, parseFloat(e), i), this) : this; },
    preloadAds(t) { if (!this.checkAPI('getInterstitialAdAsync')) return this; let e; Array.isArray(t) || (t = [t]); const i = this; let s = 0; for (e = 0; e < this.ads.length; e++) this.ads[e].shown || s++; if (s + t.length >= 3) return console.warn('Too many AdInstances. Show an ad before loading more'), this; for (e = 0; e < t.length; e++) { var r; var o = t[e]; FBInstant.getInterstitialAdAsync(o).then(((t) => (r = t, t.loadAsync()))).then((() => { const t = n(o, r, !1); i.ads.push(t), i.emit('adloaded', t); })).catch(((t) => { t.code === 'ADS_NO_FILL' ? i.emit('adsnofill', o) : t.code === 'ADS_FREQUENT_LOAD' ? i.emit('adsfrequentload', o) : console.warn(t); })); } return this; },
    preloadVideoAds(t) { if (!this.checkAPI('getRewardedVideoAsync')) return this; let e; Array.isArray(t) || (t = [t]); const i = this; let s = 0; for (e = 0; e < this.ads.length; e++) this.ads[e].shown || s++; if (s + t.length >= 3) return console.warn('Too many AdInstances. Show an ad before loading more'), this; for (e = 0; e < t.length; e++) { var r; var o = t[e]; FBInstant.getRewardedVideoAsync(o).then(((t) => (r = t, t.loadAsync()))).then((() => { const t = n(o, r, !0); i.ads.push(t), i.emit('adloaded', t); })).catch(((t) => { t.code === 'ADS_NO_FILL' ? i.emit('adsnofill', o) : t.code === 'ADS_FREQUENT_LOAD' ? i.emit('adsfrequentload', o) : console.warn(t); })); } return this; },
    showAd(t) { for (var e = this, i = 0; i < this.ads.length; i++) { var n = this.ads[i]; if (n.placementID === t && !n.shown) { n.instance.showAsync().then((() => { n.shown = !0, e.emit('adfinished', n); })).catch(((t) => { t.code === 'ADS_NOT_LOADED' ? e.emit('adsnotloaded', n) : t.code === 'RATE_LIMITED' && e.emit('adratelimited', n), e.emit('adshowerror', t, n); })); break; } } return this; },
    showVideo(t) { for (var e = this, i = 0; i < this.ads.length; i++) { var n = this.ads[i]; if (n.placementID === t && n.video && !n.shown) { n.instance.showAsync().then((() => { n.shown = !0, e.emit('adfinished', n); })).catch(((t) => { t.code === 'ADS_NOT_LOADED' ? e.emit('adsnotloaded', n) : t.code === 'RATE_LIMITED' && e.emit('adratelimited', n), e.emit('adshowerror', t, n); })); break; } } return this; },
    matchPlayer(t, e) { if (void 0 === t && (t = null), void 0 === e && (e = !1), !this.checkAPI('matchPlayerAsync')) return this; const i = this; return FBInstant.matchPlayerAsync(t, e).then((() => { i.getID(), i.getType(), i.emit('matchplayer', i.contextID, i.contextType); })), this; },
    getLeaderboard(t) { if (!this.checkAPI('getLeaderboardAsync')) return this; const e = this; return FBInstant.getLeaderboardAsync(t).then(((i) => { const n = new a(e, i); e.leaderboards[t] = n, e.emit('getleaderboard', n); })).catch(((t) => { console.warn(t); })), this; },
    destroy() { FBInstant.quit(), this.data.destroy(), this.removeAllListeners(), this.catalog = [], this.purchases = [], this.leaderboards = [], this.ads = [], this.game = null; },
  }); t.exports = u;
}, function (t, e) { t.exports = function (t) { for (var e = t.length, i = t[0].length, n = new Array(i), s = 0; s < i; s++) { n[s] = new Array(e); for (let r = e - 1; r > -1; r--)n[s][r] = t[r][s]; } return n; }; }, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  function i(t, e, i) { const n = t[e]; t[e] = t[i], t[i] = n; } function n(t, e) { return t < e ? -1 : t > e ? 1 : 0; } var s = function (t, e, r, o, a) { for (void 0 === r && (r = 0), void 0 === o && (o = t.length - 1), void 0 === a && (a = n); o > r;) { if (o - r > 600) { const h = o - r + 1; const l = e - r + 1; const u = Math.log(h); const c = 0.5 * Math.exp(2 * u / 3); const d = 0.5 * Math.sqrt(u * c * (h - c) / h) * (l - h / 2 < 0 ? -1 : 1); const f = Math.max(r, Math.floor(e - l * c / h + d)); const p = Math.min(o, Math.floor(e + (h - l) * c / h + d)); s(t, e, f, p, a); } const g = t[e]; let v = r; let m = o; for (i(t, r, e), a(t[o], g) > 0 && i(t, r, o); v < m;) { for (i(t, v, m), v++, m--; a(t[v], g) < 0;)v++; for (;a(t[m], g) > 0;)m--; }a(t[r], g) === 0 ? i(t, r, m) : i(t, ++m, o), m <= e && (r = m + 1), e <= m && (o = m - 1); } }; t.exports = s;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(6); const s = i(124); const r = function (t, e, i) { for (var n = [], s = 0; s < t.length; s++) for (let r = 0; r < e.length; r++) for (let o = 0; o < i; o++)n.push({ a: t[s], b: e[r] }); return n; }; t.exports = function (t, e, i) { const o = n(i, 'max', 0); const a = n(i, 'qty', 1); const h = n(i, 'random', !1); const l = n(i, 'randomB', !1); let u = n(i, 'repeat', 0); const c = n(i, 'yoyo', !1); let d = []; if (l && s(e), u === -1) if (o === 0)u = 0; else { let f = t.length * e.length * a; c && (f *= 2), u = Math.ceil(o / f); } for (let p = 0; p <= u; p++) { const g = r(t, e, a); h && s(g), d = d.concat(g), c && (g.reverse(), d = d.concat(g)); } return o && d.splice(o), d; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(12); t.exports = function (t, e, i) { void 0 === i && (i = new n()); const s = Math.min(t.x, e.x); const r = Math.min(t.y, e.y); const o = Math.max(t.right, e.right) - s; const a = Math.max(t.bottom, e.bottom) - r; return i.setTo(s, r, o, a); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(13); const r = i(987); const o = i(14); const a = i(8); const h = i(195); const l = i(24); const u = i(131); const c = new n({
    Extends: o, Mixins: [s.AlphaSingle, s.BlendMode, s.Depth, s.Origin, s.ScrollFactor, s.Transform, s.Visible, r], initialize(t, e, i, n, s, r) { o.call(this, t, 'DOMElement'), this.parent = t.sys.game.domContainer, this.cache = t.sys.cache.html, this.node, this.transformOnly = !1, this.skewX = 0, this.skewY = 0, this.rotate3d = new u(), this.rotate3dAngle = 'deg', this.width = 0, this.height = 0, this.displayWidth = 0, this.displayHeight = 0, this.handler = this.dispatchNativeEvent.bind(this), this.setPosition(e, i), typeof n === 'string' ? n[0] === '#' ? this.setElement(n.substr(1), s, r) : this.createElement(n, s, r) : n && this.setElement(n, s, r), t.sys.events.on(l.SLEEP, this.handleSceneEvent, this), t.sys.events.on(l.WAKE, this.handleSceneEvent, this); }, handleSceneEvent(t) { const e = this.node; const i = e.style; e && (i.display = t.settings.visible ? 'block' : 'none'); }, setSkew(t, e) { return void 0 === t && (t = 0), void 0 === e && (e = t), this.skewX = t, this.skewY = e, this; }, setPerspective(t) { return this.parent.style.perspective = `${t}px`, this; }, perspective: { get() { return parseFloat(this.parent.style.perspective); }, set(t) { this.parent.style.perspective = `${t}px`; } }, addListener(t) { if (this.node) { t = t.split(' '); for (let e = 0; e < t.length; e++) this.node.addEventListener(t[e], this.handler, !1); } return this; }, removeListener(t) { if (this.node) { t = t.split(' '); for (let e = 0; e < t.length; e++) this.node.removeEventListener(t[e], this.handler); } return this; }, dispatchNativeEvent(t) { this.emit(t.type, t); }, createElement(t, e, i) { return this.setElement(document.createElement(t), e, i); }, setElement(t, e, i) { let n; if (this.removeElement(), typeof t === 'string' ? (t[0] === '#' && (t = t.substr(1)), n = document.getElementById(t)) : typeof t === 'object' && t.nodeType === 1 && (n = t), !n) return this; if (this.node = n, e && a(e)) for (const s in e)n.style[s] = e[s]; else typeof e === 'string' && (n.style = e); return n.style.zIndex = '0', n.style.display = 'inline', n.style.position = 'absolute', n.phaser = this, this.parent && this.parent.appendChild(n), i && (n.innerText = i), this.updateSize(); }, createFromCache(t, e) { const i = this.cache.get(t); return i && this.createFromHTML(i, e), this; }, createFromHTML(t, e) { void 0 === e && (e = 'div'), this.removeElement(); const i = document.createElement(e); return this.node = i, i.style.zIndex = '0', i.style.display = 'inline', i.style.position = 'absolute', i.phaser = this, this.parent && this.parent.appendChild(i), i.innerHTML = t, this.updateSize(); }, removeElement() { return this.node && (h(this.node), this.node = null), this; }, updateSize() { const t = this.node; const e = t.getBoundingClientRect(); return this.width = t.clientWidth, this.height = t.clientHeight, this.displayWidth = e.width || 0, this.displayHeight = e.height || 0, this; }, getChildByProperty(t, e) { if (this.node) for (let i = this.node.querySelectorAll('*'), n = 0; n < i.length; n++) if (i[n][t] === e) return i[n]; return null; }, getChildByID(t) { return this.getChildByProperty('id', t); }, getChildByName(t) { return this.getChildByProperty('name', t); }, setClassName(t) { return this.node && (this.node.className = t, this.updateSize()), this; }, setText(t) { return this.node && (this.node.innerText = t, this.updateSize()), this; }, setHTML(t) { return this.node && (this.node.innerHTML = t, this.updateSize()), this; }, preUpdate() { const t = this.parentContainer; const e = this.node; e && t && !t.willRender() && (e.style.display = 'none'); }, willRender() { return !0; }, preDestroy() { this.removeElement(), this.scene.sys.events.off(l.SLEEP, this.handleSceneEvent, this), this.scene.sys.events.off(l.WAKE, this.handleSceneEvent, this); },
  }); t.exports = c;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(988); const s = i(14); t.exports = function (t, e, i, r, o) { const a = e.node; const h = a.style; const l = e.scene.sys.settings; if (!(a && h && l.visible && s.RENDER_MASK === e.renderFlags) || e.cameraFilter !== 0 && e.cameraFilter & r.id || e.parentContainer && !e.parentContainer.willRender())a && (h.display = 'none'); else { const u = e.parentContainer; let c = r.alpha * e.alpha; u && (c *= u.alpha); const d = t._tempMatrix1; const f = t._tempMatrix2; const p = t._tempMatrix3; let g = 0; let v = 0; let m = '0%'; let y = '0%'; o ? (g = e.width * e.scaleX * e.originX, v = e.height * e.scaleY * e.originY, f.applyITRS(e.x - g, e.y - v, e.rotation, e.scaleX, e.scaleY), d.copyFrom(r.matrix), d.multiplyWithOffset(o, -r.scrollX * e.scrollFactorX, -r.scrollY * e.scrollFactorY), f.e = e.x - g, f.f = e.y - v, d.multiply(f, p)) : (g = e.width * e.originX, v = e.height * e.originY, f.applyITRS(e.x - g, e.y - v, e.rotation, e.scaleX, e.scaleY), d.copyFrom(r.matrix), m = `${100 * e.originX}%`, y = `${100 * e.originY}%`, f.e -= r.scrollX * e.scrollFactorX, f.f -= r.scrollY * e.scrollFactorY, d.multiply(f, p)), e.transformOnly || (h.display = 'block', h.opacity = c, h.zIndex = e._depth, h.pointerEvents = 'auto', h.mixBlendMode = n[e._blendMode]), h.transform = `${p.getCSSMatrix()} skew(${e.skewX}rad, ${e.skewY}rad) rotate3d(${e.rotate3d.x},${e.rotate3d.y},${e.rotate3d.z},${e.rotate3d.w}${e.rotate3dAngle})`, h.transformOrigin = `${m} ${y}`; } };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(13); const r = i(14); const o = i(992); const a = new n({
    Extends: r, Mixins: [s.Alpha, s.BlendMode, s.Depth, s.Flip, s.Origin, s.ScrollFactor, s.Size, s.Texture, s.Tint, s.Transform, s.Visible, o], initialize(t) { r.call(this, t, 'Extern'); }, preUpdate() {}, render() {},
  }); t.exports = a;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(211); const s = i(97); const r = i(16); const o = i(4); t.exports = function (t, e, i) { void 0 === i && (i = new o()); const a = s(e, 0, r.PI2); return n(t, a, i); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(432); const s = i(211); const r = i(97); const o = i(16); t.exports = function (t, e, i, a) { void 0 === a && (a = []), !e && i > 0 && (e = n(t) / i); for (let h = 0; h < e; h++) { const l = r(h / e, 0, o.PI2); a.push(s(t, l)); } return a; };
}, function (t, e) { t.exports = function (t) { const e = t.width / 2; const i = t.height / 2; const n = Math.pow(e - i, 2) / Math.pow(e + i, 2); return Math.PI * (e + i) * (1 + 3 * n / (10 + Math.sqrt(4 - 3 * n))); }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(210); const s = i(31); t.exports = function (t, e, i, r, o, a, h) { const l = e.commandBuffer; const u = l.length; const c = a || t.currentContext; if (u !== 0 && s(t, c, e, r, o)) { let d = 1; let f = 1; let p = 0; let g = 0; let v = 1; let m = 0; let y = 0; let x = 0; c.beginPath(); for (let T = 0; T < u; ++T) { switch (l[T]) { case n.ARC: c.arc(l[T + 1], l[T + 2], l[T + 3], l[T + 4], l[T + 5], l[T + 6]), T += 7; break; case n.LINE_STYLE: v = l[T + 1], p = l[T + 2], d = l[T + 3], m = (16711680 & p) >>> 16, y = (65280 & p) >>> 8, x = 255 & p, c.strokeStyle = `rgba(${m},${y},${x},${d})`, c.lineWidth = v, T += 3; break; case n.FILL_STYLE: g = l[T + 1], f = l[T + 2], m = (16711680 & g) >>> 16, y = (65280 & g) >>> 8, x = 255 & g, c.fillStyle = `rgba(${m},${y},${x},${f})`, T += 2; break; case n.BEGIN_PATH: c.beginPath(); break; case n.CLOSE_PATH: c.closePath(); break; case n.FILL_PATH: h || c.fill(); break; case n.STROKE_PATH: h || c.stroke(); break; case n.FILL_RECT: h ? c.rect(l[T + 1], l[T + 2], l[T + 3], l[T + 4]) : c.fillRect(l[T + 1], l[T + 2], l[T + 3], l[T + 4]), T += 4; break; case n.FILL_TRIANGLE: c.beginPath(), c.moveTo(l[T + 1], l[T + 2]), c.lineTo(l[T + 3], l[T + 4]), c.lineTo(l[T + 5], l[T + 6]), c.closePath(), h || c.fill(), T += 6; break; case n.STROKE_TRIANGLE: c.beginPath(), c.moveTo(l[T + 1], l[T + 2]), c.lineTo(l[T + 3], l[T + 4]), c.lineTo(l[T + 5], l[T + 6]), c.closePath(), h || c.stroke(), T += 6; break; case n.LINE_TO: c.lineTo(l[T + 1], l[T + 2]), T += 2; break; case n.MOVE_TO: c.moveTo(l[T + 1], l[T + 2]), T += 2; break; case n.LINE_FX_TO: c.lineTo(l[T + 1], l[T + 2]), T += 5; break; case n.MOVE_FX_TO: c.moveTo(l[T + 1], l[T + 2]), T += 5; break; case n.SAVE: c.save(); break; case n.RESTORE: c.restore(); break; case n.TRANSLATE: c.translate(l[T + 1], l[T + 2]), T += 2; break; case n.SCALE: c.scale(l[T + 1], l[T + 2]), T += 2; break; case n.ROTATE: c.rotate(l[T + 1]), T += 1; break; case n.GRADIENT_FILL_STYLE: T += 5; break; case n.GRADIENT_LINE_STYLE: T += 6; break; case n.SET_TEXTURE: T += 2; } }c.restore(); } };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(2); const r = new n({
    initialize(t, e, i, n, r) { if (typeof t === 'object') { const o = t; t = s(o, 'x', 0), e = s(o, 'y', 0), i = s(o, 'power', 0), n = s(o, 'epsilon', 100), r = s(o, 'gravity', 50); } else void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 100), void 0 === r && (r = 50); this.x = t, this.y = e, this.active = !0, this._gravity = r, this._power = 0, this._epsilon = 0, this.power = i, this.epsilon = n; }, update(t, e) { const i = this.x - t.x; const n = this.y - t.y; let s = i * i + n * n; if (s !== 0) { const r = Math.sqrt(s); s < this._epsilon && (s = this._epsilon); const o = this._power * e / (s * r) * 100; t.velocityX += i * o, t.velocityY += n * o; } }, epsilon: { get() { return Math.sqrt(this._epsilon); }, set(t) { this._epsilon = t * t; } }, power: { get() { return this._power / this._gravity; }, set(t) { this._power = t * this._gravity; } }, gravity: { get() { return this._gravity; }, set(t) { const e = this.power; this._gravity = t, this.power = e; } },
  }); t.exports = r;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(41); const r = i(56); const o = new n({
    initialize(t) {
      this.emitter = t, this.frame = null, this.x = 0, this.y = 0, this.velocityX = 0, this.velocityY = 0, this.accelerationX = 0, this.accelerationY = 0, this.maxVelocityX = 1e4, this.maxVelocityY = 1e4, this.bounce = 0, this.scaleX = 1, this.scaleY = 1, this.alpha = 1, this.angle = 0, this.rotation = 0, this.tint = 16777215, this.life = 1e3, this.lifeCurrent = 1e3, this.delayCurrent = 0, this.lifeT = 0, this.data = {
        tint: { min: 16777215, max: 16777215, current: 16777215 }, alpha: { min: 1, max: 1 }, rotate: { min: 0, max: 0 }, scaleX: { min: 1, max: 1 }, scaleY: { min: 1, max: 1 },
      };
    },
    isAlive() { return this.lifeCurrent > 0; },
    resetPosition() { this.x = 0, this.y = 0; },
    fire(t, e) { const i = this.emitter; this.frame = i.getFrame(), i.emitZone && i.emitZone.getPoint(this), void 0 === t ? (i.follow && (this.x += i.follow.x + i.followOffset.x), this.x += i.x.onEmit(this, 'x')) : this.x += t, void 0 === e ? (i.follow && (this.y += i.follow.y + i.followOffset.y), this.y += i.y.onEmit(this, 'y')) : this.y += e, this.life = i.lifespan.onEmit(this, 'lifespan'), this.lifeCurrent = this.life, this.lifeT = 0; const n = i.speedX.onEmit(this, 'speedX'); const o = i.speedY ? i.speedY.onEmit(this, 'speedY') : n; if (i.radial) { const a = s(i.angle.onEmit(this, 'angle')); this.velocityX = Math.cos(a) * Math.abs(n), this.velocityY = Math.sin(a) * Math.abs(o); } else if (i.moveTo) { const h = i.moveToX.onEmit(this, 'moveToX'); const l = i.moveToY ? i.moveToY.onEmit(this, 'moveToY') : h; const u = Math.atan2(l - this.y, h - this.x); const c = r(this.x, this.y, h, l) / (this.life / 1e3); this.velocityX = Math.cos(u) * c, this.velocityY = Math.sin(u) * c; } else this.velocityX = n, this.velocityY = o; i.acceleration && (this.accelerationX = i.accelerationX.onEmit(this, 'accelerationX'), this.accelerationY = i.accelerationY.onEmit(this, 'accelerationY')), this.maxVelocityX = i.maxVelocityX.onEmit(this, 'maxVelocityX'), this.maxVelocityY = i.maxVelocityY.onEmit(this, 'maxVelocityY'), this.delayCurrent = i.delay.onEmit(this, 'delay'), this.scaleX = i.scaleX.onEmit(this, 'scaleX'), this.scaleY = i.scaleY ? i.scaleY.onEmit(this, 'scaleY') : this.scaleX, this.angle = i.rotate.onEmit(this, 'rotate'), this.rotation = s(this.angle), this.bounce = i.bounce.onEmit(this, 'bounce'), this.alpha = i.alpha.onEmit(this, 'alpha'), this.tint = i.tint.onEmit(this, 'tint'); },
    computeVelocity(t, e, i, n) { let s = this.velocityX; let r = this.velocityY; const o = this.accelerationX; const a = this.accelerationY; const h = this.maxVelocityX; const l = this.maxVelocityY; s += t.gravityX * i, r += t.gravityY * i, o && (s += o * i), a && (r += a * i), s > h ? s = h : s < -h && (s = -h), r > l ? r = l : r < -l && (r = -l), this.velocityX = s, this.velocityY = r; for (let u = 0; u < n.length; u++)n[u].update(this, e, i); },
    checkBounds(t) { const e = t.bounds; const i = -this.bounce; this.x < e.x && t.collideLeft ? (this.x = e.x, this.velocityX *= i) : this.x > e.right && t.collideRight && (this.x = e.right, this.velocityX *= i), this.y < e.y && t.collideTop ? (this.y = e.y, this.velocityY *= i) : this.y > e.bottom && t.collideBottom && (this.y = e.bottom, this.velocityY *= i); },
    update(t, e, i) { if (this.delayCurrent > 0) return this.delayCurrent -= t, !1; const n = this.emitter; const r = 1 - this.lifeCurrent / this.life; return this.lifeT = r, this.computeVelocity(n, t, e, i), this.x += this.velocityX * e, this.y += this.velocityY * e, n.bounds && this.checkBounds(n), n.deathZone && n.deathZone.willKill(this) ? (this.lifeCurrent = 0, !0) : (this.scaleX = n.scaleX.onUpdate(this, 'scaleX', r, this.scaleX), n.scaleY ? this.scaleY = n.scaleY.onUpdate(this, 'scaleY', r, this.scaleY) : this.scaleY = this.scaleX, this.angle = n.rotate.onUpdate(this, 'rotate', r, this.angle), this.rotation = s(this.angle), this.alpha = n.alpha.onUpdate(this, 'alpha', r, this.alpha), this.tint = n.tint.onUpdate(this, 'tint', r, this.tint), this.lifeCurrent -= t, this.lifeCurrent <= 0); },
  }); t.exports = o;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(45); const s = i(0); const r = i(13); const o = i(437); const a = i(438); const h = i(1004); const l = i(2); const u = i(202); const c = i(439); const d = i(113); const f = i(435); const p = i(440); const g = i(12); const v = i(142); const m = i(3); const y = i(64); const x = new s({
    Mixins: [r.BlendMode, r.Mask, r.ScrollFactor, r.Visible], initialize(t, e) { this.manager = t, this.texture = t.texture, this.frames = [t.defaultFrame], this.defaultFrame = t.defaultFrame, this.configFastMap = ['active', 'blendMode', 'collideBottom', 'collideLeft', 'collideRight', 'collideTop', 'deathCallback', 'deathCallbackScope', 'emitCallback', 'emitCallbackScope', 'follow', 'frequency', 'gravityX', 'gravityY', 'maxParticles', 'name', 'on', 'particleBringToTop', 'particleClass', 'radial', 'timeScale', 'trackVisible', 'visible'], this.configOpMap = ['accelerationX', 'accelerationY', 'angle', 'alpha', 'bounce', 'delay', 'lifespan', 'maxVelocityX', 'maxVelocityY', 'moveToX', 'moveToY', 'quantity', 'rotate', 'scaleX', 'scaleY', 'speedX', 'speedY', 'tint', 'x', 'y'], this.name = '', this.particleClass = f, this.x = new h(e, 'x', 0, !0), this.y = new h(e, 'y', 0, !0), this.radial = !0, this.gravityX = 0, this.gravityY = 0, this.acceleration = !1, this.accelerationX = new h(e, 'accelerationX', 0, !0), this.accelerationY = new h(e, 'accelerationY', 0, !0), this.maxVelocityX = new h(e, 'maxVelocityX', 1e4, !0), this.maxVelocityY = new h(e, 'maxVelocityY', 1e4, !0), this.speedX = new h(e, 'speedX', 0, !0), this.speedY = new h(e, 'speedY', 0, !0), this.moveTo = !1, this.moveToX = new h(e, 'moveToX', 0, !0), this.moveToY = new h(e, 'moveToY', 0, !0), this.bounce = new h(e, 'bounce', 0, !0), this.scaleX = new h(e, 'scaleX', 1), this.scaleY = new h(e, 'scaleY', 1), this.tint = new h(e, 'tint', 4294967295), this.alpha = new h(e, 'alpha', 1), this.lifespan = new h(e, 'lifespan', 1e3, !0), this.angle = new h(e, 'angle', { min: 0, max: 360 }, !0), this.rotate = new h(e, 'rotate', 0), this.emitCallback = null, this.emitCallbackScope = null, this.deathCallback = null, this.deathCallbackScope = null, this.maxParticles = 0, this.quantity = new h(e, 'quantity', 1, !0), this.delay = new h(e, 'delay', 0, !0), this.frequency = 0, this.on = !0, this.particleBringToTop = !0, this.timeScale = 1, this.emitZone = null, this.deathZone = null, this.bounds = null, this.collideLeft = !0, this.collideRight = !0, this.collideTop = !0, this.collideBottom = !0, this.active = !0, this.visible = !0, this.blendMode = n.NORMAL, this.follow = null, this.followOffset = new m(), this.trackVisible = !1, this.currentFrame = 0, this.randomFrame = !0, this.frameQuantity = 1, this.dead = [], this.alive = [], this._counter = 0, this._frameCounter = 0, e && this.fromJSON(e); }, fromJSON(t) { if (!t) return this; let e = 0; let i = ''; for (e = 0; e < this.configFastMap.length; e++)i = this.configFastMap[e], d(t, i) && (this[i] = l(t, i)); for (e = 0; e < this.configOpMap.length; e++)i = this.configOpMap[e], d(t, i) && this[i].loadConfig(t); if (this.acceleration = this.accelerationX.propertyValue !== 0 || this.accelerationY.propertyValue !== 0, this.moveTo = this.moveToX.propertyValue !== 0 || this.moveToY.propertyValue !== 0, d(t, 'speed') && (this.speedX.loadConfig(t, 'speed'), this.speedY = null), (c(t, ['speedX', 'speedY']) || this.moveTo) && (this.radial = !1), d(t, 'scale') && (this.scaleX.loadConfig(t, 'scale'), this.scaleY = null), d(t, 'callbackScope')) { const n = l(t, 'callbackScope', null); this.emitCallbackScope = n, this.deathCallbackScope = n; } return d(t, 'emitZone') && this.setEmitZone(t.emitZone), d(t, 'deathZone') && this.setDeathZone(t.deathZone), d(t, 'bounds') && this.setBounds(t.bounds), d(t, 'followOffset') && this.followOffset.setFromObject(l(t, 'followOffset', 0)), d(t, 'frame') && this.setFrame(t.frame), this; }, toJSON(t) { void 0 === t && (t = {}); let e = 0; let i = ''; for (e = 0; e < this.configFastMap.length; e++)t[i = this.configFastMap[e]] = this[i]; for (e = 0; e < this.configOpMap.length; e++) this[i = this.configOpMap[e]] && (t[i] = this[i].toJSON()); return this.speedY || (delete t.speedX, t.speed = this.speedX.toJSON()), this.scaleY || (delete t.scaleX, t.scale = this.scaleX.toJSON()), t; }, startFollow(t, e, i, n) { return void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = !1), this.follow = t, this.followOffset.set(e, i), this.trackVisible = n, this; }, stopFollow() { return this.follow = null, this.followOffset.set(0, 0), this.trackVisible = !1, this; }, getFrame() { if (this.frames.length === 1) return this.defaultFrame; if (this.randomFrame) return u(this.frames); const t = this.frames[this.currentFrame]; return this._frameCounter++, this._frameCounter === this.frameQuantity && (this._frameCounter = 0, this.currentFrame = y(this.currentFrame + 1, 0, this._frameLength)), t; }, setFrame(t, e, i) { void 0 === e && (e = !0), void 0 === i && (i = 1), this.randomFrame = e, this.frameQuantity = i, this.currentFrame = 0, this._frameCounter = 0; const n = typeof t; if (Array.isArray(t) || n === 'string' || n === 'number') this.manager.setEmitterFrames(t, this); else if (n === 'object') { const s = t; (t = l(s, 'frames', null)) && this.manager.setEmitterFrames(t, this); const r = l(s, 'cycle', !1); this.randomFrame = !r, this.frameQuantity = l(s, 'quantity', i); } return this._frameLength = this.frames.length, this._frameLength === 1 && (this.frameQuantity = 1, this.randomFrame = !1), this; }, setRadial(t) { return void 0 === t && (t = !0), this.radial = t, this; }, setPosition(t, e) { return this.x.onChange(t), this.y.onChange(e), this; }, setBounds(t, e, i, n) { if (typeof t === 'object') { const s = t; t = s.x, e = s.y, i = d(s, 'w') ? s.w : s.width, n = d(s, 'h') ? s.h : s.height; } return this.bounds ? this.bounds.setTo(t, e, i, n) : this.bounds = new g(t, e, i, n), this; }, setSpeedX(t) { return this.speedX.onChange(t), this.radial = !1, this; }, setSpeedY(t) { return this.speedY && (this.speedY.onChange(t), this.radial = !1), this; }, setSpeed(t) { return this.speedX.onChange(t), this.speedY = null, this.radial = !0, this; }, setScaleX(t) { return this.scaleX.onChange(t), this; }, setScaleY(t) { return this.scaleY.onChange(t), this; }, setScale(t) { return this.scaleX.onChange(t), this.scaleY = null, this; }, setGravityX(t) { return this.gravityX = t, this; }, setGravityY(t) { return this.gravityY = t, this; }, setGravity(t, e) { return this.gravityX = t, this.gravityY = e, this; }, setAlpha(t) { return this.alpha.onChange(t), this; }, setTint(t) { return this.tint.onChange(t), this; }, setEmitterAngle(t) { return this.angle.onChange(t), this; }, setAngle(t) { return this.angle.onChange(t), this; }, setLifespan(t) { return this.lifespan.onChange(t), this; }, setQuantity(t) { return this.quantity.onChange(t), this; }, setFrequency(t, e) { return this.frequency = t, this._counter = 0, e && this.quantity.onChange(e), this; }, setEmitZone(t) { if (void 0 === t) this.emitZone = null; else { const e = l(t, 'type', 'random'); const i = l(t, 'source', null); switch (e) { case 'random': this.emitZone = new p(i); break; case 'edge': var n = l(t, 'quantity', 1); var s = l(t, 'stepRate', 0); var r = l(t, 'yoyo', !1); var o = l(t, 'seamless', !0); this.emitZone = new a(i, n, s, r, o); } } return this; }, setDeathZone(t) { if (void 0 === t) this.deathZone = null; else { const e = l(t, 'type', 'onEnter'); const i = l(t, 'source', null); if (i && typeof i.contains === 'function') { const n = e === 'onEnter'; this.deathZone = new o(i, n); } } return this; }, reserve(t) { for (let e = this.dead, i = 0; i < t; i++)e.push(new this.particleClass(this)); return this; }, getAliveParticleCount() { return this.alive.length; }, getDeadParticleCount() { return this.dead.length; }, getParticleCount() { return this.getAliveParticleCount() + this.getDeadParticleCount(); }, atLimit() { return this.maxParticles > 0 && this.getParticleCount() === this.maxParticles; }, onParticleEmit(t, e) { return void 0 === t ? (this.emitCallback = null, this.emitCallbackScope = null) : typeof t === 'function' && (this.emitCallback = t, e && (this.emitCallbackScope = e)), this; }, onParticleDeath(t, e) { return void 0 === t ? (this.deathCallback = null, this.deathCallbackScope = null) : typeof t === 'function' && (this.deathCallback = t, e && (this.deathCallbackScope = e)), this; }, killAll() { for (let t = this.dead, e = this.alive; e.length > 0;)t.push(e.pop()); return this; }, forEachAlive(t, e) { for (let i = this.alive, n = i.length, s = 0; s < n; ++s)t.call(e, i[s], this); return this; }, forEachDead(t, e) { for (let i = this.dead, n = i.length, s = 0; s < n; ++s)t.call(e, i[s], this); return this; }, start() { return this.on = !0, this._counter = 0, this; }, stop() { return this.on = !1, this; }, pause() { return this.active = !1, this; }, resume() { return this.active = !0, this; }, remove() { return this.manager.removeEmitter(this), this; }, depthSort() { return v.inplace(this.alive, this.depthSortCallback), this; }, flow(t, e) { return void 0 === e && (e = 1), this.frequency = t, this.quantity.onChange(e), this.start(); }, explode(t, e, i) { return this.frequency = -1, this.emitParticle(t, e, i); }, emitParticleAt(t, e, i) { return this.emitParticle(i, t, e); }, emitParticle(t, e, i) { if (!this.atLimit()) { void 0 === t && (t = this.quantity.onEmit()); for (let n = this.dead, s = 0; s < t; s++) { var r = n.pop(); if (r || (r = new this.particleClass(this)), r.fire(e, i), this.particleBringToTop ? this.alive.push(r) : this.alive.unshift(r), this.emitCallback && this.emitCallback.call(this.emitCallbackScope, r, this), this.atLimit()) break; } return r; } }, preUpdate(t, e) { const i = (e *= this.timeScale) / 1e3; this.trackVisible && (this.visible = this.follow.visible); const n = this.manager.getProcessors(); const s = this.alive; const r = this.dead; let o = 0; const a = []; let h = s.length; for (o = 0; o < h; o++) { const l = s[o]; l.update(e, i, n) && a.push({ index: o, particle: l }); } if ((h = a.length) > 0) { const u = this.deathCallback; const c = this.deathCallbackScope; for (o = h - 1; o >= 0; o--) { const d = a[o]; s.splice(d.index, 1), r.push(d.particle), u && u.call(c, d.particle), d.particle.resetPosition(); } } this.on && (this.frequency === 0 ? this.emitParticle() : this.frequency > 0 && (this._counter -= e, this._counter <= 0 && (this.emitParticle(), this._counter = this.frequency - Math.abs(this._counter)))); }, depthSortCallback(t, e) { return t.y - e.y; },
  }); t.exports = x;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = new (i(0))({ initialize(t, e) { this.source = t, this.killOnEnter = e; }, willKill(t) { const e = this.source.contains(t.x, t.y); return e && this.killOnEnter || !e && !this.killOnEnter; } }); t.exports = n;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = new (i(0))({
    initialize(t, e, i, n, s) { void 0 === n && (n = !1), void 0 === s && (s = !0), this.source = t, this.points = [], this.quantity = e, this.stepRate = i, this.yoyo = n, this.counter = -1, this.seamless = s, this._length = 0, this._direction = 0, this.updateSource(); }, updateSource() { if (this.points = this.source.getPoints(this.quantity, this.stepRate), this.seamless) { const t = this.points[0]; const e = this.points[this.points.length - 1]; t.x === e.x && t.y === e.y && this.points.pop(); } const i = this._length; return this._length = this.points.length, this._length < i && this.counter > this._length && (this.counter = this._length - 1), this; }, changeSource(t) { return this.source = t, this.updateSource(); }, getPoint(t) { this._direction === 0 ? (this.counter++, this.counter >= this._length && (this.yoyo ? (this._direction = 1, this.counter = this._length - 1) : this.counter = 0)) : (this.counter--, this.counter === -1 && (this.yoyo ? (this._direction = 0, this.counter = 0) : this.counter = this._length - 1)); const e = this.points[this.counter]; e && (t.x = e.x, t.y = e.y); },
  }); t.exports = n;
}, function (t, e) { t.exports = function (t, e) { for (let i = 0; i < e.length; i++) if (t.hasOwnProperty(e[i])) return !0; return !1; }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(3); const r = new n({ initialize(t) { this.source = t, this._tempVec = new s(); }, getPoint(t) { const e = this._tempVec; this.source.getRandomPoint(e), t.x = e.x, t.y = e.y; } }); t.exports = r;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(13); const r = i(66); const o = new n({
    Extends: r, Mixins: [s.PathFollower], initialize(t, e, i, n, s, o) { r.call(this, t, i, n, s, o), this.path = e; }, preUpdate(t, e) { this.anims.update(t, e), this.pathUpdate(t); },
  }); t.exports = o;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(1030); const s = i(0); const r = i(41); const o = i(73); const a = i(72); const h = i(16); const l = i(34); const u = new s({
    Extends: l, Mixins: [n], initialize(t, e, i, n, s, r, o, h, u) { void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 128), void 0 === s && (s = 0), void 0 === r && (r = 360), void 0 === o && (o = !1), l.call(this, t, 'Arc', new a(0, 0, n)), this._startAngle = s, this._endAngle = r, this._anticlockwise = o, this._iterations = 0.01, this.setPosition(e, i); const c = 2 * this.geom.radius; this.setSize(c, c), void 0 !== h && this.setFillStyle(h, u), this.updateDisplayOrigin(), this.updateData(); }, iterations: { get() { return this._iterations; }, set(t) { this._iterations = t, this.updateData(); } }, radius: { get() { return this.geom.radius; }, set(t) { this.geom.radius = t; const e = 2 * t; this.setSize(e, e), this.updateDisplayOrigin(), this.updateData(); } }, startAngle: { get() { return this._startAngle; }, set(t) { this._startAngle = t, this.updateData(); } }, endAngle: { get() { return this._endAngle; }, set(t) { this._endAngle = t, this.updateData(); } }, anticlockwise: { get() { return this._anticlockwise; }, set(t) { this._anticlockwise = t, this.updateData(); } }, setRadius(t) { return this.radius = t, this; }, setIterations(t) { return void 0 === t && (t = 0.01), this.iterations = t, this; }, setStartAngle(t, e) { return this._startAngle = t, void 0 !== e && (this._anticlockwise = e), this.updateData(); }, setEndAngle(t, e) { return this._endAngle = t, void 0 !== e && (this._anticlockwise = e), this.updateData(); }, updateData() { const t = this._iterations; let e = t; const i = this.geom.radius; const n = r(this._startAngle); let s = r(this._endAngle); const a = i; const l = i; s -= n, this._anticlockwise ? s < -h.PI2 ? s = -h.PI2 : s > 0 && (s = -h.PI2 + s % h.PI2) : s > h.PI2 ? s = h.PI2 : s < 0 && (s = h.PI2 + s % h.PI2); for (var u, c = [a + Math.cos(n) * i, l + Math.sin(n) * i]; e < 1;)u = s * e + n, c.push(a + Math.cos(u) * i, l + Math.sin(u) * i), e += t; return u = s + n, c.push(a + Math.cos(u) * i, l + Math.sin(u) * i), c.push(a + Math.cos(n) * i, l + Math.sin(n) * i), this.pathIndexes = o(c), this.pathData = c, this; },
  }); t.exports = u;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(1033); const r = i(73); const o = i(12); const a = i(34); const h = new n({
    Extends: a, Mixins: [s], initialize(t, e, i, n, s, r) { void 0 === e && (e = 0), void 0 === i && (i = 0), a.call(this, t, 'Curve', n), this._smoothness = 32, this._curveBounds = new o(), this.closePath = !1, this.setPosition(e, i), void 0 !== s && this.setFillStyle(s, r), this.updateData(); }, smoothness: { get() { return this._smoothness; }, set(t) { this._smoothness = t, this.updateData(); } }, setSmoothness(t) { return this._smoothness = t, this.updateData(); }, updateData() { const t = this._curveBounds; const e = this._smoothness; this.geom.getBounds(t, e), this.setSize(t.width, t.height), this.updateDisplayOrigin(); for (var i = [], n = this.geom.getPoints(e), s = 0; s < n.length; s++)i.push(n[s].x, n[s].y); return i.push(n[0].x, n[0].y), this.pathIndexes = r(i), this.pathData = i, this; },
  }); t.exports = h;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(73); const r = i(1036); const o = i(108); const a = i(34); const h = new n({
    Extends: a, Mixins: [r], initialize(t, e, i, n, s, r, h) { void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 128), void 0 === s && (s = 128), a.call(this, t, 'Ellipse', new o(n / 2, s / 2, n, s)), this._smoothness = 64, this.setPosition(e, i), this.width = n, this.height = s, void 0 !== r && this.setFillStyle(r, h), this.updateDisplayOrigin(), this.updateData(); }, smoothness: { get() { return this._smoothness; }, set(t) { this._smoothness = t, this.updateData(); } }, setSize(t, e) { return this.geom.setSize(t, e), this.updateData(); }, setSmoothness(t) { return this._smoothness = t, this.updateData(); }, updateData() { for (var t = [], e = this.geom.getPoints(this._smoothness), i = 0; i < e.length; i++)t.push(e[i].x, e[i].y); return t.push(e[0].x, e[0].y), this.pathIndexes = s(t), this.pathData = t, this; },
  }); t.exports = h;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(34); const r = i(1039); const o = new n({
    Extends: s, Mixins: [r], initialize(t, e, i, n, r, o, a, h, l, u, c) { void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 128), void 0 === r && (r = 128), void 0 === o && (o = 32), void 0 === a && (a = 32), s.call(this, t, 'Grid', null), this.cellWidth = o, this.cellHeight = a, this.showCells = !0, this.outlineFillColor = 0, this.outlineFillAlpha = 0, this.showOutline = !0, this.showAltCells = !1, this.altFillColor, this.altFillAlpha, this.setPosition(e, i), this.setSize(n, r), void 0 !== h && this.setFillStyle(h, l), void 0 !== u && this.setOutlineStyle(u, c), this.updateDisplayOrigin(); }, setFillStyle(t, e) { return void 0 === e && (e = 1), void 0 === t ? this.showCells = !1 : (this.fillColor = t, this.fillAlpha = e, this.showCells = !0), this; }, setAltFillStyle(t, e) { return void 0 === e && (e = 1), void 0 === t ? this.showAltCells = !1 : (this.altFillColor = t, this.altFillAlpha = e, this.showAltCells = !0), this; }, setOutlineStyle(t, e) { return void 0 === e && (e = 1), void 0 === t ? this.showOutline = !1 : (this.outlineFillColor = t, this.outlineFillAlpha = e, this.showOutline = !0), this; },
  }); t.exports = o;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(1042); const s = i(0); const r = i(34); const o = new s({
    Extends: r, Mixins: [n], initialize(t, e, i, n, s, o, a, h) { void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 48), void 0 === s && (s = 32), void 0 === o && (o = 15658734), void 0 === a && (a = 10066329), void 0 === h && (h = 13421772), r.call(this, t, 'IsoBox', null), this.projection = 4, this.fillTop = o, this.fillLeft = a, this.fillRight = h, this.showTop = !0, this.showLeft = !0, this.showRight = !0, this.isFilled = !0, this.setPosition(e, i), this.setSize(n, s), this.updateDisplayOrigin(); }, setProjection(t) { return this.projection = t, this; }, setFaces(t, e, i) { return void 0 === t && (t = !0), void 0 === e && (e = !0), void 0 === i && (i = !0), this.showTop = t, this.showLeft = e, this.showRight = i, this; }, setFillStyle(t, e, i) { return this.fillTop = t, this.fillLeft = e, this.fillRight = i, this.isFilled = !0, this; },
  }); t.exports = o;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(1045); const r = i(34); const o = new n({
    Extends: r, Mixins: [s], initialize(t, e, i, n, s, o, a, h, l) { void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 48), void 0 === s && (s = 32), void 0 === o && (o = !1), void 0 === a && (a = 15658734), void 0 === h && (h = 10066329), void 0 === l && (l = 13421772), r.call(this, t, 'IsoTriangle', null), this.projection = 4, this.fillTop = a, this.fillLeft = h, this.fillRight = l, this.showTop = !0, this.showLeft = !0, this.showRight = !0, this.isReversed = o, this.isFilled = !0, this.setPosition(e, i), this.setSize(n, s), this.updateDisplayOrigin(); }, setProjection(t) { return this.projection = t, this; }, setReversed(t) { return this.isReversed = t, this; }, setFaces(t, e, i) { return void 0 === t && (t = !0), void 0 === e && (e = !0), void 0 === i && (i = !0), this.showTop = t, this.showLeft = e, this.showRight = i, this; }, setFillStyle(t, e, i) { return this.fillTop = t, this.fillLeft = e, this.fillRight = i, this.isFilled = !0, this; },
  }); t.exports = o;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(34); const r = i(62); const o = i(1048); const a = new n({
    Extends: s, Mixins: [o], initialize(t, e, i, n, o, a, h, l, u) { void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 0), void 0 === o && (o = 0), void 0 === a && (a = 128), void 0 === h && (h = 0), s.call(this, t, 'Line', new r(n, o, a, h)); const c = this.geom.right - this.geom.left; const d = this.geom.bottom - this.geom.top; this.lineWidth = 1, this._startWidth = 1, this._endWidth = 1, this.setPosition(e, i), this.setSize(c, d), void 0 !== l && this.setStrokeStyle(1, l, u), this.updateDisplayOrigin(); }, setLineWidth(t, e) { return void 0 === e && (e = t), this._startWidth = t, this._endWidth = e, this.lineWidth = t, this; }, setTo(t, e, i, n) { return this.geom.setTo(t, e, i, n), this; },
  }); t.exports = a;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(1051); const s = i(0); const r = i(73); const o = i(450); const a = i(219); const h = i(34); const l = i(453); const u = new s({
    Extends: h, Mixins: [n], initialize(t, e, i, n, s, r) { void 0 === e && (e = 0), void 0 === i && (i = 0), h.call(this, t, 'Polygon', new a(n)); const l = o(this.geom); this.setPosition(e, i), this.setSize(l.width, l.height), void 0 !== s && this.setFillStyle(s, r), this.updateDisplayOrigin(), this.updateData(); }, smooth(t) { void 0 === t && (t = 1); for (let e = 0; e < t; e++)l(this.geom); return this.updateData(); }, updateData() { for (var t = [], e = this.geom.points, i = 0; i < e.length; i++)t.push(e[i].x, e[i].y); return t.push(e[0].x, e[0].y), this.pathIndexes = r(t), this.pathData = t, this; },
  }); t.exports = u;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(12); t.exports = function (t, e) { void 0 === e && (e = new n()); for (var i, s = 1 / 0, r = 1 / 0, o = -s, a = -r, h = 0; h < t.points.length; h++)i = t.points[h], s = Math.min(s, i.x), r = Math.min(r, i.y), o = Math.max(o, i.x), a = Math.max(a, i.y); return e.x = s, e.y = r, e.width = o - s, e.height = a - r, e; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(63); const s = i(62); const r = i(452); t.exports = function (t, e, i, o) { void 0 === o && (o = []); const a = t.points; const h = r(t); !e && i > 0 && (e = h / i); for (let l = 0; l < e; l++) for (let u = h * (l / e), c = 0, d = 0; d < a.length; d++) { const f = a[d]; const p = a[(d + 1) % a.length]; const g = new s(f.x, f.y, p.x, p.y); const v = n(g); if (!(u < c || u > c + v)) { const m = g.getPoint((u - c) / v); o.push(m); break; }c += v; } return o; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(63); const s = i(62); t.exports = function (t) { for (var e = t.points, i = 0, r = 0; r < e.length; r++) { const o = e[r]; const a = e[(r + 1) % e.length]; const h = new s(o.x, o.y, a.x, a.y); i += n(h); } return i; };
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Igor Ognichenko <ognichenko.igor@gmail.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const i = function (t, e) { return t[0] = e[0], t[1] = e[1], t; }; t.exports = function (t) { let e; const n = []; const s = t.points; for (e = 0; e < s.length; e++)n.push([s[e].x, s[e].y]); const r = []; for (n.length > 0 && r.push(i([0, 0], n[0])), e = 0; e < n.length - 1; e++) { const o = n[e]; const a = n[e + 1]; const h = o[0]; const l = o[1]; const u = a[0]; const c = a[1]; r.push([0.85 * h + 0.15 * u, 0.85 * l + 0.15 * c]), r.push([0.15 * h + 0.85 * u, 0.15 * l + 0.85 * c]); } return n.length > 1 && r.push(i([0, 0], n[n.length - 1])), t.setTo(r); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(12); const r = i(34); const o = i(1054); const a = new n({
    Extends: r, Mixins: [o], initialize(t, e, i, n, o, a, h) { void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 128), void 0 === o && (o = 128), r.call(this, t, 'Rectangle', new s(0, 0, n, o)), this.setPosition(e, i), this.setSize(n, o), void 0 !== a && this.setFillStyle(a, h), this.updateDisplayOrigin(), this.updateData(); }, updateData() { const t = []; const e = this.geom; const i = this._tempLine; return e.getLineA(i), t.push(i.x1, i.y1, i.x2, i.y2), e.getLineB(i), t.push(i.x2, i.y2), e.getLineC(i), t.push(i.x2, i.y2), e.getLineD(i), t.push(i.x2, i.y2), this.pathData = t, this; },
  }); t.exports = a;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(1057); const s = i(0); const r = i(73); const o = i(34); const a = new s({
    Extends: o, Mixins: [n], initialize(t, e, i, n, s, r, a, h) { void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 5), void 0 === s && (s = 32), void 0 === r && (r = 64), o.call(this, t, 'Star', null), this._points = n, this._innerRadius = s, this._outerRadius = r, this.setPosition(e, i), this.setSize(2 * r, 2 * r), void 0 !== a && this.setFillStyle(a, h), this.updateDisplayOrigin(), this.updateData(); }, setPoints(t) { return this._points = t, this.updateData(); }, setInnerRadius(t) { return this._innerRadius = t, this.updateData(); }, setOuterRadius(t) { return this._outerRadius = t, this.updateData(); }, points: { get() { return this._points; }, set(t) { this._points = t, this.updateData(); } }, innerRadius: { get() { return this._innerRadius; }, set(t) { this._innerRadius = t, this.updateData(); } }, outerRadius: { get() { return this._outerRadius; }, set(t) { this._outerRadius = t, this.updateData(); } }, updateData() { const t = []; const e = this._points; const i = this._innerRadius; const n = this._outerRadius; let s = Math.PI / 2 * 3; const o = Math.PI / e; const a = n; const h = n; t.push(a, h + -n); for (let l = 0; l < e; l++)t.push(a + Math.cos(s) * n, h + Math.sin(s) * n), s += o, t.push(a + Math.cos(s) * i, h + Math.sin(s) * i), s += o; return t.push(a, h + -n), this.pathIndexes = r(t), this.pathData = t, this; },
  }); t.exports = a;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(34); const r = i(78); const o = i(1060); const a = new n({
    Extends: s, Mixins: [o], initialize(t, e, i, n, o, a, h, l, u, c, d) { void 0 === e && (e = 0), void 0 === i && (i = 0), void 0 === n && (n = 0), void 0 === o && (o = 128), void 0 === a && (a = 64), void 0 === h && (h = 0), void 0 === l && (l = 128), void 0 === u && (u = 128), s.call(this, t, 'Triangle', new r(n, o, a, h, l, u)); const f = this.geom.right - this.geom.left; const p = this.geom.bottom - this.geom.top; this.setPosition(e, i), this.setSize(f, p), void 0 !== c && this.setFillStyle(c, d), this.updateDisplayOrigin(), this.updateData(); }, setTo(t, e, i, n, s, r) { return this.geom.setTo(t, e, i, n, s, r), this.updateData(); }, updateData() { const t = []; const e = this.geom; const i = this._tempLine; return e.getLineA(i), t.push(i.x1, i.y1, i.x2, i.y2), e.getLineB(i), t.push(i.x2, i.y2), e.getLineC(i), t.push(i.x2, i.y2), this.pathData = t, this; },
  }); t.exports = a;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(4); const s = i(63); t.exports = function (t, e, i) { void 0 === i && (i = new n()); const r = t.getLineA(); const o = t.getLineB(); const a = t.getLineC(); if (e <= 0 || e >= 1) return i.x = r.x1, i.y = r.y1, i; const h = s(r); const l = s(o); const u = s(a); let c = (h + l + u) * e; let d = 0; return c < h ? (d = c / h, i.x = r.x1 + (r.x2 - r.x1) * d, i.y = r.y1 + (r.y2 - r.y1) * d) : c > h + l ? (d = (c -= h + l) / u, i.x = a.x1 + (a.x2 - a.x1) * d, i.y = a.y1 + (a.y2 - a.y1) * d) : (d = (c -= h) / l, i.x = o.x1 + (o.x2 - o.x1) * d, i.y = o.y1 + (o.y2 - o.y1) * d), i; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(63); const s = i(4); t.exports = function (t, e, i, r) { void 0 === r && (r = []); const o = t.getLineA(); const a = t.getLineB(); const h = t.getLineC(); const l = n(o); const u = n(a); const c = n(h); const d = l + u + c; !e && i > 0 && (e = d / i); for (let f = 0; f < e; f++) { let p = d * (f / e); let g = 0; const v = new s(); p < l ? (g = p / l, v.x = o.x1 + (o.x2 - o.x1) * g, v.y = o.y1 + (o.y2 - o.y1) * g) : p > l + u ? (g = (p -= l + u) / c, v.x = h.x1 + (h.x2 - h.x1) * g, v.y = h.y1 + (h.y2 - h.y1) * g) : (g = (p -= l) / u, v.x = a.x1 + (a.x2 - a.x1) * g, v.y = a.y1 + (a.y2 - a.y1) * g), r.push(v); } return r; };
}, function (t, e) { t.exports = function (t, e, i) { if (!t || typeof t === 'number') return !1; if (t.hasOwnProperty(e)) return t[e] = i, !0; if (e.indexOf('.') !== -1) { for (var n = e.split('.'), s = t, r = t, o = 0; o < n.length; o++) { if (!s.hasOwnProperty(n[o])) return !1; r = s, s = s[n[o]]; } return r[n[n.length - 1]] = i, !0; } return !1; }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(11); const r = new n({
    initialize(t, e, i, n, s, r, o) { this.x = t, this.y = e, this.radius = i, this.r = n, this.g = s, this.b = r, this.intensity = o, this.scrollFactorX = 1, this.scrollFactorY = 1; }, set(t, e, i, n, s, r, o) { return this.x = t, this.y = e, this.radius = i, this.r = n, this.g = s, this.b = r, this.intensity = o, this.scrollFactorX = 1, this.scrollFactorY = 1, this; }, setScrollFactor(t, e) { return void 0 === t && (t = 1), void 0 === e && (e = t), this.scrollFactorX = t, this.scrollFactorY = e, this; }, setColor(t) { const e = s.getFloatsFromUintRGB(t); return this.r = e[0], this.g = e[1], this.b = e[2], this; }, setIntensity(t) { return this.intensity = t, this; }, setPosition(t, e) { return this.x = t, this.y = e, this; }, setRadius(t) { return this.radius = t, this; },
  }); t.exports = r;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(460); const r = i(11); const o = new n({
    initialize() { this.lightPool = [], this.lights = [], this.culledLights = [], this.ambientColor = { r: 0.1, g: 0.1, b: 0.1 }, this.active = !1, this.maxLights = -1; }, enable() { return this.maxLights === -1 && (this.maxLights = this.scene.sys.game.renderer.config.maxLights), this.active = !0, this; }, disable() { return this.active = !1, this; }, cull(t) { const e = this.lights; const i = this.culledLights; const n = e.length; const s = t.x + t.width / 2; const r = t.y + t.height / 2; const o = (t.width + t.height) / 2; const a = { x: 0, y: 0 }; const h = t.matrix; const l = this.systems.game.config.height; i.length = 0; for (let u = 0; u < n && i.length < this.maxLights; u++) { const c = e[u]; h.transformPoint(c.x, c.y, a); const d = s - (a.x - t.scrollX * c.scrollFactorX * t.zoom); const f = r - (l - (a.y - t.scrollY * c.scrollFactorY * t.zoom)); Math.sqrt(d * d + f * f) < c.radius + o && i.push(e[u]); } return i; }, forEachLight(t) { if (t) { for (let e = this.lights, i = e.length, n = 0; n < i; ++n)t(e[n]); return this; } }, setAmbientColor(t) { const e = r.getFloatsFromUintRGB(t); return this.ambientColor.r = e[0], this.ambientColor.g = e[1], this.ambientColor.b = e[2], this; }, getMaxVisibleLights() { return 10; }, getLightCount() { return this.lights.length; }, addLight(t, e, i, n, o) { let a; let h = null; return t = void 0 === t ? 0 : t, e = void 0 === e ? 0 : e, n = void 0 === n ? 16777215 : n, i = void 0 === i ? 100 : i, o = void 0 === o ? 1 : o, a = r.getFloatsFromUintRGB(n), h = null, this.lightPool.length > 0 ? (h = this.lightPool.pop()).set(t, e, i, a[0], a[1], a[2], o) : h = new s(t, e, i, a[0], a[1], a[2], o), this.lights.push(h), h; }, removeLight(t) { const e = this.lights.indexOf(t); return e >= 0 && (this.lightPool.push(t), this.lights.splice(e, 1)), this; }, shutdown() { for (;this.lights.length > 0;) this.lightPool.push(this.lights.pop()); this.ambientColor = { r: 0.1, g: 0.1, b: 0.1 }, this.culledLights.length = 0, this.lights.length = 0; }, destroy() { this.shutdown(); },
  }); t.exports = o;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(54); const s = i(19); let r = {
    Circle: i(1120), Ellipse: i(1130), Intersects: i(463), Line: i(1149), Point: i(1171), Polygon: i(1185), Rectangle: i(476), Triangle: i(1216),
  }; r = s(!1, r, n), t.exports = r;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = {
    CircleToCircle: i(223), CircleToRectangle: i(224), GetCircleToCircle: i(1140), GetCircleToRectangle: i(1141), GetLineToCircle: i(225), GetLineToRectangle: i(227), GetRectangleIntersection: i(1142), GetRectangleToRectangle: i(1143), GetRectangleToTriangle: i(1144), GetTriangleToCircle: i(1145), GetTriangleToLine: i(468), GetTriangleToTriangle: i(1146), LineToCircle: i(226), LineToLine: i(92), LineToRectangle: i(464), PointToLine: i(472), PointToLineSegment: i(1147), RectangleToRectangle: i(145), RectangleToTriangle: i(465), RectangleToValues: i(1148), TriangleToCircle: i(467), TriangleToLine: i(469), TriangleToTriangle: i(470),
  };
}, function (t, e) { t.exports = function (t, e) { const i = t.x1; const n = t.y1; const s = t.x2; const r = t.y2; const o = e.x; const a = e.y; const h = e.right; const l = e.bottom; let u = 0; if (i >= o && i <= h && n >= a && n <= l || s >= o && s <= h && r >= a && r <= l) return !0; if (i < o && s >= o) { if ((u = n + (r - n) * (o - i) / (s - i)) > a && u <= l) return !0; } else if (i > h && s <= h && (u = n + (r - n) * (h - i) / (s - i)) >= a && u <= l) return !0; if (n < a && r >= a) { if ((u = i + (s - i) * (a - n) / (r - n)) >= o && u <= h) return !0; } else if (n > l && r <= l && (u = i + (s - i) * (l - n) / (r - n)) >= o && u <= h) return !0; return !1; }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(92); const s = i(55); const r = i(228); const o = i(466); t.exports = function (t, e) { if (e.left > t.right || e.right < t.left || e.top > t.bottom || e.bottom < t.top) return !1; const i = e.getLineA(); const a = e.getLineB(); const h = e.getLineC(); if (s(t, i.x1, i.y1) || s(t, i.x2, i.y2)) return !0; if (s(t, a.x1, a.y1) || s(t, a.x2, a.y2)) return !0; if (s(t, h.x1, h.y1) || s(t, h.x2, h.y2)) return !0; const l = t.getLineA(); const u = t.getLineB(); const c = t.getLineC(); const d = t.getLineD(); if (n(i, l) || n(i, u) || n(i, c) || n(i, d)) return !0; if (n(a, l) || n(a, u) || n(a, c) || n(a, d)) return !0; if (n(h, l) || n(h, u) || n(h, c) || n(h, d)) return !0; const f = o(t); return r(e, f, !0).length > 0; };
}, function (t, e) { t.exports = function (t, e) { return void 0 === e && (e = []), e.push({ x: t.x, y: t.y }), e.push({ x: t.right, y: t.y }), e.push({ x: t.right, y: t.bottom }), e.push({ x: t.x, y: t.bottom }), e; }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(226); const s = i(91); t.exports = function (t, e) { return !(t.left > e.right || t.right < e.left || t.top > e.bottom || t.bottom < e.top) && (!!s(t, e.x, e.y) || (!!n(t.getLineA(), e) || (!!n(t.getLineB(), e) || !!n(t.getLineC(), e)))); };
}, function (t, e, i) {
/**
 * @author       Florian Vazelle
 * @author       Geoffrey Glaive
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(4); const s = i(469); const r = i(92); t.exports = function (t, e, i) { if (void 0 === i && (i = []), s(t, e)) for (let o = t.getLineA(), a = t.getLineB(), h = t.getLineC(), l = [new n(), new n(), new n()], u = [r(o, e, l[0]), r(a, e, l[1]), r(h, e, l[2])], c = 0; c < 3; c++)u[c] && i.push(l[c]); return i; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(91); const s = i(92); t.exports = function (t, e) { return !(!n(t, e.getPointA()) && !n(t, e.getPointB())) || (!!s(t.getLineA(), e) || (!!s(t.getLineB(), e) || !!s(t.getLineC(), e))); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(228); const s = i(471); const r = i(92); t.exports = function (t, e) { if (t.left > e.right || t.right < e.left || t.top > e.bottom || t.bottom < e.top) return !1; const i = t.getLineA(); const o = t.getLineB(); const a = t.getLineC(); const h = e.getLineA(); const l = e.getLineB(); const u = e.getLineC(); if (r(i, h) || r(i, l) || r(i, u)) return !0; if (r(o, h) || r(o, l) || r(o, u)) return !0; if (r(a, h) || r(a, l) || r(a, u)) return !0; let c = s(t); let d = n(e, c, !0); return d.length > 0 || (c = s(e), (d = n(t, c, !0)).length > 0); };
}, function (t, e) { t.exports = function (t, e) { return void 0 === e && (e = []), e.push({ x: t.x1, y: t.y1 }), e.push({ x: t.x2, y: t.y2 }), e.push({ x: t.x3, y: t.y3 }), e; }; }, function (t, e) { t.exports = function (t, e, i) { void 0 === i && (i = 1); const n = e.x1; const s = e.y1; const r = e.x2; const o = e.y2; const a = t.x; const h = t.y; const l = (r - n) * (r - n) + (o - s) * (o - s); if (l === 0) return !1; const u = ((a - n) * (r - n) + (h - s) * (o - s)) / l; if (u < 0) return Math.sqrt((n - a) * (n - a) + (s - h) * (s - h)) <= i; if (u >= 0 && u <= 1) { const c = ((s - h) * (r - n) - (n - a) * (o - s)) / l; return Math.abs(c) * Math.sqrt(l) <= i; } return Math.sqrt((r - a) * (r - a) + (o - h) * (o - h)) <= i; }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(16); const s = i(64); const r = i(93); t.exports = function (t) { const e = r(t) - n.TAU; return s(e, -Math.PI, Math.PI); };
}, function (t, e) { t.exports = function (t) { return Math.sqrt(t.x * t.x + t.y * t.y); }; }, function (t, e) { t.exports = function (t) { return t.x * t.x + t.y * t.y; }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(12); n.Area = i(1190), n.Ceil = i(1191), n.CeilAll = i(1192), n.CenterOn = i(183), n.Clone = i(1193), n.Contains = i(55), n.ContainsPoint = i(1194), n.ContainsRect = i(477), n.CopyFrom = i(1195), n.Decompose = i(466), n.Equals = i(1196), n.FitInside = i(1197), n.FitOutside = i(1198), n.Floor = i(1199), n.FloorAll = i(1200), n.FromPoints = i(193), n.FromXY = i(1201), n.GetAspectRatio = i(230), n.GetCenter = i(1202), n.GetPoint = i(166), n.GetPoints = i(298), n.GetSize = i(1203), n.Inflate = i(1204), n.Intersection = i(1205), n.MarchingAnts = i(309), n.MergePoints = i(1206), n.MergeRect = i(1207), n.MergeXY = i(1208), n.Offset = i(1209), n.OffsetPoint = i(1210), n.Overlaps = i(1211), n.Perimeter = i(122), n.PerimeterPoint = i(1212), n.Random = i(169), n.RandomOutside = i(1213), n.SameDimensions = i(1214), n.Scale = i(1215), n.Union = i(426), t.exports = n;
}, function (t, e) { t.exports = function (t, e) { return !(e.width * e.height > t.width * t.height) && (e.x > t.x && e.x < t.right && e.right > t.x && e.right < t.right && e.y > t.y && e.y < t.bottom && e.bottom > t.y && e.bottom < t.bottom); }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(4); t.exports = function (t, e) { return void 0 === e && (e = new n()), e.x = (t.x1 + t.x2 + t.x3) / 3, e.y = (t.y1 + t.y2 + t.y3) / 3, e; };
}, function (t, e) { t.exports = function (t, e, i) { return t.x1 += e, t.y1 += i, t.x2 += e, t.y2 += i, t.x3 += e, t.y3 += i, t; }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(4); function s(t, e, i, n) { const s = t - i; const r = e - n; const o = s * s + r * r; return Math.sqrt(o); }t.exports = function (t, e) { void 0 === e && (e = new n()); const i = t.x1; const r = t.y1; const o = t.x2; const a = t.y2; const h = t.x3; const l = t.y3; const u = s(h, l, o, a); const c = s(i, r, h, l); const d = s(o, a, i, r); const f = u + c + d; return e.x = (i * u + o * c + h * d) / f, e.y = (r * u + a * c + l * d) / f, e; };
}, function (t, e) {
  t.exports = function (t, e, i) {
    return {
      gameObject: t, enabled: !0, alwaysEnabled: !1, draggable: !1, dropZone: !1, cursor: !1, target: null, camera: null, hitArea: e, hitAreaCallback: i, hitAreaDebug: null, customHitArea: !1, localX: 0, localY: 0, dragState: 0, dragStartX: 0, dragStartY: 0, dragStartXGlobal: 0, dragStartYGlobal: 0, dragX: 0, dragY: 0,
    };
  };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = new (i(0))({
    initialize(t, e) { this.pad = t, this.events = t.events, this.index = e, this.value = 0, this.threshold = 0.1; }, update(t) { this.value = t; }, getValue() { return Math.abs(this.value) < this.threshold ? 0 : this.value; }, destroy() { this.pad = null, this.events = null; },
  }); t.exports = n;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(232); const r = new n({ initialize(t, e) { this.pad = t, this.events = t.manager, this.index = e, this.value = 0, this.threshold = 1, this.pressed = !1; }, update(t) { this.value = t; const e = this.pad; const i = this.index; t >= this.threshold ? this.pressed || (this.pressed = !0, this.events.emit(s.BUTTON_DOWN, e, this, t), this.pad.emit(s.GAMEPAD_BUTTON_DOWN, i, t, this)) : this.pressed && (this.pressed = !1, this.events.emit(s.BUTTON_UP, e, this, t), this.pad.emit(s.GAMEPAD_BUTTON_UP, i, t, this)); }, destroy() { this.pad = null, this.events = null; } }); t.exports = r;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(482); const s = i(483); const r = i(0); const o = i(10); const a = i(3); const h = new r({
    Extends: o, initialize(t, e) { o.call(this), this.manager = t, this.pad = e, this.id = e.id, this.index = e.index; for (var i = [], r = 0; r < e.buttons.length; r++)i.push(new s(this, r)); this.buttons = i; const h = []; for (r = 0; r < e.axes.length; r++)h.push(new n(this, r)); this.axes = h, this.vibration = e.vibrationActuator; const l = { value: 0, pressed: !1 }; this._LCLeft = i[14] ? i[14] : l, this._LCRight = i[15] ? i[15] : l, this._LCTop = i[12] ? i[12] : l, this._LCBottom = i[13] ? i[13] : l, this._RCLeft = i[2] ? i[2] : l, this._RCRight = i[1] ? i[1] : l, this._RCTop = i[3] ? i[3] : l, this._RCBottom = i[0] ? i[0] : l, this._FBLeftTop = i[4] ? i[4] : l, this._FBLeftBottom = i[6] ? i[6] : l, this._FBRightTop = i[5] ? i[5] : l, this._FBRightBottom = i[7] ? i[7] : l; const u = { value: 0 }; this._HAxisLeft = h[0] ? h[0] : u, this._VAxisLeft = h[1] ? h[1] : u, this._HAxisRight = h[2] ? h[2] : u, this._VAxisRight = h[3] ? h[3] : u, this.leftStick = new a(), this.rightStick = new a(); }, getAxisTotal() { return this.axes.length; }, getAxisValue(t) { return this.axes[t].getValue(); }, setAxisThreshold(t) { for (let e = 0; e < this.axes.length; e++) this.axes[e].threshold = t; }, getButtonTotal() { return this.buttons.length; }, getButtonValue(t) { return this.buttons[t].value; }, isButtonDown(t) { return this.buttons[t].pressed; }, update(t) { let e; const i = this.buttons; const n = t.buttons; let s = i.length; for (e = 0; e < s; e++)i[e].update(n[e].value); const r = this.axes; const o = t.axes; for (s = r.length, e = 0; e < s; e++)r[e].update(o[e]); s >= 2 && (this.leftStick.set(r[0].getValue(), r[1].getValue()), s >= 4 && this.rightStick.set(r[2].getValue(), r[3].getValue())); }, destroy() { let t; for (this.removeAllListeners(), this.manager = null, this.pad = null, t = 0; t < this.buttons.length; t++) this.buttons[t].destroy(); for (t = 0; t < this.axes.length; t++) this.axes[t].destroy(); this.buttons = [], this.axes = []; }, connected: { get() { return this.pad.connected; } }, timestamp: { get() { return this.pad.timestamp; } }, left: { get() { return this._LCLeft.pressed; } }, right: { get() { return this._LCRight.pressed; } }, up: { get() { return this._LCTop.pressed; } }, down: { get() { return this._LCBottom.pressed; } }, A: { get() { return this._RCBottom.pressed; } }, Y: { get() { return this._RCTop.pressed; } }, X: { get() { return this._RCLeft.pressed; } }, B: { get() { return this._RCRight.pressed; } }, L1: { get() { return this._FBLeftTop.value; } }, L2: { get() { return this._FBLeftBottom.value; } }, R1: { get() { return this._FBRightTop.value; } }, R2: { get() { return this._FBRightBottom.value; } },
  }); t.exports = h;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(10); const r = i(147); const o = new n({
    Extends: s, initialize(t, e) { s.call(this), this.plugin = t, this.keyCode = e, this.originalEvent = void 0, this.enabled = !0, this.isDown = !1, this.isUp = !0, this.altKey = !1, this.ctrlKey = !1, this.shiftKey = !1, this.metaKey = !1, this.location = 0, this.timeDown = 0, this.duration = 0, this.timeUp = 0, this.emitOnRepeat = !1, this.repeats = 0, this._justDown = !1, this._justUp = !1, this._tick = -1; }, setEmitOnRepeat(t) { return this.emitOnRepeat = t, this; }, onDown(t) { this.originalEvent = t, this.enabled && (this.altKey = t.altKey, this.ctrlKey = t.ctrlKey, this.shiftKey = t.shiftKey, this.metaKey = t.metaKey, this.location = t.location, this.repeats++, this.isDown ? this.emitOnRepeat && this.emit(r.DOWN, this, t) : (this.isDown = !0, this.isUp = !1, this.timeDown = t.timeStamp, this.duration = 0, this._justDown = !0, this._justUp = !1, this.emit(r.DOWN, this, t))); }, onUp(t) { this.originalEvent = t, this.enabled && (this.isDown = !1, this.isUp = !0, this.timeUp = t.timeStamp, this.duration = this.timeUp - this.timeDown, this.repeats = 0, this._justDown = !1, this._justUp = !0, this._tick = -1, this.emit(r.UP, this, t)); }, reset() { return this.preventDefault = !0, this.enabled = !0, this.isDown = !1, this.isUp = !0, this.altKey = !1, this.ctrlKey = !1, this.shiftKey = !1, this.metaKey = !1, this.timeDown = 0, this.duration = 0, this.timeUp = 0, this.repeats = 0, this._justDown = !1, this._justUp = !1, this._tick = -1, this; }, getDuration() { return this.isDown ? this.plugin.game.loop.time - this.timeDown : 0; }, destroy() { this.removeAllListeners(), this.originalEvent = null, this.plugin = null; },
  }); t.exports = o;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(147); const r = i(2); const o = i(1255); const a = i(1257); const h = new n({ initialize(t, e, i) { if (void 0 === i && (i = {}), e.length < 2) return !1; this.manager = t, this.enabled = !0, this.keyCodes = []; for (let n = 0; n < e.length; n++) { const h = e[n]; typeof h === 'string' ? this.keyCodes.push(h.toUpperCase().charCodeAt(0)) : typeof h === 'number' ? this.keyCodes.push(h) : h.hasOwnProperty('keyCode') && this.keyCodes.push(h.keyCode); } this.current = this.keyCodes[0], this.index = 0, this.size = this.keyCodes.length, this.timeLastMatched = 0, this.matched = !1, this.timeMatched = 0, this.resetOnWrongKey = r(i, 'resetOnWrongKey', !0), this.maxKeyDelay = r(i, 'maxKeyDelay', 0), this.resetOnMatch = r(i, 'resetOnMatch', !1), this.deleteOnMatch = r(i, 'deleteOnMatch', !1); const l = this; this.onKeyDown = function (t) { !l.matched && l.enabled && (o(t, l) && (l.manager.emit(s.COMBO_MATCH, l, t), l.resetOnMatch ? a(l) : l.deleteOnMatch && l.destroy())); }, this.manager.on(s.ANY_KEY_DOWN, this.onKeyDown); }, progress: { get() { return this.index / this.size; } }, destroy() { this.enabled = !1, this.keyCodes = [], this.manager.off(s.ANY_KEY_DOWN, this.onKeyDown), this.manager = null; } }); t.exports = h;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(233); t.exports = function (t, e) { const i = n(e, t.xhrSettings); const s = new XMLHttpRequest(); if (s.open('GET', t.src, i.async, i.user, i.password), s.responseType = t.xhrSettings.responseType, s.timeout = i.timeout, i.headers) for (const r in i.headers)s.setRequestHeader(r, i.headers[r]); return i.header && i.headerValue && s.setRequestHeader(i.header, i.headerValue), i.requestedWith && s.setRequestHeader('X-Requested-With', i.requestedWith), i.overrideMimeType && s.overrideMimeType(i.overrideMimeType), i.withCredentials && (s.withCredentials = !0), s.onload = t.onLoad.bind(t, s), s.onerror = t.onError.bind(t, s), s.onprogress = t.onProgress.bind(t), s.send(), s; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(18); const r = i(25); const o = i(9); const a = i(2); const h = i(489); const l = i(8); const u = new n({
    Extends: r,
    initialize(t, e, i, n, s) {
      if (l(e)) { const o = e; e = a(o, 'key'), n = a(o, 'xhrSettings'), s = a(o, 'context', s); } const h = {
        type: 'audio', cache: t.cacheManager.audio, extension: i.type, responseType: 'arraybuffer', key: e, url: i.url, xhrSettings: n, config: { context: s },
      }; r.call(this, t, h);
    },
    onProcess() { this.state = s.FILE_PROCESSING; const t = this; this.config.context.decodeAudioData(this.xhrLoader.response, ((e) => { t.data = e, t.onProcessComplete(); }), (function (e) { console.error(`Error decoding audio: ${this.key} - `, e ? e.message : null), t.onProcessError(); })), this.config.context = null; },
  }); u.create = function (t, e, i, n, s) { const r = t.systems.game; const o = r.config.audio; const c = r.device.audio; l(e) && (i = a(e, 'url', []), n = a(e, 'config', {})); const d = u.getAudioURL(r, i); return d ? !c.webAudio || o && o.disableWebAudio ? new h(t, e, d, n) : new u(t, e, d, s, r.sound.context) : null; }, u.getAudioURL = function (t, e) { Array.isArray(e) || (e = [e]); for (let i = 0; i < e.length; i++) { const n = a(e[i], 'url', e[i]); if (n.indexOf('blob:') === 0 || n.indexOf('data:') === 0) return { url: n, type: '' }; let s = n.match(/\.([a-zA-Z0-9]+)($|\?)/); if (s = a(e[i], 'type', s ? s[1] : '').toLowerCase(), t.device.audio[s]) return { url: n, type: s }; } return null; }, o.register('audio', (function (t, e, i, n) { let s; const r = this.systems.game; const o = r.config.audio; const a = r.device.audio; if (o && o.noAudio || !a.webAudio && !a.audioData) return this; if (Array.isArray(t)) for (let h = 0; h < t.length; h++)(s = u.create(this, t[h])) && this.addFile(s); else (s = u.create(this, t, e, i, n)) && this.addFile(s); return this; })), t.exports = u;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(90); const r = i(25); const o = i(2); const a = i(148); const h = i(8); const l = new n({
    Extends: r,
    initialize(t, e, i, n) {
      if (h(e)) { const s = e; e = o(s, 'key'), n = o(s, 'config', n); } const a = {
        type: 'audio', cache: t.cacheManager.audio, extension: i.type, key: e, url: i.url, config: n,
      }; r.call(this, t, a), this.locked = 'ontouchstart' in window, this.loaded = !1, this.filesLoaded = 0, this.filesTotal = 0;
    },
    onLoad() { this.loaded || (this.loaded = !0, this.loader.nextFile(this, !0)); },
    onError() { for (let t = 0; t < this.data.length; t++) { const e = this.data[t]; e.oncanplaythrough = null, e.onerror = null; } this.loader.nextFile(this, !1); },
    onProgress(t) { const e = t.target; e.oncanplaythrough = null, e.onerror = null, this.filesLoaded++, this.percentComplete = Math.min(this.filesLoaded / this.filesTotal, 1), this.loader.emit(s.FILE_PROGRESS, this, this.percentComplete), this.filesLoaded === this.filesTotal && this.onLoad(); },
    load() { this.data = []; const t = this.config && this.config.instances || 1; this.filesTotal = t, this.filesLoaded = 0, this.percentComplete = 0; for (var e = 0; e < t; e++) { var i = new Audio(); i.dataset || (i.dataset = {}), i.dataset.name = this.key + (`0${e}`).slice(-2), i.dataset.used = 'false', this.locked ? i.dataset.locked = 'true' : (i.dataset.locked = 'false', i.preload = 'auto', i.oncanplaythrough = this.onProgress.bind(this), i.onerror = this.onError.bind(this)), this.data.push(i); } for (e = 0; e < this.data.length; e++)(i = this.data[e]).src = a(this, this.loader.baseURL), this.locked || i.load(); this.locked && setTimeout(this.onLoad.bind(this)); },
  }); t.exports = l;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(18); const r = i(25); const o = i(9); const a = i(2); const h = i(8); const l = new n({
    Extends: r,
    initialize(t, e, i, n) {
      let s = 'js'; if (h(e)) { const o = e; e = a(o, 'key'), i = a(o, 'url'), n = a(o, 'xhrSettings'), s = a(o, 'extension', s); } const l = {
        type: 'script', cache: !1, extension: s, responseType: 'text', key: e, url: i, xhrSettings: n,
      }; r.call(this, t, l);
    },
    onProcess() { this.state = s.FILE_PROCESSING, this.data = document.createElement('script'), this.data.language = 'javascript', this.data.type = 'text/javascript', this.data.defer = !1, this.data.text = this.xhrLoader.responseText, document.head.appendChild(this.data), this.onProcessComplete(); },
  }); o.register('script', (function (t, e, i) { if (Array.isArray(t)) for (let n = 0; n < t.length; n++) this.addFile(new l(this, t[n])); else this.addFile(new l(this, t, e, i)); return this; })), t.exports = l;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(18); const r = i(25); const o = i(9); const a = i(2); const h = i(8); const l = new n({
    Extends: r,
    initialize(t, e, i, n) {
      let s = 'txt'; if (h(e)) { const o = e; e = a(o, 'key'), i = a(o, 'url'), n = a(o, 'xhrSettings'), s = a(o, 'extension', s); } const l = {
        type: 'text', cache: t.cacheManager.text, extension: s, responseType: 'text', key: e, url: i, xhrSettings: n,
      }; r.call(this, t, l);
    },
    onProcess() { this.state = s.FILE_PROCESSING, this.data = this.xhrLoader.responseText, this.onProcessComplete(); },
  }); o.register('text', (function (t, e, i) { if (Array.isArray(t)) for (let n = 0; n < t.length; n++) this.addFile(new l(this, t[n])); else this.addFile(new l(this, t, e, i)); return this; })), t.exports = l;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(493); const s = i(150); const r = i(0); const o = i(59); const a = i(494); const h = i(495); const l = new r({
    initialize(t) { this.world = t, this.scene = t.scene, this.sys = t.scene.sys; }, collider(t, e, i, n, s) { return this.world.addCollider(t, e, i, n, s); }, overlap(t, e, i, n, s) { return this.world.addOverlap(t, e, i, n, s); }, existing(t, e) { const i = e ? o.STATIC_BODY : o.DYNAMIC_BODY; return this.world.enableBody(t, i), t; }, staticImage(t, e, i, s) { const r = new n(this.scene, t, e, i, s); return this.sys.displayList.add(r), this.world.enableBody(r, o.STATIC_BODY), r; }, image(t, e, i, s) { const r = new n(this.scene, t, e, i, s); return this.sys.displayList.add(r), this.world.enableBody(r, o.DYNAMIC_BODY), r; }, staticSprite(t, e, i, n) { const r = new s(this.scene, t, e, i, n); return this.sys.displayList.add(r), this.sys.updateList.add(r), this.world.enableBody(r, o.STATIC_BODY), r; }, sprite(t, e, i, n) { const r = new s(this.scene, t, e, i, n); return this.sys.displayList.add(r), this.sys.updateList.add(r), this.world.enableBody(r, o.DYNAMIC_BODY), r; }, staticGroup(t, e) { return this.sys.updateList.add(new h(this.world, this.world.scene, t, e)); }, group(t, e) { return this.sys.updateList.add(new a(this.world, this.world.scene, t, e)); }, destroy() { this.world = null, this.scene = null, this.sys = null; },
  }); t.exports = l;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(235); const r = i(112); const o = new n({ Extends: r, Mixins: [s.Acceleration, s.Angular, s.Bounce, s.Debug, s.Drag, s.Enable, s.Friction, s.Gravity, s.Immovable, s.Mass, s.Size, s.Velocity], initialize(t, e, i, n, s) { r.call(this, t, e, i, n, s), this.body = null; } }); t.exports = o;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(150); const s = i(0); const r = i(59); const o = i(2); const a = i(110); const h = i(8); const l = new s({
    Extends: a,
    initialize(t, e, i, s) {
      if (i || s) if (h(i))s = i, i = null, s.internalCreateCallback = this.createCallbackHandler, s.internalRemoveCallback = this.removeCallbackHandler; else if (Array.isArray(i) && h(i[0])) { s = i[0]; const l = this; i.forEach(((t) => { t.internalCreateCallback = l.createCallbackHandler, t.internalRemoveCallback = l.removeCallbackHandler; })); } else s = { internalCreateCallback: this.createCallbackHandler, internalRemoveCallback: this.removeCallbackHandler }; else s = { internalCreateCallback: this.createCallbackHandler, internalRemoveCallback: this.removeCallbackHandler }; this.world = t, s.classType = o(s, 'classType', n), this.physicsType = r.DYNAMIC_BODY, this.defaults = {
        setCollideWorldBounds: o(s, 'collideWorldBounds', !1), setBoundsRectangle: o(s, 'customBoundsRectangle', null), setAccelerationX: o(s, 'accelerationX', 0), setAccelerationY: o(s, 'accelerationY', 0), setAllowDrag: o(s, 'allowDrag', !0), setAllowGravity: o(s, 'allowGravity', !0), setAllowRotation: o(s, 'allowRotation', !0), setBounceX: o(s, 'bounceX', 0), setBounceY: o(s, 'bounceY', 0), setDragX: o(s, 'dragX', 0), setDragY: o(s, 'dragY', 0), setEnable: o(s, 'enable', !0), setGravityX: o(s, 'gravityX', 0), setGravityY: o(s, 'gravityY', 0), setFrictionX: o(s, 'frictionX', 0), setFrictionY: o(s, 'frictionY', 0), setVelocityX: o(s, 'velocityX', 0), setVelocityY: o(s, 'velocityY', 0), setAngularVelocity: o(s, 'angularVelocity', 0), setAngularAcceleration: o(s, 'angularAcceleration', 0), setAngularDrag: o(s, 'angularDrag', 0), setMass: o(s, 'mass', 1), setImmovable: o(s, 'immovable', !1),
      }, Array.isArray(i) && (s = null), a.call(this, e, i, s), this.type = 'PhysicsGroup';
    },
    createCallbackHandler(t) { t.body || this.world.enableBody(t, r.DYNAMIC_BODY); const e = t.body; for (const i in this.defaults)e[i](this.defaults[i]); },
    removeCallbackHandler(t) { t.body && this.world.disableBody(t); },
    setVelocity(t, e, i) { void 0 === i && (i = 0); for (let n = this.getChildren(), s = 0; s < n.length; s++)n[s].body.velocity.set(t + s * i, e + s * i); return this; },
    setVelocityX(t, e) { void 0 === e && (e = 0); for (let i = this.getChildren(), n = 0; n < i.length; n++)i[n].body.velocity.x = t + n * e; return this; },
    setVelocityY(t, e) { void 0 === e && (e = 0); for (let i = this.getChildren(), n = 0; n < i.length; n++)i[n].body.velocity.y = t + n * e; return this; },
  }); t.exports = l;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(150); const s = i(0); const r = i(59); const o = i(2); const a = i(110); const h = i(8); const l = new s({
    Extends: a,
    initialize(t, e, i, s) {
      i || s ? h(i) ? (s = i, i = null, s.internalCreateCallback = this.createCallbackHandler, s.internalRemoveCallback = this.removeCallbackHandler, s.createMultipleCallback = this.createMultipleCallbackHandler, s.classType = o(s, 'classType', n)) : Array.isArray(i) && h(i[0]) && (s = i, i = null, s.forEach((function (t) { t.internalCreateCallback = this.createCallbackHandler, t.internalRemoveCallback = this.removeCallbackHandler, t.createMultipleCallback = this.createMultipleCallbackHandler, t.classType = o(t, 'classType', n); }))) : s = {
        internalCreateCallback: this.createCallbackHandler, internalRemoveCallback: this.removeCallbackHandler, createMultipleCallback: this.createMultipleCallbackHandler, classType: n,
      }, this.world = t, this.physicsType = r.STATIC_BODY, a.call(this, e, i, s), this.type = 'StaticPhysicsGroup';
    },
    createCallbackHandler(t) { t.body || this.world.enableBody(t, r.STATIC_BODY); },
    removeCallbackHandler(t) { t.body && this.world.disableBody(t); },
    createMultipleCallbackHandler() { this.refresh(); },
    refresh() { for (let t = this.children.entries, e = 0; e < t.length; e++)t[e].body.reset(); return this; },
  }); t.exports = l;
}, function (t, e) {
  t.exports = function (t, e, i, n, s, r, o) {
    void 0 === r && (r = !0), void 0 === o && (o = !1); let a = []; let h = []; const l = t.treeMinMax; if (l.minX = e, l.minY = i, l.maxX = e + n, l.maxY = i + s, o && (h = t.staticTree.search(l)), r && t.useTree)a = t.tree.search(l); else if (r) {
      const u = t.bodies; const c = {
        position: { x: e, y: i }, left: e, top: i, right: e + n, bottom: i + s, isCircle: !1,
      }; const d = t.intersects; u.iterate(((t) => { d(t, c) && a.push(t); }));
    } return h.concat(a);
  };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(498); const s = i(20); const r = i(0); const o = i(499); const a = i(59); const h = i(56); const l = i(10); const u = i(236); const c = i(98); const d = i(345); const f = i(346); const p = i(500); const g = i(501); const v = i(6); const m = i(203); const y = i(1315); const x = i(12); const T = i(502); const w = i(1316); const b = i(1321); const E = i(1322); const S = i(111); const A = i(504); const _ = i(503); const C = i(33); const M = i(3); const P = i(64); const O = new r({
    Extends: l,
    initialize(t, e) {
      l.call(this), this.scene = t, this.bodies = new S(), this.staticBodies = new S(), this.pendingDestroy = new S(), this.colliders = new m(), this.gravity = new M(v(e, 'gravity.x', 0), v(e, 'gravity.y', 0)), this.bounds = new x(v(e, 'x', 0), v(e, 'y', 0), v(e, 'width', t.sys.scale.width), v(e, 'height', t.sys.scale.height)), this.checkCollision = {
        up: v(e, 'checkCollision.up', !0), down: v(e, 'checkCollision.down', !0), left: v(e, 'checkCollision.left', !0), right: v(e, 'checkCollision.right', !0),
      }, this.fps = v(e, 'fps', 60), this.fixedStep = !0, this._elapsed = 0, this._frameTime = 1 / this.fps, this._frameTimeMS = 1e3 * this._frameTime, this.stepsLastFrame = 0, this.timeScale = v(e, 'timeScale', 1), this.OVERLAP_BIAS = v(e, 'overlapBias', 4), this.TILE_BIAS = v(e, 'tileBias', 16), this.forceX = v(e, 'forceX', !1), this.isPaused = v(e, 'isPaused', !1), this._total = 0, this.drawDebug = v(e, 'debug', !1), this.debugGraphic, this.defaults = {
        debugShowBody: v(e, 'debugShowBody', !0), debugShowStaticBody: v(e, 'debugShowStaticBody', !0), debugShowVelocity: v(e, 'debugShowVelocity', !0), bodyDebugColor: v(e, 'debugBodyColor', 16711935), staticBodyDebugColor: v(e, 'debugStaticBodyColor', 255), velocityDebugColor: v(e, 'debugVelocityColor', 65280),
      }, this.maxEntries = v(e, 'maxEntries', 16), this.useTree = v(e, 'useTree', !0), this.tree = new T(this.maxEntries), this.staticTree = new T(this.maxEntries), this.treeMinMax = {
        minX: 0, minY: 0, maxX: 0, maxY: 0,
      }, this._tempMatrix = new C(), this._tempMatrix2 = new C(), this.drawDebug && this.createDebugGraphic();
    },
    enable(t, e) { void 0 === e && (e = a.DYNAMIC_BODY), Array.isArray(t) || (t = [t]); for (let i = 0; i < t.length; i++) { const n = t[i]; if (n.isParent) for (let s = n.getChildren(), r = 0; r < s.length; r++) { const o = s[r]; o.isParent ? this.enable(o, e) : this.enableBody(o, e); } else this.enableBody(n, e); } },
    enableBody(t, e) { return void 0 === e && (e = a.DYNAMIC_BODY), t.body || (e === a.DYNAMIC_BODY ? t.body = new n(this, t) : e === a.STATIC_BODY && (t.body = new A(this, t))), this.add(t.body), t; },
    add(t) { return t.physicsType === a.DYNAMIC_BODY ? this.bodies.set(t) : t.physicsType === a.STATIC_BODY && (this.staticBodies.set(t), this.staticTree.insert(t)), t.enable = !0, t; },
    disable(t) { Array.isArray(t) || (t = [t]); for (let e = 0; e < t.length; e++) { const i = t[e]; if (i.isParent) for (let n = i.getChildren(), s = 0; s < n.length; s++) { const r = n[s]; r.isParent ? this.disable(r) : this.disableBody(r.body); } else this.disableBody(i.body); } },
    disableBody(t) { this.remove(t), t.enable = !1; },
    remove(t) { t.physicsType === a.DYNAMIC_BODY ? (this.tree.remove(t), this.bodies.delete(t)) : t.physicsType === a.STATIC_BODY && (this.staticBodies.delete(t), this.staticTree.remove(t)); },
    createDebugGraphic() { const t = this.scene.sys.add.graphics({ x: 0, y: 0 }); return t.setDepth(Number.MAX_VALUE), this.debugGraphic = t, this.drawDebug = !0, t; },
    setBounds(t, e, i, n, s, r, o, a) { return this.bounds.setTo(t, e, i, n), void 0 !== s && this.setBoundsCollision(s, r, o, a), this; },
    setBoundsCollision(t, e, i, n) { return void 0 === t && (t = !0), void 0 === e && (e = !0), void 0 === i && (i = !0), void 0 === n && (n = !0), this.checkCollision.left = t, this.checkCollision.right = e, this.checkCollision.up = i, this.checkCollision.down = n, this; },
    pause() { return this.isPaused = !0, this.emit(u.PAUSE), this; },
    resume() { return this.isPaused = !1, this.emit(u.RESUME), this; },
    addCollider(t, e, i, n, s) { void 0 === i && (i = null), void 0 === n && (n = null), void 0 === s && (s = i); const r = new o(this, !1, t, e, i, n, s); return this.colliders.add(r), r; },
    addOverlap(t, e, i, n, s) { void 0 === i && (i = null), void 0 === n && (n = null), void 0 === s && (s = i); const r = new o(this, !0, t, e, i, n, s); return this.colliders.add(r), r; },
    removeCollider(t) { return this.colliders.remove(t), this; },
    setFPS(t) { return this.fps = t, this._frameTime = 1 / this.fps, this._frameTimeMS = 1e3 * this._frameTime, this; },
    update(t, e) { if (!this.isPaused && this.bodies.size !== 0) { let i; let n; let s = this._frameTime; const r = this._frameTimeMS * this.timeScale; this._elapsed += e; const o = this.bodies.entries; let a = this._elapsed >= r; for (this.fixedStep || (s = 0.001 * e, a = !0, this._elapsed = 0), i = 0; i < o.length; i++)(n = o[i]).enable && n.preUpdate(a, s); if (a) { this._elapsed -= r, this.stepsLastFrame = 1, this.useTree && (this.tree.clear(), this.tree.load(o)); const h = this.colliders.update(); for (i = 0; i < h.length; i++) { const l = h[i]; l.active && l.update(); } this.emit(u.WORLD_STEP); } for (;this._elapsed >= r;) this._elapsed -= r, this.step(s); } },
    step(t) { let e; let i; const n = this.bodies.entries; const s = n.length; for (e = 0; e < s; e++)(i = n[e]).enable && i.update(t); this.useTree && (this.tree.clear(), this.tree.load(n)); const r = this.colliders.update(); for (e = 0; e < r.length; e++) { const o = r[e]; o.active && o.update(); } this.emit(u.WORLD_STEP), this.stepsLastFrame++; },
    postUpdate() { let t; let e; let i = this.bodies.entries; let n = i.length; const s = this.bodies; const r = this.staticBodies; if (this.stepsLastFrame) for (this.stepsLastFrame = 0, t = 0; t < n; t++)(e = i[t]).enable && e.postUpdate(); if (this.drawDebug) { const o = this.debugGraphic; for (o.clear(), t = 0; t < n; t++)(e = i[t]).willDrawDebug() && e.drawDebug(o); for (n = (i = r.entries).length, t = 0; t < n; t++)(e = i[t]).willDrawDebug() && e.drawDebug(o); } const h = this.pendingDestroy; if (h.size > 0) { const l = this.tree; const u = this.staticTree; for (n = (i = h.entries).length, t = 0; t < n; t++)(e = i[t]).physicsType === a.DYNAMIC_BODY ? (l.remove(e), s.delete(e)) : e.physicsType === a.STATIC_BODY && (u.remove(e), r.delete(e)), e.world = void 0, e.gameObject = void 0; h.clear(); } },
    updateMotion(t, e) { t.allowRotation && this.computeAngularVelocity(t, e), this.computeVelocity(t, e); },
    computeAngularVelocity(t, e) { let i = t.angularVelocity; const n = t.angularAcceleration; let r = t.angularDrag; const o = t.maxAngular; n ? i += n * e : t.allowDrag && r && (d(i - (r *= e), 0, 0.1) ? i -= r : f(i + r, 0, 0.1) ? i += r : i = 0); const a = (i = s(i, -o, o)) - t.angularVelocity; t.angularVelocity += a, t.rotation += t.angularVelocity * e; },
    computeVelocity(t, e) { let i = t.velocity.x; const n = t.acceleration.x; let r = t.drag.x; const o = t.maxVelocity.x; let a = t.velocity.y; const h = t.acceleration.y; let l = t.drag.y; const u = t.maxVelocity.y; let p = t.speed; const g = t.maxSpeed; const v = t.allowDrag; const m = t.useDamping; t.allowGravity && (i += (this.gravity.x + t.gravity.x) * e, a += (this.gravity.y + t.gravity.y) * e), n ? i += n * e : v && r && (m ? (i *= r, p = Math.sqrt(i * i + a * a), c(p, 0, 0.001) && (i = 0)) : d(i - (r *= e), 0, 0.01) ? i -= r : f(i + r, 0, 0.01) ? i += r : i = 0), h ? a += h * e : v && l && (m ? (a *= l, p = Math.sqrt(i * i + a * a), c(p, 0, 0.001) && (a = 0)) : d(a - (l *= e), 0, 0.01) ? a -= l : f(a + l, 0, 0.01) ? a += l : a = 0), i = s(i, -o, o), a = s(a, -u, u), t.velocity.set(i, a), g > -1 && p > g && (t.velocity.normalize().scale(g), p = g), t.speed = p; },
    separate(t, e, i, n, s) {
      if (!t.enable || !e.enable || t.checkCollision.none || e.checkCollision.none || !this.intersects(t, e)) return !1; if (i && !1 === i.call(n, t.gameObject, e.gameObject)) return !1; if (t.isCircle && e.isCircle) return this.separateCircle(t, e, s); if (t.isCircle !== e.isCircle) {
        const r = t.isCircle ? e : t; const o = t.isCircle ? t : e; const a = {
          x: r.x, y: r.y, right: r.right, bottom: r.bottom,
        }; const h = o.center; if ((h.y < a.y || h.y > a.bottom) && (h.x < a.x || h.x > a.right)) return this.separateCircle(t, e, s);
      } let l = !1; let c = !1; this.forceX || Math.abs(this.gravity.y + t.gravity.y) < Math.abs(this.gravity.x + t.gravity.x) ? (l = b(t, e, s, this.OVERLAP_BIAS), this.intersects(t, e) && (c = E(t, e, s, this.OVERLAP_BIAS))) : (c = E(t, e, s, this.OVERLAP_BIAS), this.intersects(t, e) && (l = b(t, e, s, this.OVERLAP_BIAS))); const d = l || c; return d && (s ? (t.onOverlap || e.onOverlap) && this.emit(u.OVERLAP, t.gameObject, e.gameObject, t, e) : (t.onCollide || e.onCollide) && this.emit(u.COLLIDE, t.gameObject, e.gameObject, t, e)), d;
    },
    separateCircle(t, e, i, n) {
      p(t, e, !1, n), g(t, e, !1, n); let s = 0; if (t.isCircle !== e.isCircle) {
        const r = {
          x: e.isCircle ? t.position.x : e.position.x, y: e.isCircle ? t.position.y : e.position.y, right: e.isCircle ? t.right : e.right, bottom: e.isCircle ? t.bottom : e.bottom,
        }; const o = { x: t.isCircle ? t.center.x : e.center.x, y: t.isCircle ? t.center.y : e.center.y, radius: t.isCircle ? t.halfWidth : e.halfWidth }; o.y < r.y ? o.x < r.x ? s = h(o.x, o.y, r.x, r.y) - o.radius : o.x > r.right && (s = h(o.x, o.y, r.right, r.y) - o.radius) : o.y > r.bottom && (o.x < r.x ? s = h(o.x, o.y, r.x, r.bottom) - o.radius : o.x > r.right && (s = h(o.x, o.y, r.right, r.bottom) - o.radius)), s *= -1;
      } else s = t.halfWidth + e.halfWidth - h(t.center.x, t.center.y, e.center.x, e.center.y); if (i || s === 0 || t.immovable && e.immovable || t.customSeparateX || e.customSeparateX) return s !== 0 && (t.onOverlap || e.onOverlap) && this.emit(u.OVERLAP, t.gameObject, e.gameObject, t, e), s !== 0; const a = t.center.x - e.center.x; const l = t.center.y - e.center.y; const c = Math.sqrt(Math.pow(a, 2) + Math.pow(l, 2)); const d = (e.center.x - t.center.x) / c || 0; const f = (e.center.y - t.center.y) / c || 0; const v = 2 * (t.velocity.x * d + t.velocity.y * f - e.velocity.x * d - e.velocity.y * f) / (t.mass + e.mass); t.immovable || (t.velocity.x = t.velocity.x - v * t.mass * d, t.velocity.y = t.velocity.y - v * t.mass * f), e.immovable || (e.velocity.x = e.velocity.x + v * e.mass * d, e.velocity.y = e.velocity.y + v * e.mass * f); const m = e.velocity.x - t.velocity.x; const y = e.velocity.y - t.velocity.y; const x = Math.atan2(y, m); const T = this._frameTime; return t.immovable || e.immovable || (s /= 2), t.immovable || (t.x += t.velocity.x * T - s * Math.cos(x), t.y += t.velocity.y * T - s * Math.sin(x)), e.immovable || (e.x += e.velocity.x * T + s * Math.cos(x), e.y += e.velocity.y * T + s * Math.sin(x)), t.velocity.x *= t.bounce.x, t.velocity.y *= t.bounce.y, e.velocity.x *= e.bounce.x, e.velocity.y *= e.bounce.y, (t.onCollide || e.onCollide) && this.emit(u.COLLIDE, t.gameObject, e.gameObject, t, e), !0;
    },
    intersects(t, e) { return t !== e && (t.isCircle || e.isCircle ? t.isCircle ? e.isCircle ? h(t.center.x, t.center.y, e.center.x, e.center.y) <= t.halfWidth + e.halfWidth : this.circleBodyIntersects(t, e) : this.circleBodyIntersects(e, t) : !(t.right <= e.position.x || t.bottom <= e.position.y || t.position.x >= e.right || t.position.y >= e.bottom)); },
    circleBodyIntersects(t, e) { const i = s(t.center.x, e.left, e.right); const n = s(t.center.y, e.top, e.bottom); return (t.center.x - i) * (t.center.x - i) + (t.center.y - n) * (t.center.y - n) <= t.halfWidth * t.halfWidth; },
    overlap(t, e, i, n, s) { return void 0 === i && (i = null), void 0 === n && (n = null), void 0 === s && (s = i), this.collideObjects(t, e, i, n, s, !0); },
    collide(t, e, i, n, s) { return void 0 === i && (i = null), void 0 === n && (n = null), void 0 === s && (s = i), this.collideObjects(t, e, i, n, s, !1); },
    collideObjects(t, e, i, n, s, r) { let o; let a; t.isParent && void 0 === t.physicsType && (t = t.children.entries), e && e.isParent && void 0 === e.physicsType && (e = e.children.entries); const h = Array.isArray(t); const l = Array.isArray(e); if (this._total = 0, h || l) if (!h && l) for (o = 0; o < e.length; o++) this.collideHandler(t, e[o], i, n, s, r); else if (h && !l) if (e) for (o = 0; o < t.length; o++) this.collideHandler(t[o], e, i, n, s, r); else for (o = 0; o < t.length; o++) { const u = t[o]; for (a = o + 1; a < t.length; a++)o !== a && this.collideHandler(u, t[a], i, n, s, r); } else for (o = 0; o < t.length; o++) for (a = 0; a < e.length; a++) this.collideHandler(t[o], e[a], i, n, s, r); else this.collideHandler(t, e, i, n, s, r); return this._total > 0; },
    collideHandler(t, e, i, n, s, r) { if (void 0 === e && t.isParent) return this.collideGroupVsGroup(t, t, i, n, s, r); if (!t || !e) return !1; if (t.body) { if (e.body) return this.collideSpriteVsSprite(t, e, i, n, s, r); if (e.isParent) return this.collideSpriteVsGroup(t, e, i, n, s, r); if (e.isTilemap) return this.collideSpriteVsTilemapLayer(t, e, i, n, s, r); } else if (t.isParent) { if (e.body) return this.collideSpriteVsGroup(e, t, i, n, s, r); if (e.isParent) return this.collideGroupVsGroup(t, e, i, n, s, r); if (e.isTilemap) return this.collideGroupVsTilemapLayer(t, e, i, n, s, r); } else if (t.isTilemap) { if (e.body) return this.collideSpriteVsTilemapLayer(e, t, i, n, s, r); if (e.isParent) return this.collideGroupVsTilemapLayer(e, t, i, n, s, r); } },
    collideSpriteVsSprite(t, e, i, n, s, r) { return !(!t.body || !e.body) && (this.separate(t.body, e.body, n, s, r) && (i && i.call(s, t, e), this._total++), !0); },
    collideSpriteVsGroup(t, e, i, n, s, r) { let o; let h; let l; const u = t.body; if (e.length !== 0 && u && u.enable && !u.checkCollision.none) if (this.useTree) { const c = this.treeMinMax; c.minX = u.left, c.minY = u.top, c.maxX = u.right, c.maxY = u.bottom; const d = e.physicsType === a.DYNAMIC_BODY ? this.tree.search(c) : this.staticTree.search(c); for (h = d.length, o = 0; o < h; o++)u !== (l = d[o]) && l.enable && !l.checkCollision.none && e.contains(l.gameObject) && this.separate(u, l, n, s, r) && (i && i.call(s, u.gameObject, l.gameObject), this._total++); } else { const f = e.getChildren(); const p = e.children.entries.indexOf(t); for (h = f.length, o = 0; o < h; o++)(l = f[o].body) && o !== p && l.enable && this.separate(u, l, n, s, r) && (i && i.call(s, u.gameObject, l.gameObject), this._total++); } },
    collideGroupVsTilemapLayer(t, e, i, n, s, r) { const o = t.getChildren(); if (o.length === 0) return !1; for (var a = !1, h = 0; h < o.length; h++)o[h].body && this.collideSpriteVsTilemapLayer(o[h], e, i, n, s, r) && (a = !0); return a; },
    collideTiles(t, e, i, n, s) { return !(!t.body.enable || e.length === 0) && this.collideSpriteVsTilesHandler(t, e, i, n, s, !1, !1); },
    overlapTiles(t, e, i, n, s) { return !(!t.body.enable || e.length === 0) && this.collideSpriteVsTilesHandler(t, e, i, n, s, !0, !1); },
    collideSpriteVsTilemapLayer(t, e, i, n, s, r) { const o = t.body; if (!o.enable || o.checkCollision.none) return !1; let a = o.position.x; const h = o.position.y; let l = o.width; let u = o.height; const c = e.layer; if (c.tileWidth > c.baseTileWidth) { const d = (c.tileWidth - c.baseTileWidth) * e.scaleX; a -= d, l += d; }c.tileHeight > c.baseTileHeight && (u += (c.tileHeight - c.baseTileHeight) * e.scaleY); const f = e.getTilesWithinWorldXY(a, h, l, u); return f.length !== 0 && this.collideSpriteVsTilesHandler(t, f, i, n, s, r, !0); },
    collideSpriteVsTilesHandler(t, e, i, n, s, r, o) {
      for (var a, h, l = t.body, c = {
          left: 0, right: 0, top: 0, bottom: 0,
        }, d = !1, f = 0; f < e.length; f++)h = (a = e[f]).tilemapLayer, c.left = h.tileToWorldX(a.x), c.top = h.tileToWorldY(a.y), a.baseHeight !== a.height && (c.top -= (a.height - a.baseHeight) * h.scaleY), c.right = c.left + a.width * h.scaleX, c.bottom = c.top + a.height * h.scaleY, _(c, l) && (!n || n.call(s, t, a)) && y(a, t) && (r || w(f, l, a, c, h, this.TILE_BIAS, o)) && (this._total++, d = !0, i && i.call(s, t, a), r && l.onOverlap ? this.emit(u.TILE_OVERLAP, t, a, l) : l.onCollide && this.emit(u.TILE_COLLIDE, t, a, l)); return d;
    },
    collideGroupVsGroup(t, e, i, n, s, r) { if (t.length !== 0 && e.length !== 0) for (let o = t.getChildren(), a = 0; a < o.length; a++) this.collideSpriteVsGroup(o[a], e, i, n, s, r); },
    wrap(t, e) { t.body ? this.wrapObject(t, e) : t.getChildren ? this.wrapArray(t.getChildren(), e) : Array.isArray(t) ? this.wrapArray(t, e) : this.wrapObject(t, e); },
    wrapArray(t, e) { for (let i = 0; i < t.length; i++) this.wrapObject(t[i], e); },
    wrapObject(t, e) { void 0 === e && (e = 0), t.x = P(t.x, this.bounds.left - e, this.bounds.right + e), t.y = P(t.y, this.bounds.top - e, this.bounds.bottom + e); },
    shutdown() { this.tree.clear(), this.staticTree.clear(), this.bodies.clear(), this.staticBodies.clear(), this.colliders.destroy(), this.removeAllListeners(); },
    destroy() { this.shutdown(), this.scene = null; },
  }); t.exports = O;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Benjamin D. Richards <benjamindrichards@gmail.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(59); const r = i(236); const o = i(188); const a = i(12); const h = i(55); const l = i(3); const u = new n({
    initialize(t, e) {
      const i = e.displayWidth ? e.displayWidth : 64; const n = e.displayHeight ? e.displayHeight : 64; this.world = t, this.gameObject = e, this.transform = {
        x: e.x, y: e.y, rotation: e.angle, scaleX: e.scaleX, scaleY: e.scaleY, displayOriginX: e.displayOriginX, displayOriginY: e.displayOriginY,
      }, this.debugShowBody = t.defaults.debugShowBody, this.debugShowVelocity = t.defaults.debugShowVelocity, this.debugBodyColor = t.defaults.bodyDebugColor, this.enable = !0, this.isCircle = !1, this.radius = 0, this.offset = new l(), this.position = new l(e.x - e.scaleX * e.displayOriginX, e.y - e.scaleY * e.displayOriginY), this.prev = new l(e.x, e.y), this.prevFrame = new l(e.x, e.y), this.allowRotation = !0, this.rotation = e.angle, this.preRotation = e.angle, this.width = i, this.height = n, this.sourceWidth = i, this.sourceHeight = n, e.frame && (this.sourceWidth = e.frame.realWidth, this.sourceHeight = e.frame.realHeight), this.halfWidth = Math.abs(i / 2), this.halfHeight = Math.abs(n / 2), this.center = new l(this.position.x + this.halfWidth, this.position.y + this.halfHeight), this.velocity = new l(), this.newVelocity = new l(), this.deltaMax = new l(), this.acceleration = new l(), this.allowDrag = !0, this.drag = new l(), this.allowGravity = !0, this.gravity = new l(), this.bounce = new l(), this.worldBounce = null, this.customBoundsRectangle = t.bounds, this.onWorldBounds = !1, this.onCollide = !1, this.onOverlap = !1, this.maxVelocity = new l(1e4, 1e4), this.maxSpeed = -1, this.friction = new l(1, 0), this.useDamping = !1, this.angularVelocity = 0, this.angularAcceleration = 0, this.angularDrag = 0, this.maxAngular = 1e3, this.mass = 1, this.angle = 0, this.speed = 0, this.facing = s.FACING_NONE, this.immovable = !1, this.moves = !0, this.customSeparateX = !1, this.customSeparateY = !1, this.overlapX = 0, this.overlapY = 0, this.overlapR = 0, this.embedded = !1, this.collideWorldBounds = !1, this.checkCollision = {
        none: !1, up: !0, down: !0, left: !0, right: !0,
      }, this.touching = {
        none: !0, up: !1, down: !1, left: !1, right: !1,
      }, this.wasTouching = {
        none: !0, up: !1, down: !1, left: !1, right: !1,
      }, this.blocked = {
        none: !0, up: !1, down: !1, left: !1, right: !1,
      }, this.syncBounds = !1, this.physicsType = s.DYNAMIC_BODY, this._sx = e.scaleX, this._sy = e.scaleY, this._dx = 0, this._dy = 0, this._tx = 0, this._ty = 0, this._bounds = new a();
    },
    updateBounds() { const t = this.gameObject; const e = this.transform; if (t.parentContainer) { const i = t.getWorldTransformMatrix(this.world._tempMatrix, this.world._tempMatrix2); e.x = i.tx, e.y = i.ty, e.rotation = o(i.rotation), e.scaleX = i.scaleX, e.scaleY = i.scaleY, e.displayOriginX = t.displayOriginX, e.displayOriginY = t.displayOriginY; } else e.x = t.x, e.y = t.y, e.rotation = t.angle, e.scaleX = t.scaleX, e.scaleY = t.scaleY, e.displayOriginX = t.displayOriginX, e.displayOriginY = t.displayOriginY; let n = !1; if (this.syncBounds) { const s = t.getBounds(this._bounds); this.width = s.width, this.height = s.height, n = !0; } else { const r = Math.abs(e.scaleX); const a = Math.abs(e.scaleY); this._sx === r && this._sy === a || (this.width = this.sourceWidth * r, this.height = this.sourceHeight * a, this._sx = r, this._sy = a, n = !0); }n && (this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), this.updateCenter()); },
    updateCenter() { this.center.set(this.position.x + this.halfWidth, this.position.y + this.halfHeight); },
    resetFlags() { const t = this.wasTouching; const e = this.touching; const i = this.blocked; t.none = e.none, t.up = e.up, t.down = e.down, t.left = e.left, t.right = e.right, e.none = !0, e.up = !1, e.down = !1, e.left = !1, e.right = !1, i.none = !0, i.up = !1, i.down = !1, i.left = !1, i.right = !1, this.overlapR = 0, this.overlapX = 0, this.overlapY = 0, this.embedded = !1; },
    preUpdate(t, e) { t && this.resetFlags(), this.updateBounds(); const i = this.transform; this.position.x = i.x + i.scaleX * (this.offset.x - i.displayOriginX), this.position.y = i.y + i.scaleY * (this.offset.y - i.displayOriginY), this.updateCenter(), this.rotation = i.rotation, this.preRotation = this.rotation, this.moves && (this.prev.x = this.position.x, this.prev.y = this.position.y, this.prevFrame.x = this.position.x, this.prevFrame.y = this.position.y), t && this.update(e); },
    update(t) { if (this.prev.x = this.position.x, this.prev.y = this.position.y, this.moves) { this.world.updateMotion(this, t); const e = this.velocity.x; const i = this.velocity.y; this.newVelocity.set(e * t, i * t), this.position.add(this.newVelocity), this.updateCenter(), this.angle = Math.atan2(i, e), this.speed = Math.sqrt(e * e + i * i), this.collideWorldBounds && this.checkWorldBounds() && this.onWorldBounds && this.world.emit(r.WORLD_BOUNDS, this, this.blocked.up, this.blocked.down, this.blocked.left, this.blocked.right); } this._dx = this.position.x - this.prev.x, this._dy = this.position.y - this.prev.y; },
    postUpdate() { let t = this.position.x - this.prevFrame.x; let e = this.position.y - this.prevFrame.y; if (this.moves) { const i = this.deltaMax.x; const n = this.deltaMax.y; i !== 0 && t !== 0 && (t < 0 && t < -i ? t = -i : t > 0 && t > i && (t = i)), n !== 0 && e !== 0 && (e < 0 && e < -n ? e = -n : e > 0 && e > n && (e = n)), this.gameObject.x += t, this.gameObject.y += e; }t < 0 ? this.facing = s.FACING_LEFT : t > 0 && (this.facing = s.FACING_RIGHT), e < 0 ? this.facing = s.FACING_UP : e > 0 && (this.facing = s.FACING_DOWN), this.allowRotation && (this.gameObject.angle += this.deltaZ()), this._tx = t, this._ty = e; },
    setBoundsRectangle(t) { return this.customBoundsRectangle = t || this.world.bounds, this; },
    checkWorldBounds() { const t = this.position; const e = this.customBoundsRectangle; const i = this.world.checkCollision; const n = this.worldBounce ? -this.worldBounce.x : -this.bounce.x; const s = this.worldBounce ? -this.worldBounce.y : -this.bounce.y; let r = !1; return t.x < e.x && i.left ? (t.x = e.x, this.velocity.x *= n, this.blocked.left = !0, r = !0) : this.right > e.right && i.right && (t.x = e.right - this.width, this.velocity.x *= n, this.blocked.right = !0, r = !0), t.y < e.y && i.up ? (t.y = e.y, this.velocity.y *= s, this.blocked.up = !0, r = !0) : this.bottom > e.bottom && i.down && (t.y = e.bottom - this.height, this.velocity.y *= s, this.blocked.down = !0, r = !0), r && (this.blocked.none = !1), r; },
    setOffset(t, e) { return void 0 === e && (e = t), this.offset.set(t, e), this.updateCenter(), this; },
    setSize(t, e, i) { void 0 === i && (i = !0); const n = this.gameObject; if (!t && n.frame && (t = n.frame.realWidth), !e && n.frame && (e = n.frame.realHeight), this.sourceWidth = t, this.sourceHeight = e, this.width = this.sourceWidth * this._sx, this.height = this.sourceHeight * this._sy, this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), this.updateCenter(), i && n.getCenter) { const s = (n.width - t) / 2; const r = (n.height - e) / 2; this.offset.set(s, r); } return this.isCircle = !1, this.radius = 0, this; },
    setCircle(t, e, i) { return void 0 === e && (e = this.offset.x), void 0 === i && (i = this.offset.y), t > 0 ? (this.isCircle = !0, this.radius = t, this.sourceWidth = 2 * t, this.sourceHeight = 2 * t, this.width = this.sourceWidth * this._sx, this.height = this.sourceHeight * this._sy, this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), this.offset.set(e, i), this.updateCenter()) : this.isCircle = !1, this; },
    reset(t, e) { this.stop(); const i = this.gameObject; i.setPosition(t, e), i.getTopLeft ? i.getTopLeft(this.position) : this.position.set(t, e), this.prev.copy(this.position), this.prevFrame.copy(this.position), this.rotation = i.angle, this.preRotation = i.angle, this.updateBounds(), this.updateCenter(); },
    stop() { return this.velocity.set(0), this.acceleration.set(0), this.speed = 0, this.angularVelocity = 0, this.angularAcceleration = 0, this; },
    getBounds(t) { return t.x = this.x, t.y = this.y, t.right = this.right, t.bottom = this.bottom, t; },
    hitTest(t, e) { return this.isCircle ? this.radius > 0 && t >= this.left && t <= this.right && e >= this.top && e <= this.bottom && (this.center.x - t) * (this.center.x - t) + (this.center.y - e) * (this.center.y - e) <= this.radius * this.radius : h(this, t, e); },
    onFloor() { return this.blocked.down; },
    onCeiling() { return this.blocked.up; },
    onWall() { return this.blocked.left || this.blocked.right; },
    deltaAbsX() { return this._dx > 0 ? this._dx : -this._dx; },
    deltaAbsY() { return this._dy > 0 ? this._dy : -this._dy; },
    deltaX() { return this._dx; },
    deltaY() { return this._dy; },
    deltaXFinal() { return this._tx; },
    deltaYFinal() { return this._ty; },
    deltaZ() { return this.rotation - this.preRotation; },
    destroy() { this.enable = !1, this.world && this.world.pendingDestroy.set(this); },
    drawDebug(t) { const e = this.position; const i = e.x + this.halfWidth; const n = e.y + this.halfHeight; this.debugShowBody && (t.lineStyle(t.defaultStrokeWidth, this.debugBodyColor), this.isCircle ? t.strokeCircle(i, n, this.width / 2) : (this.checkCollision.up && t.lineBetween(e.x, e.y, e.x + this.width, e.y), this.checkCollision.right && t.lineBetween(e.x + this.width, e.y, e.x + this.width, e.y + this.height), this.checkCollision.down && t.lineBetween(e.x, e.y + this.height, e.x + this.width, e.y + this.height), this.checkCollision.left && t.lineBetween(e.x, e.y, e.x, e.y + this.height))), this.debugShowVelocity && (t.lineStyle(t.defaultStrokeWidth, this.world.defaults.velocityDebugColor, 1), t.lineBetween(i, n, i + this.velocity.x / 2, n + this.velocity.y / 2)); },
    willDrawDebug() { return this.debugShowBody || this.debugShowVelocity; },
    setCollideWorldBounds(t, e, i) { void 0 === t && (t = !0), this.collideWorldBounds = t; const n = void 0 !== e; const s = void 0 !== i; return (n || s) && (this.worldBounce || (this.worldBounce = new l()), n && (this.worldBounce.x = e), s && (this.worldBounce.y = i)), this; },
    setVelocity(t, e) { return this.velocity.set(t, e), t = this.velocity.x, e = this.velocity.y, this.speed = Math.sqrt(t * t + e * e), this; },
    setVelocityX(t) { this.velocity.x = t; const e = t; const i = this.velocity.y; return this.speed = Math.sqrt(e * e + i * i), this; },
    setVelocityY(t) { this.velocity.y = t; const e = this.velocity.x; const i = t; return this.speed = Math.sqrt(e * e + i * i), this; },
    setMaxVelocity(t, e) { return this.maxVelocity.set(t, e), this; },
    setMaxSpeed(t) { return this.maxSpeed = t, this; },
    setBounce(t, e) { return this.bounce.set(t, e), this; },
    setBounceX(t) { return this.bounce.x = t, this; },
    setBounceY(t) { return this.bounce.y = t, this; },
    setAcceleration(t, e) { return this.acceleration.set(t, e), this; },
    setAccelerationX(t) { return this.acceleration.x = t, this; },
    setAccelerationY(t) { return this.acceleration.y = t, this; },
    setAllowDrag(t) { return void 0 === t && (t = !0), this.allowDrag = t, this; },
    setAllowGravity(t) { return void 0 === t && (t = !0), this.allowGravity = t, this; },
    setAllowRotation(t) { return void 0 === t && (t = !0), this.allowRotation = t, this; },
    setDrag(t, e) { return this.drag.set(t, e), this; },
    setDragX(t) { return this.drag.x = t, this; },
    setDragY(t) { return this.drag.y = t, this; },
    setGravity(t, e) { return this.gravity.set(t, e), this; },
    setGravityX(t) { return this.gravity.x = t, this; },
    setGravityY(t) { return this.gravity.y = t, this; },
    setFriction(t, e) { return this.friction.set(t, e), this; },
    setFrictionX(t) { return this.friction.x = t, this; },
    setFrictionY(t) { return this.friction.y = t, this; },
    setAngularVelocity(t) { return this.angularVelocity = t, this; },
    setAngularAcceleration(t) { return this.angularAcceleration = t, this; },
    setAngularDrag(t) { return this.angularDrag = t, this; },
    setMass(t) { return this.mass = t, this; },
    setImmovable(t) { return void 0 === t && (t = !0), this.immovable = t, this; },
    setEnable(t) { return void 0 === t && (t = !0), this.enable = t, this; },
    x: { get() { return this.position.x; }, set(t) { this.position.x = t; } },
    y: { get() { return this.position.y; }, set(t) { this.position.y = t; } },
    left: { get() { return this.position.x; } },
    right: { get() { return this.position.x + this.width; } },
    top: { get() { return this.position.y; } },
    bottom: { get() { return this.position.y + this.height; } },
  }); t.exports = u;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = new (i(0))({
    initialize(t, e, i, n, s, r, o) { this.world = t, this.name = '', this.active = !0, this.overlapOnly = e, this.object1 = i, this.object2 = n, this.collideCallback = s, this.processCallback = r, this.callbackContext = o; }, setName(t) { return this.name = t, this; }, update() { this.world.collideObjects(this.object1, this.object2, this.collideCallback, this.processCallback, this.callbackContext, this.overlapOnly); }, destroy() { this.world.removeCollider(this), this.active = !1, this.world = null, this.object1 = null, this.object2 = null, this.collideCallback = null, this.processCallback = null, this.callbackContext = null; },
  }); t.exports = n;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(59); t.exports = function (t, e, i, s) { let r = 0; const o = t.deltaAbsX() + e.deltaAbsX() + s; return t._dx === 0 && e._dx === 0 ? (t.embedded = !0, e.embedded = !0) : t._dx > e._dx ? (r = t.right - e.x) > o && !i || !1 === t.checkCollision.right || !1 === e.checkCollision.left ? r = 0 : (t.touching.none = !1, t.touching.right = !0, e.touching.none = !1, e.touching.left = !0, e.physicsType === n.STATIC_BODY && (t.blocked.none = !1, t.blocked.right = !0), t.physicsType === n.STATIC_BODY && (e.blocked.none = !1, e.blocked.left = !0)) : t._dx < e._dx && (-(r = t.x - e.width - e.x) > o && !i || !1 === t.checkCollision.left || !1 === e.checkCollision.right ? r = 0 : (t.touching.none = !1, t.touching.left = !0, e.touching.none = !1, e.touching.right = !0, e.physicsType === n.STATIC_BODY && (t.blocked.none = !1, t.blocked.left = !0), t.physicsType === n.STATIC_BODY && (e.blocked.none = !1, e.blocked.right = !0))), t.overlapX = r, e.overlapX = r, r; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(59); t.exports = function (t, e, i, s) { let r = 0; const o = t.deltaAbsY() + e.deltaAbsY() + s; return t._dy === 0 && e._dy === 0 ? (t.embedded = !0, e.embedded = !0) : t._dy > e._dy ? (r = t.bottom - e.y) > o && !i || !1 === t.checkCollision.down || !1 === e.checkCollision.up ? r = 0 : (t.touching.none = !1, t.touching.down = !0, e.touching.none = !1, e.touching.up = !0, e.physicsType === n.STATIC_BODY && (t.blocked.none = !1, t.blocked.down = !0), t.physicsType === n.STATIC_BODY && (e.blocked.none = !1, e.blocked.up = !0)) : t._dy < e._dy && (-(r = t.y - e.bottom) > o && !i || !1 === t.checkCollision.up || !1 === e.checkCollision.down ? r = 0 : (t.touching.none = !1, t.touching.up = !0, e.touching.none = !1, e.touching.down = !0, e.physicsType === n.STATIC_BODY && (t.blocked.none = !1, t.blocked.up = !0), t.physicsType === n.STATIC_BODY && (e.blocked.none = !1, e.blocked.down = !0))), t.overlapY = r, e.overlapY = r, r; };
}, function (t, e, i) {
/**
 * @author       Vladimir Agafonkin
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(424); function s(t) { if (!(this instanceof s)) return new s(t, ['.left', '.top', '.right', '.bottom']); this._maxEntries = Math.max(4, t || 9), this._minEntries = Math.max(2, Math.ceil(0.4 * this._maxEntries)), this.clear(); } function r(t, e, i) { if (!i) return e.indexOf(t); for (let n = 0; n < e.length; n++) if (i(t, e[n])) return n; return -1; } function o(t, e) { a(t, 0, t.children.length, e, t); } function a(t, e, i, n, s) { s || (s = g(null)), s.minX = 1 / 0, s.minY = 1 / 0, s.maxX = -1 / 0, s.maxY = -1 / 0; for (var r, o = e; o < i; o++)r = t.children[o], h(s, t.leaf ? n(r) : r); return s; } function h(t, e) { return t.minX = Math.min(t.minX, e.minX), t.minY = Math.min(t.minY, e.minY), t.maxX = Math.max(t.maxX, e.maxX), t.maxY = Math.max(t.maxY, e.maxY), t; } function l(t, e) { return t.minX - e.minX; } function u(t, e) { return t.minY - e.minY; } function c(t) { return (t.maxX - t.minX) * (t.maxY - t.minY); } function d(t) { return t.maxX - t.minX + (t.maxY - t.minY); } function f(t, e) { return t.minX <= e.minX && t.minY <= e.minY && e.maxX <= t.maxX && e.maxY <= t.maxY; } function p(t, e) { return e.minX <= t.maxX && e.minY <= t.maxY && e.maxX >= t.minX && e.maxY >= t.minY; } function g(t) {
    return {
      children: t, height: 1, leaf: !0, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0,
    };
  } function v(t, e, i, s, r) { for (var o, a = [e, i]; a.length;)(i = a.pop()) - (e = a.pop()) <= s || (o = e + Math.ceil((i - e) / s / 2) * s, n(t, o, e, i, r), a.push(e, o, o, i)); }s.prototype = {
    all() { return this._all(this.data, []); },
    search(t) { let e = this.data; const i = []; const n = this.toBBox; if (!p(t, e)) return i; for (var s, r, o, a, h = []; e;) { for (s = 0, r = e.children.length; s < r; s++)o = e.children[s], p(t, a = e.leaf ? n(o) : o) && (e.leaf ? i.push(o) : f(t, a) ? this._all(o, i) : h.push(o)); e = h.pop(); } return i; },
    collides(t) { let e = this.data; const i = this.toBBox; if (!p(t, e)) return !1; for (var n, s, r, o, a = []; e;) { for (n = 0, s = e.children.length; n < s; n++) if (r = e.children[n], p(t, o = e.leaf ? i(r) : r)) { if (e.leaf || f(t, o)) return !0; a.push(r); }e = a.pop(); } return !1; },
    load(t) { if (!t || !t.length) return this; if (t.length < this._minEntries) { for (let e = 0, i = t.length; e < i; e++) this.insert(t[e]); return this; } let n = this._build(t.slice(), 0, t.length - 1, 0); if (this.data.children.length) if (this.data.height === n.height) this._splitRoot(this.data, n); else { if (this.data.height < n.height) { const s = this.data; this.data = n, n = s; } this._insert(n, this.data.height - n.height - 1, !0); } else this.data = n; return this; },
    insert(t) { return t && this._insert(t, this.data.height - 1), this; },
    clear() { return this.data = g([]), this; },
    remove(t, e) { if (!t) return this; for (var i, n, s, o, a = this.data, h = this.toBBox(t), l = [], u = []; a || l.length;) { if (a || (a = l.pop(), n = l[l.length - 1], i = u.pop(), o = !0), a.leaf && (s = r(t, a.children, e)) !== -1) return a.children.splice(s, 1), l.push(a), this._condense(l), this; o || a.leaf || !f(a, h) ? n ? (i++, a = n.children[i], o = !1) : a = null : (l.push(a), u.push(i), i = 0, n = a, a = a.children[0]); } return this; },
    toBBox(t) { return t; },
    compareMinX: l,
    compareMinY: u,
    toJSON() { return this.data; },
    fromJSON(t) { return this.data = t, this; },
    _all(t, e) { for (let i = []; t;)t.leaf ? e.push.apply(e, t.children) : i.push.apply(i, t.children), t = i.pop(); return e; },
    _build(t, e, i, n) { let s; const r = i - e + 1; let a = this._maxEntries; if (r <= a) return o(s = g(t.slice(e, i + 1)), this.toBBox), s; n || (n = Math.ceil(Math.log(r) / Math.log(a)), a = Math.ceil(r / Math.pow(a, n - 1))), (s = g([])).leaf = !1, s.height = n; let h; let l; let u; let c; const d = Math.ceil(r / a); const f = d * Math.ceil(Math.sqrt(a)); for (v(t, e, i, f, this.compareMinX), h = e; h <= i; h += f) for (v(t, h, u = Math.min(h + f - 1, i), d, this.compareMinY), l = h; l <= u; l += d)c = Math.min(l + d - 1, u), s.children.push(this._build(t, l, c, n - 1)); return o(s, this.toBBox), s; },
    _chooseSubtree(t, e, i, n) { for (var s, r, o, a, h, l, u, d, f, p; n.push(e), !e.leaf && n.length - 1 !== i;) { for (u = d = 1 / 0, s = 0, r = e.children.length; s < r; s++)h = c(o = e.children[s]), f = t, p = o, (l = (Math.max(p.maxX, f.maxX) - Math.min(p.minX, f.minX)) * (Math.max(p.maxY, f.maxY) - Math.min(p.minY, f.minY)) - h) < d ? (d = l, u = h < u ? h : u, a = o) : l === d && h < u && (u = h, a = o); e = a || e.children[0]; } return e; },
    _insert(t, e, i) { const n = this.toBBox; const s = i ? t : n(t); const r = []; const o = this._chooseSubtree(s, this.data, e, r); for (o.children.push(t), h(o, s); e >= 0 && r[e].children.length > this._maxEntries;) this._split(r, e), e--; this._adjustParentBBoxes(s, r, e); },
    _split(t, e) { const i = t[e]; const n = i.children.length; const s = this._minEntries; this._chooseSplitAxis(i, s, n); const r = this._chooseSplitIndex(i, s, n); const a = g(i.children.splice(r, i.children.length - r)); a.height = i.height, a.leaf = i.leaf, o(i, this.toBBox), o(a, this.toBBox), e ? t[e - 1].children.push(a) : this._splitRoot(i, a); },
    _splitRoot(t, e) { this.data = g([t, e]), this.data.height = t.height + 1, this.data.leaf = !1, o(this.data, this.toBBox); },
    _chooseSplitIndex(t, e, i) { let n; let s; let r; let o; let h; let l; let u; let d; let f; let p; let g; let v; let m; let y; for (l = u = 1 / 0, n = e; n <= i - e; n++)s = a(t, 0, n, this.toBBox), r = a(t, n, i, this.toBBox), f = s, p = r, g = void 0, v = void 0, m = void 0, y = void 0, g = Math.max(f.minX, p.minX), v = Math.max(f.minY, p.minY), m = Math.min(f.maxX, p.maxX), y = Math.min(f.maxY, p.maxY), o = Math.max(0, m - g) * Math.max(0, y - v), h = c(s) + c(r), o < l ? (l = o, d = n, u = h < u ? h : u) : o === l && h < u && (u = h, d = n); return d; },
    _chooseSplitAxis(t, e, i) { const n = t.leaf ? this.compareMinX : l; const s = t.leaf ? this.compareMinY : u; this._allDistMargin(t, e, i, n) < this._allDistMargin(t, e, i, s) && t.children.sort(n); },
    _allDistMargin(t, e, i, n) { t.children.sort(n); let s; let r; const o = this.toBBox; const l = a(t, 0, e, o); const u = a(t, i - e, i, o); let c = d(l) + d(u); for (s = e; s < i - e; s++)r = t.children[s], h(l, t.leaf ? o(r) : r), c += d(l); for (s = i - e - 1; s >= e; s--)r = t.children[s], h(u, t.leaf ? o(r) : r), c += d(u); return c; },
    _adjustParentBBoxes(t, e, i) { for (let n = i; n >= 0; n--)h(e[n], t); },
    _condense(t) { for (var e, i = t.length - 1; i >= 0; i--)t[i].children.length === 0 ? i > 0 ? (e = t[i - 1].children).splice(e.indexOf(t[i]), 1) : this.clear() : o(t[i], this.toBBox); },
    compareMinX(t, e) { return t.left - e.left; },
    compareMinY(t, e) { return t.top - e.top; },
    toBBox(t) {
      return {
        minX: t.left, minY: t.top, maxX: t.right, maxY: t.bottom,
      };
    },
  }, t.exports = s;
}, function (t, e) { t.exports = function (t, e) { return !(e.right <= t.left || e.bottom <= t.top || e.position.x >= t.right || e.position.y >= t.bottom); }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(61); const s = i(0); const r = i(59); const o = i(55); const a = i(3); const h = new s({
    initialize(t, e) {
      const i = e.displayWidth ? e.displayWidth : 64; const n = e.displayHeight ? e.displayHeight : 64; this.world = t, this.gameObject = e, this.debugShowBody = t.defaults.debugShowStaticBody, this.debugBodyColor = t.defaults.staticBodyDebugColor, this.enable = !0, this.isCircle = !1, this.radius = 0, this.offset = new a(), this.position = new a(e.x - e.displayOriginX, e.y - e.displayOriginY), this.width = i, this.height = n, this.halfWidth = Math.abs(this.width / 2), this.halfHeight = Math.abs(this.height / 2), this.center = new a(this.position.x + this.halfWidth, this.position.y + this.halfHeight), this.velocity = a.ZERO, this.allowGravity = !1, this.gravity = a.ZERO, this.bounce = a.ZERO, this.onWorldBounds = !1, this.onCollide = !1, this.onOverlap = !1, this.mass = 1, this.immovable = !0, this.customSeparateX = !1, this.customSeparateY = !1, this.overlapX = 0, this.overlapY = 0, this.overlapR = 0, this.embedded = !1, this.collideWorldBounds = !1, this.checkCollision = {
        none: !1, up: !0, down: !0, left: !0, right: !0,
      }, this.touching = {
        none: !0, up: !1, down: !1, left: !1, right: !1,
      }, this.wasTouching = {
        none: !0, up: !1, down: !1, left: !1, right: !1,
      }, this.blocked = {
        none: !0, up: !1, down: !1, left: !1, right: !1,
      }, this.physicsType = r.STATIC_BODY, this._dx = 0, this._dy = 0;
    },
    setGameObject(t, e) { return t && t !== this.gameObject && (this.gameObject.body = null, t.body = this, this.gameObject = t), e && this.updateFromGameObject(), this; },
    updateFromGameObject() { this.world.staticTree.remove(this); const t = this.gameObject; return t.getTopLeft(this.position), this.width = t.displayWidth, this.height = t.displayHeight, this.halfWidth = Math.abs(this.width / 2), this.halfHeight = Math.abs(this.height / 2), this.center.set(this.position.x + this.halfWidth, this.position.y + this.halfHeight), this.world.staticTree.insert(this), this; },
    setOffset(t, e) { return void 0 === e && (e = t), this.world.staticTree.remove(this), this.position.x -= this.offset.x, this.position.y -= this.offset.y, this.offset.set(t, e), this.position.x += this.offset.x, this.position.y += this.offset.y, this.updateCenter(), this.world.staticTree.insert(this), this; },
    setSize(t, e, i) { void 0 === i && (i = !0); const n = this.gameObject; if (!t && n.frame && (t = n.frame.realWidth), !e && n.frame && (e = n.frame.realHeight), this.world.staticTree.remove(this), this.width = t, this.height = e, this.halfWidth = Math.floor(t / 2), this.halfHeight = Math.floor(e / 2), i && n.getCenter) { const s = n.displayWidth / 2; const r = n.displayHeight / 2; this.position.x -= this.offset.x, this.position.y -= this.offset.y, this.offset.set(s - this.halfWidth, r - this.halfHeight), this.position.x += this.offset.x, this.position.y += this.offset.y; } return this.updateCenter(), this.isCircle = !1, this.radius = 0, this.world.staticTree.insert(this), this; },
    setCircle(t, e, i) { return void 0 === e && (e = this.offset.x), void 0 === i && (i = this.offset.y), t > 0 ? (this.world.staticTree.remove(this), this.isCircle = !0, this.radius = t, this.width = 2 * t, this.height = 2 * t, this.halfWidth = Math.floor(this.width / 2), this.halfHeight = Math.floor(this.height / 2), this.offset.set(e, i), this.updateCenter(), this.world.staticTree.insert(this)) : this.isCircle = !1, this; },
    updateCenter() { this.center.set(this.position.x + this.halfWidth, this.position.y + this.halfHeight); },
    reset(t, e) { const i = this.gameObject; void 0 === t && (t = i.x), void 0 === e && (e = i.y), this.world.staticTree.remove(this), i.setPosition(t, e), i.getTopLeft(this.position), this.updateCenter(), this.world.staticTree.insert(this); },
    stop() { return this; },
    getBounds(t) { return t.x = this.x, t.y = this.y, t.right = this.right, t.bottom = this.bottom, t; },
    hitTest(t, e) { return this.isCircle ? n(this, t, e) : o(this, t, e); },
    postUpdate() {},
    deltaAbsX() { return 0; },
    deltaAbsY() { return 0; },
    deltaX() { return 0; },
    deltaY() { return 0; },
    deltaZ() { return 0; },
    destroy() { this.enable = !1, this.world.pendingDestroy.set(this); },
    drawDebug(t) { const e = this.position; const i = e.x + this.halfWidth; const n = e.y + this.halfHeight; this.debugShowBody && (t.lineStyle(t.defaultStrokeWidth, this.debugBodyColor, 1), this.isCircle ? t.strokeCircle(i, n, this.width / 2) : t.strokeRect(e.x, e.y, this.width, this.height)); },
    willDrawDebug() { return this.debugShowBody; },
    setMass(t) { return t <= 0 && (t = 0.1), this.mass = t, this; },
    x: { get() { return this.position.x; }, set(t) { this.world.staticTree.remove(this), this.position.x = t, this.world.staticTree.insert(this); } },
    y: { get() { return this.position.y; }, set(t) { this.world.staticTree.remove(this), this.position.y = t, this.world.staticTree.insert(this); } },
    left: { get() { return this.position.x; } },
    right: { get() { return this.position.x + this.width; } },
    top: { get() { return this.position.y; } },
    bottom: { get() { return this.position.y + this.height; } },
  }); t.exports = h;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(3); const r = new n({
    initialize() { this.boundsCenter = new s(), this.centerDiff = new s(); }, parseBody(t) { if (!(t = t.hasOwnProperty('body') ? t.body : t).hasOwnProperty('bounds') || !t.hasOwnProperty('centerOfMass')) return !1; const e = this.boundsCenter; const i = this.centerDiff; const n = t.bounds.max.x - t.bounds.min.x; const s = t.bounds.max.y - t.bounds.min.y; const r = n * t.centerOfMass.x; const o = s * t.centerOfMass.y; return e.set(n / 2, s / 2), i.set(r - e.x, o - e.y), !0; }, getTopLeft(t, e, i) { if (void 0 === e && (e = 0), void 0 === i && (i = 0), this.parseBody(t)) { const n = this.boundsCenter; const r = this.centerDiff; return new s(e + n.x + r.x, i + n.y + r.y); } return !1; }, getTopCenter(t, e, i) { if (void 0 === e && (e = 0), void 0 === i && (i = 0), this.parseBody(t)) { const n = this.boundsCenter; const r = this.centerDiff; return new s(e + r.x, i + n.y + r.y); } return !1; }, getTopRight(t, e, i) { if (void 0 === e && (e = 0), void 0 === i && (i = 0), this.parseBody(t)) { const n = this.boundsCenter; const r = this.centerDiff; return new s(e - (n.x - r.x), i + n.y + r.y); } return !1; }, getLeftCenter(t, e, i) { if (void 0 === e && (e = 0), void 0 === i && (i = 0), this.parseBody(t)) { const n = this.boundsCenter; const r = this.centerDiff; return new s(e + n.x + r.x, i + r.y); } return !1; }, getCenter(t, e, i) { if (void 0 === e && (e = 0), void 0 === i && (i = 0), this.parseBody(t)) { const n = this.centerDiff; return new s(e + n.x, i + n.y); } return !1; }, getRightCenter(t, e, i) { if (void 0 === e && (e = 0), void 0 === i && (i = 0), this.parseBody(t)) { const n = this.boundsCenter; const r = this.centerDiff; return new s(e - (n.x - r.x), i + r.y); } return !1; }, getBottomLeft(t, e, i) { if (void 0 === e && (e = 0), void 0 === i && (i = 0), this.parseBody(t)) { const n = this.boundsCenter; const r = this.centerDiff; return new s(e + n.x + r.x, i - (n.y - r.y)); } return !1; }, getBottomCenter(t, e, i) { if (void 0 === e && (e = 0), void 0 === i && (i = 0), this.parseBody(t)) { const n = this.boundsCenter; const r = this.centerDiff; return new s(e + r.x, i - (n.y - r.y)); } return !1; }, getBottomRight(t, e, i) { if (void 0 === e && (e = 0), void 0 === i && (i = 0), this.parseBody(t)) { const n = this.boundsCenter; const r = this.centerDiff; return new s(e - (n.x - r.x), i - (n.y - r.y)); } return !1; },
  }); t.exports = r;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(44); const s = i(0); const r = i(237); const o = i(80); const a = i(238); const h = i(1324); const l = i(508); const u = i(509); const c = i(242); const d = i(239); const f = i(240); const p = i(1353); const g = i(32); const v = new s({
    initialize(t) { this.world = t, this.scene = t.scene, this.sys = t.scene.sys; }, rectangle(t, e, i, s, r) { const o = n.rectangle(t, e, i, s, r); return this.world.add(o), o; }, trapezoid(t, e, i, s, r, o) { const a = n.trapezoid(t, e, i, s, r, o); return this.world.add(a), a; }, circle(t, e, i, s, r) { const o = n.circle(t, e, i, s, r); return this.world.add(o), o; }, polygon(t, e, i, s, r) { const o = n.polygon(t, e, i, s, r); return this.world.add(o), o; }, fromVertices(t, e, i, s, r, o, a) { typeof i === 'string' && (i = g.fromPath(i)); const h = n.fromVertices(t, e, i, s, r, o, a); return this.world.add(h), h; }, fromPhysicsEditor(t, e, i, n, s) { void 0 === s && (s = !0); const r = d.parseBody(t, e, i, n); return s && !this.world.has(r) && this.world.add(r), r; }, fromSVG(t, e, i, s, r, o) { void 0 === s && (s = 1), void 0 === r && (r = {}), void 0 === o && (o = !0); for (var h = i.getElementsByTagName('path'), l = [], u = 0; u < h.length; u++) { const c = a.pathToVertices(h[u], 30); s !== 1 && g.scale(c, s, s), l.push(c); } const d = n.fromVertices(t, e, l, r); return o && this.world.add(d), d; }, fromJSON(t, e, i, n, s) { void 0 === n && (n = {}), void 0 === s && (s = !0); const r = f.parseBody(t, e, i, n); return r && s && this.world.add(r), r; }, imageStack(t, e, i, n, s, o, a, h, u) { void 0 === a && (a = 0), void 0 === h && (h = 0), void 0 === u && (u = {}); const c = this.world; const d = this.sys.displayList; u.addToWorld = !1; const f = r.stack(i, n, s, o, a, h, ((i, n) => { const s = new l(c, i, n, t, e, u); return d.add(s), s.body; })); return c.add(f), f; }, stack(t, e, i, n, s, o, a) { const h = r.stack(t, e, i, n, s, o, a); return this.world.add(h), h; }, pyramid(t, e, i, n, s, o, a) { const h = r.pyramid(t, e, i, n, s, o, a); return this.world.add(h), h; }, chain(t, e, i, n, s, o) { return r.chain(t, e, i, n, s, o); }, mesh(t, e, i, n, s) { return r.mesh(t, e, i, n, s); }, newtonsCradle(t, e, i, n, s) { const o = r.newtonsCradle(t, e, i, n, s); return this.world.add(o), o; }, car(t, e, i, n, s) { const o = r.car(t, e, i, n, s); return this.world.add(o), o; }, softBody(t, e, i, n, s, o, a, h, l, u) { const c = r.softBody(t, e, i, n, s, o, a, h, l, u); return this.world.add(c), c; }, joint(t, e, i, n, s) { return this.constraint(t, e, i, n, s); }, spring(t, e, i, n, s) { return this.constraint(t, e, i, n, s); }, constraint(t, e, i, n, s) { void 0 === n && (n = 1), void 0 === s && (s = {}), s.bodyA = t.type === 'body' ? t : t.body, s.bodyB = e.type === 'body' ? e : e.body, isNaN(i) || (s.length = i), s.stiffness = n; const r = o.create(s); return this.world.add(r), r; }, worldConstraint(t, e, i, n) { void 0 === i && (i = 1), void 0 === n && (n = {}), n.bodyB = t.type === 'body' ? t : t.body, isNaN(e) || (n.length = e), n.stiffness = i; const s = o.create(n); return this.world.add(s), s; }, mouseSpring(t) { return this.pointerConstraint(t); }, pointerConstraint(t) { void 0 === t && (t = {}), t.hasOwnProperty('render') || (t.render = { visible: !1 }); const e = new p(this.scene, this.world, t); return this.world.add(e.constraint), e; }, image(t, e, i, n, s) { const r = new l(this.world, t, e, i, n, s); return this.sys.displayList.add(r), r; }, tileBody(t, e) { return new c(this.world, t, e); }, sprite(t, e, i, n, s) { const r = new u(this.world, t, e, i, n, s); return this.sys.displayList.add(r), this.sys.updateList.add(r), r; }, gameObject(t, e, i) { return h(this.world, t, e, i); }, destroy() { this.world = null, this.scene = null, this.sys = null; },
  }); t.exports = v;
}, function (t, e) {
  function i(t, e, i) { i = i || 0; let n; let s; let r; let o; let a; let h; let l; const u = [0, 0]; return n = t[1][1] - t[0][1], s = t[0][0] - t[1][0], r = n * t[0][0] + s * t[0][1], o = e[1][1] - e[0][1], a = e[0][0] - e[1][0], h = o * e[0][0] + a * e[0][1], b(l = n * a - o * s, 0, i) || (u[0] = (a * r - s * h) / l, u[1] = (n * h - o * r) / l), u; } function n(t, e, i, n) { const s = e[0] - t[0]; const r = e[1] - t[1]; const o = n[0] - i[0]; const a = n[1] - i[1]; if (o * r - a * s == 0) return !1; const h = (s * (i[1] - t[1]) + r * (t[0] - i[0])) / (o * r - a * s); const l = (o * (t[1] - i[1]) + a * (i[0] - t[0])) / (a * s - o * r); return h >= 0 && h <= 1 && l >= 0 && l <= 1; } function s(t, e, i) { return (e[0] - t[0]) * (i[1] - t[1]) - (i[0] - t[0]) * (e[1] - t[1]); } function r(t, e, i) { return s(t, e, i) > 0; } function o(t, e, i) { return s(t, e, i) >= 0; } function a(t, e, i) { return s(t, e, i) < 0; } function h(t, e, i) { return s(t, e, i) <= 0; }
  /**
 * @author       Stefan Hedman <schteppe@gmail.com> (http://steffe.se)
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = {
    decomp(t) { const e = (function t(e) { for (var i = [], n = [], s = [], r = [], o = Number.MAX_VALUE, a = 0; a < e.length; ++a) if (g(e, a)) for (let h = 0; h < e.length; ++h) if (y(e, a, h)) { n = t(T(e, a, h, r)), s = t(T(e, h, a, r)); for (let l = 0; l < s.length; l++)n.push(s[l]); n.length < o && (i = n, o = n.length, i.push([f(e, a), f(e, h)])); } return i; }(t)); return e.length > 0 ? (function t(e, i) { if (i.length === 0) return [e]; if (i instanceof Array && i.length && i[0] instanceof Array && i[0].length === 2 && i[0][0] instanceof Array) { for (var n = [e], s = 0; s < i.length; s++) for (var r = i[s], o = 0; o < n.length; o++) { const a = n[o]; const h = t(a, r); if (h) { n.splice(o, 1), n.push(h[0], h[1]); break; } } return n; }r = i, s = e.indexOf(r[0]), o = e.indexOf(r[1]); return s !== -1 && o !== -1 && [T(e, s, o), T(e, o, s)]; }(t, e)) : [t]; }, quickDecomp: function t(e, i, n, s, l, u, c) { u = u || 100, c = c || 0, l = l || 25, i = void 0 !== i ? i : [], n = n || [], s = s || []; let v = [0, 0]; let m = [0, 0]; let y = [0, 0]; let T = 0; let b = 0; let E = 0; let S = 0; let A = 0; let _ = 0; let C = 0; const M = []; const P = []; const O = e; const R = e; if (R.length < 3) return i; if (++c > u) return console.warn(`quickDecomp: max level (${u}) reached.`), i; for (let L = 0; L < e.length; ++L) if (g(O, L)) { n.push(O[L]), T = b = Number.MAX_VALUE; for (var D = 0; D < e.length; ++D)r(f(O, L - 1), f(O, L), f(O, D)) && h(f(O, L - 1), f(O, L), f(O, D - 1)) && (y = w(f(O, L - 1), f(O, L), f(O, D), f(O, D - 1)), a(f(O, L + 1), f(O, L), y) && (E = d(O[L], y)) < b && (b = E, m = y, _ = D)), r(f(O, L + 1), f(O, L), f(O, D + 1)) && h(f(O, L + 1), f(O, L), f(O, D)) && (y = w(f(O, L + 1), f(O, L), f(O, D), f(O, D + 1)), r(f(O, L - 1), f(O, L), y) && (E = d(O[L], y)) < T && (T = E, v = y, A = D)); if (_ === (A + 1) % e.length)y[0] = (m[0] + v[0]) / 2, y[1] = (m[1] + v[1]) / 2, s.push(y), L < A ? (p(M, O, L, A + 1), M.push(y), P.push(y), _ !== 0 && p(P, O, _, O.length), p(P, O, 0, L + 1)) : (L !== 0 && p(M, O, L, O.length), p(M, O, 0, A + 1), M.push(y), P.push(y), p(P, O, _, L + 1)); else { if (_ > A && (A += e.length), S = Number.MAX_VALUE, A < _) return i; for (D = _; D <= A; ++D)o(f(O, L - 1), f(O, L), f(O, D)) && h(f(O, L + 1), f(O, L), f(O, D)) && (E = d(f(O, L), f(O, D))) < S && x(O, L, D) && (S = E, C = D % e.length); L < C ? (p(M, O, L, C + 1), C !== 0 && p(P, O, C, R.length), p(P, O, 0, L + 1)) : (L !== 0 && p(M, O, L, R.length), p(M, O, 0, C + 1), p(P, O, C, L + 1)); } return M.length < P.length ? (t(M, i, n, s, l, u, c), t(P, i, n, s, l, u, c)) : (t(P, i, n, s, l, u, c), t(M, i, n, s, l, u, c)), i; } return i.push(e), i; }, isSimple(t) { let e; const i = t; for (e = 0; e < i.length - 1; e++) for (let s = 0; s < e - 1; s++) if (n(i[e], i[e + 1], i[s], i[s + 1])) return !1; for (e = 1; e < i.length - 2; e++) if (n(i[0], i[i.length - 1], i[e], i[e + 1])) return !1; return !0; }, removeCollinearPoints(t, e) { for (var i = 0, n = t.length - 1; t.length > 3 && n >= 0; --n)c(f(t, n - 1), f(t, n), f(t, n + 1), e) && (t.splice(n % t.length, 1), i++); return i; }, removeDuplicatePoints(t, e) { for (let i = t.length - 1; i >= 1; --i) for (let n = t[i], s = i - 1; s >= 0; --s)E(n, t[s], e) && t.splice(i, 1); }, makeCCW(t) { for (var e = 0, i = t, n = 1; n < t.length; ++n)(i[n][1] < i[e][1] || i[n][1] === i[e][1] && i[n][0] > i[e][0]) && (e = n); return !r(f(t, e - 1), f(t, e), f(t, e + 1)) && ((function (t) { for (var e = [], i = t.length, n = 0; n !== i; n++)e.push(t.pop()); for (n = 0; n !== i; n++)t[n] = e[n]; }(t)), !0); },
  }; const l = []; const u = []; function c(t, e, i, n) { if (n) { const r = l; const o = u; r[0] = e[0] - t[0], r[1] = e[1] - t[1], o[0] = i[0] - e[0], o[1] = i[1] - e[1]; const a = r[0] * o[0] + r[1] * o[1]; const h = Math.sqrt(r[0] * r[0] + r[1] * r[1]); const c = Math.sqrt(o[0] * o[0] + o[1] * o[1]); return Math.acos(a / (h * c)) < n; } return s(t, e, i) === 0; } function d(t, e) { const i = e[0] - t[0]; const n = e[1] - t[1]; return i * i + n * n; } function f(t, e) { const i = t.length; return t[e < 0 ? e % i + i : e % i]; } function p(t, e, i, n) { for (let s = i; s < n; s++)t.push(e[s]); } function g(t, e) { return a(f(t, e - 1), f(t, e), f(t, e + 1)); } const v = []; const m = []; function y(t, e, n) { let s; let r; const a = v; const l = m; if (o(f(t, e + 1), f(t, e), f(t, n)) && h(f(t, e - 1), f(t, e), f(t, n))) return !1; r = d(f(t, e), f(t, n)); for (let u = 0; u !== t.length; ++u) if ((u + 1) % t.length !== e && u !== e && o(f(t, e), f(t, n), f(t, u + 1)) && h(f(t, e), f(t, n), f(t, u)) && (a[0] = f(t, e), a[1] = f(t, n), l[0] = f(t, u), l[1] = f(t, u + 1), s = i(a, l), d(f(t, e), s) < r)) return !1; return !0; } function x(t, e, i) { for (let s = 0; s !== t.length; ++s) if (s !== e && s !== i && (s + 1) % t.length !== e && (s + 1) % t.length !== i && n(f(t, e), f(t, i), f(t, s), f(t, s + 1))) return !1; return !0; } function T(t, e, i, n) { const s = n || []; if ((function (t) { t.length = 0; }(s)), e < i) for (var r = e; r <= i; r++)s.push(t[r]); else { for (r = 0; r <= i; r++)s.push(t[r]); for (r = e; r < t.length; r++)s.push(t[r]); } return s; } function w(t, e, i, n, s) { s = s || 0; const r = e[1] - t[1]; const o = t[0] - e[0]; const a = r * t[0] + o * t[1]; const h = n[1] - i[1]; const l = i[0] - n[0]; const u = h * i[0] + l * i[1]; const c = r * l - h * o; return b(c, 0, s) ? [0, 0] : [(l * a - o * u) / c, (r * u - h * a) / c]; } function b(t, e, i) { return i = i || 0, Math.abs(t - e) <= i; } function E(t, e, i) { return b(t[0], e[0], i) && b(t[1], e[1], i); }
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(152); const r = i(14); const o = i(2); const a = i(112); const h = i(123); const l = i(3); const u = new n({ Extends: a, Mixins: [s.Bounce, s.Collision, s.Force, s.Friction, s.Gravity, s.Mass, s.Sensor, s.SetBody, s.Sleep, s.Static, s.Transform, s.Velocity, h], initialize(t, e, i, n, s, a) { r.call(this, t.scene, 'Image'), this.setTexture(n, s), this.setSizeToFrame(), this.setOrigin(), this.world = t, this._tempVec2 = new l(e, i); const h = o(a, 'shape', null); h ? this.setBody(h, a) : this.setRectangle(this.width, this.height, a), this.setPosition(e, i), this.initPipeline('TextureTintPipeline'); } }); t.exports = u;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(293); const s = i(0); const r = i(152); const o = i(14); const a = i(2); const h = i(123); const l = i(66); const u = i(3); const c = new s({ Extends: l, Mixins: [r.Bounce, r.Collision, r.Force, r.Friction, r.Gravity, r.Mass, r.Sensor, r.SetBody, r.Sleep, r.Static, r.Transform, r.Velocity, h], initialize(t, e, i, s, r, h) { o.call(this, t.scene, 'Sprite'), this.anims = new n(this), this.setTexture(s, r), this.setSizeToFrame(), this.setOrigin(), this.world = t, this._tempVec2 = new u(e, i); const l = a(h, 'shape', null); l ? this.setBody(l, h) : this.setRectangle(this.width, this.height, h), this.setPosition(e, i), this.initPipeline('TextureTintPipeline'); } }); t.exports = c;
}, function (t, e, i) { const n = {}; t.exports = n; const s = i(244); const r = i(21); n.name = 'matter-js', n.version = '0.14.2', n.uses = [], n.used = [], n.use = function () { s.use(n, Array.prototype.slice.call(arguments)); }, n.before = function (t, e) { return t = t.replace(/^Matter./, ''), r.chainPathBefore(n, t, e); }, n.after = function (t, e) { return t = t.replace(/^Matter./, ''), r.chainPathAfter(n, t, e); }; }, function (t, e, i) { const n = {}; t.exports = n; const s = i(37); const r = i(154); const o = i(38); const a = i(44); const h = i(32); n.collides = function (t, e) { for (var i = [], n = 0; n < e.length; n++) { const s = e[n]; if (t !== s && o.overlaps(s.bounds, t.bounds)) for (let a = s.parts.length === 1 ? 0 : 1; a < s.parts.length; a++) { const h = s.parts[a]; if (o.overlaps(h.bounds, t.bounds)) { const l = r.collides(h, t); if (l.collided) { i.push(l); break; } } } } return i; }, n.ray = function (t, e, i, r) { r = r || 1e-100; for (var o = s.angle(e, i), h = s.magnitude(s.sub(e, i)), l = 0.5 * (i.x + e.x), u = 0.5 * (i.y + e.y), c = a.rectangle(l, u, h, r, { angle: o }), d = n.collides(c, t), f = 0; f < d.length; f += 1) { const p = d[f]; p.body = p.bodyB = p.bodyA; } return d; }, n.region = function (t, e, i) { for (var n = [], s = 0; s < t.length; s++) { const r = t[s]; const a = o.overlaps(r.bounds, e); (a && !i || !a && i) && n.push(r); } return n; }, n.point = function (t, e) { for (var i = [], n = 0; n < t.length; n++) { const s = t[n]; if (o.contains(s.bounds, e)) for (let r = s.parts.length === 1 ? 0 : 1; r < s.parts.length; r++) { const a = s.parts[r]; if (o.contains(a.bounds, e) && h.contains(a.vertices, e)) { i.push(s); break; } } } return i; }; }, function (t, e, i) {
  const n = {}; t.exports = n; const s = i(245); const r = i(94); const o = i(248); const a = i(247); const h = i(1354); const l = i(246); const u = i(95); const c = i(69); const d = i(80); const f = i(21); const p = i(26); n.create = function (t, e) {
    e = (e = f.isElement(t) ? e : t) || {}, ((t = f.isElement(t) ? t : null) || e.render) && f.warn('Engine.create: engine.render is deprecated (see docs)'); const i = {
      positionIterations: 6, velocityIterations: 4, constraintIterations: 2, enableSleeping: !1, events: [], plugin: {}, timing: { timestamp: 0, timeScale: 1 }, broadphase: { controller: l },
    }; const n = f.extend(i, e); return n.world = e.world || s.create(n.world), n.pairs = a.create(), n.broadphase = n.broadphase.controller.create(n.broadphase), n.metrics = n.metrics || { extended: !1 }, n.metrics = h.create(n.metrics), n;
  }, n.update = function (t, e, i) { e = e || 1e3 / 60, i = i || 1; let s; const l = t.world; const f = t.timing; const p = t.broadphase; let g = []; f.timestamp += e * f.timeScale; const v = { timestamp: f.timestamp }; u.trigger(t, 'beforeUpdate', v); const m = c.allBodies(l); const y = c.allConstraints(l); for (h.reset(t.metrics), t.enableSleeping && r.update(m, f.timeScale), n._bodiesApplyGravity(m, l.gravity), n._bodiesUpdate(m, e, f.timeScale, i, l.bounds), d.preSolveAll(m), s = 0; s < t.constraintIterations; s++)d.solveAll(y, f.timeScale); d.postSolveAll(m), p.controller ? (l.isModified && p.controller.clear(p), p.controller.update(p, m, t, l.isModified), g = p.pairsList) : g = m, l.isModified && c.setModified(l, !1, !1, !0); const x = p.detector(g, t); const T = t.pairs; const w = f.timestamp; for (a.update(T, x, w), a.removeOld(T, w), t.enableSleeping && r.afterCollisions(T.list, f.timeScale), T.collisionStart.length > 0 && u.trigger(t, 'collisionStart', { pairs: T.collisionStart }), o.preSolvePosition(T.list), s = 0; s < t.positionIterations; s++)o.solvePosition(T.list, m, f.timeScale); for (o.postSolvePosition(m), d.preSolveAll(m), s = 0; s < t.constraintIterations; s++)d.solveAll(y, f.timeScale); for (d.postSolveAll(m), o.preSolveVelocity(T.list), s = 0; s < t.velocityIterations; s++)o.solveVelocity(T.list, f.timeScale); return T.collisionActive.length > 0 && u.trigger(t, 'collisionActive', { pairs: T.collisionActive }), T.collisionEnd.length > 0 && u.trigger(t, 'collisionEnd', { pairs: T.collisionEnd }), h.update(t.metrics, t), n._bodiesClearForces(m), u.trigger(t, 'afterUpdate', v), t; }, n.merge = function (t, e) { if (f.extend(t, e), e.world) { t.world = e.world, n.clear(t); for (let i = c.allBodies(t.world), s = 0; s < i.length; s++) { const o = i[s]; r.set(o, !1), o.id = f.nextId(); } } }, n.clear = function (t) { const e = t.world; a.clear(t.pairs); const i = t.broadphase; if (i.controller) { const n = c.allBodies(e); i.controller.clear(i), i.controller.update(i, n, t, !0); } }, n._bodiesClearForces = function (t) { for (let e = 0; e < t.length; e++) { const i = t[e]; i.force.x = 0, i.force.y = 0, i.torque = 0; } }, n._bodiesApplyGravity = function (t, e) { const i = void 0 !== e.scale ? e.scale : 0.001; if ((e.x !== 0 || e.y !== 0) && i !== 0) for (let n = 0; n < t.length; n++) { const s = t[n]; s.ignoreGravity || s.isStatic || s.isSleeping || (s.force.x += s.mass * e.x * i * s.gravityScale.x, s.force.y += s.mass * e.y * i * s.gravityScale.y); } }, n._bodiesUpdate = function (t, e, i, n, s) { for (let r = 0; r < t.length; r++) { const o = t[r]; o.isStatic || o.isSleeping || p.update(o, e, i, n); } };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(44); const s = i(26); const r = i(0); const o = i(21); const a = i(69); const h = i(512); const l = i(10); const u = i(241); const c = i(2); const d = i(6); const f = i(26); const p = i(95); const g = i(242); const v = i(245); const m = i(37); const y = new r({
    Extends: l,
    initialize(t, e) {
      l.call(this), this.scene = t, this.engine = h.create(e), this.localWorld = this.engine.world; const i = d(e, 'gravity', null); i ? this.setGravity(i.x, i.y, i.scale) : !1 === i && this.setGravity(0, 0, 0), this.walls = {
        left: null, right: null, top: null, bottom: null,
      }, this.enabled = d(e, 'enabled', !0), this.correction = d(e, 'correction', 1), this.getDelta = d(e, 'getDelta', this.update60Hz); const n = c(e, 'runner', {}); const s = c(n, 'fps', !1); let r = c(n, 'fps', 60); const o = c(n, 'delta', 1e3 / r); const a = c(n, 'deltaMin', 1e3 / r); const u = c(n, 'deltaMax', 1e3 / (0.5 * r)); s || (r = 1e3 / o), this.runner = {
        fps: r, correction: c(n, 'correction', 1), deltaSampleSize: c(n, 'deltaSampleSize', 60), counterTimestamp: 0, frameCounter: 0, deltaHistory: [], timePrev: null, timeScalePrev: 1, frameRequestId: null, isFixed: c(n, 'isFixed', !1), delta: o, deltaMin: a, deltaMax: u,
      }, this.autoUpdate = d(e, 'autoUpdate', !0); const f = d(e, 'debug', !1); if (this.drawDebug = typeof f === 'object' || f, this.debugGraphic, this.debugConfig = {
        showAxes: c(f, 'showAxes', !1), showAngleIndicator: c(f, 'showAngleIndicator', !1), angleColor: c(f, 'angleColor', 15208787), showBroadphase: c(f, 'showBroadphase', !1), broadphaseColor: c(f, 'broadphaseColor', 16757760), showBounds: c(f, 'showBounds', !1), boundsColor: c(f, 'boundsColor', 16777215), showVelocity: c(f, 'showVelocity', !1), velocityColor: c(f, 'velocityColor', 44783), showCollisions: c(f, 'showCollisions', !1), collisionColor: c(f, 'collisionColor', 16094476), showSeparations: c(f, 'showSeparations', !1), separationColor: c(f, 'separationColor', 16753920), showBody: c(f, 'showBody', !0), showStaticBody: c(f, 'showStaticBody', !0), showInternalEdges: c(f, 'showInternalEdges', !1), renderFill: c(f, 'renderFill', !1), renderLine: c(f, 'renderLine', !0), fillColor: c(f, 'fillColor', 1075465), fillOpacity: c(f, 'fillOpacity', 1), lineColor: c(f, 'lineColor', 2678297), lineOpacity: c(f, 'lineOpacity', 1), lineThickness: c(f, 'lineThickness', 1), staticFillColor: c(f, 'staticFillColor', 857979), staticLineColor: c(f, 'staticLineColor', 1255396), showSleeping: c(f, 'showSleeping', !1), staticBodySleepOpacity: c(f, 'staticBodySleepOpacity', 0.7), sleepFillColor: c(f, 'sleepFillColor', 4605510), sleepLineColor: c(f, 'sleepLineColor', 10066585), showSensors: c(f, 'showSensors', !0), sensorFillColor: c(f, 'sensorFillColor', 857979), sensorLineColor: c(f, 'sensorLineColor', 1255396), showPositions: c(f, 'showPositions', !0), positionSize: c(f, 'positionSize', 4), positionColor: c(f, 'positionColor', 14697178), showJoint: c(f, 'showJoint', !0), jointColor: c(f, 'jointColor', 14737474), jointLineOpacity: c(f, 'jointLineOpacity', 1), jointLineThickness: c(f, 'jointLineThickness', 2), pinSize: c(f, 'pinSize', 4), pinColor: c(f, 'pinColor', 4382944), springColor: c(f, 'springColor', 14697184), anchorColor: c(f, 'anchorColor', 15724527), anchorSize: c(f, 'anchorSize', 4), showConvexHulls: c(f, 'showConvexHulls', !1), hullColor: c(f, 'hullColor', 14091216),
      }, this.drawDebug && this.createDebugGraphic(), this.setEventsProxy(), c(e, 'setBounds', !1)) { const p = e.setBounds; if (typeof p === 'boolean') this.setBounds(); else { const g = c(p, 'x', 0); const v = c(p, 'y', 0); const m = c(p, 'width', t.sys.scale.width); const y = c(p, 'height', t.sys.scale.height); const x = c(p, 'thickness', 64); const T = c(p, 'left', !0); const w = c(p, 'right', !0); const b = c(p, 'top', !0); const E = c(p, 'bottom', !0); this.setBounds(g, v, m, y, x, T, w, b, E); } }
    },
    setCompositeRenderStyle(t) { let e; let i; let n; const s = t.bodies; const r = t.constraints; const o = t.composites; for (e = 0; e < s.length; e++)n = (i = s[e]).render, this.setBodyRenderStyle(i, n.lineColor, n.lineOpacity, n.lineThickness, n.fillColor, n.fillOpacity); for (e = 0; e < r.length; e++)n = (i = r[e]).render, this.setConstraintRenderStyle(i, n.lineColor, n.lineOpacity, n.lineThickness, n.pinSize, n.anchorColor, n.anchorSize); for (e = 0; e < o.length; e++)i = o[e], this.setCompositeRenderStyle(i); return this; },
    setBodyRenderStyle(t, e, i, n, s, r) { const o = t.render; const a = this.debugConfig; return o ? (e == null && (e = t.isStatic ? a.staticLineColor : a.lineColor), i == null && (i = a.lineOpacity), n == null && (n = a.lineThickness), s == null && (s = t.isStatic ? a.staticFillColor : a.fillColor), r == null && (r = a.fillOpacity), !1 !== e && (o.lineColor = e), !1 !== i && (o.lineOpacity = i), !1 !== n && (o.lineThickness = n), !1 !== s && (o.fillColor = s), !1 !== r && (o.fillOpacity = r), this) : this; },
    setConstraintRenderStyle(t, e, i, n, s, r, o) { const a = t.render; const h = this.debugConfig; if (!a) return this; if (e == null) { const l = a.type; l === 'line' ? e = h.jointColor : l === 'pin' ? e = h.pinColor : l === 'spring' && (e = h.springColor); } return i == null && (i = h.jointLineOpacity), n == null && (n = h.jointLineThickness), s == null && (s = h.pinSize), r == null && (r = h.anchorColor), o == null && (o = h.anchorSize), !1 !== e && (a.lineColor = e), !1 !== i && (a.lineOpacity = i), !1 !== n && (a.lineThickness = n), !1 !== s && (a.pinSize = s), !1 !== r && (a.anchorColor = r), !1 !== o && (a.anchorSize = o), this; },
    setEventsProxy() { const t = this; const e = this.engine; const i = this.localWorld; this.drawDebug && (p.on(i, 'compositeModified', ((e) => { t.setCompositeRenderStyle(e); })), p.on(i, 'beforeAdd', ((e) => { for (let i = [].concat(e.object), n = 0; n < i.length; n++) { const s = i[n]; const r = s.render; s.type === 'body' ? t.setBodyRenderStyle(s, r.lineColor, r.lineOpacity, r.lineThickness, r.fillColor, r.fillOpacity) : s.type === 'composite' ? t.setCompositeRenderStyle(s) : s.type === 'constraint' && t.setConstraintRenderStyle(s, r.lineColor, r.lineOpacity, r.lineThickness, r.pinSize, r.anchorColor, r.anchorSize); } }))), p.on(i, 'beforeAdd', ((e) => { t.emit(u.BEFORE_ADD, e); })), p.on(i, 'afterAdd', ((e) => { t.emit(u.AFTER_ADD, e); })), p.on(i, 'beforeRemove', ((e) => { t.emit(u.BEFORE_REMOVE, e); })), p.on(i, 'afterRemove', ((e) => { t.emit(u.AFTER_REMOVE, e); })), p.on(e, 'beforeUpdate', ((e) => { t.emit(u.BEFORE_UPDATE, e); })), p.on(e, 'afterUpdate', ((e) => { t.emit(u.AFTER_UPDATE, e); })), p.on(e, 'collisionStart', ((e) => { let i; let n; const s = e.pairs; s.length > 0 && (i = s[0].bodyA, n = s[0].bodyB), t.emit(u.COLLISION_START, e, i, n); })), p.on(e, 'collisionActive', ((e) => { let i; let n; const s = e.pairs; s.length > 0 && (i = s[0].bodyA, n = s[0].bodyB), t.emit(u.COLLISION_ACTIVE, e, i, n); })), p.on(e, 'collisionEnd', ((e) => { let i; let n; const s = e.pairs; s.length > 0 && (i = s[0].bodyA, n = s[0].bodyB), t.emit(u.COLLISION_END, e, i, n); })); },
    setBounds(t, e, i, n, s, r, o, a, h) { return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = this.scene.sys.scale.width), void 0 === n && (n = this.scene.sys.scale.height), void 0 === s && (s = 64), void 0 === r && (r = !0), void 0 === o && (o = !0), void 0 === a && (a = !0), void 0 === h && (h = !0), this.updateWall(r, 'left', t - s, e - s, s, n + 2 * s), this.updateWall(o, 'right', t + i, e - s, s, n + 2 * s), this.updateWall(a, 'top', t, e - s, i, s), this.updateWall(h, 'bottom', t, e + n, i, s), this; },
    updateWall(t, e, i, n, s, r) { const o = this.walls[e]; t ? (o && v.remove(this.localWorld, o), i += s / 2, n += r / 2, this.walls[e] = this.create(i, n, s, r, { isStatic: !0, friction: 0, frictionStatic: 0 })) : (o && v.remove(this.localWorld, o), this.walls[e] = null); },
    createDebugGraphic() { const t = this.scene.sys.add.graphics({ x: 0, y: 0 }); return t.setDepth(Number.MAX_VALUE), this.debugGraphic = t, this.drawDebug = !0, t; },
    disableGravity() { return this.localWorld.gravity.x = 0, this.localWorld.gravity.y = 0, this.localWorld.gravity.scale = 0, this; },
    setGravity(t, e, i) { return void 0 === t && (t = 0), void 0 === e && (e = 1), this.localWorld.gravity.x = t, this.localWorld.gravity.y = e, void 0 !== i && (this.localWorld.gravity.scale = i), this; },
    create(t, e, i, s, r) { const o = n.rectangle(t, e, i, s, r); return v.add(this.localWorld, o), o; },
    add(t) { return v.add(this.localWorld, t), this; },
    remove(t, e) { Array.isArray(t) || (t = [t]); for (let i = 0; i < t.length; i++) { const n = t[i]; const s = n.body ? n.body : n; a.remove(this.localWorld, s, e); } return this; },
    removeConstraint(t, e) { return a.remove(this.localWorld, t, e), this; },
    convertTilemapLayer(t, e) { const i = t.layer; const n = t.getTilesWithin(0, 0, i.width, i.height, { isColliding: !0 }); return this.convertTiles(n, e), this; },
    convertTiles(t, e) { if (t.length === 0) return this; for (let i = 0; i < t.length; i++) new g(this, t[i], e); return this; },
    nextGroup(t) { return f.nextGroup(t); },
    nextCategory() { return f.nextCategory(); },
    pause() { return this.enabled = !1, this.emit(u.PAUSE), this; },
    resume() { return this.enabled = !0, this.emit(u.RESUME), this; },
    update(t, e) { if (this.enabled && this.autoUpdate) { const i = this.engine; const n = this.runner; const s = i.timing; let r = this.correction; n.isFixed ? e = this.getDelta(t, e) : (e = t - n.timePrev || n.delta, n.timePrev = t, n.deltaHistory.push(e), n.deltaHistory = n.deltaHistory.slice(-n.deltaSampleSize), r = (e = (e = (e = Math.min.apply(null, n.deltaHistory)) < n.deltaMin ? n.deltaMin : e) > n.deltaMax ? n.deltaMax : e) / n.delta, n.delta = e), n.timeScalePrev !== 0 && (r *= s.timeScale / n.timeScalePrev), s.timeScale === 0 && (r = 0), n.timeScalePrev = s.timeScale, n.correction = r, n.frameCounter += 1, t - n.counterTimestamp >= 1e3 && (n.fps = n.frameCounter * ((t - n.counterTimestamp) / 1e3), n.counterTimestamp = t, n.frameCounter = 0), h.update(i, e, r); } },
    step(t, e) { h.update(this.engine, t, e); },
    update60Hz() { return 1e3 / 60; },
    update30Hz() { return 1e3 / 30; },
    has(t) { const e = t.hasOwnProperty('body') ? t.body : t; return a.get(this.localWorld, e.id, e.type) !== null; },
    getAllBodies() { return a.allBodies(this.localWorld); },
    getAllConstraints() { return a.allConstraints(this.localWorld); },
    getAllComposites() { return a.allComposites(this.localWorld); },
    postUpdate() { if (this.drawDebug) { const t = this.debugConfig; const e = this.engine; const i = this.debugGraphic; const n = a.allBodies(this.localWorld); this.debugGraphic.clear(), t.showBroadphase && e.broadphase.controller && this.renderGrid(e.broadphase, i, t.broadphaseColor, 0.5), t.showBounds && this.renderBodyBounds(n, i, t.boundsColor, 0.5), (t.showBody || t.showStaticBody) && this.renderBodies(n), t.showJoint && this.renderJoints(), (t.showAxes || t.showAngleIndicator) && this.renderBodyAxes(n, i, t.showAxes, t.angleColor, 0.5), t.showVelocity && this.renderBodyVelocity(n, i, t.velocityColor, 1, 2), t.showSeparations && this.renderSeparations(e.pairs.list, i, t.separationColor), t.showCollisions && this.renderCollisions(e.pairs.list, i, t.collisionColor); } },
    renderGrid(t, e, i, n) { e.lineStyle(1, i, n); for (let s = o.keys(t.buckets), r = 0; r < s.length; r++) { const a = s[r]; if (!(t.buckets[a].length < 2)) { const h = a.split(/C|R/); e.strokeRect(parseInt(h[1], 10) * t.bucketWidth, parseInt(h[2], 10) * t.bucketHeight, t.bucketWidth, t.bucketHeight); } } return this; },
    renderSeparations(t, e, i) { e.lineStyle(1, i, 1); for (let n = 0; n < t.length; n++) { const s = t[n]; if (s.isActive) { const r = s.collision; const o = r.bodyA; const a = r.bodyB; const h = o.position; const l = a.position; const u = r.penetration; let c = o.isStatic || a.isStatic ? 1 : 4; a.isStatic && (c = 0), e.lineBetween(l.x, l.y, l.x - u.x * c, l.y - u.y * c), c = o.isStatic || a.isStatic ? 1 : 4, o.isStatic && (c = 0), e.lineBetween(h.x, h.y, h.x - u.x * c, h.y - u.y * c); } } return this; },
    renderCollisions(t, e, i) { let n; let s; for (e.lineStyle(1, i, 0.5), e.fillStyle(i, 1), n = 0; n < t.length; n++) if ((s = t[n]).isActive) for (let r = 0; r < s.activeContacts.length; r++) { const o = s.activeContacts[r].vertex; e.fillRect(o.x - 2, o.y - 2, 5, 5); } for (n = 0; n < t.length; n++) if ((s = t[n]).isActive) { const a = s.collision; const h = s.activeContacts; if (h.length > 0) { let l = h[0].vertex.x; let u = h[0].vertex.y; h.length === 2 && (l = (h[0].vertex.x + h[1].vertex.x) / 2, u = (h[0].vertex.y + h[1].vertex.y) / 2), a.bodyB === a.supports[0].body || a.bodyA.isStatic ? e.lineBetween(l - 8 * a.normal.x, u - 8 * a.normal.y, l, u) : e.lineBetween(l + 8 * a.normal.x, u + 8 * a.normal.y, l, u); } } return this; },
    renderBodyBounds(t, e, i, n) { e.lineStyle(1, i, n); for (let s = 0; s < t.length; s++) { const r = t[s]; if (r.render.visible) { const o = r.bounds; if (o)e.strokeRect(o.min.x, o.min.y, o.max.x - o.min.x, o.max.y - o.min.y); else for (let a = r.parts, h = a.length > 1 ? 1 : 0; h < a.length; h++) { const l = a[h]; e.strokeRect(l.bounds.min.x, l.bounds.min.y, l.bounds.max.x - l.bounds.min.x, l.bounds.max.y - l.bounds.min.y); } } } return this; },
    renderBodyAxes(t, e, i, n, s) { e.lineStyle(1, n, s); for (let r = 0; r < t.length; r++) { var o; var a; var h; const l = t[r]; const u = l.parts; if (l.render.visible) if (i) for (a = u.length > 1 ? 1 : 0; a < u.length; a++) for (o = u[a], h = 0; h < o.axes.length; h++) { const c = o.axes[h]; e.lineBetween(o.position.x, o.position.y, o.position.x + 20 * c.x, o.position.y + 20 * c.y); } else for (a = u.length > 1 ? 1 : 0; a < u.length; a++) for (o = u[a], h = 0; h < o.axes.length; h++)e.lineBetween(o.position.x, o.position.y, (o.vertices[0].x + o.vertices[o.vertices.length - 1].x) / 2, (o.vertices[0].y + o.vertices[o.vertices.length - 1].y) / 2); } return this; },
    renderBodyVelocity(t, e, i, n, s) { e.lineStyle(s, i, n); for (let r = 0; r < t.length; r++) { const o = t[r]; o.render.visible && e.lineBetween(o.position.x, o.position.y, o.position.x + 2 * (o.position.x - o.positionPrev.x), o.position.y + 2 * (o.position.y - o.positionPrev.y)); } return this; },
    renderBodies(t) { for (let e = this.debugGraphic, i = this.debugConfig, n = i.showBody, s = i.showStaticBody, r = i.showSleeping, o = i.showInternalEdges, a = i.showConvexHulls, h = i.renderFill, l = i.renderLine, u = i.staticBodySleepOpacity, c = i.sleepFillColor, d = i.sleepLineColor, f = i.hullColor, p = 0; p < t.length; p++) { const g = t[p]; if (g.render.visible && ((s || !g.isStatic) && (n || g.isStatic))) { let v = g.render.lineColor; let m = g.render.lineOpacity; const y = g.render.lineThickness; let x = g.render.fillColor; let T = g.render.fillOpacity; r && g.isSleeping && (g.isStatic ? (m *= u, T *= u) : (v = d, x = c)), h || (x = null), l || (v = null), this.renderBody(g, e, o, v, m, y, x, T); const w = g.parts.length; a && w > 1 && this.renderConvexHull(g, e, f, y); } } },
    renderBody(t, e, i, n, s, r, o, a) { void 0 === n && (n = null), void 0 === s && (s = null), void 0 === r && (r = 1), void 0 === o && (o = null), void 0 === a && (a = null); for (var h = this.debugConfig, l = h.sensorFillColor, u = h.sensorLineColor, c = t.parts, d = c.length, f = d > 1 ? 1 : 0; f < d; f++) { const p = c[f]; const g = p.render; const v = g.opacity; if (g.visible && v !== 0 && (!p.isSensor || h.showSensors)) { const m = p.circleRadius; if (e.beginPath(), p.isSensor ? (o !== null && e.fillStyle(l, a * v), n !== null && e.lineStyle(r, u, s * v)) : (o !== null && e.fillStyle(o, a * v), n !== null && e.lineStyle(r, n, s * v)), m)e.arc(p.position.x, p.position.y, m, 0, 2 * Math.PI); else { const y = p.vertices; const x = y.length; e.moveTo(y[0].x, y[0].y); for (let T = 1; T < x; T++) { const w = y[T]; if (!y[T - 1].isInternal || i ? e.lineTo(w.x, w.y) : e.moveTo(w.x, w.y), T < x && w.isInternal && !i) { const b = (T + 1) % x; e.moveTo(y[b].x, y[b].y); } }e.closePath(); }o !== null && e.fillPath(), n !== null && e.strokePath(); } } if (h.showPositions && !t.isStatic) { const E = t.position.x; const S = t.position.y; const A = Math.ceil(h.positionSize / 2); e.fillStyle(h.positionColor, 1), e.fillRect(E - A, S - A, h.positionSize, h.positionSize); } return this; },
    renderConvexHull(t, e, i, n) { if (void 0 === n && (n = 1), t.parts.length > 1) { const s = t.vertices; e.lineStyle(n, i), e.beginPath(), e.moveTo(s[0].x, s[0].y); for (let r = 1; r < s.length; r++)e.lineTo(s[r].x, s[r].y); e.lineTo(s[0].x, s[0].y), e.strokePath(); } return this; },
    renderJoints() { for (let t = this.debugGraphic, e = a.allConstraints(this.localWorld), i = 0; i < e.length; i++) { const n = e[i].render; const s = n.lineColor; const r = n.lineOpacity; const o = n.lineThickness; const h = n.pinSize; const l = n.anchorColor; const u = n.anchorSize; this.renderConstraint(e[i], t, s, r, o, h, l, u); } },
    renderConstraint(t, e, i, n, s, r, a, h) { const l = t.render; if (!l.visible || !t.pointA || !t.pointB) return this; e.lineStyle(s, i, n); let u; let c; const d = t.bodyA; const f = t.bodyB; if (u = d ? m.add(d.position, t.pointA) : t.pointA, l.type === 'pin')e.strokeCircle(u.x, u.y, r); else { if (c = f ? m.add(f.position, t.pointB) : t.pointB, e.beginPath(), e.moveTo(u.x, u.y), l.type === 'spring') for (var p, g = m.sub(c, u), v = m.perp(m.normalise(g)), y = Math.ceil(o.clamp(t.length / 5, 12, 20)), x = 1; x < y; x += 1)p = x % 2 == 0 ? 1 : -1, e.lineTo(u.x + g.x * (x / y) + v.x * p * 4, u.y + g.y * (x / y) + v.y * p * 4); e.lineTo(c.x, c.y); } return e.strokePath(), l.anchors && h > 0 && (e.fillStyle(a), e.fillCircle(u.x, u.y, h), e.fillCircle(c.x, c.y, h)), this; },
    resetCollisionIDs() { return s._nextCollidingGroupId = 1, s._nextNonCollidingGroupId = -1, s._nextCategory = 1, this; },
    shutdown() { p.off(this.engine), this.removeAllListeners(), v.clear(this.localWorld, !1), h.clear(this.engine), this.drawDebug && this.debugGraphic.destroy(); },
    destroy() { this.shutdown(); },
  }); t.exports = y;
}, function (t, e, i) {
/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2020 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser3-plugin-template/blob/master/LICENSE|MIT License}
*/
  const n = new (i(0))({
    initialize(t) { this.pluginManager = t, this.game = t.game; }, init() {}, start() {}, stop() {}, destroy() { this.pluginManager = null, this.game = null, this.scene = null, this.systems = null; },
  }); t.exports = n;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(27); t.exports = function (t, e, i, s, r, o, a) { for (let h = n(i, s, r, o, null, a), l = 0; l < h.length; l++)h[l] && h[l].index === t && (h[l].index = e); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(116); t.exports = function (t, e, i) { if (n(t, e, i)) { const s = i.data[e][t]; return s !== null && s.index > -1; } return !1; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(82); const s = i(116); const r = i(249); t.exports = function (t, e, i, o, a) { if (void 0 === i && (i = !1), void 0 === o && (o = !0), !s(t, e, a)) return null; const h = a.data[e][t]; return h ? (a.data[e][t] = i ? null : new n(a, -1, t, e, h.width, h.height), o && h && h.collides && r(t, e, a), h) : null; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(36); const s = i(252); const r = i(519); const o = i(520); const a = i(531); t.exports = function (t, e, i, h, l, u) { let c; switch (e) { case n.ARRAY_2D: c = s(t, i, h, l, u); break; case n.CSV: c = r(t, i, h, l, u); break; case n.TILED_JSON: c = o(t, i, u); break; case n.WELTMEISTER: c = a(t, i, u); break; default: console.warn(`Unrecognized tilemap data format: ${e}`), c = null; } return c; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(36); const s = i(252); t.exports = function (t, e, i, r, o) { const a = e.trim().split('\n').map(((t) => t.split(','))); const h = s(t, a, i, r, o); return h.format = n.CSV, h; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(36); const s = i(118); const r = i(521); const o = i(523); const a = i(524); const h = i(527); const l = i(529); const u = i(530); t.exports = function (t, e, i) {
    if (e.orientation !== 'orthogonal') return console.warn('Only orthogonal map types are supported in this version of Phaser'), null; const c = new s({
      width: e.width, height: e.height, name: t, tileWidth: e.tilewidth, tileHeight: e.tileheight, orientation: e.orientation, format: n.TILED_JSON, version: e.version, properties: e.properties, renderOrder: e.renderorder, infinite: e.infinite,
    }); c.layers = r(e, i), c.images = o(e); const d = a(e); return c.tilesets = d.tilesets, c.imageCollections = d.imageCollections, c.objects = h(e), c.tiles = l(c), u(c), c;
  };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(522); const s = i(2); const r = i(117); const o = i(253); const a = i(82); const h = i(254); t.exports = function (t, e) {
    for (var i = s(t, 'infinite', !1), l = [], u = [], c = h(t); c.i < c.layers.length || u.length > 0;) {
      if (c.i >= c.layers.length) { if (u.length < 1) { console.warn('TilemapParser.parseTiledJSON - Invalid layer group hierarchy'); break; }c = u.pop(); } else {
        const d = c.layers[c.i]; if (c.i++, d.type === 'tilelayer') {
          if (d.compression)console.warn(`TilemapParser.parseTiledJSON - Layer compression is unsupported, skipping layer '${d.name}'`); else {
            if (d.encoding && d.encoding === 'base64') { if (d.chunks) for (let f = 0; f < d.chunks.length; f++)d.chunks[f].data = n(d.chunks[f].data); d.data && (d.data = n(d.data)), delete d.encoding; } var p; var g; var v; var m; const y = []; let x = 0; if (i) {
              const T = s(d, 'startx', 0) + d.x; const w = s(d, 'starty', 0) + d.y; p = new r({
                name: c.name + d.name, x: c.x + s(d, 'offsetx', 0) + T * t.tilewidth, y: c.y + s(d, 'offsety', 0) + w * t.tileheight, width: d.width, height: d.height, tileWidth: t.tilewidth, tileHeight: t.tileheight, alpha: c.opacity * d.opacity, visible: c.visible && d.visible, properties: s(d, 'properties', []),
              }); for (var b = 0; b < d.height; b++) { y.push([null]); for (let E = 0; E < d.width; E++)y[b][E] = null; } for (b = 0, k = d.chunks.length; b < k; b++) for (let S = d.chunks[b], A = S.x - T, _ = S.y - w, C = 0, M = 0, P = S.data.length; M < P; M++) { const O = x + A; const R = C + _; (g = o(S.data[M])).gid > 0 ? ((v = new a(p, g.gid, O, R, t.tilewidth, t.tileheight)).rotation = g.rotation, v.flipX = g.flipped, y[R][O] = v) : (m = e ? null : new a(p, -1, O, R, t.tilewidth, t.tileheight), y[R][O] = m), ++x === S.width && (C++, x = 0); }
            } else {
              p = new r({
                name: c.name + d.name, x: c.x + s(d, 'offsetx', 0) + d.x, y: c.y + s(d, 'offsety', 0) + d.y, width: d.width, height: d.height, tileWidth: t.tilewidth, tileHeight: t.tileheight, alpha: c.opacity * d.opacity, visible: c.visible && d.visible, properties: s(d, 'properties', []),
              }); for (var L = [], D = 0, k = d.data.length; D < k; D++)(g = o(d.data[D])).gid > 0 ? ((v = new a(p, g.gid, x, y.length, t.tilewidth, t.tileheight)).rotation = g.rotation, v.flipX = g.flipped, L.push(v)) : (m = e ? null : new a(p, -1, x, y.length, t.tilewidth, t.tileheight), L.push(m)), ++x === d.width && (y.push(L), x = 0, L = []);
            }p.data = y, l.push(p);
          }
        } else if (d.type === 'group') { const F = h(t, d, c); u.push(c), c = F; }
      }
    } return l;
  };
}, function (t, e) { t.exports = function (t) { for (var e = window.atob(t), i = e.length, n = new Array(i / 4), s = 0; s < i; s += 4)n[s / 4] = (e.charCodeAt(s) | e.charCodeAt(s + 1) << 8 | e.charCodeAt(s + 2) << 16 | e.charCodeAt(s + 3) << 24) >>> 0; return n; }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(2); const s = i(254); t.exports = function (t) {
    for (var e = [], i = [], r = s(t); r.i < r.layers.length || i.length > 0;) {
      if (r.i >= r.layers.length) { if (i.length < 1) { console.warn('TilemapParser.parseTiledJSON - Invalid layer group hierarchy'); break; }r = i.pop(); } else {
        const o = r.layers[r.i]; if (r.i++, o.type === 'imagelayer') {
          const a = n(o, 'offsetx', 0) + n(o, 'startx', 0); const h = n(o, 'offsety', 0) + n(o, 'starty', 0); e.push({
            name: r.name + o.name, image: o.image, x: r.x + a + o.x, y: r.y + h + o.y, alpha: r.opacity * o.opacity, visible: r.visible && o.visible, properties: n(o, 'properties', {}),
          });
        } else if (o.type === 'group') { const l = s(t, o, r); i.push(r), r = l; }
      }
    } return e;
  };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(119); const s = i(525); const r = i(255); t.exports = function (t) { for (var e, i = [], o = [], a = null, h = 0; h < t.tilesets.length; h++) { const l = t.tilesets[h]; if (l.source)console.warn("Phaser can't load external tilesets. Use the Embed Tileset button and then export the map again."); else if (l.image) { const u = new n(l.name, l.firstgid, l.tilewidth, l.tileheight, l.margin, l.spacing); if (t.version > 1) { if (Array.isArray(l.tiles)) { for (var c = {}, d = {}, f = 0; f < l.tiles.length; f++) { const p = l.tiles[f]; if (p.properties) { var g = {}; p.properties.forEach(((t) => { g[t.name] = t.value; })), d[p.id] = g; } if (p.objectgroup && (c[p.id] = { objectgroup: p.objectgroup }, p.objectgroup.objects)) { const v = p.objectgroup.objects.map(((t) => r(t))); c[p.id].objectgroup.objects = v; }p.animation && (c.hasOwnProperty(p.id) ? c[p.id].animation = p.animation : c[p.id] = { animation: p.animation }); }u.tileData = c, u.tileProperties = d; } } else if (l.tileproperties && (u.tileProperties = l.tileproperties), l.tiles) for (e in u.tileData = l.tiles, u.tileData) { const m = u.tileData[e].objectgroup; if (m && m.objects) { const y = m.objects.map(((t) => r(t))); u.tileData[e].objectgroup.objects = y; } }u.updateTileData(l.imagewidth, l.imageheight), i.push(u); } else { const x = new s(l.name, l.firstgid, l.tilewidth, l.tileheight, l.margin, l.spacing, l.properties); for (e in l.tiles) { const T = l.tiles[e].image; const w = l.firstgid + parseInt(e, 10); x.addImage(w, T); }o.push(x); }a && (a.lastgid = l.firstgid - 1), a = l; } return { tilesets: i, imageCollections: o }; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = new (i(0))({ initialize(t, e, i, n, s, r, o) { (void 0 === i || i <= 0) && (i = 32), (void 0 === n || n <= 0) && (n = 32), void 0 === s && (s = 0), void 0 === r && (r = 0), this.name = t, this.firstgid = 0 | e, this.imageWidth = 0 | i, this.imageHeight = 0 | n, this.imageMargin = 0 | s, this.imageSpacing = 0 | r, this.properties = o || {}, this.images = [], this.total = 0; }, containsImageIndex(t) { return t >= this.firstgid && t < this.firstgid + this.total; }, addImage(t, e) { return this.images.push({ gid: t, image: e }), this.total++, this; } }); t.exports = n;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(113); t.exports = function (t, e) { for (var i = {}, s = 0; s < e.length; s++) { const r = e[s]; n(t, r) && (i[r] = t[r]); } return i; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(2); const s = i(255); const r = i(528); const o = i(254); t.exports = function (t) { for (var e = [], i = [], a = o(t); a.i < a.layers.length || i.length > 0;) if (a.i >= a.layers.length) { if (i.length < 1) { console.warn('TilemapParser.parseTiledJSON - Invalid layer group hierarchy'); break; }a = i.pop(); } else { const h = a.layers[a.i]; if (a.i++, h.opacity *= a.opacity, h.visible = a.visible && h.visible, h.type === 'objectgroup') { h.name = a.name + h.name; for (var l = a.x + n(h, 'startx', 0) + n(h, 'offsetx', 0), u = a.y + n(h, 'starty', 0) + n(h, 'offsety', 0), c = [], d = 0; d < h.objects.length; d++) { const f = s(h.objects[d], l, u); c.push(f); } const p = new r(h); p.objects = c, e.push(p); } else if (h.type === 'group') { const g = o(t, h, a); i.push(a), a = g; } } return e; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(2); const r = new n({ initialize(t) { void 0 === t && (t = {}), this.name = s(t, 'name', 'object layer'), this.opacity = s(t, 'opacity', 1), this.properties = s(t, 'properties', {}), this.propertyTypes = s(t, 'propertytypes', {}), this.type = s(t, 'type', 'objectgroup'), this.visible = s(t, 'visible', !0), this.objects = s(t, 'objects', []); } }); t.exports = r;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(119); t.exports = function (t) { let e; let i; const s = []; for (e = 0; e < t.imageCollections.length; e++) for (let r = t.imageCollections[e], o = r.images, a = 0; a < o.length; a++) { const h = o[a]; (i = new n(h.image, h.gid, r.imageWidth, r.imageHeight, 0, 0)).updateTileData(r.imageWidth, r.imageHeight), t.tilesets.push(i); } for (e = 0; e < t.tilesets.length; e++) for (let l = (i = t.tilesets[e]).tileMargin, u = i.tileMargin, c = 0, d = 0, f = 0, p = i.firstgid; p < i.firstgid + i.total && (s[p] = [l, u, e], l += i.tileWidth + i.tileSpacing, ++c !== i.total) && (++d !== i.columns || (l = i.tileMargin, u += i.tileHeight + i.tileSpacing, d = 0, ++f !== i.rows)); p++);return s; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(19); t.exports = function (t) { for (var e, i, s, r, o, a = 0; a < t.layers.length; a++) { e = t.layers[a], r = null; for (let h = 0; h < e.data.length; h++) { o = e.data[h]; for (let l = 0; l < o.length; l++)(i = o[l]) === null || i.index < 0 || (s = t.tiles[i.index][2], r = t.tilesets[s], i.width = r.tileWidth, i.height = r.tileHeight, r.tileProperties && r.tileProperties[i.index - r.firstgid] && (i.properties = n(i.properties, r.tileProperties[i.index - r.firstgid]))); } } };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(36); const s = i(118); const r = i(532); const o = i(533); t.exports = function (t, e, i) {
    if (e.layer.length === 0) return console.warn(`No layers found in the Weltmeister map: ${t}`), null; for (var a = 0, h = 0, l = 0; l < e.layer.length; l++)e.layer[l].width > a && (a = e.layer[l].width), e.layer[l].height > h && (h = e.layer[l].height); const u = new s({
      width: a, height: h, name: t, tileWidth: e.layer[0].tilesize, tileHeight: e.layer[0].tilesize, format: n.WELTMEISTER,
    }); return u.layers = r(e, i), u.tilesets = o(e), u;
  };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(117); const s = i(82); t.exports = function (t, e) {
    for (var i = [], r = 0; r < t.layer.length; r++) {
      for (var o = t.layer[r], a = new n({
          name: o.name, width: o.width, height: o.height, tileWidth: o.tilesize, tileHeight: o.tilesize, visible: o.visible === 1,
        }), h = [], l = [], u = 0; u < o.data.length; u++) { for (let c = 0; c < o.data[u].length; c++) { var d; const f = o.data[u][c] - 1; d = f > -1 ? new s(a, f, c, u, o.tilesize, o.tilesize) : e ? null : new s(a, -1, c, u, o.tilesize, o.tilesize), h.push(d); }l.push(h), h = []; }a.data = l, i.push(a);
    } return i;
  };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(119); t.exports = function (t) { for (var e = [], i = [], s = 0; s < t.layer.length; s++) { const r = t.layer[s]; const o = r.tilesetName; o !== '' && i.indexOf(o) === -1 && (i.push(o), e.push(new n(o, 0, r.tilesize, r.tilesize, 0, 0))); } return e; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(41); const r = i(535); const o = i(19); const a = i(36); const h = i(117); const l = i(356); const u = i(88); const c = i(536); const d = i(82); const f = i(155); const p = i(119); const g = new n({
    initialize(t, e) { this.scene = t, this.tileWidth = e.tileWidth, this.tileHeight = e.tileHeight, this.width = e.width, this.height = e.height, this.orientation = e.orientation, this.renderOrder = e.renderOrder, this.format = e.format, this.version = e.version, this.properties = e.properties, this.widthInPixels = e.widthInPixels, this.heightInPixels = e.heightInPixels, this.imageCollections = e.imageCollections, this.images = e.images, this.layers = e.layers, this.tilesets = e.tilesets, this.objects = e.objects, this.currentLayerIndex = 0; },
    setRenderOrder(t) { const e = ['right-down', 'left-down', 'right-up', 'left-up']; return typeof t === 'number' && (t = e[t]), e.indexOf(t) > -1 && (this.renderOrder = t), this; },
    addTilesetImage(t, e, i, n, s, r, o) { if (void 0 === t) return null; if (e == null && (e = t), !this.scene.sys.textures.exists(e)) return console.warn(`Invalid Tileset Image: ${e}`), null; const h = this.scene.sys.textures.get(e); const l = this.getTilesetIndex(t); if (l === null && this.format === a.TILED_JSON) return console.warn(`No data found for Tileset: ${t}`), null; let u = this.tilesets[l]; return u ? (u.setTileSize(i, n), u.setSpacing(s, r), u.setImage(h), u) : (void 0 === i && (i = this.tileWidth), void 0 === n && (n = this.tileHeight), void 0 === s && (s = 0), void 0 === r && (r = 0), void 0 === o && (o = 0), (u = new p(t, o, i, n, s, r)).setImage(h), this.tilesets.push(u), u); },
    convertLayerToStatic(t) { if ((t = this.getLayer(t)) === null) return null; const e = t.tilemapLayer; if (!(e && e instanceof r)) return null; const i = new c(e.scene, e.tilemap, e.layerIndex, e.tileset, e.x, e.y); return this.scene.sys.displayList.add(i), e.destroy(), i; },
    copy(t, e, i, n, s, r, o, a) { return a = this.getLayer(a), this._isStaticCall(a, 'copy') ? this : a !== null ? (f.Copy(t, e, i, n, s, r, o, a), this) : null; },
    createBlankDynamicLayer(t, e, i, n, s, o, a, l) {
      if (void 0 === i && (i = 0), void 0 === n && (n = 0), void 0 === s && (s = this.width), void 0 === o && (o = this.height), void 0 === a && (a = this.tileWidth), void 0 === l && (l = this.tileHeight), this.getLayerIndex(t) !== null) return console.warn(`Invalid Tilemap Layer ID: ${t}`), null; for (var u, c = new h({
          name: t, tileWidth: a, tileHeight: l, width: s, height: o,
        }), f = 0; f < o; f++) { u = []; for (let p = 0; p < s; p++)u.push(new d(c, -1, p, f, a, l, this.tileWidth, this.tileHeight)); c.data.push(u); } this.layers.push(c), this.currentLayerIndex = this.layers.length - 1; const g = new r(this.scene, this, this.currentLayerIndex, e, i, n); return g.setRenderOrder(this.renderOrder), this.scene.sys.displayList.add(g), g;
    },
    createDynamicLayer(t, e, i, n) { const s = this.getLayerIndex(t); if (s === null) return console.warn(`Invalid Tilemap Layer ID: ${t}`), typeof t === 'string' && console.warn(`Valid tilelayer names:\n\t${this.getTileLayerNames().join(',\n\t')}`), null; const o = this.layers[s]; if (o.tilemapLayer) return console.warn(`Tilemap Layer ID already exists:${t}`), null; this.currentLayerIndex = s, void 0 === i && (i = o.x), void 0 === n && (n = o.y); const a = new r(this.scene, this, s, e, i, n); return a.setRenderOrder(this.renderOrder), this.scene.sys.displayList.add(a), a; },
    createFromObjects(t, e, i, n) { void 0 === i && (i = {}), void 0 === n && (n = this.scene); const r = this.getObjectLayer(t); if (!r) return console.warn(`Cannot create from object. Invalid objectgroup name given: ${t}`), typeof layerID === 'string' && console.warn(`Valid objectgroup names:\n\t${this.getObjectLayerNames().join(',\n\t')}`), null; for (var a = r.objects, h = [], u = 0; u < a.length; u++) { let c = !1; const d = a[u]; if ((void 0 !== d.gid && typeof e === 'number' && d.gid === e || void 0 !== d.id && typeof e === 'number' && d.id === e || void 0 !== d.name && typeof e === 'string' && d.name === e) && (c = !0), c) { const f = o({}, i, d.properties); f.x = d.x, f.y = d.y; const p = n.make.sprite(f); p.name = d.name, d.width && (p.displayWidth = d.width), d.height && (p.displayHeight = d.height); const g = { x: p.originX * d.width, y: (p.originY - 1) * d.height }; if (d.rotation) { const v = s(d.rotation); l(g, v), p.rotation = v; } for (const m in p.x += g.x, p.y += g.y, void 0 === d.flippedHorizontal && void 0 === d.flippedVertical || p.setFlip(d.flippedHorizontal, d.flippedVertical), d.visible || (p.visible = !1), d.properties)p.hasOwnProperty(m) || p.setData(m, d.properties[m]); h.push(p); } } return h; },
    createFromTiles(t, e, i, n, s, r) { return (r = this.getLayer(r)) === null ? null : f.CreateFromTiles(t, e, i, n, s, r); },
    createStaticLayer(t, e, i, n) { const s = this.getLayerIndex(t); if (s === null) return console.warn(`Invalid Tilemap Layer ID: ${t}`), typeof t === 'string' && console.warn(`Valid tilelayer names:\n\t${this.getTileLayerNames().join(',\n\t')}`), null; if (this.layers[s].tilemapLayer) return console.warn(`Tilemap Layer ID already exists:${t}`), null; this.currentLayerIndex = s, void 0 === i && this.layers[s].x && (i = this.layers[s].x), void 0 === n && this.layers[s].y && (n = this.layers[s].y); const r = new c(this.scene, this, s, e, i, n); return r.setRenderOrder(this.renderOrder), this.scene.sys.displayList.add(r), r; },
    destroy() { this.removeAllLayers(), this.tilesets.length = 0, this.objects.length = 0, this.scene = void 0; },
    fill(t, e, i, n, s, r, o) { return (o = this.getLayer(o)) === null ? null : (this._isStaticCall(o, 'fill') || f.Fill(t, e, i, n, s, r, o), this); },
    filterObjects(t, e, i) { if (typeof t === 'string') { const n = t; if (!(t = this.getObjectLayer(t))) return console.warn(`No object layer found with the name: ${n}`), null; } return t.objects.filter(e, i); },
    filterTiles(t, e, i, n, s, r, o, a) { return (a = this.getLayer(a)) === null ? null : f.FilterTiles(t, e, i, n, s, r, o, a); },
    findByIndex(t, e, i, n) { return (n = this.getLayer(n)) === null ? null : f.FindByIndex(t, e, i, n); },
    findObject(t, e, i) { if (typeof t === 'string') { const n = t; if (!(t = this.getObjectLayer(t))) return console.warn(`No object layer found with the name: ${n}`), null; } return t.objects.find(e, i) || null; },
    findTile(t, e, i, n, s, r, o, a) { return (a = this.getLayer(a)) === null ? null : f.FindTile(t, e, i, n, s, r, o, a); },
    forEachTile(t, e, i, n, s, r, o, a) { return (a = this.getLayer(a)) === null ? null : (f.ForEachTile(t, e, i, n, s, r, o, a), this); },
    getImageIndex(t) { return this.getIndex(this.images, t); },
    getImageLayerNames() { return this.images && Array.isArray(this.images) ? this.images.map(((t) => t.name)) : []; },
    getIndex(t, e) { for (let i = 0; i < t.length; i++) if (t[i].name === e) return i; return null; },
    getLayer(t) { const e = this.getLayerIndex(t); return e !== null ? this.layers[e] : null; },
    getObjectLayer(t) { const e = this.getIndex(this.objects, t); return e !== null ? this.objects[e] : null; },
    getObjectLayerNames() { return this.objects && Array.isArray(this.objects) ? this.objects.map(((t) => t.name)) : []; },
    getLayerIndex(t) { return void 0 === t ? this.currentLayerIndex : typeof t === 'string' ? this.getLayerIndexByName(t) : typeof t === 'number' && t < this.layers.length ? t : t instanceof c || t instanceof r ? t.layerIndex : null; },
    getLayerIndexByName(t) { return this.getIndex(this.layers, t); },
    getTileAt(t, e, i, n) { return (n = this.getLayer(n)) === null ? null : f.GetTileAt(t, e, i, n); },
    getTileAtWorldXY(t, e, i, n, s) { return (s = this.getLayer(s)) === null ? null : f.GetTileAtWorldXY(t, e, i, n, s); },
    getTileLayerNames() { return this.layers && Array.isArray(this.layers) ? this.layers.map(((t) => t.name)) : []; },
    getTilesWithin(t, e, i, n, s, r) { return (r = this.getLayer(r)) === null ? null : f.GetTilesWithin(t, e, i, n, s, r); },
    getTilesWithinShape(t, e, i, n) { return (n = this.getLayer(n)) === null ? null : f.GetTilesWithinShape(t, e, i, n); },
    getTilesWithinWorldXY(t, e, i, n, s, r, o) { return (o = this.getLayer(o)) === null ? null : f.GetTilesWithinWorldXY(t, e, i, n, s, r, o); },
    getTileset(t) { const e = this.getIndex(this.tilesets, t); return e !== null ? this.tilesets[e] : null; },
    getTilesetIndex(t) { return this.getIndex(this.tilesets, t); },
    hasTileAt(t, e, i) { return (i = this.getLayer(i)) === null ? null : f.HasTileAt(t, e, i); },
    hasTileAtWorldXY(t, e, i, n) { return (n = this.getLayer(n)) === null ? null : f.HasTileAtWorldXY(t, e, i, n); },
    layer: { get() { return this.layers[this.currentLayerIndex]; }, set(t) { this.setLayer(t); } },
    putTileAt(t, e, i, n, s) { return s = this.getLayer(s), this._isStaticCall(s, 'putTileAt') || s === null ? null : f.PutTileAt(t, e, i, n, s); },
    putTileAtWorldXY(t, e, i, n, s, r) { return r = this.getLayer(r), this._isStaticCall(r, 'putTileAtWorldXY') || r === null ? null : f.PutTileAtWorldXY(t, e, i, n, s, r); },
    putTilesAt(t, e, i, n, s) { return s = this.getLayer(s), this._isStaticCall(s, 'putTilesAt') ? this : s === null ? null : (f.PutTilesAt(t, e, i, n, s), this); },
    randomize(t, e, i, n, s, r) { return r = this.getLayer(r), this._isStaticCall(r, 'randomize') ? this : r === null ? null : (f.Randomize(t, e, i, n, s, r), this); },
    calculateFacesAt(t, e, i) { return (i = this.getLayer(i)) === null ? null : (f.CalculateFacesAt(t, e, i), this); },
    calculateFacesWithin(t, e, i, n, s) { return (s = this.getLayer(s)) === null ? null : (f.CalculateFacesWithin(t, e, i, n, s), this); },
    removeLayer(t) { const e = this.getLayerIndex(t); if (e !== null) { u(this.layers, e); for (let i = e; i < this.layers.length; i++) this.layers[i].tilemapLayer && this.layers[i].tilemapLayer.layerIndex--; return this.currentLayerIndex === e && (this.currentLayerIndex = 0), this; } return null; },
    destroyLayer(t) { const e = this.getLayerIndex(t); return e !== null ? ((t = this.layers[e]).destroy(), u(this.layers, e), this.currentLayerIndex === e && (this.currentLayerIndex = 0), this) : null; },
    removeAllLayers() { for (var t = this.layers, e = 0; e < t.length; e++)t[e].tilemapLayer && t[e].tilemapLayer.destroy(!1); return t.length = 0, this.currentLayerIndex = 0, this; },
    removeTile(t, e, i) { void 0 === e && (e = -1), void 0 === i && (i = !0); const n = []; Array.isArray(t) || (t = [t]); for (let s = 0; s < t.length; s++) { const r = t[s]; n.push(this.removeTileAt(r.x, r.y, !0, i, r.tilemapLayer)), e > -1 && this.putTileAt(e, r.x, r.y, i, r.tilemapLayer); } return n; },
    removeTileAt(t, e, i, n, s) { return s = this.getLayer(s), this._isStaticCall(s, 'removeTileAt') || s === null ? null : f.RemoveTileAt(t, e, i, n, s); },
    removeTileAtWorldXY(t, e, i, n, s, r) { return r = this.getLayer(r), this._isStaticCall(r, 'removeTileAtWorldXY') || r === null ? null : f.RemoveTileAtWorldXY(t, e, i, n, s, r); },
    renderDebug(t, e, i) { return (i = this.getLayer(i)) === null ? null : (f.RenderDebug(t, e, i), this); },
    renderDebugFull(t, e) { for (let i = this.layers, n = 0; n < i.length; n++)f.RenderDebug(t, e, i[n]); return this; },
    replaceByIndex(t, e, i, n, s, r, o) { return o = this.getLayer(o), this._isStaticCall(o, 'replaceByIndex') ? this : o === null ? null : (f.ReplaceByIndex(t, e, i, n, s, r, o), this); },
    setCollision(t, e, i, n, s) { return (n = this.getLayer(n)) === null ? null : (f.SetCollision(t, e, i, n, s), this); },
    setCollisionBetween(t, e, i, n, s) { return (s = this.getLayer(s)) === null ? null : (f.SetCollisionBetween(t, e, i, n, s), this); },
    setCollisionByProperty(t, e, i, n) { return (n = this.getLayer(n)) === null ? null : (f.SetCollisionByProperty(t, e, i, n), this); },
    setCollisionByExclusion(t, e, i, n) { return (n = this.getLayer(n)) === null ? null : (f.SetCollisionByExclusion(t, e, i, n), this); },
    setCollisionFromCollisionGroup(t, e, i) { return (i = this.getLayer(i)) === null ? null : (f.SetCollisionFromCollisionGroup(t, e, i), this); },
    setTileIndexCallback(t, e, i, n) { return (n = this.getLayer(n)) === null ? null : (f.SetTileIndexCallback(t, e, i, n), this); },
    setTileLocationCallback(t, e, i, n, s, r, o) { return (o = this.getLayer(o)) === null ? null : (f.SetTileLocationCallback(t, e, i, n, s, r, o), this); },
    setLayer(t) { const e = this.getLayerIndex(t); return e !== null && (this.currentLayerIndex = e), this; },
    setBaseTileSize(t, e) { this.tileWidth = t, this.tileHeight = e, this.widthInPixels = this.width * t, this.heightInPixels = this.height * e; for (let i = 0; i < this.layers.length; i++) { this.layers[i].baseTileWidth = t, this.layers[i].baseTileHeight = e; for (let n = this.layers[i].data, s = this.layers[i].width, r = this.layers[i].height, o = 0; o < r; o++) for (let a = 0; a < s; a++) { const h = n[o][a]; h !== null && h.setSize(void 0, void 0, t, e); } } return this; },
    setLayerTileSize(t, e, i) { if ((i = this.getLayer(i)) === null) return this; i.tileWidth = t, i.tileHeight = e; for (let n = i.data, s = i.width, r = i.height, o = 0; o < r; o++) for (let a = 0; a < s; a++) { const h = n[o][a]; h !== null && h.setSize(t, e); } return this; },
    shuffle(t, e, i, n, s) { return s = this.getLayer(s), this._isStaticCall(s, 'shuffle') ? this : s === null ? null : (f.Shuffle(t, e, i, n, s), this); },
    swapByIndex(t, e, i, n, s, r, o) { return o = this.getLayer(o), this._isStaticCall(o, 'swapByIndex') ? this : o === null ? null : (f.SwapByIndex(t, e, i, n, s, r, o), this); },
    tileToWorldX(t, e, i) { return (i = this.getLayer(i)) === null ? null : f.TileToWorldX(t, e, i); },
    tileToWorldY(t, e, i) { return (i = this.getLayer(i)) === null ? null : f.TileToWorldY(t, e, i); },
    tileToWorldXY(t, e, i, n, s) { return (s = this.getLayer(s)) === null ? null : f.TileToWorldXY(t, e, i, n, s); },
    weightedRandomize(t, e, i, n, s, r) { return r = this.getLayer(r), this._isStaticCall(r, 'weightedRandomize') ? this : r === null ? null : (f.WeightedRandomize(t, e, i, n, s, r), this); },
    worldToTileX(t, e, i, n) { return (n = this.getLayer(n)) === null ? null : f.WorldToTileX(t, e, i, n); },
    worldToTileY(t, e, i, n) { return (n = this.getLayer(n)) === null ? null : f.WorldToTileY(t, e, i, n); },
    worldToTileXY(t, e, i, n, s, r) { return (r = this.getLayer(r)) === null ? null : f.WorldToTileXY(t, e, i, n, s, r); },
    _isStaticCall(t, e) { return t.tilemapLayer instanceof c && (console.warn(`${e}: You cannot change the tiles in a static tilemap layer`), !0); },
  }); t.exports = g;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(13); const r = i(1405); const o = i(14); const a = i(155); const h = new n({
    Extends: o, Mixins: [s.Alpha, s.BlendMode, s.ComputedSize, s.Depth, s.Flip, s.GetBounds, s.Origin, s.Pipeline, s.Transform, s.Visible, s.ScrollFactor, r], initialize(t, e, i, n, s, r) { o.call(this, t, 'DynamicTilemapLayer'), this.isTilemap = !0, this.tilemap = e, this.layerIndex = i, this.layer = e.layers[i], this.layer.tilemapLayer = this, this.tileset = [], this.culledTiles = [], this.skipCull = !1, this.tilesDrawn = 0, this.tilesTotal = this.layer.width * this.layer.height, this.cullPaddingX = 1, this.cullPaddingY = 1, this.cullCallback = a.CullTiles, this._renderOrder = 0, this.gidMap = [], this.setTilesets(n), this.setAlpha(this.layer.alpha), this.setPosition(s, r), this.setOrigin(), this.setSize(e.tileWidth * this.layer.width, e.tileHeight * this.layer.height), this.initPipeline('TextureTintPipeline'); }, setTilesets(t) { const e = []; const i = []; const n = this.tilemap; Array.isArray(t) || (t = [t]); for (let s = 0; s < t.length; s++) { let r = t[s]; if (typeof r === 'string' && (r = n.getTileset(r)), r) { i.push(r); for (let o = r.firstgid, a = 0; a < r.total; a++)e[o + a] = r; } } this.gidMap = e, this.tileset = i; }, setRenderOrder(t) { return typeof t === 'string' && (t = ['right-down', 'left-down', 'right-up', 'left-up'].indexOf(t)), t >= 0 && t < 4 && (this._renderOrder = t), this; }, calculateFacesAt(t, e) { return a.CalculateFacesAt(t, e, this.layer), this; }, calculateFacesWithin(t, e, i, n) { return a.CalculateFacesWithin(t, e, i, n, this.layer), this; }, createFromTiles(t, e, i, n, s) { return a.CreateFromTiles(t, e, i, n, s, this.layer); }, cull(t) { return this.cullCallback(this.layer, t, this.culledTiles, this._renderOrder); }, copy(t, e, i, n, s, r, o) { return a.Copy(t, e, i, n, s, r, o, this.layer), this; }, destroy(t) { void 0 === t && (t = !0), this.tilemap && (this.layer.tilemapLayer === this && (this.layer.tilemapLayer = void 0), t && this.tilemap.removeLayer(this), this.tilemap = void 0, this.layer = void 0, this.culledTiles.length = 0, this.cullCallback = null, this.gidMap = [], this.tileset = [], o.prototype.destroy.call(this)); }, fill(t, e, i, n, s, r) { return a.Fill(t, e, i, n, s, r, this.layer), this; }, filterTiles(t, e, i, n, s, r, o) { return a.FilterTiles(t, e, i, n, s, r, o, this.layer); }, findByIndex(t, e, i) { return a.FindByIndex(t, e, i, this.layer); }, findTile(t, e, i, n, s, r, o) { return a.FindTile(t, e, i, n, s, r, o, this.layer); }, forEachTile(t, e, i, n, s, r, o) { return a.ForEachTile(t, e, i, n, s, r, o, this.layer), this; }, getTileAt(t, e, i) { return a.GetTileAt(t, e, i, this.layer); }, getTileAtWorldXY(t, e, i, n) { return a.GetTileAtWorldXY(t, e, i, n, this.layer); }, getTilesWithin(t, e, i, n, s) { return a.GetTilesWithin(t, e, i, n, s, this.layer); }, getTilesWithinShape(t, e, i) { return a.GetTilesWithinShape(t, e, i, this.layer); }, getTilesWithinWorldXY(t, e, i, n, s, r) { return a.GetTilesWithinWorldXY(t, e, i, n, s, r, this.layer); }, hasTileAt(t, e) { return a.HasTileAt(t, e, this.layer); }, hasTileAtWorldXY(t, e, i) { return a.HasTileAtWorldXY(t, e, i, this.layer); }, putTileAt(t, e, i, n) { return a.PutTileAt(t, e, i, n, this.layer); }, putTileAtWorldXY(t, e, i, n, s) { return a.PutTileAtWorldXY(t, e, i, n, s, this.layer); }, putTilesAt(t, e, i, n) { return a.PutTilesAt(t, e, i, n, this.layer), this; }, randomize(t, e, i, n, s) { return a.Randomize(t, e, i, n, s, this.layer), this; }, removeTileAt(t, e, i, n) { return a.RemoveTileAt(t, e, i, n, this.layer); }, removeTileAtWorldXY(t, e, i, n, s) { return a.RemoveTileAtWorldXY(t, e, i, n, s, this.layer); }, renderDebug(t, e) { return a.RenderDebug(t, e, this.layer), this; }, replaceByIndex(t, e, i, n, s, r) { return a.ReplaceByIndex(t, e, i, n, s, r, this.layer), this; }, setSkipCull(t) { return void 0 === t && (t = !0), this.skipCull = t, this; }, setCullPadding(t, e) { return void 0 === t && (t = 1), void 0 === e && (e = 1), this.cullPaddingX = t, this.cullPaddingY = e, this; }, setCollision(t, e, i, n) { return a.SetCollision(t, e, i, this.layer, n), this; }, setCollisionBetween(t, e, i, n) { return a.SetCollisionBetween(t, e, i, n, this.layer), this; }, setCollisionByProperty(t, e, i) { return a.SetCollisionByProperty(t, e, i, this.layer), this; }, setCollisionByExclusion(t, e, i) { return a.SetCollisionByExclusion(t, e, i, this.layer), this; }, setCollisionFromCollisionGroup(t, e) { return a.SetCollisionFromCollisionGroup(t, e, this.layer), this; }, setTileIndexCallback(t, e, i) { return a.SetTileIndexCallback(t, e, i, this.layer), this; }, setTileLocationCallback(t, e, i, n, s, r) { return a.SetTileLocationCallback(t, e, i, n, s, r, this.layer), this; }, shuffle(t, e, i, n) { return a.Shuffle(t, e, i, n, this.layer), this; }, swapByIndex(t, e, i, n, s, r) { return a.SwapByIndex(t, e, i, n, s, r, this.layer), this; }, tileToWorldX(t, e) { return a.TileToWorldX(t, e, this.layer); }, tileToWorldY(t, e) { return a.TileToWorldY(t, e, this.layer); }, tileToWorldXY(t, e, i, n) { return a.TileToWorldXY(t, e, i, n, this.layer); }, weightedRandomize(t, e, i, n, s) { return a.WeightedRandomize(t, e, i, n, s, this.layer), this; }, worldToTileX(t, e, i) { return a.WorldToTileX(t, e, i, this.layer); }, worldToTileY(t, e, i) { return a.WorldToTileY(t, e, i, this.layer); }, worldToTileXY(t, e, i, n, s) { return a.WorldToTileXY(t, e, i, n, s, this.layer); },
  }); t.exports = h;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(13); const r = i(22); const o = i(14); const a = i(1408); const h = i(155); const l = i(33); const u = i(11); const c = new n({
    Extends: o, Mixins: [s.Alpha, s.BlendMode, s.ComputedSize, s.Depth, s.Flip, s.GetBounds, s.Origin, s.Pipeline, s.Transform, s.Visible, s.ScrollFactor, a], initialize(t, e, i, n, s, a) { o.call(this, t, 'StaticTilemapLayer'), this.isTilemap = !0, this.tilemap = e, this.layerIndex = i, this.layer = e.layers[i], this.layer.tilemapLayer = this, this.tileset = [], this.culledTiles = [], this.skipCull = !1, this.tilesDrawn = 0, this.tilesTotal = this.layer.width * this.layer.height, this.cullPaddingX = 1, this.cullPaddingY = 1, this.cullCallback = h.CullTiles, this.renderer = t.sys.game.renderer, this.vertexBuffer = [], this.bufferData = [], this.vertexViewF32 = [], this.vertexViewU32 = [], this.dirty = [], this.vertexCount = [], this._renderOrder = 0, this._tempMatrix = new l(), this.gidMap = [], this.setTilesets(n), this.setAlpha(this.layer.alpha), this.setPosition(s, a), this.setOrigin(), this.setSize(e.tileWidth * this.layer.width, e.tileHeight * this.layer.height), this.updateVBOData(), this.initPipeline('TextureTintPipeline'), t.sys.game.events.on(r.CONTEXT_RESTORED, (function () { this.updateVBOData(); }), this); }, setTilesets(t) { const e = []; const i = []; const n = this.tilemap; Array.isArray(t) || (t = [t]); for (let s = 0; s < t.length; s++) { let r = t[s]; if (typeof r === 'string' && (r = n.getTileset(r)), r) { i.push(r); for (let o = r.firstgid, a = 0; a < r.total; a++)e[o + a] = r; } } this.gidMap = e, this.tileset = i; }, updateVBOData() { for (let t = 0; t < this.tileset.length; t++) this.dirty[t] = !0, this.vertexCount[t] = 0, this.vertexBuffer[t] = null, this.bufferData[t] = null, this.vertexViewF32[t] = null, this.vertexViewU32[t] = null; return this; }, upload(t, e) { const i = this.renderer; const n = i.gl; const s = i.pipelines.TextureTintPipeline; if (this.dirty[e]) { let r; let o; let a; const h = this.tileset[e]; const l = this.layer.width; const u = this.layer.height; const c = h.image.source[0].width; const d = h.image.source[0].height; const f = this.layer.data; const p = this._renderOrder; const g = h.firstgid; const v = h.firstgid + h.total; let m = this.vertexBuffer[e]; let y = this.bufferData[e]; let x = -1; const T = l * u * s.vertexSize * 6; if (this.vertexCount[e] = 0, y === null && (y = new ArrayBuffer(T), this.bufferData[e] = y, this.vertexViewF32[e] = new Float32Array(y), this.vertexViewU32[e] = new Uint32Array(y)), p === 0) for (o = 0; o < u; o++) for (a = 0; a < l; a++)!(r = f[o][a]) || r.index < g || r.index > v || !r.visible || (x = this.batchTile(x, r, h, c, d, t, e)); else if (p === 1) for (o = 0; o < u; o++) for (a = l - 1; a >= 0; a--)!(r = f[o][a]) || r.index < g || r.index > v || !r.visible || (x = this.batchTile(x, r, h, c, d, t, e)); else if (p === 2) for (o = u - 1; o >= 0; o--) for (a = 0; a < l; a++)!(r = f[o][a]) || r.index < g || r.index > v || !r.visible || (x = this.batchTile(x, r, h, c, d, t, e)); else if (p === 3) for (o = u - 1; o >= 0; o--) for (a = l - 1; a >= 0; a--)!(r = f[o][a]) || r.index < g || r.index > v || !r.visible || (x = this.batchTile(x, r, h, c, d, t, e)); this.dirty[e] = !1, m === null ? (m = i.createVertexBuffer(y, n.STATIC_DRAW), this.vertexBuffer[e] = m) : (i.setVertexBuffer(m), n.bufferSubData(n.ARRAY_BUFFER, 0, y)); } return this; }, batchTile(t, e, i, n, s, r, o) { const a = i.getTileTextureCoordinates(e.index); if (!a) return t; let h = i.tileWidth; let l = i.tileHeight; const c = h / 2; const d = l / 2; const f = a.x / n; const p = a.y / s; const g = (a.x + h) / n; const v = (a.y + l) / s; const m = this._tempMatrix; let y = -c; let x = -d; e.flipX && (h *= -1, y += i.tileWidth), e.flipY && (l *= -1, x += i.tileHeight); const T = y + h; const w = x + l; m.applyITRS(c + e.pixelX, d + e.pixelY, e.rotation, 1, 1); const b = u.getTintAppendFloatAlpha(16777215, r.alpha * this.alpha * e.alpha); let E = m.getX(y, x); let S = m.getY(y, x); let A = m.getX(y, w); let _ = m.getY(y, w); let C = m.getX(T, w); let M = m.getY(T, w); let P = m.getX(T, x); let O = m.getY(T, x); r.roundPixels && (E = Math.round(E), S = Math.round(S), A = Math.round(A), _ = Math.round(_), C = Math.round(C), M = Math.round(M), P = Math.round(P), O = Math.round(O)); const R = this.vertexViewF32[o]; const L = this.vertexViewU32[o]; return R[++t] = E, R[++t] = S, R[++t] = f, R[++t] = p, R[++t] = 0, L[++t] = b, R[++t] = A, R[++t] = _, R[++t] = f, R[++t] = v, R[++t] = 0, L[++t] = b, R[++t] = C, R[++t] = M, R[++t] = g, R[++t] = v, R[++t] = 0, L[++t] = b, R[++t] = E, R[++t] = S, R[++t] = f, R[++t] = p, R[++t] = 0, L[++t] = b, R[++t] = C, R[++t] = M, R[++t] = g, R[++t] = v, R[++t] = 0, L[++t] = b, R[++t] = P, R[++t] = O, R[++t] = g, R[++t] = p, R[++t] = 0, L[++t] = b, this.vertexCount[o] += 6, t; }, setRenderOrder(t) { if (typeof t === 'string' && (t = ['right-down', 'left-down', 'right-up', 'left-up'].indexOf(t)), t >= 0 && t < 4) { this._renderOrder = t; for (let e = 0; e < this.tileset.length; e++) this.dirty[e] = !0; } return this; }, calculateFacesAt(t, e) { return h.CalculateFacesAt(t, e, this.layer), this; }, calculateFacesWithin(t, e, i, n) { return h.CalculateFacesWithin(t, e, i, n, this.layer), this; }, createFromTiles(t, e, i, n, s) { return h.CreateFromTiles(t, e, i, n, s, this.layer); }, cull(t) { return this.cullCallback(this.layer, t, this.culledTiles); }, setSkipCull(t) { return void 0 === t && (t = !0), this.skipCull = t, this; }, setCullPadding(t, e) { return void 0 === t && (t = 1), void 0 === e && (e = 1), this.cullPaddingX = t, this.cullPaddingY = e, this; }, findByIndex(t, e, i) { return h.FindByIndex(t, e, i, this.layer); }, findTile(t, e, i, n, s, r, o) { return h.FindTile(t, e, i, n, s, r, o, this.layer); }, filterTiles(t, e, i, n, s, r, o) { return h.FilterTiles(t, e, i, n, s, r, o, this.layer); }, forEachTile(t, e, i, n, s, r, o) { return h.ForEachTile(t, e, i, n, s, r, o, this.layer), this; }, getTileAt(t, e, i) { return h.GetTileAt(t, e, i, this.layer); }, getTileAtWorldXY(t, e, i, n) { return h.GetTileAtWorldXY(t, e, i, n, this.layer); }, getTilesWithin(t, e, i, n, s) { return h.GetTilesWithin(t, e, i, n, s, this.layer); }, getTilesWithinWorldXY(t, e, i, n, s, r) { return h.GetTilesWithinWorldXY(t, e, i, n, s, r, this.layer); }, getTilesWithinShape(t, e, i) { return h.GetTilesWithinShape(t, e, i, this.layer); }, hasTileAt(t, e) { return h.HasTileAt(t, e, this.layer); }, hasTileAtWorldXY(t, e, i) { return h.HasTileAtWorldXY(t, e, i, this.layer); }, renderDebug(t, e) { return h.RenderDebug(t, e, this.layer), this; }, setCollision(t, e, i, n) { return h.SetCollision(t, e, i, this.layer, n), this; }, setCollisionBetween(t, e, i, n) { return h.SetCollisionBetween(t, e, i, n, this.layer), this; }, setCollisionByProperty(t, e, i) { return h.SetCollisionByProperty(t, e, i, this.layer), this; }, setCollisionByExclusion(t, e, i) { return h.SetCollisionByExclusion(t, e, i, this.layer), this; }, setTileIndexCallback(t, e, i) { return h.SetTileIndexCallback(t, e, i, this.layer), this; }, setCollisionFromCollisionGroup(t, e) { return h.SetCollisionFromCollisionGroup(t, e, this.layer), this; }, setTileLocationCallback(t, e, i, n, s, r) { return h.SetTileLocationCallback(t, e, i, n, s, r, this.layer), this; }, tileToWorldX(t, e) { return h.TileToWorldX(t, e, this.layer); }, tileToWorldY(t, e) { return h.TileToWorldY(t, e, this.layer); }, tileToWorldXY(t, e, i, n) { return h.TileToWorldXY(t, e, i, n, this.layer); }, worldToTileX(t, e, i) { return h.WorldToTileX(t, e, i, this.layer); }, worldToTileY(t, e, i) { return h.WorldToTileY(t, e, i, this.layer); }, worldToTileXY(t, e, i, n, s) { return h.WorldToTileXY(t, e, i, n, s, this.layer); }, destroy(t) { if (void 0 === t && (t = !0), this.tilemap) { this.layer.tilemapLayer === this && (this.layer.tilemapLayer = void 0), t && this.tilemap.removeLayer(this), this.tilemap = void 0, this.layer = void 0, this.culledTiles.length = 0, this.cullCallback = null; for (let e = 0; e < this.tileset.length; e++) this.dirty[e] = !0, this.vertexCount[e] = 0, this.vertexBuffer[e] = null, this.bufferData[e] = null, this.vertexViewF32[e] = null, this.vertexViewU32[e] = null; this.gidMap = [], this.tileset = [], o.prototype.destroy.call(this); } },
  }); t.exports = c;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(2); const r = new n({
    initialize(t) { this.delay = 0, this.repeat = 0, this.repeatCount = 0, this.loop = !1, this.callback, this.callbackScope, this.args, this.timeScale = 1, this.startAt = 0, this.elapsed = 0, this.paused = !1, this.hasDispatched = !1, this.reset(t); }, reset(t) { return this.delay = s(t, 'delay', 0), this.repeat = s(t, 'repeat', 0), this.loop = s(t, 'loop', !1), this.callback = s(t, 'callback', void 0), this.callbackScope = s(t, 'callbackScope', this.callback), this.args = s(t, 'args', []), this.timeScale = s(t, 'timeScale', 1), this.startAt = s(t, 'startAt', 0), this.paused = s(t, 'paused', !1), this.elapsed = this.startAt, this.hasDispatched = !1, this.repeatCount = this.repeat === -1 || this.loop ? 999999999999 : this.repeat, this; }, getProgress() { return this.elapsed / this.delay; }, getOverallProgress() { if (this.repeat > 0) { const t = this.delay + this.delay * this.repeat; return (this.elapsed + this.delay * (this.repeat - this.repeatCount)) / t; } return this.getProgress(); }, getRepeatCount() { return this.repeatCount; }, getElapsed() { return this.elapsed; }, getElapsedSeconds() { return 0.001 * this.elapsed; }, remove(t) { void 0 === t && (t = !1), this.elapsed = this.delay, this.hasDispatched = !t, this.repeatCount = 0; }, destroy() { this.callback = void 0, this.callbackScope = void 0, this.args = []; },
  }); t.exports = r;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(1417); t.exports = function (t) { let e; const i = []; if (t.hasOwnProperty('props')) for (e in t.props)e.substr(0, 1) !== '_' && i.push({ key: e, value: t.props[e] }); else for (e in t)n.indexOf(e) === -1 && e.substr(0, 1) !== '_' && i.push({ key: e, value: t[e] }); return i; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(6); t.exports = function (t) { let e = n(t, 'tweens', null); return e === null ? [] : (typeof e === 'function' && (e = e.call()), Array.isArray(e) || (e = [e]), e); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(259); const s = i(15); const r = i(99); const o = i(76); const a = i(159); const h = i(6); const l = i(258); const u = i(260); const c = i(262); t.exports = function (t, e, i) { void 0 === i && (i = n); const d = h(e, 'from', 0); const f = h(e, 'to', 1); const p = [{ value: d }]; const g = a(e, 'delay', i.delay); const v = a(e, 'duration', i.duration); const m = h(e, 'easeParams', i.easeParams); const y = o(h(e, 'ease', i.ease), m); const x = a(e, 'hold', i.hold); const T = a(e, 'repeat', i.repeat); const w = a(e, 'repeatDelay', i.repeatDelay); const b = r(e, 'yoyo', i.yoyo); const E = []; const S = l('value', f); const A = c(p[0], 0, 'value', S.getEnd, S.getStart, S.getActive, y, g, v, b, x, T, w, !1, !1); A.start = d, A.current = d, A.to = f, E.push(A); const _ = new u(t, E, p); _.offset = s(e, 'offset', null), _.completeDelay = s(e, 'completeDelay', 0), _.loop = Math.round(s(e, 'loop', 0)), _.loopDelay = Math.round(s(e, 'loopDelay', 0)), _.paused = r(e, 'paused', !1), _.useFrames = r(e, 'useFrames', !1); for (let C = h(e, 'callbackScope', _), M = [_, null], P = u.TYPES, O = 0; O < P.length; O++) { const R = P[O]; const L = h(e, R, !1); if (L) { const D = h(e, `${R}Scope`, C); const k = h(e, `${R}Params`, []); _.setCallback(R, L, M.concat(k), D); } } return _; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(76); const s = i(6); const r = i(16); t.exports = function (t, e) { void 0 === e && (e = {}); let i = s(e, 'start', 0); const o = s(e, 'ease', null); const a = s(e, 'grid', null); const h = s(e, 'from', 0); const l = h === 'first'; const u = h === 'center'; const c = h === 'last'; const d = typeof h === 'number'; const f = Array.isArray(t); const p = f ? parseFloat(t[0]) : parseFloat(t); const g = f ? parseFloat(t[1]) : 0; const v = Math.max(p, g); if (f && (i += p), a) { var m = a[0]; var y = a[1]; let x = 0; let T = 0; let w = 0; let b = 0; var E = []; c ? (x = m - 1, T = y - 1) : d ? (x = h % m, T = Math.floor(h / m)) : u && (x = (m - 1) / 2, T = (y - 1) / 2); for (var S = r.MIN_SAFE_INTEGER, A = 0; A < y; A++) { E[A] = []; for (let _ = 0; _ < m; _++) { w = x - _, b = T - A; const C = Math.sqrt(w * w + b * b); C > S && (S = C), E[A][_] = C; } } } const M = o ? n(o) : null; return a ? function (t, e, n, s) { let r; let o = 0; const a = s % m; const h = Math.floor(s / m); if (a >= 0 && a < m && h >= 0 && h < y && (o = E[h][a]), f) { const l = g - p; r = M ? o / S * l * M(o / S) : o / S * l; } else r = M ? o * p * M(o / S) : o * p; return r + i; } : function (t, e, n, s, r) { let o; let a; let m; (r--, l ? o = s : u ? o = Math.abs(r / 2 - s) : c ? o = r - s : d && (o = Math.abs(h - s)), f) ? (m = u ? (g - p) / r * (2 * o) : (g - p) / r * o, a = M ? m * M(o / r) : m) : a = M ? r * v * M(o / r) : o * p; return a + i; }; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(74); const s = i(259); const r = i(15); const o = i(99); const a = i(76); const h = i(159); const l = i(257); const u = i(539); const c = i(6); const d = i(543); const f = i(160); t.exports = function (t, e) { const i = new d(t); const p = u(e); if (p.length === 0) return i.paused = !0, i; const g = n(s); g.targets = l(e); const v = r(e, 'totalDuration', 0); g.duration = v > 0 ? Math.floor(v / p.length) : h(e, 'duration', g.duration), g.delay = h(e, 'delay', g.delay), g.easeParams = c(e, 'easeParams', g.easeParams), g.ease = a(c(e, 'ease', g.ease), g.easeParams), g.hold = h(e, 'hold', g.hold), g.repeat = h(e, 'repeat', g.repeat), g.repeatDelay = h(e, 'repeatDelay', g.repeatDelay), g.yoyo = o(e, 'yoyo', g.yoyo), g.flipX = o(e, 'flipX', g.flipX), g.flipY = o(e, 'flipY', g.flipY); for (let m = 0; m < p.length; m++)i.queue(f(i, p[m], g)); i.completeDelay = r(e, 'completeDelay', 0), i.loop = Math.round(r(e, 'loop', 0)), i.loopDelay = Math.round(r(e, 'loopDelay', 0)), i.paused = o(e, 'paused', !1), i.useFrames = o(e, 'useFrames', !1); const y = c(e, 'callbackScope', i); const x = [i]; const T = c(e, 'onStart', !1); if (T) { const w = c(e, 'onStartScope', y); const b = c(e, 'onStartParams', []); i.setCallback('onStart', T, x.concat(b), w); } const E = c(e, 'onUpdate', !1); if (E) { const S = c(e, 'onUpdateScope', y); const A = c(e, 'onUpdateParams', []); i.setCallback('onUpdate', E, x.concat(A), S); } const _ = c(e, 'onLoop', !1); if (_) { const C = c(e, 'onLoopScope', y); const M = c(e, 'onLoopParams', []); i.setCallback('onLoop', _, x.concat(M), C); } const P = c(e, 'onYoyo', !1); if (P) { const O = c(e, 'onYoyoScope', y); const R = c(e, 'onYoyoParams', []); i.setCallback('onYoyo', P, x.concat(null, R), O); } const L = c(e, 'onComplete', !1); if (L) { const D = c(e, 'onCompleteScope', y); const k = c(e, 'onCompleteParams', []); i.setCallback('onComplete', L, x.concat(k), D); } return i; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(10); const r = i(261); const o = i(160); const a = i(100); var h = new n({
    Extends: s,
    initialize(t) {
      s.call(this), this.manager = t, this.isTimeline = !0, this.data = [], this.totalData = 0, this.useFrames = !1, this.timeScale = 1, this.loop = 0, this.loopDelay = 0, this.loopCounter = 0, this.completeDelay = 0, this.countdown = 0, this.state = a.PENDING_ADD, this._pausedState = a.PENDING_ADD, this.paused = !1, this.elapsed = 0, this.totalElapsed = 0, this.duration = 0, this.progress = 0, this.totalDuration = 0, this.totalProgress = 0, this.callbacks = {
        onComplete: null, onLoop: null, onStart: null, onUpdate: null, onYoyo: null,
      }, this.callbackScope;
    },
    dispatchTimelineEvent(t, e) { this.emit(t, this), e && e.func.apply(e.scope, e.params); },
    setTimeScale(t) { return this.timeScale = t, this; },
    getTimeScale() { return this.timeScale; },
    isPlaying() { return this.state === a.ACTIVE; },
    add(t) { return this.queue(o(this, t)); },
    queue(t) { return this.isPlaying() || (t.parent = this, t.parentIsTimeline = !0, this.data.push(t), this.totalData = this.data.length), this; },
    hasOffset(t) { return t.offset !== null; },
    isOffsetAbsolute(t) { return typeof t === 'number'; },
    isOffsetRelative(t) { if (typeof t === 'string') { const e = t[0]; if (e === '-' || e === '+') return !0; } return !1; },
    getRelativeOffset(t, e) { const i = t[0]; const n = parseFloat(t.substr(2)); let s = e; switch (i) { case '+': s += n; break; case '-': s -= n; } return Math.max(0, s); },
    calcDuration() { for (var t = 0, e = 0, i = 0, n = 0; n < this.totalData; n++) { const s = this.data[n]; s.init(), this.hasOffset(s) ? this.isOffsetAbsolute(s.offset) ? (s.calculatedOffset = s.offset, s.offset === 0 && (i = 0)) : this.isOffsetRelative(s.offset) && (s.calculatedOffset = this.getRelativeOffset(s.offset, t)) : s.calculatedOffset = i, t = s.totalDuration + s.calculatedOffset, e += s.totalDuration, i += s.totalDuration; } this.duration = e, this.loopCounter = this.loop === -1 ? 999999999999 : this.loop, this.loopCounter > 0 ? this.totalDuration = this.duration + this.completeDelay + (this.duration + this.loopDelay) * this.loopCounter : this.totalDuration = this.duration + this.completeDelay; },
    init() { return this.calcDuration(), this.progress = 0, this.totalProgress = 0, !this.paused || (this.state = a.PAUSED, !1); },
    resetTweens(t) { for (let e = 0; e < this.totalData; e++) { this.data[e].play(t); } },
    setCallback(t, e, i, n) { return h.TYPES.indexOf(t) !== -1 && (this.callbacks[t] = { func: e, scope: n, params: i }), this; },
    makeActive(t) { return this.manager.makeActive(t); },
    play() { if (this.state !== a.ACTIVE) { if (this.paused) return this.paused = !1, void this.manager.makeActive(this); this.resetTweens(!1), this.state = a.ACTIVE, this.dispatchTimelineEvent(r.TIMELINE_START, this.callbacks.onStart); } },
    nextState() { this.loopCounter > 0 ? (this.elapsed = 0, this.progress = 0, this.loopCounter--, this.resetTweens(!0), this.loopDelay > 0 ? (this.countdown = this.loopDelay, this.state = a.LOOP_DELAY) : (this.state = a.ACTIVE, this.dispatchTimelineEvent(r.TIMELINE_LOOP, this.callbacks.onLoop))) : this.completeDelay > 0 ? (this.state = a.COMPLETE_DELAY, this.countdown = this.completeDelay) : (this.state = a.PENDING_REMOVE, this.dispatchTimelineEvent(r.TIMELINE_COMPLETE, this.callbacks.onComplete)); },
    update(t, e) { if (this.state !== a.PAUSED) { switch (this.useFrames && (e = 1 * this.manager.timeScale), e *= this.timeScale, this.elapsed += e, this.progress = Math.min(this.elapsed / this.duration, 1), this.totalElapsed += e, this.totalProgress = Math.min(this.totalElapsed / this.totalDuration, 1), this.state) { case a.ACTIVE: for (var i = this.totalData, n = 0; n < this.totalData; n++) { this.data[n].update(t, e) && i--; } this.dispatchTimelineEvent(r.TIMELINE_UPDATE, this.callbacks.onUpdate), i === 0 && this.nextState(); break; case a.LOOP_DELAY: this.countdown -= e, this.countdown <= 0 && (this.state = a.ACTIVE, this.dispatchTimelineEvent(r.TIMELINE_LOOP, this.callbacks.onLoop)); break; case a.COMPLETE_DELAY: this.countdown -= e, this.countdown <= 0 && (this.state = a.PENDING_REMOVE, this.dispatchTimelineEvent(r.TIMELINE_COMPLETE, this.callbacks.onComplete)); } return this.state === a.PENDING_REMOVE; } },
    stop() { this.state = a.PENDING_REMOVE; },
    pause() { if (this.state !== a.PAUSED) return this.paused = !0, this._pausedState = this.state, this.state = a.PAUSED, this.emit(r.TIMELINE_PAUSE, this), this; },
    resume() { return this.state === a.PAUSED && (this.paused = !1, this.state = this._pausedState, this.emit(r.TIMELINE_RESUME, this)), this; },
    hasTarget(t) { for (let e = 0; e < this.data.length; e++) if (this.data[e].hasTarget(t)) return !0; return !1; },
    destroy() { for (let t = 0; t < this.data.length; t++) this.data[t].stop(); },
  }); h.TYPES = ['onStart', 'onUpdate', 'onLoop', 'onComplete', 'onYoyo'], t.exports = h;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2018 Photon Storm Ltd.
 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
 */
  const n = i(263); const s = i(0); const r = new (i(87))(); const o = new s({
    Extends: n, initialize(t, e, i) { void 0 === e && (e = 0), void 0 === i && (i = 0), n.call(this, t), this.viewportWidth = e, this.viewportHeight = i, this._zoom = 1, this.near = 0, this.update(); }, setToOrtho(t, e, i) { void 0 === e && (e = this.viewportWidth), void 0 === i && (i = this.viewportHeight); const n = this.zoom; return this.up.set(0, t ? -1 : 1, 0), this.direction.set(0, 0, t ? 1 : -1), this.position.set(n * e / 2, n * i / 2, 0), this.viewportWidth = e, this.viewportHeight = i, this.update(); }, update() { const t = this.viewportWidth; const e = this.viewportHeight; const i = Math.abs(this.near); const n = Math.abs(this.far); const s = this.zoom; return t === 0 || e === 0 || (this.projection.ortho(s * -t / 2, s * t / 2, s * -e / 2, s * e / 2, i, n), r.copy(this.position).add(this.direction), this.view.lookAt(this.position, r, this.up), this.combined.copy(this.projection).multiply(this.view), this.invProjectionView.copy(this.combined).invert(), this.billboardMatrixDirty = !0, this.updateChildren()), this; }, zoom: { get() { return this._zoom; }, set(t) { this._zoom = t, this.update(); } },
  }); t.exports = o;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2018 Photon Storm Ltd.
 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
 */
  const n = i(263); const s = i(0); const r = new (i(87))(); const o = new s({
    Extends: n, initialize(t, e, i, s) { void 0 === e && (e = 80), void 0 === i && (i = 0), void 0 === s && (s = 0), n.call(this, t), this.viewportWidth = i, this.viewportHeight = s, this.fieldOfView = e * Math.PI / 180, this.update(); }, setFOV(t) { return this.fieldOfView = t * Math.PI / 180, this; }, update() { const t = this.viewportWidth / this.viewportHeight; return this.projection.perspective(this.fieldOfView, t, Math.abs(this.near), Math.abs(this.far)), r.copy(this.position).add(this.direction), this.view.lookAt(this.position, r, this.up), this.combined.copy(this.projection).multiply(this.view), this.invProjectionView.copy(this.combined).invert(), this.billboardMatrixDirty = !0, this.updateChildren(), this; },
  }); t.exports = o;
}, function (t, e) { let i; i = (function () { return this; }()); try { i = i || new Function('return this')(); } catch (t) { typeof window === 'object' && (i = window); }t.exports = i; }, function (t, e, i) { i(548), i(549), i(550), i(551), i(552), i(553), i(554), i(555); }, function (t, e) {
  Array.prototype.forEach || (Array.prototype.forEach = function (t) {
    if (this == null) throw new TypeError(); const e = Object(this); const i = e.length >>> 0; if (typeof t !== 'function') throw new TypeError(); for (let n = arguments.length >= 2 ? arguments[1] : void 0, s = 0; s < i; s++)s in e && t.call(n, e[s], s, e);
  });
}, function (t, e) { Array.isArray || (Array.isArray = function (t) { return Object.prototype.toString.call(t) === '[object Array]'; }); }, function (t, e) { !(function () { function t(t) { t && (t.setTargetAtTime || (t.setTargetAtTime = t.setTargetValueAtTime)); }window.hasOwnProperty('webkitAudioContext') && !window.hasOwnProperty('AudioContext') && (window.AudioContext = webkitAudioContext, AudioContext.prototype.hasOwnProperty('createGain') || (AudioContext.prototype.createGain = AudioContext.prototype.createGainNode), AudioContext.prototype.hasOwnProperty('createDelay') || (AudioContext.prototype.createDelay = AudioContext.prototype.createDelayNode), AudioContext.prototype.hasOwnProperty('createScriptProcessor') || (AudioContext.prototype.createScriptProcessor = AudioContext.prototype.createJavaScriptNode), AudioContext.prototype.hasOwnProperty('createPeriodicWave') || (AudioContext.prototype.createPeriodicWave = AudioContext.prototype.createWaveTable), AudioContext.prototype.internal_createGain = AudioContext.prototype.createGain, AudioContext.prototype.createGain = function () { const e = this.internal_createGain(); return t(e.gain), e; }, AudioContext.prototype.internal_createDelay = AudioContext.prototype.createDelay, AudioContext.prototype.createDelay = function (e) { const i = e ? this.internal_createDelay(e) : this.internal_createDelay(); return t(i.delayTime), i; }, AudioContext.prototype.internal_createBufferSource = AudioContext.prototype.createBufferSource, AudioContext.prototype.createBufferSource = function () { const e = this.internal_createBufferSource(); return e.start ? (e.internal_start = e.start, e.start = function (t, i, n) { void 0 !== n ? e.internal_start(t || 0, i, n) : e.internal_start(t || 0, i || 0); }) : e.start = function (t, e, i) { e || i ? this.noteGrainOn(t || 0, e, i) : this.noteOn(t || 0); }, e.stop ? (e.internal_stop = e.stop, e.stop = function (t) { e.internal_stop(t || 0); }) : e.stop = function (t) { this.noteOff(t || 0); }, t(e.playbackRate), e; }, AudioContext.prototype.internal_createDynamicsCompressor = AudioContext.prototype.createDynamicsCompressor, AudioContext.prototype.createDynamicsCompressor = function () { const e = this.internal_createDynamicsCompressor(); return t(e.threshold), t(e.knee), t(e.ratio), t(e.reduction), t(e.attack), t(e.release), e; }, AudioContext.prototype.internal_createBiquadFilter = AudioContext.prototype.createBiquadFilter, AudioContext.prototype.createBiquadFilter = function () { const e = this.internal_createBiquadFilter(); return t(e.frequency), t(e.detune), t(e.Q), t(e.gain), e; }, AudioContext.prototype.hasOwnProperty('createOscillator') && (AudioContext.prototype.internal_createOscillator = AudioContext.prototype.createOscillator, AudioContext.prototype.createOscillator = function () { const e = this.internal_createOscillator(); return e.start ? (e.internal_start = e.start, e.start = function (t) { e.internal_start(t || 0); }) : e.start = function (t) { this.noteOn(t || 0); }, e.stop ? (e.internal_stop = e.stop, e.stop = function (t) { e.internal_stop(t || 0); }) : e.stop = function (t) { this.noteOff(t || 0); }, e.setPeriodicWave || (e.setPeriodicWave = e.setWaveTable), t(e.frequency), t(e.detune), e; })), window.hasOwnProperty('webkitOfflineAudioContext') && !window.hasOwnProperty('OfflineAudioContext') && (window.OfflineAudioContext = webkitOfflineAudioContext); }()); }, function (t, e) { window.console || (window.console = {}, window.console.log = window.console.assert = function () {}, window.console.warn = window.console.assert = function () {}); }, function (t, e) { Math.trunc || (Math.trunc = function (t) { return t < 0 ? Math.ceil(t) : Math.floor(t); }); }, function (t, e) { !(function () { if ('performance' in window == !1 && (window.performance = {}), Date.now = Date.now || function () { return (new Date()).getTime(); }, 'now' in window.performance == !1) { let t = Date.now(); performance.timing && performance.timing.navigationStart && (t = performance.timing.navigationStart), window.performance.now = function () { return Date.now() - t; }; } }()); }, function (t, e) { for (var i = Date.now(), n = ['ms', 'moz', 'webkit', 'o'], s = 0; s < n.length && !window.requestAnimationFrame; s++)window.requestAnimationFrame = window[`${n[s]}RequestAnimationFrame`], window.cancelAnimationFrame = window[`${n[s]}CancelAnimationFrame`] || window[`${n[s]}CancelRequestAnimationFrame`]; window.requestAnimationFrame || (window.requestAnimationFrame = function (t) { if (typeof t !== 'function') throw new TypeError(`${t}is not a function`); const e = Date.now(); let n = 16 + i - e; return n < 0 && (n = 0), i = e, setTimeout((() => { i = Date.now(), t(performance.now()); }), n); }), window.cancelAnimationFrame || (window.cancelAnimationFrame = function (t) { clearTimeout(t); }); }, function (t, e) { if (typeof window.Uint32Array !== 'function' && typeof window.Uint32Array !== 'object') { const i = function (t) { const e = new Array(); window[t] = function (t) { if (typeof t === 'number') { Array.call(this, t), this.length = t; for (var e = 0; e < this.length; e++) this[e] = 0; } else { Array.call(this, t.length), this.length = t.length; for (e = 0; e < this.length; e++) this[e] = t[e]; } }, window[t].prototype = e, window[t].constructor = window[t]; }; i('Float32Array'), i('Uint32Array'), i('Uint16Array'), i('Int16Array'), i('ArrayBuffer'); } }, function (t, e, i) {
/**
 * @author       samme
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(265); t.exports = function (t, e, i, s) { for (let r = t[0], o = 1; o < t.length; o++) { const a = t[o]; n(a, r, e, i, s), r = a; } return t; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(40); t.exports = function (t, e, i, s, r) { return n(t, 'angle', e, i, s, r); };
}, function (t, e) { t.exports = function (t, e, i) { for (let n = 0; n < t.length; n++) { const s = t[n]; e.call(i, s); } return t; }; }, function (t, e) { t.exports = function (t, e, i) { void 0 === i && (i = 0); for (let n = i; n < t.length; n++) { const s = t[n]; let r = !0; for (const o in e)s[o] !== e[o] && (r = !1); if (r) return s; } return null; }; }, function (t, e) { t.exports = function (t, e, i) { void 0 === i && (i = 0); for (let n = i; n < t.length; n++) { const s = t[n]; let r = !0; for (const o in e)s[o] !== e[o] && (r = !1); if (r) return s; } return null; }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(278); const s = i(96); const r = i(2); const o = i(1); const a = new (i(120))({ sys: { queueDepthSort: o, events: { once: o } } }, 0, 0, 1, 1); t.exports = function (t, e) { void 0 === e && (e = {}); const i = e.hasOwnProperty('width'); const o = e.hasOwnProperty('height'); const h = r(e, 'width', -1); const l = r(e, 'height', -1); const u = r(e, 'cellWidth', 1); const c = r(e, 'cellHeight', u); const d = r(e, 'position', s.TOP_LEFT); const f = r(e, 'x', 0); const p = r(e, 'y', 0); let g = 0; let v = 0; const m = h * u; const y = l * c; a.setPosition(f, p), a.setSize(u, c); for (let x = 0; x < t.length; x++) if (n(t[x], a, d), i && h === -1)a.x += u; else if (o && l === -1)a.y += c; else if (g += u, a.x += u, g === m && (g = 0, v += c, a.x = f, a.y += c, v === y)) break; return t; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(20); const s = {
    _alpha: 1, _alphaTL: 1, _alphaTR: 1, _alphaBL: 1, _alphaBR: 1, clearAlpha() { return this.setAlpha(1); }, setAlpha(t, e, i, s) { return void 0 === t && (t = 1), void 0 === e ? this.alpha = t : (this._alphaTL = n(t, 0, 1), this._alphaTR = n(e, 0, 1), this._alphaBL = n(i, 0, 1), this._alphaBR = n(s, 0, 1)), this; }, alpha: { get() { return this._alpha; }, set(t) { const e = n(t, 0, 1); this._alpha = e, this._alphaTL = e, this._alphaTR = e, this._alphaBL = e, this._alphaBR = e, e === 0 ? this.renderFlags &= -3 : this.renderFlags |= 2; } }, alphaTopLeft: { get() { return this._alphaTL; }, set(t) { const e = n(t, 0, 1); this._alphaTL = e, e !== 0 && (this.renderFlags |= 2); } }, alphaTopRight: { get() { return this._alphaTR; }, set(t) { const e = n(t, 0, 1); this._alphaTR = e, e !== 0 && (this.renderFlags |= 2); } }, alphaBottomLeft: { get() { return this._alphaBL; }, set(t) { const e = n(t, 0, 1); this._alphaBL = e, e !== 0 && (this.renderFlags |= 2); } }, alphaBottomRight: { get() { return this._alphaBR; }, set(t) { const e = n(t, 0, 1); this._alphaBR = e, e !== 0 && (this.renderFlags |= 2); } },
  }; t.exports = s;
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'add';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'complete';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'repeat';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'restart';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'start';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'pauseall';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'remove';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'resumeall';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'animationcomplete';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'animationcomplete-';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'animationrepeat-';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'animationrestart-';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'animationstart-';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'animationupdate-';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'animationrepeat';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'animationrestart';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'animationstart';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'animationupdate';
}, function (t, e) {
  t.exports = {
    width: 0, height: 0, displayWidth: { get() { return this.scaleX * this.width; }, set(t) { this.scaleX = t / this.width; } }, displayHeight: { get() { return this.scaleY * this.height; }, set(t) { this.scaleY = t / this.height; } }, setSize(t, e) { return this.width = t, this.height = e, this; }, setDisplaySize(t, e) { return this.displayWidth = t, this.displayHeight = e, this; },
  };
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const i = {
    texture: null,
    frame: null,
    isCropped: !1,
    setCrop(t, e, i, n) { if (void 0 === t) this.isCropped = !1; else if (this.frame) { if (typeof t === 'number') this.frame.setCropUVs(this._crop, t, e, i, n, this.flipX, this.flipY); else { const s = t; this.frame.setCropUVs(this._crop, s.x, s.y, s.width, s.height, this.flipX, this.flipY); } this.isCropped = !0; } return this; },
    resetCropObject() {
      return {
        u0: 0, v0: 0, u1: 0, v1: 0, width: 0, height: 0, x: 0, y: 0, flipX: !1, flipY: !1, cx: 0, cy: 0, cw: 0, ch: 0,
      };
    },
  }; t.exports = i;
}, function (t, e) {
  t.exports = {
    flipX: !1, flipY: !1, toggleFlipX() { return this.flipX = !this.flipX, this; }, toggleFlipY() { return this.flipY = !this.flipY, this; }, setFlipX(t) { return this.flipX = t, this; }, setFlipY(t) { return this.flipY = t, this; }, setFlip(t, e) { return this.flipX = t, this.flipY = e, this; }, resetFlip() { return this.flipX = !1, this.flipY = !1, this; },
  };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(12); const s = i(300); const r = i(3); const o = {
    prepareBoundsOutput(t, e) { (void 0 === e && (e = !1), this.rotation !== 0 && s(t, this.x, this.y, this.rotation), e && this.parentContainer) && this.parentContainer.getBoundsTransformMatrix().transformPoint(t.x, t.y, t); return t; }, getCenter(t) { return void 0 === t && (t = new r()), t.x = this.x - this.displayWidth * this.originX + this.displayWidth / 2, t.y = this.y - this.displayHeight * this.originY + this.displayHeight / 2, t; }, getTopLeft(t, e) { return t || (t = new r()), t.x = this.x - this.displayWidth * this.originX, t.y = this.y - this.displayHeight * this.originY, this.prepareBoundsOutput(t, e); }, getTopCenter(t, e) { return t || (t = new r()), t.x = this.x - this.displayWidth * this.originX + this.displayWidth / 2, t.y = this.y - this.displayHeight * this.originY, this.prepareBoundsOutput(t, e); }, getTopRight(t, e) { return t || (t = new r()), t.x = this.x - this.displayWidth * this.originX + this.displayWidth, t.y = this.y - this.displayHeight * this.originY, this.prepareBoundsOutput(t, e); }, getLeftCenter(t, e) { return t || (t = new r()), t.x = this.x - this.displayWidth * this.originX, t.y = this.y - this.displayHeight * this.originY + this.displayHeight / 2, this.prepareBoundsOutput(t, e); }, getRightCenter(t, e) { return t || (t = new r()), t.x = this.x - this.displayWidth * this.originX + this.displayWidth, t.y = this.y - this.displayHeight * this.originY + this.displayHeight / 2, this.prepareBoundsOutput(t, e); }, getBottomLeft(t, e) { return t || (t = new r()), t.x = this.x - this.displayWidth * this.originX, t.y = this.y - this.displayHeight * this.originY + this.displayHeight, this.prepareBoundsOutput(t, e); }, getBottomCenter(t, e) { return t || (t = new r()), t.x = this.x - this.displayWidth * this.originX + this.displayWidth / 2, t.y = this.y - this.displayHeight * this.originY + this.displayHeight, this.prepareBoundsOutput(t, e); }, getBottomRight(t, e) { return t || (t = new r()), t.x = this.x - this.displayWidth * this.originX + this.displayWidth, t.y = this.y - this.displayHeight * this.originY + this.displayHeight, this.prepareBoundsOutput(t, e); }, getBounds(t) { let e; let i; let s; let r; let o; let a; let h; let l; if (void 0 === t && (t = new n()), this.parentContainer) { const u = this.parentContainer.getBoundsTransformMatrix(); this.getTopLeft(t), u.transformPoint(t.x, t.y, t), e = t.x, i = t.y, this.getTopRight(t), u.transformPoint(t.x, t.y, t), s = t.x, r = t.y, this.getBottomLeft(t), u.transformPoint(t.x, t.y, t), o = t.x, a = t.y, this.getBottomRight(t), u.transformPoint(t.x, t.y, t), h = t.x, l = t.y; } else this.getTopLeft(t), e = t.x, i = t.y, this.getTopRight(t), s = t.x, r = t.y, this.getBottomLeft(t), o = t.x, a = t.y, this.getBottomRight(t), h = t.x, l = t.y; return t.x = Math.min(e, s, o, h), t.y = Math.min(i, r, a, l), t.width = Math.max(e, s, o, h) - t.x, t.height = Math.max(i, r, a, l) - t.y, t; },
  }; t.exports = o;
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'blur';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'boot';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'contextlost';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'contextrestored';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'destroy';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'focus';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'hidden';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'pause';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'postrender';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'poststep';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'prerender';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'prestep';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'ready';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'resume';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'step';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'visible';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const i = {
    _originComponent: !0, originX: 0.5, originY: 0.5, _displayOriginX: 0, _displayOriginY: 0, displayOriginX: { get() { return this._displayOriginX; }, set(t) { this._displayOriginX = t, this.originX = t / this.width; } }, displayOriginY: { get() { return this._displayOriginY; }, set(t) { this._displayOriginY = t, this.originY = t / this.height; } }, setOrigin(t, e) { return void 0 === t && (t = 0.5), void 0 === e && (e = t), this.originX = t, this.originY = e, this.updateDisplayOrigin(); }, setOriginFromFrame() { return this.frame && this.frame.customPivot ? (this.originX = this.frame.pivotX, this.originY = this.frame.pivotY, this.updateDisplayOrigin()) : this.setOrigin(); }, setDisplayOrigin(t, e) { return void 0 === t && (t = 0), void 0 === e && (e = t), this.displayOriginX = t, this.displayOriginY = e, this; }, updateDisplayOrigin() { return this._displayOriginX = this.originX * this.width, this._displayOriginY = this.originY * this.height, this; },
  }; t.exports = i;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(41); const s = i(99); const r = i(6); const o = i(100); const a = i(3); const h = {
    path: null, rotateToPath: !1, pathRotationOffset: 0, pathOffset: null, pathVector: null, pathDelta: null, pathTween: null, pathConfig: null, _prevDirection: o.PLAYING_FORWARD, setPath(t, e) { void 0 === e && (e = this.pathConfig); const i = this.pathTween; return i && i.isPlaying() && i.stop(), this.path = t, e && this.startFollow(e), this; }, setRotateToPath(t, e) { return void 0 === e && (e = 0), this.rotateToPath = t, this.pathRotationOffset = e, this; }, isFollowing() { const t = this.pathTween; return t && t.isPlaying(); }, startFollow(t, e) { void 0 === t && (t = {}), void 0 === e && (e = 0); const i = this.pathTween; i && i.isPlaying() && i.stop(), typeof t === 'number' && (t = { duration: t }), t.from = r(t, 'from', 0), t.to = r(t, 'to', 1); const h = s(t, 'positionOnPath', !1); this.rotateToPath = s(t, 'rotateToPath', !1), this.pathRotationOffset = r(t, 'rotationOffset', 0); const l = r(t, 'startAt', e); if (l && (t.onStart = function (t) { const e = t.data[0]; e.progress = l, e.elapsed = e.duration * l; const i = e.ease(e.progress); e.current = e.start + (e.end - e.start) * i, e.target[e.key] = e.current; }), this.pathOffset || (this.pathOffset = new a(this.x, this.y)), this.pathVector || (this.pathVector = new a()), this.pathDelta || (this.pathDelta = new a()), this.pathDelta.reset(), this.pathTween = this.scene.sys.tweens.addCounter(t), this.path.getStartPoint(this.pathOffset), h && (this.x = this.pathOffset.x, this.y = this.pathOffset.y), this.pathOffset.x = this.x - this.pathOffset.x, this.pathOffset.y = this.y - this.pathOffset.y, this._prevDirection = o.PLAYING_FORWARD, this.rotateToPath) { const u = this.path.getPoint(0.1); this.rotation = Math.atan2(u.y - this.y, u.x - this.x) + n(this.pathRotationOffset); } return this.pathConfig = t, this; }, pauseFollow() { const t = this.pathTween; return t && t.isPlaying() && t.pause(), this; }, resumeFollow() { const t = this.pathTween; return t && t.isPaused() && t.resume(), this; }, stopFollow() { const t = this.pathTween; return t && t.isPlaying() && t.stop(), this; }, pathUpdate() { const t = this.pathTween; if (t) { const e = t.data[0]; const i = this.pathDelta; const s = this.pathVector; if (i.copy(s).negate(), e.state === o.COMPLETE) return this.path.getPoint(1, s), i.add(s), s.add(this.pathOffset), void this.setPosition(s.x, s.y); if (e.state !== o.PLAYING_FORWARD && e.state !== o.PLAYING_BACKWARD) return; this.path.getPoint(t.getValue(), s), i.add(s), s.add(this.pathOffset); const r = this.x; const a = this.y; this.setPosition(s.x, s.y); const h = this.x - r; const l = this.y - a; if (h === 0 && l === 0) return; if (e.state !== this._prevDirection) return void (this._prevDirection = e.state); this.rotateToPath && (this.rotation = Math.atan2(l, h) + n(this.pathRotationOffset)); } },
  }; t.exports = h;
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const i = {
    _sizeComponent: !0, width: 0, height: 0, displayWidth: { get() { return Math.abs(this.scaleX * this.frame.realWidth); }, set(t) { this.scaleX = t / this.frame.realWidth; } }, displayHeight: { get() { return Math.abs(this.scaleY * this.frame.realHeight); }, set(t) { this.scaleY = t / this.frame.realHeight; } }, setSizeToFrame(t) { return void 0 === t && (t = this.frame), this.width = t.realWidth, this.height = t.realHeight, this; }, setSize(t, e) { return this.width = t, this.height = e, this; }, setDisplaySize(t, e) { return this.displayWidth = t, this.displayHeight = e, this; },
  }; t.exports = i;
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const i = {
    texture: null, frame: null, isCropped: !1, setTexture(t, e) { return this.texture = this.scene.sys.textures.get(t), this.setFrame(e); }, setFrame(t, e, i) { return void 0 === e && (e = !0), void 0 === i && (i = !0), this.frame = this.texture.get(t), this.frame.cutWidth && this.frame.cutHeight ? this.renderFlags |= 8 : this.renderFlags &= -9, this._sizeComponent && e && this.setSizeToFrame(), this._originComponent && i && (this.frame.customPivot ? this.setOrigin(this.frame.pivotX, this.frame.pivotY) : this.updateDisplayOrigin()), this; },
  }; t.exports = i;
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const i = {
    texture: null,
    frame: null,
    isCropped: !1,
    setCrop(t, e, i, n) { if (void 0 === t) this.isCropped = !1; else if (this.frame) { if (typeof t === 'number') this.frame.setCropUVs(this._crop, t, e, i, n, this.flipX, this.flipY); else { const s = t; this.frame.setCropUVs(this._crop, s.x, s.y, s.width, s.height, this.flipX, this.flipY); } this.isCropped = !0; } return this; },
    setTexture(t, e) { return this.texture = this.scene.sys.textures.get(t), this.setFrame(e); },
    setFrame(t, e, i) { return void 0 === e && (e = !0), void 0 === i && (i = !0), this.frame = this.texture.get(t), this.frame.cutWidth && this.frame.cutHeight ? this.renderFlags |= 8 : this.renderFlags &= -9, this._sizeComponent && e && this.setSizeToFrame(), this._originComponent && i && (this.frame.customPivot ? this.setOrigin(this.frame.pivotX, this.frame.pivotY) : this.updateDisplayOrigin()), this.isCropped && this.frame.updateCropUVs(this._crop, this.flipX, this.flipY), this; },
    resetCropObject() {
      return {
        u0: 0, v0: 0, u1: 0, v1: 0, width: 0, height: 0, x: 0, y: 0, flipX: !1, flipY: !1, cx: 0, cy: 0, cw: 0, ch: 0,
      };
    },
  }; t.exports = i;
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const i = function (t) { return (t >> 16) + (65280 & t) + ((255 & t) << 16); }; const n = {
    _tintTL: 16777215, _tintTR: 16777215, _tintBL: 16777215, _tintBR: 16777215, _isTinted: !1, tintFill: !1, clearTint() { return this.setTint(16777215), this._isTinted = !1, this; }, setTint(t, e, n, s) { return void 0 === t && (t = 16777215), void 0 === e && (e = t, n = t, s = t), this._tintTL = i(t), this._tintTR = i(e), this._tintBL = i(n), this._tintBR = i(s), this._isTinted = !0, this.tintFill = !1, this; }, setTintFill(t, e, i, n) { return this.setTint(t, e, i, n), this.tintFill = !0, this; }, tintTopLeft: { get() { return this._tintTL; }, set(t) { this._tintTL = i(t), this._isTinted = !0; } }, tintTopRight: { get() { return this._tintTR; }, set(t) { this._tintTR = i(t), this._isTinted = !0; } }, tintBottomLeft: { get() { return this._tintBL; }, set(t) { this._tintBL = i(t), this._isTinted = !0; } }, tintBottomRight: { get() { return this._tintBR; }, set(t) { this._tintBR = i(t), this._isTinted = !0; } }, tint: { set(t) { this.setTint(t, t, t, t); } }, isTinted: { get() { return this._isTinted; } },
  }; t.exports = n;
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'changedata';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'changedata-';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'removedata';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'setdata';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'destroy';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'complete';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'created';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'error';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'loop';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'play';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'seeked';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'seeking';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'stop';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'timeout';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'unlocked';
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(40); t.exports = function (t, e, i, s, r) { return n(t, 'alpha', e, i, s, r); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(40); t.exports = function (t, e, i, s, r) { return n(t, 'x', e, i, s, r); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(40); t.exports = function (t, e, i, s, r, o, a) { return i == null && (i = e), n(t, 'x', e, s, o, a), n(t, 'y', i, r, o, a); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(40); t.exports = function (t, e, i, s, r) { return n(t, 'y', e, i, s, r); };
}, function (t, e) { t.exports = function (t, e, i, n) { void 0 === i && (i = 0), void 0 === n && (n = 6.28); for (let s = i, r = (n - i) / t.length, o = 0; o < t.length; o++)t[o].x = e.x + e.radius * Math.cos(s), t[o].y = e.y + e.radius * Math.sin(s), s += r; return t; }; }, function (t, e) { t.exports = function (t, e, i, n) { void 0 === i && (i = 0), void 0 === n && (n = 6.28); for (let s = i, r = (n - i) / t.length, o = e.width / 2, a = e.height / 2, h = 0; h < t.length; h++)t[h].x = e.x + o * Math.cos(s), t[h].y = e.y + a * Math.sin(s), s += r; return t; }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(167); t.exports = function (t, e) { for (let i = n(e, t.length), s = 0; s < t.length; s++) { const r = t[s]; const o = i[s]; r.x = o.x, r.y = o.y; } return t; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(309); const s = i(310); const r = i(311); t.exports = function (t, e, i) { void 0 === i && (i = 0); const o = n(e, !1, t.length); i > 0 ? s(o, i) : i < 0 && r(o, Math.abs(i)); for (let a = 0; a < t.length; a++)t[a].x = o[a].x, t[a].y = o[a].y; return t; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(312); t.exports = function (t, e, i) {
    let s = n({
      x1: e.x1, y1: e.y1, x2: e.x2, y2: e.y2,
    }, i); const r = n({
      x1: e.x2, y1: e.y2, x2: e.x3, y2: e.y3,
    }, i); const o = n({
      x1: e.x3, y1: e.y3, x2: e.x1, y2: e.y1,
    }, i); s.pop(), r.pop(), o.pop(); for (let a = (s = s.concat(r, o)).length / t.length, h = 0, l = 0; l < t.length; l++) { const u = t[l]; const c = s[Math.floor(h)]; u.x = c.x, u.y = c.y, h += a; } return t;
  };
}, function (t, e) { t.exports = function (t, e, i) { for (let n = 0; n < t.length; n++)t[n].anims.play(e, i); return t; }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(164); t.exports = function (t, e) { for (let i = 0; i < t.length; i++)n(e, t[i]); return t; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(172); t.exports = function (t, e) { for (let i = 0; i < t.length; i++)n(e, t[i]); return t; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(168); t.exports = function (t, e) { for (let i = 0; i < t.length; i++)n(e, t[i]); return t; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(169); t.exports = function (t, e) { for (let i = 0; i < t.length; i++)n(e, t[i]); return t; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(173); t.exports = function (t, e) { for (let i = 0; i < t.length; i++)n(e, t[i]); return t; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(40); t.exports = function (t, e, i, s, r) { return n(t, 'rotation', e, i, s, r); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(174); const s = i(56); t.exports = function (t, e, i) { for (let r = e.x, o = e.y, a = 0; a < t.length; a++) { const h = t[a]; n(h, r, o, i, Math.max(1, s(h.x, h.y, r, o))); } return t; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(174); t.exports = function (t, e, i, s) { const r = e.x; const o = e.y; if (s === 0) return t; for (let a = 0; a < t.length; a++)n(t[a], r, o, i, s); return t; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(40); t.exports = function (t, e, i, s, r) { return n(t, 'scaleX', e, i, s, r); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(40); t.exports = function (t, e, i, s, r, o, a) { return i == null && (i = e), n(t, 'scaleX', e, s, o, a), n(t, 'scaleY', i, r, o, a); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(40); t.exports = function (t, e, i, s, r) { return n(t, 'scaleY', e, i, s, r); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(28); t.exports = function (t, e, i, s, r) { return n(t, 'alpha', e, i, s, r); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(28); t.exports = function (t, e, i, s) { return n(t, 'blendMode', e, 0, i, s); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(28); t.exports = function (t, e, i, s, r) { return n(t, 'depth', e, i, s, r); };
}, function (t, e) { t.exports = function (t, e, i) { for (let n = 0; n < t.length; n++)t[n].setInteractive(e, i); return t; }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(28); t.exports = function (t, e, i, s, r, o, a) { return i == null && (i = e), n(t, 'originX', e, s, o, a), n(t, 'originY', i, r, o, a); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(28); t.exports = function (t, e, i, s, r) { return n(t, 'rotation', e, i, s, r); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(28); t.exports = function (t, e, i, s, r, o, a) { return i == null && (i = e), n(t, 'scaleX', e, s, o, a), n(t, 'scaleY', i, r, o, a); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(28); t.exports = function (t, e, i, s, r) { return n(t, 'scaleX', e, i, s, r); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(28); t.exports = function (t, e, i, s, r) { return n(t, 'scaleY', e, i, s, r); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(28); t.exports = function (t, e, i, s, r, o, a) { return i == null && (i = e), n(t, 'scrollFactorX', e, s, o, a), n(t, 'scrollFactorY', i, r, o, a); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(28); t.exports = function (t, e, i, s, r) { return n(t, 'scrollFactorX', e, i, s, r); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(28); t.exports = function (t, e, i, s, r) { return n(t, 'scrollFactorY', e, i, s, r); };
}, function (t, e) { t.exports = function (t, e, i, n, s) { for (let r = 0; r < t.length; r++)t[r].setTint(e, i, n, s); return t; }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(28); t.exports = function (t, e, i, s) { return n(t, 'visible', e, 0, i, s); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(28); t.exports = function (t, e, i, s, r) { return n(t, 'x', e, i, s, r); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(28); t.exports = function (t, e, i, s, r, o, a) { return i == null && (i = e), n(t, 'x', e, s, o, a), n(t, 'y', i, r, o, a); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(28); t.exports = function (t, e, i, s, r) { return n(t, 'y', e, i, s, r); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(3); t.exports = function (t, e, i, s, r) { let o; let a; let h; let l; let u; let c; if (void 0 === s && (s = 0), void 0 === r && (r = new n()), t.length > 1) if (s === 0) { const d = t.length - 1; for (o = t[d].x, a = t[d].y, h = d - 1; h >= 0; h--)l = (c = t[h]).x, u = c.y, c.x = o, c.y = a, o = l, a = u; t[d].x = e, t[d].y = i; } else { for (o = t[0].x, a = t[0].y, h = 1; h < t.length; h++)l = (c = t[h]).x, u = c.y, c.x = o, c.y = a, o = l, a = u; t[0].x = e, t[0].y = i; } else o = t[0].x, a = t[0].y, t[0].x = e, t[0].y = i; return r.x = o, r.y = a, r; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(124); t.exports = function (t) { return n(t); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(175); t.exports = function (t, e, i, s, r) { void 0 === r && (r = !1); let o; const a = Math.abs(s - i) / t.length; if (r) for (o = 0; o < t.length; o++)t[o][e] += n(o * a, i, s); else for (o = 0; o < t.length; o++)t[o][e] = n(o * a, i, s); return t; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(176); t.exports = function (t, e, i, s, r) { void 0 === r && (r = !1); let o; const a = Math.abs(s - i) / t.length; if (r) for (o = 0; o < t.length; o++)t[o][e] += n(o * a, i, s); else for (o = 0; o < t.length; o++)t[o][e] = n(o * a, i, s); return t; };
}, function (t, e) { t.exports = function (t, e, i, n, s) { void 0 === s && (s = !1); let r; const o = Math.abs(n - i) / t.length; if (s) for (r = 0; r < t.length; r++)t[r][e] += r * o + i; else for (r = 0; r < t.length; r++)t[r][e] = r * o + i; return t; }; }, function (t, e) { t.exports = function (t) { for (let e = 0; e < t.length; e++)t[e].visible = !t[e].visible; return t; }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       samme <samme.npm@gmail.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(64); t.exports = function (t, e, i) { void 0 === i && (i = 0); for (let s = 0; s < t.length; s++) { const r = t[s]; r.x = n(r.x, e.left - i, e.right + i), r.y = n(r.y, e.top - i, e.bottom + i); } return t; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = {
    Animation: i(165), AnimationFrame: i(295), AnimationManager: i(313), Events: i(121),
  };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = { BaseCache: i(314), CacheManager: i(316), Events: i(315) };
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'add';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'remove';
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = { Controls: i(672), Scene2D: i(675) };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = { FixedKeyControl: i(673), SmoothedKeyControl: i(674) };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(6); const r = new n({
    initialize(t) { this.camera = s(t, 'camera', null), this.left = s(t, 'left', null), this.right = s(t, 'right', null), this.up = s(t, 'up', null), this.down = s(t, 'down', null), this.zoomIn = s(t, 'zoomIn', null), this.zoomOut = s(t, 'zoomOut', null), this.zoomSpeed = s(t, 'zoomSpeed', 0.01), this.speedX = 0, this.speedY = 0; const e = s(t, 'speed', null); typeof e === 'number' ? (this.speedX = e, this.speedY = e) : (this.speedX = s(t, 'speed.x', 0), this.speedY = s(t, 'speed.y', 0)), this._zoom = 0, this.active = this.camera !== null; }, start() { return this.active = this.camera !== null, this; }, stop() { return this.active = !1, this; }, setCamera(t) { return this.camera = t, this; }, update(t) { if (this.active) { void 0 === t && (t = 1); const e = this.camera; this.up && this.up.isDown ? e.scrollY -= this.speedY * t | 0 : this.down && this.down.isDown && (e.scrollY += this.speedY * t | 0), this.left && this.left.isDown ? e.scrollX -= this.speedX * t | 0 : this.right && this.right.isDown && (e.scrollX += this.speedX * t | 0), this.zoomIn && this.zoomIn.isDown ? (e.zoom -= this.zoomSpeed, e.zoom < 0.1 && (e.zoom = 0.1)) : this.zoomOut && this.zoomOut.isDown && (e.zoom += this.zoomSpeed); } }, destroy() { this.camera = null, this.left = null, this.right = null, this.up = null, this.down = null, this.zoomIn = null, this.zoomOut = null; },
  }); t.exports = r;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(6); const r = new n({
    initialize(t) { this.camera = s(t, 'camera', null), this.left = s(t, 'left', null), this.right = s(t, 'right', null), this.up = s(t, 'up', null), this.down = s(t, 'down', null), this.zoomIn = s(t, 'zoomIn', null), this.zoomOut = s(t, 'zoomOut', null), this.zoomSpeed = s(t, 'zoomSpeed', 0.01), this.accelX = 0, this.accelY = 0; const e = s(t, 'acceleration', null); typeof e === 'number' ? (this.accelX = e, this.accelY = e) : (this.accelX = s(t, 'acceleration.x', 0), this.accelY = s(t, 'acceleration.y', 0)), this.dragX = 0, this.dragY = 0; const i = s(t, 'drag', null); typeof i === 'number' ? (this.dragX = i, this.dragY = i) : (this.dragX = s(t, 'drag.x', 0), this.dragY = s(t, 'drag.y', 0)), this.maxSpeedX = 0, this.maxSpeedY = 0; const n = s(t, 'maxSpeed', null); typeof n === 'number' ? (this.maxSpeedX = n, this.maxSpeedY = n) : (this.maxSpeedX = s(t, 'maxSpeed.x', 0), this.maxSpeedY = s(t, 'maxSpeed.y', 0)), this._speedX = 0, this._speedY = 0, this._zoom = 0, this.active = this.camera !== null; }, start() { return this.active = this.camera !== null, this; }, stop() { return this.active = !1, this; }, setCamera(t) { return this.camera = t, this; }, update(t) { if (this.active) { void 0 === t && (t = 1); const e = this.camera; this._speedX > 0 ? (this._speedX -= this.dragX * t, this._speedX < 0 && (this._speedX = 0)) : this._speedX < 0 && (this._speedX += this.dragX * t, this._speedX > 0 && (this._speedX = 0)), this._speedY > 0 ? (this._speedY -= this.dragY * t, this._speedY < 0 && (this._speedY = 0)) : this._speedY < 0 && (this._speedY += this.dragY * t, this._speedY > 0 && (this._speedY = 0)), this.up && this.up.isDown ? (this._speedY += this.accelY, this._speedY > this.maxSpeedY && (this._speedY = this.maxSpeedY)) : this.down && this.down.isDown && (this._speedY -= this.accelY, this._speedY < -this.maxSpeedY && (this._speedY = -this.maxSpeedY)), this.left && this.left.isDown ? (this._speedX += this.accelX, this._speedX > this.maxSpeedX && (this._speedX = this.maxSpeedX)) : this.right && this.right.isDown && (this._speedX -= this.accelX, this._speedX < -this.maxSpeedX && (this._speedX = -this.maxSpeedX)), this.zoomIn && this.zoomIn.isDown ? this._zoom = -this.zoomSpeed : this.zoomOut && this.zoomOut.isDown ? this._zoom = this.zoomSpeed : this._zoom = 0, this._speedX !== 0 && (e.scrollX -= this._speedX * t | 0), this._speedY !== 0 && (e.scrollY -= this._speedY * t | 0), this._zoom !== 0 && (e.zoom += this._zoom, e.zoom < 0.001 && (e.zoom = 0.001)); } }, destroy() { this.camera = null, this.left = null, this.right = null, this.up = null, this.down = null, this.zoomIn = null, this.zoomOut = null; },
  }); t.exports = r;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = {
    Camera: i(317), BaseCamera: i(103), CameraManager: i(731), Effects: i(325), Events: i(42),
  };
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'cameradestroy';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'camerafadeincomplete';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'camerafadeinstart';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'camerafadeoutcomplete';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'camerafadeoutstart';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'cameraflashcomplete';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'cameraflashstart';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'camerapancomplete';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'camerapanstart';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'postrender';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'prerender';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'camerarotatecomplete';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'camerarotatestart';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'camerashakecomplete';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'camerashakestart';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'camerazoomcomplete';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'camerazoomstart';
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(20); const s = i(0); const r = i(42); const o = new s({
    initialize(t) { this.camera = t, this.isRunning = !1, this.isComplete = !1, this.direction = !0, this.duration = 0, this.red = 0, this.green = 0, this.blue = 0, this.alpha = 0, this.progress = 0, this._elapsed = 0, this._onUpdate, this._onUpdateScope; }, start(t, e, i, n, s, o, a, h) { if (void 0 === t && (t = !0), void 0 === e && (e = 1e3), void 0 === i && (i = 0), void 0 === n && (n = 0), void 0 === s && (s = 0), void 0 === o && (o = !1), void 0 === a && (a = null), void 0 === h && (h = this.camera.scene), !o && this.isRunning) return this.camera; this.isRunning = !0, this.isComplete = !1, this.duration = e, this.direction = t, this.progress = 0, this.red = i, this.green = n, this.blue = s, this.alpha = t ? Number.MIN_VALUE : 1, this._elapsed = 0, this._onUpdate = a, this._onUpdateScope = h; const l = t ? r.FADE_OUT_START : r.FADE_IN_START; return this.camera.emit(l, this.camera, this, e, i, n, s), this.camera; }, update(t, e) { this.isRunning && (this._elapsed += e, this.progress = n(this._elapsed / this.duration, 0, 1), this._onUpdate && this._onUpdate.call(this._onUpdateScope, this.camera, this.progress), this._elapsed < this.duration ? this.alpha = this.direction ? this.progress : 1 - this.progress : (this.alpha = this.direction ? 1 : 0, this.effectComplete())); }, postRenderCanvas(t) { if (!this.isRunning && !this.isComplete) return !1; const e = this.camera; return t.fillStyle = `rgba(${this.red},${this.green},${this.blue},${this.alpha})`, t.fillRect(e._cx, e._cy, e._cw, e._ch), !0; }, postRenderWebGL(t, e) { if (!this.isRunning && !this.isComplete) return !1; const i = this.camera; const n = this.red / 255; const s = this.blue / 255; const r = this.green / 255; return t.drawFillRect(i._cx, i._cy, i._cw, i._ch, e(n, r, s, 1), this.alpha), !0; }, effectComplete() { this._onUpdate = null, this._onUpdateScope = null, this.isRunning = !1, this.isComplete = !0; const t = this.direction ? r.FADE_OUT_COMPLETE : r.FADE_IN_COMPLETE; this.camera.emit(t, this.camera, this); }, reset() { this.isRunning = !1, this.isComplete = !1, this._onUpdate = null, this._onUpdateScope = null; }, destroy() { this.reset(), this.camera = null; },
  }); t.exports = o;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(20); const s = i(0); const r = i(42); const o = new s({
    initialize(t) { this.camera = t, this.isRunning = !1, this.duration = 0, this.red = 0, this.green = 0, this.blue = 0, this.alpha = 0, this.progress = 0, this._elapsed = 0, this._onUpdate, this._onUpdateScope; }, start(t, e, i, n, s, o, a) { return void 0 === t && (t = 250), void 0 === e && (e = 255), void 0 === i && (i = 255), void 0 === n && (n = 255), void 0 === s && (s = !1), void 0 === o && (o = null), void 0 === a && (a = this.camera.scene), !s && this.isRunning || (this.isRunning = !0, this.duration = t, this.progress = 0, this.red = e, this.green = i, this.blue = n, this.alpha = 1, this._elapsed = 0, this._onUpdate = o, this._onUpdateScope = a, this.camera.emit(r.FLASH_START, this.camera, this, t, e, i, n)), this.camera; }, update(t, e) { this.isRunning && (this._elapsed += e, this.progress = n(this._elapsed / this.duration, 0, 1), this._onUpdate && this._onUpdate.call(this._onUpdateScope, this.camera, this.progress), this._elapsed < this.duration ? this.alpha = 1 - this.progress : this.effectComplete()); }, postRenderCanvas(t) { if (!this.isRunning) return !1; const e = this.camera; return t.fillStyle = `rgba(${this.red},${this.green},${this.blue},${this.alpha})`, t.fillRect(e._cx, e._cy, e._cw, e._ch), !0; }, postRenderWebGL(t, e) { if (!this.isRunning) return !1; const i = this.camera; const n = this.red / 255; const s = this.blue / 255; const r = this.green / 255; return t.drawFillRect(i._cx, i._cy, i._cw, i._ch, e(n, r, s, 1), this.alpha), !0; }, effectComplete() { this._onUpdate = null, this._onUpdateScope = null, this.isRunning = !1, this.camera.emit(r.FLASH_COMPLETE, this.camera, this); }, reset() { this.isRunning = !1, this._onUpdate = null, this._onUpdateScope = null; }, destroy() { this.reset(), this.camera = null; },
  }); t.exports = o;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(20); const s = i(0); const r = i(125); const o = i(42); const a = i(3); const h = new s({
    initialize(t) { this.camera = t, this.isRunning = !1, this.duration = 0, this.source = new a(), this.current = new a(), this.destination = new a(), this.ease, this.progress = 0, this._elapsed = 0, this._onUpdate, this._onUpdateScope; }, start(t, e, i, n, s, a, h) { void 0 === i && (i = 1e3), void 0 === n && (n = r.Linear), void 0 === s && (s = !1), void 0 === a && (a = null), void 0 === h && (h = this.camera.scene); const l = this.camera; return !s && this.isRunning || (this.isRunning = !0, this.duration = i, this.progress = 0, this.source.set(l.scrollX, l.scrollY), this.destination.set(t, e), l.getScroll(t, e, this.current), typeof n === 'string' && r.hasOwnProperty(n) ? this.ease = r[n] : typeof n === 'function' && (this.ease = n), this._elapsed = 0, this._onUpdate = a, this._onUpdateScope = h, this.camera.emit(o.PAN_START, this.camera, this, i, t, e)), l; }, update(t, e) { if (this.isRunning) { this._elapsed += e; const i = n(this._elapsed / this.duration, 0, 1); this.progress = i; const s = this.camera; if (this._elapsed < this.duration) { const r = this.ease(i); s.getScroll(this.destination.x, this.destination.y, this.current); const o = this.source.x + (this.current.x - this.source.x) * r; const a = this.source.y + (this.current.y - this.source.y) * r; s.setScroll(o, a), this._onUpdate && this._onUpdate.call(this._onUpdateScope, s, i, o, a); } else s.centerOn(this.destination.x, this.destination.y), this._onUpdate && this._onUpdate.call(this._onUpdateScope, s, i, s.scrollX, s.scrollY), this.effectComplete(); } }, effectComplete() { this._onUpdate = null, this._onUpdateScope = null, this.isRunning = !1, this.camera.emit(o.PAN_COMPLETE, this.camera, this); }, reset() { this.isRunning = !1, this._onUpdate = null, this._onUpdateScope = null; }, destroy() { this.reset(), this.camera = null, this.source = null, this.destination = null; },
  }); t.exports = h;
}, function (t, e) { t.exports = function (t, e) { return void 0 === e && (e = 1.70158), t * t * ((e + 1) * t - e); }; }, function (t, e) { t.exports = function (t, e) { return void 0 === e && (e = 1.70158), --t * t * ((e + 1) * t + e) + 1; }; }, function (t, e) { t.exports = function (t, e) { void 0 === e && (e = 1.70158); const i = 1.525 * e; return (t *= 2) < 1 ? t * t * ((i + 1) * t - i) * 0.5 : 0.5 * ((t -= 2) * t * ((i + 1) * t + i) + 2); }; }, function (t, e) { t.exports = function (t) { return (t = 1 - t) < 1 / 2.75 ? 1 - 7.5625 * t * t : t < 2 / 2.75 ? 1 - (7.5625 * (t -= 1.5 / 2.75) * t + 0.75) : t < 2.5 / 2.75 ? 1 - (7.5625 * (t -= 2.25 / 2.75) * t + 0.9375) : 1 - (7.5625 * (t -= 2.625 / 2.75) * t + 0.984375); }; }, function (t, e) { t.exports = function (t) { return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + 0.75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375 : 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375; }; }, function (t, e) { t.exports = function (t) { let e = !1; return t < 0.5 ? (t = 1 - 2 * t, e = !0) : t = 2 * t - 1, t < 1 / 2.75 ? t *= 7.5625 * t : t = t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + 0.75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + 0.9375 : 7.5625 * (t -= 2.625 / 2.75) * t + 0.984375, e ? 0.5 * (1 - t) : 0.5 * t + 0.5; }; }, function (t, e) { t.exports = function (t) { return 1 - Math.sqrt(1 - t * t); }; }, function (t, e) { t.exports = function (t) { return Math.sqrt(1 - --t * t); }; }, function (t, e) { t.exports = function (t) { return (t *= 2) < 1 ? -0.5 * (Math.sqrt(1 - t * t) - 1) : 0.5 * (Math.sqrt(1 - (t -= 2) * t) + 1); }; }, function (t, e) { t.exports = function (t) { return t * t * t; }; }, function (t, e) { t.exports = function (t) { return --t * t * t + 1; }; }, function (t, e) { t.exports = function (t) { return (t *= 2) < 1 ? 0.5 * t * t * t : 0.5 * ((t -= 2) * t * t + 2); }; }, function (t, e) { t.exports = function (t, e, i) { if (void 0 === e && (e = 0.1), void 0 === i && (i = 0.1), t === 0) return 0; if (t === 1) return 1; let n = i / 4; return e < 1 ? e = 1 : n = i * Math.asin(1 / e) / (2 * Math.PI), -e * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - n) * (2 * Math.PI) / i); }; }, function (t, e) { t.exports = function (t, e, i) { if (void 0 === e && (e = 0.1), void 0 === i && (i = 0.1), t === 0) return 0; if (t === 1) return 1; let n = i / 4; return e < 1 ? e = 1 : n = i * Math.asin(1 / e) / (2 * Math.PI), e * Math.pow(2, -10 * t) * Math.sin((t - n) * (2 * Math.PI) / i) + 1; }; }, function (t, e) { t.exports = function (t, e, i) { if (void 0 === e && (e = 0.1), void 0 === i && (i = 0.1), t === 0) return 0; if (t === 1) return 1; let n = i / 4; return e < 1 ? e = 1 : n = i * Math.asin(1 / e) / (2 * Math.PI), (t *= 2) < 1 ? e * Math.pow(2, 10 * (t -= 1)) * Math.sin((t - n) * (2 * Math.PI) / i) * -0.5 : e * Math.pow(2, -10 * (t -= 1)) * Math.sin((t - n) * (2 * Math.PI) / i) * 0.5 + 1; }; }, function (t, e) { t.exports = function (t) { return Math.pow(2, 10 * (t - 1)) - 0.001; }; }, function (t, e) { t.exports = function (t) { return 1 - Math.pow(2, -10 * t); }; }, function (t, e) { t.exports = function (t) { return (t *= 2) < 1 ? 0.5 * Math.pow(2, 10 * (t - 1)) : 0.5 * (2 - Math.pow(2, -10 * (t - 1))); }; }, function (t, e) { t.exports = function (t) { return t; }; }, function (t, e) { t.exports = function (t) { return t * t; }; }, function (t, e) { t.exports = function (t) { return t * (2 - t); }; }, function (t, e) { t.exports = function (t) { return (t *= 2) < 1 ? 0.5 * t * t : -0.5 * (--t * (t - 2) - 1); }; }, function (t, e) { t.exports = function (t) { return t * t * t * t; }; }, function (t, e) { t.exports = function (t) { return 1 - --t * t * t * t; }; }, function (t, e) { t.exports = function (t) { return (t *= 2) < 1 ? 0.5 * t * t * t * t : -0.5 * ((t -= 2) * t * t * t - 2); }; }, function (t, e) { t.exports = function (t) { return t * t * t * t * t; }; }, function (t, e) { t.exports = function (t) { return --t * t * t * t * t + 1; }; }, function (t, e) { t.exports = function (t) { return (t *= 2) < 1 ? 0.5 * t * t * t * t * t : 0.5 * ((t -= 2) * t * t * t * t + 2); }; }, function (t, e) { t.exports = function (t) { return t === 0 ? 0 : t === 1 ? 1 : 1 - Math.cos(t * Math.PI / 2); }; }, function (t, e) { t.exports = function (t) { return t === 0 ? 0 : t === 1 ? 1 : Math.sin(t * Math.PI / 2); }; }, function (t, e) { t.exports = function (t) { return t === 0 ? 0 : t === 1 ? 1 : 0.5 * (1 - Math.cos(Math.PI * t)); }; }, function (t, e) { t.exports = function (t, e) { return void 0 === e && (e = 1), t <= 0 ? 0 : t >= 1 ? 1 : 1 / e * (1 + (e * t | 0)); }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(20); const s = i(0); const r = i(42); const o = i(3); const a = new s({
    initialize(t) { this.camera = t, this.isRunning = !1, this.duration = 0, this.intensity = new o(), this.progress = 0, this._elapsed = 0, this._offsetX = 0, this._offsetY = 0, this._onUpdate, this._onUpdateScope; }, start(t, e, i, n, s) { return void 0 === t && (t = 100), void 0 === e && (e = 0.05), void 0 === i && (i = !1), void 0 === n && (n = null), void 0 === s && (s = this.camera.scene), !i && this.isRunning || (this.isRunning = !0, this.duration = t, this.progress = 0, typeof e === 'number' ? this.intensity.set(e) : this.intensity.set(e.x, e.y), this._elapsed = 0, this._offsetX = 0, this._offsetY = 0, this._onUpdate = n, this._onUpdateScope = s, this.camera.emit(r.SHAKE_START, this.camera, this, t, e)), this.camera; }, preRender() { this.isRunning && this.camera.matrix.translate(this._offsetX, this._offsetY); }, update(t, e) { if (this.isRunning) if (this._elapsed += e, this.progress = n(this._elapsed / this.duration, 0, 1), this._onUpdate && this._onUpdate.call(this._onUpdateScope, this.camera, this.progress), this._elapsed < this.duration) { const i = this.intensity; const s = this.camera._cw; const r = this.camera._ch; const o = this.camera.zoom; this._offsetX = (Math.random() * i.x * s * 2 - i.x * s) * o, this._offsetY = (Math.random() * i.y * r * 2 - i.y * r) * o, this.camera.roundPixels && (this._offsetX = Math.round(this._offsetX), this._offsetY = Math.round(this._offsetY)); } else this.effectComplete(); }, effectComplete() { this._offsetX = 0, this._offsetY = 0, this._onUpdate = null, this._onUpdateScope = null, this.isRunning = !1, this.camera.emit(r.SHAKE_COMPLETE, this.camera, this); }, reset() { this.isRunning = !1, this._offsetX = 0, this._offsetY = 0, this._onUpdate = null, this._onUpdateScope = null; }, destroy() { this.reset(), this.camera = null, this.intensity = null; },
  }); t.exports = a;
}, function (t, e, i) {
/**
 * @author       Jason Nicholls <nicholls.jason@gmail.com>
 * @copyright    2018 Photon Storm Ltd.
 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
 */
  const n = i(20); const s = i(0); const r = i(42); const o = i(125); const a = new s({
    initialize(t) { this.camera = t, this.isRunning = !1, this.duration = 0, this.source = 0, this.current = 0, this.destination = 0, this.ease, this.progress = 0, this._elapsed = 0, this._onUpdate, this._onUpdateScope, this.clockwise = !0, this.shortestPath = !1; }, start(t, e, i, n, s, a, h) { void 0 === i && (i = 1e3), void 0 === n && (n = o.Linear), void 0 === s && (s = !1), void 0 === a && (a = null), void 0 === h && (h = this.camera.scene), void 0 === e && (e = !1), this.shortestPath = e; let l = t; t < 0 ? (l = -1 * t, this.clockwise = !1) : this.clockwise = !0; const u = 360 * Math.PI / 180; l -= Math.floor(l / u) * u; const c = this.camera; if (!s && this.isRunning) return c; if (this.isRunning = !0, this.duration = i, this.progress = 0, this.source = c.rotation, this.destination = l, typeof n === 'string' && o.hasOwnProperty(n) ? this.ease = o[n] : typeof n === 'function' && (this.ease = n), this._elapsed = 0, this._onUpdate = a, this._onUpdateScope = h, this.shortestPath) { let d = 0; let f = 0; (d = this.destination > this.source ? Math.abs(this.destination - this.source) : Math.abs(this.destination + u) - this.source) < (f = this.source > this.destination ? Math.abs(this.source - this.destination) : Math.abs(this.source + u) - this.destination) ? this.clockwise = !0 : d > f && (this.clockwise = !1); } return this.camera.emit(r.ROTATE_START, this.camera, this, i, l), c; }, update(t, e) { if (this.isRunning) { this._elapsed += e; const i = n(this._elapsed / this.duration, 0, 1); this.progress = i; const s = this.camera; if (this._elapsed < this.duration) { const r = this.ease(i); this.current = s.rotation; let o = 0; const a = 360 * Math.PI / 180; let h = this.destination; let l = this.current; !1 === this.clockwise && (h = this.current, l = this.destination), o = h >= l ? Math.abs(h - l) : Math.abs(h + a) - l; let u = 0; u = this.clockwise ? s.rotation + o * r : s.rotation - o * r, s.rotation = u, this._onUpdate && this._onUpdate.call(this._onUpdateScope, s, i, u); } else s.rotation = this.destination, this._onUpdate && this._onUpdate.call(this._onUpdateScope, s, i, this.destination), this.effectComplete(); } }, effectComplete() { this._onUpdate = null, this._onUpdateScope = null, this.isRunning = !1, this.camera.emit(r.ROTATE_COMPLETE, this.camera, this); }, reset() { this.isRunning = !1, this._onUpdate = null, this._onUpdateScope = null; }, destroy() { this.reset(), this.camera = null, this.source = null, this.destination = null; },
  }); t.exports = a;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(20); const s = i(0); const r = i(125); const o = i(42); const a = new s({
    initialize(t) { this.camera = t, this.isRunning = !1, this.duration = 0, this.source = 1, this.destination = 1, this.ease, this.progress = 0, this._elapsed = 0, this._onUpdate, this._onUpdateScope; }, start(t, e, i, n, s, a) { void 0 === e && (e = 1e3), void 0 === i && (i = r.Linear), void 0 === n && (n = !1), void 0 === s && (s = null), void 0 === a && (a = this.camera.scene); const h = this.camera; return !n && this.isRunning || (this.isRunning = !0, this.duration = e, this.progress = 0, this.source = h.zoom, this.destination = t, typeof i === 'string' && r.hasOwnProperty(i) ? this.ease = r[i] : typeof i === 'function' && (this.ease = i), this._elapsed = 0, this._onUpdate = s, this._onUpdateScope = a, this.camera.emit(o.ZOOM_START, this.camera, this, e, t)), h; }, update(t, e) { this.isRunning && (this._elapsed += e, this.progress = n(this._elapsed / this.duration, 0, 1), this._elapsed < this.duration ? (this.camera.zoom = this.source + (this.destination - this.source) * this.ease(this.progress), this._onUpdate && this._onUpdate.call(this._onUpdateScope, this.camera, this.progress, this.camera.zoom)) : (this.camera.zoom = this.destination, this._onUpdate && this._onUpdate.call(this._onUpdateScope, this.camera, this.progress, this.destination), this.effectComplete())); }, effectComplete() { this._onUpdate = null, this._onUpdateScope = null, this.isRunning = !1, this.camera.emit(o.ZOOM_COMPLETE, this.camera, this); }, reset() { this.isRunning = !1, this._onUpdate = null, this._onUpdateScope = null; }, destroy() { this.reset(), this.camera = null; },
  }); t.exports = a;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(317); const s = i(0); const r = i(2); const o = i(23); const a = i(55); const h = i(104); const l = i(24); const u = new s({
    initialize(t) { this.scene = t, this.systems = t.sys, this.roundPixels = t.sys.game.config.roundPixels, this.cameras = [], this.main, this.default, t.sys.events.once(l.BOOT, this.boot, this), t.sys.events.on(l.START, this.start, this); }, boot() { const t = this.systems; t.settings.cameras ? this.fromJSON(t.settings.cameras) : this.add(), this.main = this.cameras[0], this.default = new n(0, 0, t.scale.width, t.scale.height).setScene(this.scene), t.game.scale.on(h.RESIZE, this.onResize, this), this.systems.events.once(l.DESTROY, this.destroy, this); }, start() { if (!this.main) { const t = this.systems; t.settings.cameras ? this.fromJSON(t.settings.cameras) : this.add(), this.main = this.cameras[0]; } const e = this.systems.events; e.on(l.UPDATE, this.update, this), e.once(l.SHUTDOWN, this.shutdown, this); }, add(t, e, i, s, r, o) { void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = this.scene.sys.scale.width), void 0 === s && (s = this.scene.sys.scale.height), void 0 === r && (r = !1), void 0 === o && (o = ''); const a = new n(t, e, i, s); return a.setName(o), a.setScene(this.scene), a.setRoundPixels(this.roundPixels), a.id = this.getNextID(), this.cameras.push(a), r && (this.main = a), a; }, addExisting(t, e) { return void 0 === e && (e = !1), this.cameras.indexOf(t) === -1 ? (t.id = this.getNextID(), t.setRoundPixels(this.roundPixels), this.cameras.push(t), e && (this.main = t), t) : null; }, getNextID() { for (let t = this.cameras, e = 1, i = 0; i < 32; i++) { for (var n = !1, s = 0; s < t.length; s++) { const r = t[s]; r && r.id === e && (n = !0); } if (!n) return e; e <<= 1; } return 0; }, getTotal(t) { void 0 === t && (t = !1); for (var e = 0, i = this.cameras, n = 0; n < i.length; n++) { const s = i[n]; (!t || t && s.visible) && e++; } return e; }, fromJSON(t) { Array.isArray(t) || (t = [t]); for (let e = this.scene.sys.scale.width, i = this.scene.sys.scale.height, n = 0; n < t.length; n++) { const s = t[n]; const o = r(s, 'x', 0); const a = r(s, 'y', 0); const h = r(s, 'width', e); const l = r(s, 'height', i); const u = this.add(o, a, h, l); u.name = r(s, 'name', ''), u.zoom = r(s, 'zoom', 1), u.rotation = r(s, 'rotation', 0), u.scrollX = r(s, 'scrollX', 0), u.scrollY = r(s, 'scrollY', 0), u.roundPixels = r(s, 'roundPixels', !1), u.visible = r(s, 'visible', !0); const c = r(s, 'backgroundColor', !1); c && u.setBackgroundColor(c); const d = r(s, 'bounds', null); if (d) { const f = r(d, 'x', 0); const p = r(d, 'y', 0); const g = r(d, 'width', e); const v = r(d, 'height', i); u.setBounds(f, p, g, v); } } return this; }, getCamera(t) { for (let e = this.cameras, i = 0; i < e.length; i++) if (e[i].name === t) return e[i]; return null; }, getCamerasBelowPointer(t) { for (var e = this.cameras, i = t.x, n = t.y, s = [], r = 0; r < e.length; r++) { const o = e[r]; o.visible && o.inputEnabled && a(o, i, n) && s.unshift(o); } return s; }, remove(t, e) { void 0 === e && (e = !0), Array.isArray(t) || (t = [t]); for (var i = 0, n = this.cameras, s = 0; s < t.length; s++) { const r = n.indexOf(t[s]); r !== -1 && (e && n[r].destroy(), n.splice(r, 1), i++); } return !this.main && n[0] && (this.main = n[0]), i; }, render(t, e, i) { for (let n = this.scene, s = this.cameras, r = 0; r < this.cameras.length; r++) { const o = s[r]; o.visible && o.alpha > 0 && (o.preRender(1), t.render(n, e, i, o)); } }, resetAll() { for (let t = 0; t < this.cameras.length; t++) this.cameras[t].destroy(); return this.cameras = [], this.main = this.add(), this.main; }, update(t, e) { for (let i = 0; i < this.cameras.length; i++) this.cameras[i].update(t, e); }, onResize(t, e, i, n, s, r) { for (let o = 0; o < this.cameras.length; o++) { const a = this.cameras[o]; a._x === 0 && a._y === 0 && a._width === s && a._height === r && a.setSize(e.width, e.height); } }, resize(t, e) { for (let i = 0; i < this.cameras.length; i++) this.cameras[i].setSize(t, e); }, shutdown() { this.main = void 0; for (let t = 0; t < this.cameras.length; t++) this.cameras[t].destroy(); this.cameras = []; const e = this.systems.events; e.off(l.UPDATE, this.update, this), e.off(l.SHUTDOWN, this.shutdown, this); }, destroy() { this.shutdown(), this.default.destroy(), this.scene.sys.events.off(l.START, this.start, this), this.scene = null, this.systems = null; },
  }); o.register('CameraManager', u, 'cameras'), t.exports = u;
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'enterfullscreen';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'fullscreenfailed';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'fullscreenunsupported';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'leavefullscreen';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'orientationchange';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'resize';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'boot';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'create';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'destroy';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'pause';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'postupdate';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'preupdate';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'ready';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'render';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'resume';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'shutdown';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'sleep';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'start';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'transitioncomplete';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'transitioninit';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'transitionout';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'transitionstart';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'transitionwake';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'update';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'wake';
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = {
    Config: i(338), CreateRenderer: i(362), DebugHeader: i(374), Events: i(22), TimeStep: i(375), VisibilityHandler: i(377),
  };
}, function (t, e) { let i; let n; const s = t.exports = {}; function r() { throw new Error('setTimeout has not been defined'); } function o() { throw new Error('clearTimeout has not been defined'); } function a(t) { if (i === setTimeout) return setTimeout(t, 0); if ((i === r || !i) && setTimeout) return i = setTimeout, setTimeout(t, 0); try { return i(t, 0); } catch (e) { try { return i.call(null, t, 0); } catch (e) { return i.call(this, t, 0); } } }!(function () { try { i = typeof setTimeout === 'function' ? setTimeout : r; } catch (t) { i = r; } try { n = typeof clearTimeout === 'function' ? clearTimeout : o; } catch (t) { n = o; } }()); let h; let l = []; let u = !1; let c = -1; function d() { u && h && (u = !1, h.length ? l = h.concat(l) : c = -1, l.length && f()); } function f() { if (!u) { const t = a(d); u = !0; for (let e = l.length; e;) { for (h = l, l = []; ++c < e;)h && h[c].run(); c = -1, e = l.length; }h = null, u = !1, (function (t) { if (n === clearTimeout) return clearTimeout(t); if ((n === o || !n) && clearTimeout) return n = clearTimeout, clearTimeout(t); try { n(t); } catch (e) { try { return n.call(null, t); } catch (e) { return n.call(this, t); } } }(t)); } } function p(t, e) { this.fun = t, this.array = e; } function g() {}s.nextTick = function (t) { const e = new Array(arguments.length - 1); if (arguments.length > 1) for (let i = 1; i < arguments.length; i++)e[i - 1] = arguments[i]; l.push(new p(t, e)), l.length !== 1 || u || a(f); }, p.prototype.run = function () { this.fun.apply(null, this.array); }, s.title = 'browser', s.browser = !0, s.env = {}, s.argv = [], s.version = '', s.versions = {}, s.on = g, s.addListener = g, s.once = g, s.off = g, s.removeListener = g, s.removeAllListeners = g, s.emit = g, s.prependListener = g, s.prependOnceListener = g, s.listeners = function (t) { return []; }, s.binding = function (t) { throw new Error('process.binding is not supported'); }, s.cwd = function () { return '/'; }, s.chdir = function (t) { throw new Error('process.chdir is not supported'); }, s.umask = function () { return 0; }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(128); const s = {
    gamepads: !1, mspointer: !1, touch: !1, wheelEvent: null,
  }; t.exports = (('ontouchstart' in document.documentElement || navigator.maxTouchPoints && navigator.maxTouchPoints >= 1) && (s.touch = !0), (navigator.msPointerEnabled || navigator.pointerEnabled) && (s.mspointer = !0), navigator.getGamepads && (s.gamepads = !0), 'onwheel' in window || n.ie && 'WheelEvent' in window ? s.wheelEvent = 'wheel' : 'onmousewheel' in window ? s.wheelEvent = 'mousewheel' : n.firefox && 'MouseScrollEvent' in window && (s.wheelEvent = 'DOMMouseScroll'), s);
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(128); const s = {
    audioData: !1, dolby: !1, m4a: !1, mp3: !1, ogg: !1, opus: !1, wav: !1, webAudio: !1, webm: !1,
  }; t.exports = (function () { s.audioData = !!window.Audio, s.webAudio = !(!window.AudioContext && !window.webkitAudioContext); const t = document.createElement('audio'); const e = !!t.canPlayType; try { if (e && (t.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, '') && (s.ogg = !0), (t.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, '') || t.canPlayType('audio/opus;').replace(/^no$/, '')) && (s.opus = !0), t.canPlayType('audio/mpeg;').replace(/^no$/, '') && (s.mp3 = !0), t.canPlayType('audio/wav; codecs="1"').replace(/^no$/, '') && (s.wav = !0), (t.canPlayType('audio/x-m4a;') || t.canPlayType('audio/aac;').replace(/^no$/, '')) && (s.m4a = !0), t.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, '') && (s.webm = !0), t.canPlayType('audio/mp4;codecs="ec-3"') !== '')) if (n.edge)s.dolby = !0; else if (n.safari && n.safariVersion >= 9 && /Mac OS X (\d+)_(\d+)/.test(navigator.userAgent)) { const i = parseInt(RegExp.$1, 10); const r = parseInt(RegExp.$2, 10); (i === 10 && r >= 11 || i > 10) && (s.dolby = !0); } } catch (t) {} return s; }());
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const i = {
    h264: !1, hls: !1, mp4: !1, ogg: !1, vp9: !1, webm: !1,
  }; t.exports = (function () { const t = document.createElement('video'); const e = !!t.canPlayType; try { e && (t.canPlayType('video/ogg; codecs="theora"').replace(/^no$/, '') && (i.ogg = !0), t.canPlayType('video/mp4; codecs="avc1.42E01E"').replace(/^no$/, '') && (i.h264 = !0, i.mp4 = !0), t.canPlayType('video/webm; codecs="vp8, vorbis"').replace(/^no$/, '') && (i.webm = !0), t.canPlayType('video/webm; codecs="vp9"').replace(/^no$/, '') && (i.vp9 = !0), t.canPlayType('application/x-mpegURL; codecs="avc1.42E01E"').replace(/^no$/, '') && (i.hls = !0)); } catch (t) {} return i; }());
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const i = {
    available: !1, cancel: '', keyboard: !1, request: '',
  }; t.exports = (function () { let t; const e = 'Fullscreen'; const n = 'FullScreen'; const s = [`request${e}`, `request${n}`, `webkitRequest${e}`, `webkitRequest${n}`, `msRequest${e}`, `msRequest${n}`, `mozRequest${n}`, `mozRequest${e}`]; for (t = 0; t < s.length; t++) if (document.documentElement[s[t]]) { i.available = !0, i.request = s[t]; break; } const r = [`cancel${n}`, `exit${e}`, `webkitCancel${n}`, `webkitExit${e}`, `msCancel${n}`, `msExit${e}`, `mozCancel${n}`, `mozExit${e}`]; if (i.available) for (t = 0; t < r.length; t++) if (document[r[t]]) { i.cancel = r[t]; break; } return window.Element && Element.ALLOW_KEYBOARD_INPUT && !/ Version\/5\.1(?:\.\d+)? Safari\//.test(navigator.userAgent) && (i.keyboard = !0), Object.defineProperty(i, 'active', { get() { return !!(document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement); } }), i; }());
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = {
    Between: i(341), BetweenPoints: i(764), BetweenPointsY: i(765), BetweenY: i(766), CounterClockwise: i(767), Normalize: i(342), Random: i(768), RandomDegrees: i(769), Reverse: i(770), RotateTo: i(771), ShortestBetween: i(772), Wrap: i(170), WrapDegrees: i(171),
  };
}, function (t, e) { t.exports = function (t, e) { return Math.atan2(e.y - t.y, e.x - t.x); }; }, function (t, e) { t.exports = function (t, e) { return Math.atan2(e.x - t.x, e.y - t.y); }; }, function (t, e) { t.exports = function (t, e, i, n) { return Math.atan2(i - t, n - e); }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(16); t.exports = function (t) { return t > Math.PI && (t -= n.PI2), Math.abs(((t + n.TAU) % n.PI2 - n.PI2) % n.PI2); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       @samme
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(129); t.exports = function () { return n(-Math.PI, Math.PI); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       @samme
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(129); t.exports = function () { return n(-180, 180); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(342); t.exports = function (t) { return n(t + Math.PI); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(16); t.exports = function (t, e, i) { return void 0 === i && (i = 0.05), t === e || (Math.abs(e - t) <= i || Math.abs(e - t) >= n.PI2 - i ? t = e : (Math.abs(e - t) > Math.PI && (e < t ? e += n.PI2 : e -= n.PI2), e > t ? t += i : e < t && (t -= i))), t; };
}, function (t, e) { t.exports = function (t, e) { const i = e - t; return i === 0 ? 0 : i - 360 * Math.floor((i - -180) / 360); }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = {
    Between: i(56), BetweenPoints: i(343), BetweenPointsSquared: i(774), Chebyshev: i(775), Power: i(776), Snake: i(777), Squared: i(344),
  };
}, function (t, e) { t.exports = function (t, e) { const i = t.x - e.x; const n = t.y - e.y; return i * i + n * n; }; }, function (t, e) { t.exports = function (t, e, i, n) { return Math.max(Math.abs(t - i), Math.abs(e - n)); }; }, function (t, e) { t.exports = function (t, e, i, n, s) { return void 0 === s && (s = 2), Math.sqrt(Math.pow(i - t, s) + Math.pow(n - e, s)); }; }, function (t, e) { t.exports = function (t, e, i, n) { return Math.abs(t - i) + Math.abs(e - n); }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = {
    Back: i(326), Bounce: i(327), Circular: i(328), Cubic: i(329), Elastic: i(330), Expo: i(331), Linear: i(332), Quadratic: i(333), Quartic: i(334), Quintic: i(335), Sine: i(336), Stepped: i(337),
  };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = {
    Ceil: i(780), Equal: i(98), Floor: i(781), GreaterThan: i(345), LessThan: i(346),
  };
}, function (t, e) { t.exports = function (t, e) { return void 0 === e && (e = 1e-4), Math.ceil(t - e); }; }, function (t, e) { t.exports = function (t, e) { return void 0 === e && (e = 1e-4), Math.floor(t + e); }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = {
    Bezier: i(783), CatmullRom: i(784), CubicBezier: i(349), Linear: i(785), QuadraticBezier: i(350), SmoothStep: i(351), SmootherStep: i(786),
  };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(347); t.exports = function (t, e) { for (var i = 0, s = t.length - 1, r = 0; r <= s; r++)i += Math.pow(1 - e, s - r) * Math.pow(e, r) * t[r] * n(s, r); return i; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(186); t.exports = function (t, e) { const i = t.length - 1; let s = i * e; let r = Math.floor(s); return t[0] === t[i] ? (e < 0 && (r = Math.floor(s = i * (1 + e))), n(s - r, t[(r - 1 + i) % i], t[r], t[(r + 1) % i], t[(r + 2) % i])) : e < 0 ? t[0] - (n(-s, t[0], t[0], t[1], t[1]) - t[0]) : e > 1 ? t[i] - (n(s - i, t[i], t[i], t[i - 1], t[i - 1]) - t[i]) : n(s - r, t[r ? r - 1 : 0], t[r], t[i < r + 1 ? i : r + 1], t[i < r + 2 ? i : r + 2]); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(126); t.exports = function (t, e) { const i = t.length - 1; const s = i * e; const r = Math.floor(s); return e < 0 ? n(t[0], t[1], s) : e > 1 ? n(t[i], t[i - 1], i - s) : n(t[r], t[r + 1 > i ? i : r + 1], s - r); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(175); t.exports = function (t, e, i) { return e + (i - e) * n(t, 0, 1); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = { GetNext: i(352), IsSize: i(130), IsValue: i(788) };
}, function (t, e) { t.exports = function (t) { return t > 0 && (t & t - 1) == 0; }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = { Ceil: i(353), Floor: i(105), To: i(790) };
}, function (t, e) { t.exports = function (t, e, i, n) { return void 0 === i && (i = 0), e === 0 ? t : (t -= i, t = e * Math.round(t / e), n ? (i + t) / e : i + t); }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = new (i(0))({
    initialize(t) { void 0 === t && (t = [(Date.now() * Math.random()).toString()]), this.c = 1, this.s0 = 0, this.s1 = 0, this.s2 = 0, this.n = 0, this.signs = [-1, 1], t && this.init(t); }, rnd() { const t = 2091639 * this.s0 + 2.3283064365386963e-10 * this.c; return this.c = 0 | t, this.s0 = this.s1, this.s1 = this.s2, this.s2 = t - this.c, this.s2; }, hash(t) { let e; let i = this.n; t = t.toString(); for (let n = 0; n < t.length; n++)e = 0.02519603282416938 * (i += t.charCodeAt(n)), e -= i = e >>> 0, i = (e *= i) >>> 0, i += 4294967296 * (e -= i); return this.n = i, 2.3283064365386963e-10 * (i >>> 0); }, init(t) { typeof t === 'string' ? this.state(t) : this.sow(t); }, sow(t) { if (this.n = 4022871197, this.s0 = this.hash(' '), this.s1 = this.hash(' '), this.s2 = this.hash(' '), this.c = 1, t) for (let e = 0; e < t.length && t[e] != null; e++) { const i = t[e]; this.s0 -= this.hash(i), this.s0 += ~~(this.s0 < 0), this.s1 -= this.hash(i), this.s1 += ~~(this.s1 < 0), this.s2 -= this.hash(i), this.s2 += ~~(this.s2 < 0); } }, integer() { return 4294967296 * this.rnd(); }, frac() { return this.rnd() + 11102230246251565e-32 * (2097152 * this.rnd() | 0); }, real() { return this.integer() + this.frac(); }, integerInRange(t, e) { return Math.floor(this.realInRange(0, e - t + 1) + t); }, between(t, e) { return Math.floor(this.realInRange(0, e - t + 1) + t); }, realInRange(t, e) { return this.frac() * (e - t) + t; }, normal() { return 1 - 2 * this.frac(); }, uuid() { let t = ''; let e = ''; for (e = t = ''; t++ < 36; e += ~t % 5 | 3 * t & 4 ? (15 ^ t ? 8 ^ this.frac() * (20 ^ t ? 16 : 4) : 4).toString(16) : '-');return e; }, pick(t) { return t[this.integerInRange(0, t.length - 1)]; }, sign() { return this.pick(this.signs); }, weightedPick(t) { return t[~~(Math.pow(this.frac(), 2) * (t.length - 1) + 0.5)]; }, timestamp(t, e) { return this.realInRange(t || 9466848e5, e || 1577862e6); }, angle() { return this.integerInRange(-180, 180); }, rotation() { return this.realInRange(-3.1415926, 3.1415926); }, state(t) { return typeof t === 'string' && t.match(/^!rnd/) && (t = t.split(','), this.c = parseFloat(t[1]), this.s0 = parseFloat(t[2]), this.s1 = parseFloat(t[3]), this.s2 = parseFloat(t[4])), ['!rnd', this.c, this.s0, this.s1, this.s2].join(','); }, shuffle(t) { for (let e = t.length - 1; e > 0; e--) { const i = Math.floor(this.frac() * (e + 1)); const n = t[i]; t[i] = t[e], t[e] = n; } return t; },
  }); t.exports = n;
}, function (t, e) { t.exports = function (t) { for (var e = 0, i = 0; i < t.length; i++)e += +t[i]; return e / t.length; }; }, function (t, e) { t.exports = function (t, e, i) { void 0 === e && (e = 0), void 0 === i && (i = 10); const n = Math.pow(i, -e); return Math.ceil(t * n) / n; }; }, function (t, e) { t.exports = function (t, e) { return Math.abs(t - e); }; }, function (t, e) { t.exports = function (t, e, i) { void 0 === e && (e = 0), void 0 === i && (i = 10); const n = Math.pow(i, -e); return Math.floor(t * n) / n; }; }, function (t, e) { t.exports = function (t, e) { return t / e / 1e3; }; }, function (t, e) { t.exports = function (t) { return t == parseFloat(t) ? !(t % 2) : void 0; }; }, function (t, e) { t.exports = function (t) { return t === parseFloat(t) ? !(t % 2) : void 0; }; }, function (t, e) { t.exports = function (t, e, i) { return Math.min(t + e, i); }; }, function (t, e) { t.exports = function (t, e, i) { return Math.max(t - e, i); }; }, function (t, e) { t.exports = function (t, e, i, n) { void 0 === i && (i = e + 1); let s = (t - e) / (i - e); return s > 1 ? void 0 !== n ? (s = (n - t) / (n - i)) < 0 && (s = 0) : s = 1 : s < 0 && (s = 0), s; }; }, function (t, e) { t.exports = function (t, e) { void 0 === e && (e = 1); const i = 2 * Math.random() * Math.PI; return t.x = Math.cos(i) * e, t.y = Math.sin(i) * e, t; }; }, function (t, e) { t.exports = function (t, e, i) { void 0 === e && (e = 0), void 0 === i && (i = 10); const n = Math.pow(i, -e); return Math.round(t * n) / n; }; }, function (t, e) { t.exports = function (t, e, i, n) { void 0 === e && (e = 1), void 0 === i && (i = 1), void 0 === n && (n = 1), n *= Math.PI / t; for (var s = [], r = [], o = 0; o < t; o++)e += (i -= e * n) * n, s[o] = i, r[o] = e; return { sin: r, cos: s, length: t }; }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(3); t.exports = function (t, e, i, s) { void 0 === s && (s = new n()); let r = 0; let o = 0; return t > 0 && t <= e * i && (r = t > e - 1 ? t - (o = Math.floor(t / e)) * e : t, s.set(r, o)), s; };
}, function (t, e) { t.exports = function (t, e, i) { return Math.abs(t - e) <= i; }; }, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'addtexture';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'onerror';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'onload';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'ready';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'removetexture';
}, function (t, e) { t.exports = ['#define SHADER_NAME PHASER_BITMAP_MASK_FS', '', 'precision mediump float;', '', 'uniform vec2 uResolution;', 'uniform sampler2D uMainSampler;', 'uniform sampler2D uMaskSampler;', 'uniform bool uInvertMaskAlpha;', '', 'void main()', '{', '    vec2 uv = gl_FragCoord.xy / uResolution;', '    vec4 mainColor = texture2D(uMainSampler, uv);', '    vec4 maskColor = texture2D(uMaskSampler, uv);', '    float alpha = mainColor.a;', '', '    if (!uInvertMaskAlpha)', '    {', '        alpha *= (maskColor.a);', '    }', '    else', '    {', '        alpha *= (1.0 - maskColor.a);', '    }', '', '    gl_FragColor = vec4(mainColor.rgb * alpha, alpha);', '}', ''].join('\n'); }, function (t, e) { t.exports = ['#define SHADER_NAME PHASER_BITMAP_MASK_VS', '', 'precision mediump float;', '', 'attribute vec2 inPosition;', '', 'void main()', '{', '    gl_Position = vec4(inPosition, 0.0, 1.0);', '}', ''].join('\n'); }, function (t, e) { t.exports = ['#define SHADER_NAME PHASER_FORWARD_DIFFUSE_FS', '', 'precision mediump float;', '', 'struct Light', '{', '    vec2 position;', '    vec3 color;', '    float intensity;', '    float radius;', '};', '', 'const int kMaxLights = %LIGHT_COUNT%;', '', 'uniform vec4 uCamera; /* x, y, rotation, zoom */', 'uniform vec2 uResolution;', 'uniform sampler2D uMainSampler;', 'uniform sampler2D uNormSampler;', 'uniform vec3 uAmbientLightColor;', 'uniform Light uLights[kMaxLights];', 'uniform mat3 uInverseRotationMatrix;', '', 'varying vec2 outTexCoord;', 'varying vec4 outTint;', '', 'void main()', '{', '    vec3 finalColor = vec3(0.0, 0.0, 0.0);', '    vec4 color = texture2D(uMainSampler, outTexCoord) * vec4(outTint.rgb * outTint.a, outTint.a);', '    vec3 normalMap = texture2D(uNormSampler, outTexCoord).rgb;', '    vec3 normal = normalize(uInverseRotationMatrix * vec3(normalMap * 2.0 - 1.0));', '    vec2 res = vec2(min(uResolution.x, uResolution.y)) * uCamera.w;', '', '    for (int index = 0; index < kMaxLights; ++index)', '    {', '        Light light = uLights[index];', '        vec3 lightDir = vec3((light.position.xy / res) - (gl_FragCoord.xy / res), 0.1);', '        vec3 lightNormal = normalize(lightDir);', '        float distToSurf = length(lightDir) * uCamera.w;', '        float diffuseFactor = max(dot(normal, lightNormal), 0.0);', '        float radius = (light.radius / res.x * uCamera.w) * uCamera.w;', '        float attenuation = clamp(1.0 - distToSurf * distToSurf / (radius * radius), 0.0, 1.0);', '        vec3 diffuse = light.color * diffuseFactor;', '        finalColor += (attenuation * diffuse) * light.intensity;', '    }', '', '    vec4 colorOutput = vec4(uAmbientLightColor + finalColor, 1.0);', '    gl_FragColor = color * vec4(colorOutput.rgb * colorOutput.a, colorOutput.a);', '', '}', ''].join('\n'); }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = { GenerateTexture: i(378), Palettes: i(816) };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = {
    ARNE16: i(379), C64: i(817), CGA: i(818), JMP: i(819), MSX: i(820),
  };
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = {
    0: '#000', 1: '#fff', 2: '#8b4131', 3: '#7bbdc5', 4: '#8b41ac', 5: '#6aac41', 6: '#3931a4', 7: '#d5de73', 8: '#945a20', 9: '#5a4100', A: '#bd736a', B: '#525252', C: '#838383', D: '#acee8b', E: '#7b73de', F: '#acacac',
  };
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = {
    0: '#000', 1: '#2234d1', 2: '#0c7e45', 3: '#44aacc', 4: '#8a3622', 5: '#5c2e78', 6: '#aa5c3d', 7: '#b5b5b5', 8: '#5e606e', 9: '#4c81fb', A: '#6cd947', B: '#7be2f9', C: '#eb8a60', D: '#e23d69', E: '#ffd93f', F: '#fff',
  };
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = {
    0: '#000', 1: '#191028', 2: '#46af45', 3: '#a1d685', 4: '#453e78', 5: '#7664fe', 6: '#833129', 7: '#9ec2e8', 8: '#dc534b', 9: '#e18d79', A: '#d6b97b', B: '#e9d8a1', C: '#216c4b', D: '#d365c8', E: '#afaab9', F: '#f5f4eb',
  };
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = {
    0: '#000', 1: '#191028', 2: '#46af45', 3: '#a1d685', 4: '#453e78', 5: '#7664fe', 6: '#833129', 7: '#9ec2e8', 8: '#dc534b', 9: '#e18d79', A: '#d6b97b', B: '#e9d8a1', C: '#216c4b', D: '#d365c8', E: '#afaab9', F: '#fff',
  };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = {
    Path: i(822), CubicBezier: i(380), Curve: i(89), Ellipse: i(381), Line: i(382), QuadraticBezier: i(383), Spline: i(384),
  };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(380); const r = i(381); const o = i(5); const a = i(382); const h = i(823); const l = i(383); const u = i(12); const c = i(384); const d = i(3); const f = i(16); const p = new n({
    initialize(t, e) { void 0 === t && (t = 0), void 0 === e && (e = 0), this.name = '', this.curves = [], this.cacheLengths = [], this.autoClose = !1, this.startPoint = new d(), this._tmpVec2A = new d(), this._tmpVec2B = new d(), typeof t === 'object' ? this.fromJSON(t) : this.startPoint.set(t, e); },
    add(t) { return this.curves.push(t), this; },
    circleTo(t, e, i) { return void 0 === e && (e = !1), this.ellipseTo(t, t, 0, 360, e, i); },
    closePath() { const t = this.curves[0].getPoint(0); const e = this.curves[this.curves.length - 1].getPoint(1); return t.equals(e) || this.curves.push(new a(e, t)), this; },
    cubicBezierTo(t, e, i, n, r, o) { let a; let h; let l; const u = this.getEndPoint(); return t instanceof d ? (a = t, h = e, l = i) : (a = new d(i, n), h = new d(r, o), l = new d(t, e)), this.add(new s(u, a, h, l)); },
    quadraticBezierTo(t, e, i, n) { let s; let r; const o = this.getEndPoint(); return t instanceof d ? (s = t, r = e) : (s = new d(i, n), r = new d(t, e)), this.add(new l(o, s, r)); },
    draw(t, e) { for (let i = 0; i < this.curves.length; i++) { const n = this.curves[i]; n.active && n.draw(t, e); } return t; },
    ellipseTo(t, e, i, n, s, o) { const a = new r(0, 0, t, e, i, n, s, o); const h = this.getEndPoint(this._tmpVec2A); const l = a.getStartPoint(this._tmpVec2B); return h.subtract(l), a.x = h.x, a.y = h.y, this.add(a); },
    fromJSON(t) { this.curves = [], this.cacheLengths = [], this.startPoint.set(t.x, t.y), this.autoClose = t.autoClose; for (let e = 0; e < t.curves.length; e++) { const i = t.curves[e]; switch (i.type) { case 'LineCurve': this.add(a.fromJSON(i)); break; case 'EllipseCurve': this.add(r.fromJSON(i)); break; case 'SplineCurve': this.add(c.fromJSON(i)); break; case 'CubicBezierCurve': this.add(s.fromJSON(i)); break; case 'QuadraticBezierCurve': this.add(l.fromJSON(i)); } } return this; },
    getBounds(t, e) { void 0 === t && (t = new u()), void 0 === e && (e = 16), t.x = Number.MAX_VALUE, t.y = Number.MAX_VALUE; for (var i = new u(), n = f.MIN_SAFE_INTEGER, s = f.MIN_SAFE_INTEGER, r = 0; r < this.curves.length; r++) { const o = this.curves[r]; o.active && (o.getBounds(i, e), t.x = Math.min(t.x, i.x), t.y = Math.min(t.y, i.y), n = Math.max(n, i.right), s = Math.max(s, i.bottom)); } return t.right = n, t.bottom = s, t; },
    getCurveLengths() { if (this.cacheLengths.length === this.curves.length) return this.cacheLengths; for (var t = [], e = 0, i = 0; i < this.curves.length; i++)e += this.curves[i].getLength(), t.push(e); return this.cacheLengths = t, t; },
    getEndPoint(t) { return void 0 === t && (t = new d()), this.curves.length > 0 ? this.curves[this.curves.length - 1].getPoint(1, t) : t.copy(this.startPoint), t; },
    getLength() { const t = this.getCurveLengths(); return t[t.length - 1]; },
    getPoint(t, e) { void 0 === e && (e = new d()); for (let i = t * this.getLength(), n = this.getCurveLengths(), s = 0; s < n.length;) { if (n[s] >= i) { const r = n[s] - i; const o = this.curves[s]; const a = o.getLength(); const h = a === 0 ? 0 : 1 - r / a; return o.getPointAt(h, e); }s++; } return null; },
    getPoints(t) { void 0 === t && (t = 12); for (var e, i = [], n = 0; n < this.curves.length; n++) { const s = this.curves[n]; if (s.active) for (let r = s.getResolution(t), o = s.getPoints(r), a = 0; a < o.length; a++) { const h = o[a]; e && e.equals(h) || (i.push(h), e = h); } } return this.autoClose && i.length > 1 && !i[i.length - 1].equals(i[0]) && i.push(i[0]), i; },
    getRandomPoint(t) { return void 0 === t && (t = new d()), this.getPoint(Math.random(), t); },
    getSpacedPoints(t) { void 0 === t && (t = 40); for (var e = [], i = 0; i <= t; i++)e.push(this.getPoint(i / t)); return this.autoClose && e.push(e[0]), e; },
    getStartPoint(t) { return void 0 === t && (t = new d()), t.copy(this.startPoint); },
    getTangent(t, e) { void 0 === e && (e = new d()); for (let i = t * this.getLength(), n = this.getCurveLengths(), s = 0; s < n.length;) { if (n[s] >= i) { const r = n[s] - i; const o = this.curves[s]; const a = o.getLength(); const h = a === 0 ? 0 : 1 - r / a; return o.getTangentAt(h, e); }s++; } return null; },
    lineTo(t, e) { t instanceof d ? this._tmpVec2B.copy(t) : this._tmpVec2B.set(t, e); const i = this.getEndPoint(this._tmpVec2A); return this.add(new a([i.x, i.y, this._tmpVec2B.x, this._tmpVec2B.y])); },
    splineTo(t) { return t.unshift(this.getEndPoint()), this.add(new c(t)); },
    moveTo(t, e) { return t instanceof d ? this.add(new h(t.x, t.y)) : this.add(new h(t, e)); },
    toJSON() {
      for (var t = [], e = 0; e < this.curves.length; e++)t.push(this.curves[e].toJSON()); return {
        type: 'Path', x: this.startPoint.x, y: this.startPoint.y, autoClose: this.autoClose, curves: t,
      };
    },
    updateArcLengths() { this.cacheLengths = [], this.getCurveLengths(); },
    destroy() { this.curves.length = 0, this.cacheLengths.length = 0, this.startPoint = void 0; },
  }); o.register('path', ((t, e) => new p(t, e))), t.exports = p;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(3); const r = new n({
    initialize(t, e) { this.active = !1, this.p0 = new s(t, e); }, getPoint(t, e) { return void 0 === e && (e = new s()), e.copy(this.p0); }, getPointAt(t, e) { return this.getPoint(t, e); }, getResolution() { return 1; }, getLength() { return 0; }, toJSON() { return { type: 'MoveTo', points: [this.p0.x, this.p0.y] }; },
  }); t.exports = r;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = { DataManager: i(101), DataManagerPlugin: i(825), Events: i(308) };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(101); const r = i(23); const o = i(24); const a = new n({
    Extends: s, initialize(t) { s.call(this, t, t.sys.events), this.scene = t, this.systems = t.sys, t.sys.events.once(o.BOOT, this.boot, this), t.sys.events.on(o.START, this.start, this); }, boot() { this.events = this.systems.events, this.events.once(o.DESTROY, this.destroy, this); }, start() { this.events.once(o.SHUTDOWN, this.shutdown, this); }, shutdown() { this.systems.events.off(o.SHUTDOWN, this.shutdown, this); }, destroy() { s.prototype.destroy.call(this), this.events.off(o.START, this.start, this), this.scene = null, this.systems = null; },
  }); r.register('DataManagerPlugin', a, 'data'), t.exports = a;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = {
    Align: i(827), BaseShader: i(385), Bounds: i(830), Canvas: i(833), Color: i(386), Masks: i(842),
  };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(96); const s = i(19); let r = { In: i(828), To: i(829) }; r = s(!1, r, n), t.exports = r;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = {
    BottomCenter: i(279), BottomLeft: i(280), BottomRight: i(281), Center: i(282), LeftCenter: i(284), QuickSet: i(278), RightCenter: i(285), TopCenter: i(286), TopLeft: i(287), TopRight: i(288),
  };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = {
    BottomCenter: i(266), BottomLeft: i(267), BottomRight: i(268), LeftBottom: i(269), LeftCenter: i(270), LeftTop: i(271), QuickSet: i(265), RightBottom: i(272), RightCenter: i(273), RightTop: i(274), TopCenter: i(275), TopLeft: i(276), TopRight: i(277),
  };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = {
    CenterOn: i(283), GetBottom: i(46), GetCenterX: i(83), GetCenterY: i(85), GetLeft: i(48), GetOffsetX: i(831), GetOffsetY: i(832), GetRight: i(50), GetTop: i(53), SetBottom: i(52), SetCenterX: i(84), SetCenterY: i(86), SetLeft: i(49), SetRight: i(51), SetTop: i(47),
  };
}, function (t, e) { t.exports = function (t) { return t.width * t.originX; }; }, function (t, e) { t.exports = function (t) { return t.height * t.originY; }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = {
    CanvasInterpolation: i(363), CanvasPool: i(30), Smoothing: i(182), TouchAction: i(834), UserSelect: i(835),
  };
}, function (t, e) { t.exports = function (t, e) { return void 0 === e && (e = 'none'), t.style.msTouchAction = e, t.style['ms-touch-action'] = e, t.style['touch-action'] = e, t; }; }, function (t, e) { t.exports = function (t, e) { void 0 === e && (e = 'none'); return ['-webkit-', '-khtml-', '-moz-', '-ms-', ''].forEach(((i) => { t.style[`${i}user-select`] = e; })), t.style['-webkit-touch-callout'] = e, t.style['-webkit-tap-highlight-color'] = 'rgba(0, 0, 0, 0)', t; }; }, function (t, e) {
  t.exports = function (t) {
    const e = {
      r: t >> 16 & 255, g: t >> 8 & 255, b: 255 & t, a: 255,
    }; return t > 16777215 && (e.a = t >>> 24), e;
  };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(35); const s = i(388); t.exports = function (t, e, i) { let r = i; let o = i; let a = i; if (e !== 0) { const h = i < 0.5 ? i * (1 + e) : i + e - i * e; const l = 2 * i - h; r = s(l, h, t + 1 / 3), o = s(l, h, t), a = s(l, h, t - 1 / 3); } return (new n()).setGLTo(r, o, a, 1); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(181); t.exports = function (t, e) { void 0 === t && (t = 1), void 0 === e && (e = 1); for (var i = [], s = 0; s <= 359; s++)i.push(n(s / 359, t, e)); return i; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(126); const s = function (t, e, i, s, r, o, a, h) { void 0 === a && (a = 100), void 0 === h && (h = 0); const l = h / a; return { r: n(t, s, l), g: n(e, r, l), b: n(i, o, l) }; }; t.exports = { RGBWithRGB: s, ColorWithRGB(t, e, i, n, r, o) { return void 0 === r && (r = 100), void 0 === o && (o = 0), s(t.r, t.g, t.b, e, i, n, r, o); }, ColorWithColor(t, e, i, n) { return void 0 === i && (i = 100), void 0 === n && (n = 0), s(t.r, t.g, t.b, e.r, e.g, e.b, i, n); } };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(187); const s = i(35); t.exports = function (t, e) { return void 0 === t && (t = 0), void 0 === e && (e = 255), new s(n(t, e), n(t, e), n(t, e)); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(387); t.exports = function (t, e, i, s, r) { return void 0 === s && (s = 255), void 0 === r && (r = '#'), r === '#' ? `#${((1 << 24) + (t << 16) + (e << 8) + i).toString(16).slice(1)}` : `0x${n(s)}${n(t)}${n(e)}${n(i)}`; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = { BitmapMask: i(302), GeometryMask: i(303) };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = {
    AddToDOM: i(134), DOMContentLoaded: i(389), GetScreenOrientation: i(390), GetTarget: i(395), ParseXML: i(396), RemoveFromDOM: i(195), RequestAnimationFrame: i(376),
  }; t.exports = n;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = { EventEmitter: i(845) };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(10); const r = i(23); const o = new n({
    Extends: s, initialize() { s.call(this); }, shutdown() { this.removeAllListeners(); }, destroy() { this.removeAllListeners(); },
  }); r.register('EventEmitter', o, 'events'), t.exports = o;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(134); const s = i(313); const r = i(316); const o = i(30); const a = i(0); const h = i(338); const l = i(847); const u = i(362); const c = i(101); const d = i(374); const f = i(339); const p = i(389); const g = i(10); const v = i(22); const m = i(397); const y = i(23); const x = i(402); const T = i(403); const w = i(405); const b = i(132); const E = i(408); const S = i(375); const A = i(377); const _ = i(412); const C = i(422); const M = new a({
    initialize(t) { this.config = new h(t), this.renderer = null, this.domContainer = null, this.canvas = null, this.context = null, this.isBooted = !1, this.isRunning = !1, this.events = new g(), this.anims = new s(this), this.textures = new E(this), this.cache = new r(this), this.registry = new c(this), this.input = new m(this, this.config), this.scene = new w(this, this.config.sceneConfig), this.device = f, this.scale = new T(this, this.config), this.sound = null, this.sound = _.create(this), this.loop = new S(this, this.config.fps), this.plugins = new x(this, this.config), this.facebook = new C(this), this.pendingDestroy = !1, this.removeCanvas = !1, this.noReturn = !1, this.hasFocus = !1, p(this.boot.bind(this)); }, boot() { y.hasCore('EventEmitter') ? (this.isBooted = !0, this.config.preBoot(this), this.scale.preBoot(), u(this), l(this), d(this), n(this.canvas, this.config.parent), this.textures.once(b.READY, this.texturesReady, this), this.events.emit(v.BOOT)) : console.warn('Aborting. Core Plugins missing.'); }, texturesReady() { this.events.emit(v.READY), this.start(); }, start() { this.isRunning = !0, this.config.postBoot(this), this.renderer ? this.loop.start(this.step.bind(this)) : this.loop.start(this.headlessStep.bind(this)), A(this); const t = this.events; t.on(v.HIDDEN, this.onHidden, this), t.on(v.VISIBLE, this.onVisible, this), t.on(v.BLUR, this.onBlur, this), t.on(v.FOCUS, this.onFocus, this); }, step(t, e) { if (this.pendingDestroy) return this.runDestroy(); const i = this.events; i.emit(v.PRE_STEP, t, e), i.emit(v.STEP, t, e), this.scene.update(t, e), i.emit(v.POST_STEP, t, e); const n = this.renderer; n.preRender(), i.emit(v.PRE_RENDER, n, t, e), this.scene.render(n), n.postRender(), i.emit(v.POST_RENDER, n, t, e); }, headlessStep(t, e) { if (this.pendingDestroy) return this.runDestroy(); const i = this.events; i.emit(v.PRE_STEP, t, e), i.emit(v.STEP, t, e), this.scene.update(t, e), i.emit(v.POST_STEP, t, e), i.emit(v.PRE_RENDER), i.emit(v.POST_RENDER); }, onHidden() { this.loop.pause(), this.events.emit(v.PAUSE); }, onVisible() { this.loop.resume(), this.events.emit(v.RESUME); }, onBlur() { this.hasFocus = !1, this.loop.blur(); }, onFocus() { this.hasFocus = !0, this.loop.focus(); }, getFrame() { return this.loop.frame; }, getTime() { return this.loop.now; }, destroy(t, e) { void 0 === e && (e = !1), this.pendingDestroy = !0, this.removeCanvas = t, this.noReturn = e; }, runDestroy() { this.scene.destroy(), this.events.emit(v.DESTROY), this.events.removeAllListeners(), this.renderer && this.renderer.destroy(), this.removeCanvas && this.canvas && (o.remove(this.canvas), this.canvas.parentNode && this.canvas.parentNode.removeChild(this.canvas)), this.domContainer && this.domContainer.parentNode.removeChild(this.domContainer), this.loop.destroy(), this.pendingDestroy = !1; },
  }); t.exports = M;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(134); t.exports = function (t) { const e = t.config; if (e.parent && e.domCreateContainer) { const i = document.createElement('div'); i.style.cssText = ['display: block;', `width: ${t.scale.width}px;`, `height: ${t.scale.height}px;`, 'padding: 0; margin: 0;', 'position: absolute;', 'overflow: hidden;', 'pointer-events: none;', 'transform: scale(1);', 'transform-origin: left top;'].join(' '), t.domContainer = i, n(i, e.parent); } };
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'boot';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'destroy';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'dragend';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'dragenter';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'drag';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'dragleave';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'dragover';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'dragstart';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'drop';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'gameout';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'gameover';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'gameobjectdown';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'dragend';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'dragenter';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'drag';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'dragleave';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'dragover';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'dragstart';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'drop';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'gameobjectmove';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'gameobjectout';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'gameobjectover';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'pointerdown';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'pointermove';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'pointerout';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'pointerover';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'pointerup';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'wheel';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'gameobjectup';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'gameobjectwheel';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'boot';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'process';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'update';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'pointerdown';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'pointerdownoutside';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'pointermove';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'pointerout';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'pointerover';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'pointerup';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'pointerupoutside';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'wheel';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'pointerlockchange';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'preupdate';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'shutdown';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'start';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'update';
}, function (t, e) { t.exports = function (t) { if (!t) return window.innerHeight; const e = Math.abs(window.orientation); const i = { w: 0, h: 0 }; let n = document.createElement('div'); return n.setAttribute('style', 'position: fixed; height: 100vh; width: 0; top: 0'), document.documentElement.appendChild(n), i.w = e === 90 ? n.offsetHeight : window.innerWidth, i.h = e === 90 ? window.innerWidth : n.offsetHeight, document.documentElement.removeChild(n), n = null, Math.abs(window.orientation) !== 90 ? i.h : i.w; }; }, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'addfile';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'complete';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'filecomplete';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'filecomplete-';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'loaderror';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'load';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'fileprogress';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'postprocess';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'progress';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'start';
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(2); const s = i(198); t.exports = function (t) { const e = t.game.config.defaultPhysicsSystem; const i = n(t.settings, 'physics', !1); if (e || i) { const r = []; if (e && r.push(s(`${e}Physics`)), i) for (let o in i)o = s(o.concat('Physics')), r.indexOf(o) === -1 && r.push(o); return r; } };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(2); t.exports = function (t) { const e = t.plugins.getDefaultScenePlugins(); const i = n(t.settings, 'plugins', !1); return Array.isArray(i) ? i : e || []; };
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const i = {
    game: 'game', anims: 'anims', cache: 'cache', plugins: 'plugins', registry: 'registry', scale: 'scale', sound: 'sound', textures: 'textures', events: 'events', cameras: 'cameras', add: 'add', make: 'make', scenePlugin: 'scene', displayList: 'children', lights: 'lights', data: 'data', input: 'input', load: 'load', time: 'time', tweens: 'tweens', arcadePhysics: 'physics', impactPhysics: 'impact', matterPhysics: 'matter', cameras3d: 'cameras3d', facebook: 'facebook',
  }; t.exports = i;
}, function (t, e) { t.exports = function (t, e, i) { if (i.getElementsByTagName('TextureAtlas')) { const n = t.source[e]; t.add('__BASE', e, 0, 0, n.width, n.height); for (var s, r = i.getElementsByTagName('SubTexture'), o = 0; o < r.length; o++) { const a = r[o].attributes; const h = a.name.value; const l = parseInt(a.x.value, 10); const u = parseInt(a.y.value, 10); const c = parseInt(a.width.value, 10); const d = parseInt(a.height.value, 10); if (s = t.add(h, e, l, u, c, d), a.frameX) { const f = Math.abs(parseInt(a.frameX.value, 10)); const p = Math.abs(parseInt(a.frameY.value, 10)); const g = parseInt(a.frameWidth.value, 10); const v = parseInt(a.frameHeight.value, 10); s.setTrim(c, d, f, p, g, v); } } return t; }console.warn('Invalid Texture Atlas XML given'); }; }, function (t, e) { t.exports = function (t, e) { const i = t.source[e]; return t.add('__BASE', e, 0, 0, i.width, i.height), t; }; }, function (t, e) { t.exports = function (t, e) { const i = t.source[e]; return t.add('__BASE', e, 0, 0, i.width, i.height), t; }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(74); t.exports = function (t, e, i) { if (i.frames || i.textures) { const s = t.source[e]; t.add('__BASE', e, 0, 0, s.width, s.height); for (var r, o = Array.isArray(i.textures) ? i.textures[e].frames : i.frames, a = 0; a < o.length; a++) { const h = o[a]; r = t.add(h.filename, e, h.frame.x, h.frame.y, h.frame.w, h.frame.h), h.trimmed && r.setTrim(h.sourceSize.w, h.sourceSize.h, h.spriteSourceSize.x, h.spriteSourceSize.y, h.spriteSourceSize.w, h.spriteSourceSize.h), h.rotated && (r.rotated = !0, r.updateUVsInverted()); const l = h.anchor || h.pivot; l && (r.customPivot = !0, r.pivotX = l.x, r.pivotY = l.y), r.customData = n(h); } for (const u in i)u !== 'frames' && (Array.isArray(i[u]) ? t.customData[u] = i[u].slice(0) : t.customData[u] = i[u]); return t; }console.warn('Invalid Texture Atlas JSON Array'); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(74); t.exports = function (t, e, i) { if (i.frames) { const s = t.source[e]; t.add('__BASE', e, 0, 0, s.width, s.height); let r; const o = i.frames; for (const a in o) { const h = o[a]; r = t.add(a, e, h.frame.x, h.frame.y, h.frame.w, h.frame.h), h.trimmed && r.setTrim(h.sourceSize.w, h.sourceSize.h, h.spriteSourceSize.x, h.spriteSourceSize.y, h.spriteSourceSize.w, h.spriteSourceSize.h), h.rotated && (r.rotated = !0, r.updateUVsInverted()); const l = h.anchor || h.pivot; l && (r.customPivot = !0, r.pivotX = l.x, r.pivotY = l.y), r.customData = n(h); } for (const u in i)u !== 'frames' && (Array.isArray(i[u]) ? t.customData[u] = i[u].slice(0) : t.customData[u] = i[u]); return t; }console.warn("Invalid Texture Atlas JSON Hash given, missing 'frames' Object"); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(2); t.exports = function (t, e, i, s, r, o, a) { const h = n(a, 'frameWidth', null); const l = n(a, 'frameHeight', h); if (h === null) throw new Error('TextureManager.SpriteSheet: Invalid frameWidth given.'); const u = t.source[e]; t.add('__BASE', e, 0, 0, u.width, u.height); let c = n(a, 'startFrame', 0); const d = n(a, 'endFrame', -1); const f = n(a, 'margin', 0); const p = n(a, 'spacing', 0); let g = Math.floor((r - f + p) / (h + p)) * Math.floor((o - f + p) / (l + p)); g === 0 && console.warn('SpriteSheet frame dimensions will result in zero frames.'), (c > g || c < -g) && (c = 0), c < 0 && (c = g + c), d !== -1 && (g = c + (d + 1)); for (let v = f, m = f, y = 0, x = 0, T = 0; T < g; T++) { y = 0, x = 0; const w = v + h; const b = m + l; w > r && (y = w - r), b > o && (x = b - o), t.add(T, e, i + v, s + m, h - y, l - x), (v += h + p) + h > r && (v = f, m += l + p); } return t; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(2); t.exports = function (t, e, i) { const s = n(i, 'frameWidth', null); const r = n(i, 'frameHeight', s); if (!s) throw new Error('TextureManager.SpriteSheetFromAtlas: Invalid frameWidth given.'); const o = t.source[0]; t.add('__BASE', 0, 0, 0, o.width, o.height); let a; let h = n(i, 'startFrame', 0); const l = n(i, 'endFrame', -1); const u = n(i, 'margin', 0); const c = n(i, 'spacing', 0); const d = e.cutX; const f = e.cutY; const p = e.cutWidth; const g = e.cutHeight; const v = e.realWidth; const m = e.realHeight; const y = Math.floor((v - u + c) / (s + c)); const x = Math.floor((m - u + c) / (r + c)); let T = y * x; const w = e.x; const b = s - w; const E = s - (v - p - w); const S = e.y; const A = r - S; const _ = r - (m - g - S); (h > T || h < -T) && (h = 0), h < 0 && (h = T + h), l !== -1 && (T = h + (l + 1)); for (let C = u, M = u, P = 0, O = e.sourceIndex, R = 0; R < x; R++) { for (var L = R === 0, D = R === x - 1, k = 0; k < y; k++) { const F = k === 0; const I = k === y - 1; if (a = t.add(P, O, d + C, f + M, s, r), F || L || I || D) { const B = F ? w : 0; const N = L ? S : 0; let Y = 0; let X = 0; F && (Y += s - b), I && (Y += s - E), L && (X += r - A), D && (X += r - _); const z = s - Y; const U = r - X; a.cutWidth = z, a.cutHeight = U, a.setTrim(s, r, B, N, z, U); }C += c, C += F ? b : I ? E : s, P++; }C = u, M += c, M += L ? A : D ? _ : r; } return t; };
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  let i = 0; const n = function (t, e, n, s) { const r = i - s.y - s.height; t.add(n, e, s.x, r, s.width, s.height); }; t.exports = function (t, e, s) {
    const r = t.source[e]; t.add('__BASE', e, 0, 0, r.width, r.height), i = r.height; for (var o = s.split('\n'), a = /^[ ]*(- )*(\w+)+[: ]+(.*)/, h = '', l = '', u = {
        x: 0, y: 0, width: 0, height: 0,
      }, c = 0; c < o.length; c++) {
      const d = o[c].match(a); if (d) {
        const f = d[1] === '- '; const p = d[2]; const g = d[3]; if (f && (l !== h && (n(t, e, l, u), h = l), u = {
          x: 0, y: 0, width: 0, height: 0,
        }), p !== 'name') switch (p) { case 'x': case 'y': case 'width': case 'height': u[p] = parseInt(g, 10); } else l = g;
      }
    } return l !== h && n(t, e, l, u), t;
  };
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'complete';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'decoded';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'decodedall';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'destroy';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'detune';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'detune';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'mute';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'rate';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'volume';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'loop';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'looped';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'mute';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'pauseall';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'pause';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'play';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'rate';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'resumeall';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'resume';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'seek';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'stopall';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'stop';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'unlocked';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'volume';
}, function (t, e) {
  t.exports = function (t, e, i) {
    return {
      instance: e, placementID: t, shown: !1, video: i,
    };
  };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2018 Photon Storm Ltd.
 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
 */
  const n = i(0); const s = i(10); const r = i(941); const o = new n({
    Extends: s, initialize(t, e) { s.call(this), this.plugin = t, this.ref = e, this.name = e.getName(), this.contextID = e.getContextID(), this.entryCount = 0, this.playerScore = null, this.scores = [], this.getEntryCount(); }, getEntryCount() { const t = this; return this.ref.getEntryCountAsync().then(((e) => { t.entryCount = e, t.emit('getentrycount', e, t.name); })).catch(((t) => { console.warn(t); })), this; }, setScore(t, e) { void 0 === e && (e = ''), typeof e === 'object' && (e = JSON.stringify(e)); const i = this; return this.ref.setScoreAsync(t, e).then(((t) => { if (t) { const e = r(t); i.playerScore = e, i.emit('setscore', e, i.name); } else i.emit('setscore', null, i.name); })).catch(((t) => { console.warn(t); })), this; }, getPlayerScore() { const t = this; return this.ref.getPlayerEntryAsync().then(((e) => { if (e) { const i = r(e); t.playerScore = i, t.emit('getplayerscore', i, t.name); } else t.emit('getplayerscore', null, t.name); })).catch(((t) => { console.warn(t); })), this; }, getScores(t, e) { void 0 === t && (t = 10), void 0 === e && (e = 0); const i = this; return this.ref.getEntriesAsync(t, e).then(((t) => { i.scores = [], t.forEach(((t) => { i.scores.push(r(t)); })), i.emit('getscores', i.scores, i.name); })).catch(((t) => { console.warn(t); })), this; }, getConnectedScores() { const t = this; return this.ref.getConnectedPlayerEntriesAsync().then(((e) => { t.scores = [], e.forEach(((e) => { t.scores.push(r(e)); })), t.emit('getconnectedscores', t.scores, t.name); })).catch(((t) => { console.warn(t); })), this; },
  }); t.exports = o;
}, function (t, e) {
  t.exports = function (t) {
    return {
      score: t.getScore(), scoreFormatted: t.getFormattedScore(), timestamp: t.getTimestamp(), rank: t.getRank(), data: t.getExtraData(), playerName: t.getPlayer().getName(), playerPhotoURL: t.getPlayer().getPhoto(), playerID: t.getPlayer().getID(),
    };
  };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2018 Photon Storm Ltd.
 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
 */
  const n = i(2); t.exports = function (t) {
    return {
      title: n(t, 'title', ''), productID: n(t, 'productID', ''), description: n(t, 'description', ''), imageURI: n(t, 'imageURI', ''), price: n(t, 'price', ''), priceCurrencyCode: n(t, 'priceCurrencyCode', ''),
    };
  };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2018 Photon Storm Ltd.
 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
 */
  const n = i(2); t.exports = function (t) {
    return {
      developerPayload: n(t, 'developerPayload', ''), paymentID: n(t, 'paymentID', ''), productID: n(t, 'productID', ''), purchaseTime: n(t, 'purchaseTime', ''), purchaseToken: n(t, 'purchaseToken', ''), signedRequest: n(t, 'signedRequest', ''),
    };
  };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = {
    Events: i(102),
    DisplayList: i(945),
    GameObjectCreator: i(17),
    GameObjectFactory: i(5),
    UpdateList: i(971),
    Components: i(13),
    BuildGameObject: i(29),
    BuildGameObjectAnimation: i(204),
    GameObject: i(14),
    BitmapText: i(143),
    Blitter: i(206),
    Container: i(207),
    DOMElement: i(427),
    DynamicBitmapText: i(208),
    Extern: i(429),
    Graphics: i(209),
    Group: i(110),
    Image: i(112),
    Particles: i(1003),
    PathFollower: i(441),
    RenderTexture: i(213),
    RetroFont: i(1012),
    Rope: i(215),
    Sprite: i(66),
    Text: i(216),
    TileSprite: i(217),
    Zone: i(120),
    Video: i(218),
    Shape: i(34),
    Arc: i(442),
    Curve: i(443),
    Ellipse: i(444),
    Grid: i(445),
    IsoBox: i(446),
    IsoTriangle: i(447),
    Line: i(448),
    Polygon: i(449),
    Rectangle: i(454),
    Star: i(455),
    Triangle: i(456),
    Factories: {
      Blitter: i(1063), Container: i(1064), DOMElement: i(1065), DynamicBitmapText: i(1066), Extern: i(1067), Graphics: i(1068), Group: i(1069), Image: i(1070), Particles: i(1071), PathFollower: i(1072), RenderTexture: i(1073), Rope: i(1074), Sprite: i(1075), StaticBitmapText: i(1076), Text: i(1077), TileSprite: i(1078), Zone: i(1079), Video: i(1080), Arc: i(1081), Curve: i(1082), Ellipse: i(1083), Grid: i(1084), IsoBox: i(1085), IsoTriangle: i(1086), Line: i(1087), Polygon: i(1088), Rectangle: i(1089), Star: i(1090), Triangle: i(1091),
    },
    Creators: {
      Blitter: i(1092), Container: i(1093), DynamicBitmapText: i(1094), Graphics: i(1095), Group: i(1096), Image: i(1097), Particles: i(1098), RenderTexture: i(1099), Rope: i(1100), Sprite: i(1101), StaticBitmapText: i(1102), Text: i(1103), TileSprite: i(1104), Zone: i(1105), Video: i(1106),
    },
  }; n.Mesh = i(144), n.Quad = i(221), n.Shader = i(222), n.Factories.Mesh = i(1113), n.Factories.Quad = i(1114), n.Factories.Shader = i(1115), n.Creators.Mesh = i(1116), n.Creators.Quad = i(1117), n.Creators.Shader = i(1118), n.Light = i(460), i(461), i(1119), t.exports = n;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(140); const r = i(23); const o = i(24); const a = i(142); const h = new n({
    Extends: s, initialize(t) { s.call(this, t), this.sortChildrenFlag = !1, this.scene = t, this.systems = t.sys, t.sys.events.once(o.BOOT, this.boot, this), t.sys.events.on(o.START, this.start, this); }, boot() { this.systems.events.once(o.DESTROY, this.destroy, this); }, start() { this.systems.events.once(o.SHUTDOWN, this.shutdown, this); }, queueDepthSort() { this.sortChildrenFlag = !0; }, depthSort() { this.sortChildrenFlag && (a.inplace(this.list, this.sortByDepth), this.sortChildrenFlag = !1); }, sortByDepth(t, e) { return t._depth - e._depth; }, getChildren() { return this.list; }, shutdown() { for (let t = this.list.length; t--;) this.list[t].destroy(!0); this.list.length = 0, this.systems.events.off(o.SHUTDOWN, this.shutdown, this); }, destroy() { this.shutdown(), this.scene.sys.events.off(o.START, this.start, this), this.scene = null, this.systems = null; },
  }); r.register('DisplayList', h, 'displayList'), t.exports = h;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = {
    CheckMatrix: i(201), MatrixToString: i(947), ReverseColumns: i(948), ReverseRows: i(949), Rotate180: i(950), RotateLeft: i(951), RotateMatrix: i(141), RotateRight: i(952), TransposeMatrix: i(423),
  };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(178); const s = i(201); t.exports = function (t) { let e = ''; if (!s(t)) return e; for (let i = 0; i < t.length; i++) { for (let r = 0; r < t[i].length; r++) { const o = t[i][r].toString(); e += o !== 'undefined' ? n(o, 2) : '?', r < t[i].length - 1 && (e += ' |'); } if (i < t.length - 1) { e += '\n'; for (let a = 0; a < t[i].length; a++)e += '---', a < t[i].length - 1 && (e += '+'); e += '\n'; } } return e; };
}, function (t, e) { t.exports = function (t) { return t.reverse(); }; }, function (t, e) { t.exports = function (t) { for (let e = 0; e < t.length; e++)t[e].reverse(); return t; }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(141); t.exports = function (t) { return n(t, 180); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(141); t.exports = function (t) { return n(t, 90); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(141); t.exports = function (t) { return n(t, -90); };
}, function (t, e) { t.exports = function (t, e, i, n, s) { if (void 0 === s && (s = t), i > 0) { var r = i - t.length; if (r <= 0) return null; } if (!Array.isArray(e)) return t.indexOf(e) === -1 ? (t.push(e), n && n.call(s, e), e) : null; for (var o = e.length - 1; o >= 0;)t.indexOf(e[o]) !== -1 && e.splice(o, 1), o--; if ((o = e.length) === 0) return null; i > 0 && o > r && (e.splice(r), o = r); for (let a = 0; a < o; a++) { const h = e[a]; t.push(h), n && n.call(s, h); } return e; }; }, function (t, e) { t.exports = function (t, e, i, n, s, r) { if (void 0 === i && (i = 0), void 0 === r && (r = t), n > 0) { var o = n - t.length; if (o <= 0) return null; } if (!Array.isArray(e)) return t.indexOf(e) === -1 ? (t.splice(i, 0, e), s && s.call(r, e), e) : null; for (var a = e.length - 1; a >= 0;)t.indexOf(e[a]) !== -1 && e.pop(), a--; if ((a = e.length) === 0) return null; n > 0 && a > o && (e.splice(o), a = o); for (let h = a - 1; h >= 0; h--) { const l = e[h]; t.splice(i, 0, l), s && s.call(r, l); } return e; }; }, function (t, e) { t.exports = function (t, e) { const i = t.indexOf(e); return i !== -1 && i < t.length && (t.splice(i, 1), t.push(e)), e; }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(75); t.exports = function (t, e, i, s, r) { void 0 === s && (s = 0), void 0 === r && (r = t.length); let o = 0; if (n(t, s, r)) for (let a = s; a < r; a++) { t[a][e] === i && o++; } return o; };
}, function (t, e) { t.exports = function (t, e, i) { let n; const s = [null]; for (n = 3; n < arguments.length; n++)s.push(arguments[n]); for (n = 0; n < t.length; n++)s[0] = t[n], e.apply(i, s); return t; }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(75); t.exports = function (t, e, i, s, r) { if (void 0 === s && (s = 0), void 0 === r && (r = t.length), n(t, s, r)) { let o; const a = [null]; for (o = 5; o < arguments.length; o++)a.push(arguments[o]); for (o = s; o < r; o++)a[0] = t[o], e.apply(i, a); } return t; };
}, function (t, e) { t.exports = function (t, e) { const i = t.indexOf(e); if (i > 0) { const n = t[i - 1]; const s = t.indexOf(n); t[i] = n, t[s] = e; } return t; }; }, function (t, e) { t.exports = function (t, e, i) { const n = t.indexOf(e); if (n === -1 || i < 0 || i >= t.length) throw new Error('Supplied index out of bounds'); return n !== i && (t.splice(n, 1), t.splice(i, 0, e)), e; }; }, function (t, e) { t.exports = function (t, e) { const i = t.indexOf(e); if (i !== -1 && i < t.length - 1) { const n = t[i + 1]; const s = t.indexOf(n); t[i] = n, t[s] = e; } return t; }; }, function (t, e) { t.exports = function (t, e, i, n) { for (var s = [], r = t; r <= e; r++) if (i || n) { let o = i ? i + r.toString() : r.toString(); n && (o = o.concat(n)), s.push(o); } else s.push(r); return s; }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(357); t.exports = function (t, e, i) { void 0 === t && (t = 0), void 0 === e && (e = null), void 0 === i && (i = 1), e === null && (e = t, t = 0); for (var s = [], r = Math.max(n((e - t) / (i || 1)), 0), o = 0; o < r; o++)s.push(t), t += i; return s; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(88); t.exports = function (t, e, i, s) { if (void 0 === s && (s = t), e < 0 || e > t.length - 1) throw new Error('Index out of bounds'); const r = n(t, e); return i && i.call(s, r), r; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(75); t.exports = function (t, e, i, s, r) { if (void 0 === e && (e = 0), void 0 === i && (i = t.length), void 0 === r && (r = t), n(t, e, i)) { const o = i - e; const a = t.splice(e, o); if (s) for (let h = 0; h < a.length; h++) { const l = a[h]; s.call(r, l); } return a; } return []; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(88); t.exports = function (t, e, i) { void 0 === e && (e = 0), void 0 === i && (i = t.length); const s = e + Math.floor(Math.random() * i); return n(t, s); };
}, function (t, e) { t.exports = function (t, e, i) { const n = t.indexOf(e); const s = t.indexOf(i); return n !== -1 && s === -1 && (t[n] = i, !0); }; }, function (t, e) { t.exports = function (t, e) { const i = t.indexOf(e); return i !== -1 && i > 0 && (t.splice(i, 1), t.unshift(e)), e; }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(75); t.exports = function (t, e, i, s, r) { if (void 0 === s && (s = 0), void 0 === r && (r = t.length), n(t, s, r)) for (let o = s; o < r; o++) { const a = t[o]; a.hasOwnProperty(e) && (a[e] = i); } return t; };
}, function (t, e) { t.exports = function (t, e, i) { if (e !== i) { const n = t.indexOf(e); const s = t.indexOf(i); if (n < 0 || s < 0) throw new Error('Supplied items must be elements of the same array'); return t[n] = i, t[s] = e, t; } }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(203); const r = i(23); const o = i(24); const a = new n({
    Extends: s, initialize(t) { s.call(this), this.scene = t, this.systems = t.sys, t.sys.events.once(o.BOOT, this.boot, this), t.sys.events.on(o.START, this.start, this); }, boot() { this.systems.events.once(o.DESTROY, this.destroy, this); }, start() { const t = this.systems.events; t.on(o.PRE_UPDATE, this.update, this), t.on(o.UPDATE, this.sceneUpdate, this), t.once(o.SHUTDOWN, this.shutdown, this); }, sceneUpdate(t, e) { for (let i = this._active, n = i.length, s = 0; s < n; s++) { const r = i[s]; r.active && r.preUpdate.call(r, t, e); } }, shutdown() { for (var t = this._active.length; t--;) this._active[t].destroy(!0); for (t = this._pending.length; t--;) this._pending[t].destroy(!0); for (t = this._destroy.length; t--;) this._destroy[t].destroy(!0); this._toProcess = 0, this._pending = [], this._active = [], this._destroy = [], this.removeAllListeners(); const e = this.systems.events; e.off(o.PRE_UPDATE, this.preUpdate, this), e.off(o.UPDATE, this.sceneUpdate, this), e.off(o.SHUTDOWN, this.shutdown, this); }, destroy() { this.shutdown(), this.systems.events.off(o.START, this.start, this), this.scene = null, this.systems = null; },
  }); r.register('UpdateList', a, 'updateList'), t.exports = a;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = { PROCESS_QUEUE_ADD: i(973), PROCESS_QUEUE_REMOVE: i(974) };
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'add';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'remove';
}, function (t, e) {
  t.exports = function (t, e, i) {
    if (void 0 === i) {
      return i = {
        local: {
          x: 0, y: 0, width: 0, height: 0,
        },
        global: {
          x: 0, y: 0, width: 0, height: 0,
        },
        lines: {
          shortest: 0, longest: 0, lengths: null, height: 0,
        },
        wrappedText: '',
        words: [],
        scaleX: 0,
        scaleY: 0,
      };
    } let n; let s; let r; let o; let a = t.text; let h = a.length; const l = t.maxWidth; const u = t.wordWrapCharCode; let c = Number.MAX_VALUE; let d = Number.MAX_VALUE; let f = 0; let p = 0; const g = t.fontData.chars; const v = t.fontData.lineHeight; const m = t.letterSpacing; let y = 0; let x = 0; let T = 0; let w = null; let b = 0; let E = 0; const S = t.fontSize / t.fontData.size; const A = S * t.scaleX; const _ = S * t.scaleY; let C = null; let M = 0; const P = []; let O = Number.MAX_VALUE; let R = 0; let L = 0; let D = 0; let k = []; let F = null; if (l > 0) {
      for (n = 0; n < h; n++) {
        if ((T = a.charCodeAt(n)) !== 10) {
          if (w = g[T]) {
            if (C !== null) var I = w.kerning[M]; T === u ? F !== null && (k.push({
              word: F.word, i: F.i, x: F.x * A, y: F.y * _, w: F.w * A, h: F.h * _, cr: !1,
            }), F = null) : (F === null && (F = {
              word: '', i: n, x: y, y: x, w: 0, h: v, cr: !1,
            }), F.word = F.word.concat(a[n]), F.w += w.xOffset + w.xAdvance + (void 0 !== I ? I : 0)), y += w.xAdvance + m, C = w, M = T;
          }
        } else {
          F !== null && (k.push({
            word: F.word, i: F.i, x: F.x * A, y: F.y * _, w: F.w * A, h: F.h * _, cr: !0,
          }), F = null), y = 0, x += v, C = null;
        }
      } let B; F !== null && k.push({
        word: F.word, i: F.i, x: F.x * A, y: F.y * _, w: F.w * A, h: F.h * _, cr: !1,
      }), y = 0, x = 0, C = null, M = 0; let N = 0; const Y = []; for (n = 0; n < k.length; n++) { const X = k[n]; const z = X.x; const U = X.x + X.w; if (B)N = z - (z - (B.x + B.w) + B.w), B = null; z - N > l || U - N > l ? (Y.push(X.i - 1), X.cr ? (Y.push(X.i + X.word.length), N = 0, B = null) : B = X) : X.cr && (Y.push(X.i + X.word.length), N = 0, B = null); } for (n = Y.length - 1; n >= 0; n--)s = a, r = Y[n], o = '\n', a = s.substr(0, r) + o + s.substr(r + 1); i.wrappedText = a, h = a.length, k = [], F = null;
    } for (n = 0; n < h; n++) {
      if ((T = a.charCodeAt(n)) !== 10) {
        if (w = g[T]) {
          if (b = y, E = x, C !== null) { var G = w.kerning[M]; b += void 0 !== G ? G : 0; }c > b && (c = b), d > E && (d = E); const W = b + w.xAdvance; const V = E + v; f < W && (f = W), p < V && (p = V), T === u ? F !== null && (k.push({
            word: F.word, i: F.i, x: F.x * A, y: F.y * _, w: F.w * A, h: F.h * _,
          }), F = null) : (F === null && (F = {
            word: '', i: n, x: y, y: x, w: 0, h: v,
          }), F.word = F.word.concat(a[n]), F.w += w.xOffset + w.xAdvance + (void 0 !== G ? G : 0)), y += w.xAdvance + m, C = w, M = T, D = W * S;
        }
      } else {
        F !== null && (k.push({
          word: F.word, i: F.i, x: F.x * A, y: F.y * _, w: F.w * A, h: F.h * _,
        }), F = null), y = 0, x += v, C = null, P[L] = D, D > R && (R = D), D < O && (O = D), L++, D = 0;
      }
    } F !== null && k.push({
      word: F.word, i: F.i, x: F.x * A, y: F.y * _, w: F.w * A, h: F.h * _,
    }), P[L] = D, D > R && (R = D), D < O && (O = D); const H = i.local; const j = i.global; const q = i.lines; return H.x = c * S, H.y = d * S, H.width = f * S, H.height = p * S, j.x = t.x - t.displayOriginX + c * A, j.y = t.y - t.displayOriginY + d * _, j.width = f * A, j.height = p * _, q.shortest = O, q.longest = R, q.lengths = P, e && (H.x = Math.round(H.x), H.y = Math.round(H.y), H.width = Math.round(H.width), H.height = Math.round(H.height), j.x = Math.round(j.x), j.y = Math.round(j.y), j.width = Math.round(j.width), j.height = Math.round(j.height), q.shortest = Math.round(O), q.longest = Math.round(R)), i.words = k, i.lines.height = v, i.scaleX = t.scaleX, i.scaleY = t.scaleY, i;
  };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(205); t.exports = function (t, e, i, s, r, o, a) { const h = t.sys.textures.getFrame(i, s); const l = t.sys.cache.xml.get(r); if (h && l) { const u = n(l, o, a, h); return t.sys.cache.bitmapFont.add(e, { data: u, texture: i, frame: s }), !0; } return !1; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  let n = i(1); let s = i(1); n = i(978), s = i(979), t.exports = { renderWebGL: n, renderCanvas: s };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(11); t.exports = function (t, e, i, s, r) { let o = e._text; let a = o.length; if (a !== 0) { const h = this.pipeline; t.setPipeline(h, e); const l = h._tempMatrix1; const u = h._tempMatrix2; const c = h._tempMatrix3; u.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY), l.copyFrom(s.matrix), r ? (l.multiplyWithOffset(r, -s.scrollX * e.scrollFactorX, -s.scrollY * e.scrollFactorY), u.e = e.x, u.f = e.y, l.multiply(u, c)) : (u.e -= s.scrollX * e.scrollFactorX, u.f -= s.scrollY * e.scrollFactorY, l.multiply(u, c)); const d = e.frame; const f = d.glTexture; const p = d.cutX; const g = d.cutY; const v = f.width; const m = f.height; const y = e._isTinted && e.tintFill; const x = n.getTintAppendFloatAlpha(e._tintTL, s.alpha * e._alphaTL); const T = n.getTintAppendFloatAlpha(e._tintTR, s.alpha * e._alphaTR); const w = n.getTintAppendFloatAlpha(e._tintBL, s.alpha * e._alphaBL); const b = n.getTintAppendFloatAlpha(e._tintBR, s.alpha * e._alphaBR); h.setTexture2D(f, 0); let E; let S; let A = 0; let _ = 0; let C = 0; let M = 0; const P = e._letterSpacing; let O = 0; let R = 0; let L = 0; let D = 0; const k = e.fontData; const F = k.chars; const I = k.lineHeight; const B = e._fontSize / k.size; const N = e._align; let Y = 0; let X = 0; const z = e.getTextBounds(!1); e.maxWidth > 0 && (a = (o = z.wrappedText).length); const U = e._bounds.lines; N === 1 ? X = (U.longest - U.lengths[0]) / 2 : N === 2 && (X = U.longest - U.lengths[0]); for (let G = s.roundPixels, W = 0; W < a; W++) if ((C = o.charCodeAt(W)) !== 10) { if (E = F[C]) { O = p + E.x, R = g + E.y, L = E.width, D = E.height; let V = E.xOffset + A; let H = E.yOffset + _; if (S !== null) { const j = E.kerning[M]; V += void 0 !== j ? j : 0; } if (A += E.xAdvance + P, S = E, M = C, L !== 0 && D !== 0 && C !== 32) { V *= B, H *= B, V -= e.displayOriginX; const q = O / v; const K = R / m; const J = (O + L) / v; const Z = (R + D) / m; const Q = (V += X) + L * B; const $ = (H -= e.displayOriginY) + D * B; let tt = c.getX(V, H); let et = c.getY(V, H); let it = c.getX(V, $); let nt = c.getY(V, $); let st = c.getX(Q, $); let rt = c.getY(Q, $); let ot = c.getX(Q, H); let at = c.getY(Q, H); G && (tt = Math.round(tt), et = Math.round(et), it = Math.round(it), nt = Math.round(nt), st = Math.round(st), rt = Math.round(rt), ot = Math.round(ot), at = Math.round(at)), h.batchQuad(tt, et, it, nt, st, rt, ot, at, q, K, J, Z, x, T, w, b, y, f, 0); } } } else Y++, N === 1 ? X = (U.longest - U.lengths[Y]) / 2 : N === 2 && (X = U.longest - U.lengths[Y]), A = 0, _ += I, S = null; } };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(31); t.exports = function (t, e, i, s, r) { let o = e._text; let a = o.length; const h = t.currentContext; if (a !== 0 && n(t, h, e, s, r)) { const l = e.frame; const u = e.fontData.chars; const c = e.fontData.lineHeight; const d = e._letterSpacing; let f = 0; let p = 0; let g = 0; let v = null; let m = 0; let y = 0; let x = 0; let T = 0; let w = 0; let b = 0; let E = null; let S = 0; const A = e.frame.source.image; const _ = l.cutX; const C = l.cutY; const M = e._fontSize / e.fontData.size; const P = e._align; let O = 0; let R = 0; const L = e.getTextBounds(!1); e.maxWidth > 0 && (a = (o = L.wrappedText).length); const D = e._bounds.lines; P === 1 ? R = (D.longest - D.lengths[0]) / 2 : P === 2 && (R = D.longest - D.lengths[0]), h.translate(-e.displayOriginX, -e.displayOriginY); for (let k = s.roundPixels, F = 0; F < a; F++) if ((g = o.charCodeAt(F)) !== 10) { if (v = u[g]) { if (m = _ + v.x, y = C + v.y, x = v.width, T = v.height, w = v.xOffset + f, b = v.yOffset + p, E !== null) { const I = v.kerning[S]; w += void 0 !== I ? I : 0; }w *= M, b *= M, w += R, f += v.xAdvance + d, E = v, S = g, x !== 0 && T !== 0 && g !== 32 && (k && (w = Math.round(w), b = Math.round(b)), h.save(), h.translate(w, b), h.scale(M, M), h.drawImage(A, m, y, x, T, 0, 0, x, T), h.restore()); } } else O++, P === 1 ? R = (D.longest - D.lengths[O]) / 2 : P === 2 && (R = D.longest - D.lengths[O]), f = 0, p += c, E = null; h.restore(); } };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  let n = i(1); let s = i(1); n = i(981), s = i(982), t.exports = { renderWebGL: n, renderCanvas: s };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(11); t.exports = function (t, e, i, s, r) { const o = e.getRenderList(); if (o.length !== 0) { const a = this.pipeline; t.setPipeline(a, e); let h = s.scrollX * e.scrollFactorX; let l = s.scrollY * e.scrollFactorY; const u = a._tempMatrix1; u.copyFrom(s.matrix), r && (u.multiplyWithOffset(r, -h, -l), h = 0, l = 0); for (let c = e.x - h, d = e.y - l, f = -1, p = s.alpha * e.alpha, g = s.roundPixels, v = 0; v < o.length; v++) { const m = o[v]; const y = m.frame; const x = m.alpha * p; if (x !== 0) { let T = y.width; let w = y.height; let b = c + m.x + y.x; let E = d + m.y + y.y; m.flipX && (T *= -1, b += y.width), m.flipY && (w *= -1, E += y.height); const S = b + T; const A = E + w; let _ = u.getX(b, E); let C = u.getY(b, E); let M = u.getX(S, A); let P = u.getY(S, A); const O = n.getTintAppendFloatAlpha(m.tint, x); y.sourceIndex !== f && (a.setTexture2D(y.glTexture, 0), f = y.sourceIndex), g && (_ = Math.round(_), C = Math.round(C), M = Math.round(M), P = Math.round(P)), a.batchQuad(_, C, _, P, M, P, M, C, y.u0, y.v0, y.u1, y.v1, O, O, O, O, !1, y.glTexture, 0) && (f = -1); } } } };
}, function (t, e) { t.exports = function (t, e, i, n, s) { const r = e.getRenderList(); if (r.length !== 0) { const o = t.currentContext; const a = n.alpha * e.alpha; if (a !== 0) { o.globalCompositeOperation = t.blendModes[e.blendMode], o.imageSmoothingEnabled = !(!t.antialias || e.frame.source.scaleMode); const h = e.x - n.scrollX * e.scrollFactorX; const l = e.y - n.scrollY * e.scrollFactorY; o.save(), s && s.copyToContext(o); for (let u = n.roundPixels, c = 0; c < r.length; c++) { const d = r[c]; const f = d.flipX || d.flipY; const p = d.frame; const g = p.canvasData; let v = p.x; let m = p.y; let y = 1; let x = 1; const T = d.alpha * a; T !== 0 && (o.globalAlpha = T, f ? (d.flipX && (y = -1, v -= g.width), d.flipY && (x = -1, m -= g.height), o.save(), o.translate(d.x + h, d.y + l), o.scale(y, x), o.drawImage(p.source.image, g.x, g.y, g.width, g.height, v, m, g.width, g.height), o.restore()) : (u && (v = Math.round(v), m = Math.round(m)), o.drawImage(p.source.image, g.x, g.y, g.width, g.height, v + d.x + h, m + d.y + l, g.width, g.height))); }o.restore(); } } }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(107); const r = new n({
    initialize(t, e, i, n, s) { this.parent = t, this.x = e, this.y = i, this.frame = n, this.data = {}, this.tint = 16777215, this._visible = s, this._alpha = 1, this.flipX = !1, this.flipY = !1; }, setFrame(t) { return void 0 === t ? this.frame = this.parent.frame : t instanceof s && t.texture === this.parent.texture ? this.frame = t : this.frame = this.parent.texture.get(t), this; }, resetFlip() { return this.flipX = !1, this.flipY = !1, this; }, reset(t, e, i) { return this.x = t, this.y = e, this.flipX = !1, this.flipY = !1, this._alpha = 1, this._visible = !0, this.parent.dirty = !0, i && this.setFrame(i), this; }, setPosition(t, e) { return this.x = t, this.y = e, this; }, setFlipX(t) { return this.flipX = t, this; }, setFlipY(t) { return this.flipY = t, this; }, setFlip(t, e) { return this.flipX = t, this.flipY = e, this; }, setVisible(t) { return this.visible = t, this; }, setAlpha(t) { return this.alpha = t, this; }, setTint(t) { return this.tint = t, this; }, destroy() { this.parent.dirty = !0, this.parent.children.remove(this), this.parent = void 0, this.frame = void 0, this.data = void 0; }, visible: { get() { return this._visible; }, set(t) { this.parent.dirty |= this._visible !== t, this._visible = t; } }, alpha: { get() { return this._alpha; }, set(t) { this.parent.dirty |= this._alpha > 0 != t > 0, this._alpha = t; } },
  }); t.exports = r;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Felipe Alfonso <@bitnenfer>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  let n = i(1); let s = i(1); n = i(985), s = i(986), t.exports = { renderWebGL: n, renderCanvas: s };
}, function (t, e) { t.exports = function (t, e, i, n, s) { const r = e.list; if (r.length !== 0) { const o = e.localTransform; s ? (o.loadIdentity(), o.multiply(s), o.translate(e.x, e.y), o.rotate(e.rotation), o.scale(e.scaleX, e.scaleY)) : o.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY); const a = e.blendMode !== -1; a || t.setBlendMode(0); for (let h = e.alpha, l = e.scrollFactorX, u = e.scrollFactorY, c = r, d = r.length, f = 0; f < d; f++) { const p = r[f]; if (p.willRender(n)) { var g; var v; var m; var y; if (void 0 !== p.alphaTopLeft)g = p.alphaTopLeft, v = p.alphaTopRight, m = p.alphaBottomLeft, y = p.alphaBottomRight; else { const x = p.alpha; g = x, v = x, m = x, y = x; } const T = p.scrollFactorX; const w = p.scrollFactorY; a || p.blendMode === t.currentBlendMode || t.setBlendMode(p.blendMode); const b = p.mask; b && b.preRenderWebGL(t, p, n); const E = p.type; E !== t.currentType && (t.newType = !0, t.currentType = E), t.nextTypeMatch = f < d - 1 && c[f + 1].type === t.currentType, p.setScrollFactor(T * l, w * u), p.setAlpha(g * h, v * h, m * h, y * h), p.renderWebGL(t, p, i, n, o), p.setAlpha(g, v, m, y), p.setScrollFactor(T, w), b && b.postRenderWebGL(t, n), t.newType = !1; } } } }; }, function (t, e) { t.exports = function (t, e, i, n, s) { const r = e.list; if (r.length !== 0) { const o = e.localTransform; s ? (o.loadIdentity(), o.multiply(s), o.translate(e.x, e.y), o.rotate(e.rotation), o.scale(e.scaleX, e.scaleY)) : o.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY); const a = e.blendMode !== -1; a || t.setBlendMode(0); for (let h = e._alpha, l = e.scrollFactorX, u = e.scrollFactorY, c = 0; c < r.length; c++) { const d = r[c]; if (d.willRender(n)) { const f = d.alpha; const p = d.scrollFactorX; const g = d.scrollFactorY; a || d.blendMode === t.currentBlendMode || t.setBlendMode(d.blendMode), d.setScrollFactor(p * l, g * u), d.setAlpha(f * h), d.renderCanvas(t, d, i, n, o), d.setAlpha(f), d.setScrollFactor(p, g); } } } }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  let n = i(1); let s = i(1); n = i(428), s = i(428), t.exports = { renderWebGL: n, renderCanvas: s };
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = ['normal', 'multiply', 'multiply', 'screen', 'overlay', 'darken', 'lighten', 'color-dodge', 'color-burn', 'hard-light', 'soft-light', 'difference', 'exclusion', 'hue', 'saturation', 'color', 'luminosity'];
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  let n = i(1); let s = i(1); n = i(990), s = i(991), t.exports = { renderWebGL: n, renderCanvas: s };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(11); t.exports = function (t, e, i, s, r) { const o = e.text; const a = o.length; if (a !== 0) { const h = this.pipeline; t.setPipeline(h, e); const l = e.cropWidth > 0 || e.cropHeight > 0; l && (h.flush(), t.pushScissor(e.x, e.y, e.cropWidth * e.scaleX, e.cropHeight * e.scaleY)); const u = h._tempMatrix1; const c = h._tempMatrix2; const d = h._tempMatrix3; const f = h._tempMatrix4; c.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY), u.copyFrom(s.matrix), r ? (u.multiplyWithOffset(r, -s.scrollX * e.scrollFactorX, -s.scrollY * e.scrollFactorY), c.e = e.x, c.f = e.y, u.multiply(c, d)) : (c.e -= s.scrollX * e.scrollFactorX, c.f -= s.scrollY * e.scrollFactorY, u.multiply(c, d)); const p = e.frame; const g = p.glTexture; const v = p.cutX; const m = p.cutY; const y = g.width; const x = g.height; const T = e._isTinted && e.tintFill; let w = n.getTintAppendFloatAlpha(e._tintTL, s.alpha * e._alphaTL); let b = n.getTintAppendFloatAlpha(e._tintTR, s.alpha * e._alphaTR); let E = n.getTintAppendFloatAlpha(e._tintBL, s.alpha * e._alphaBL); let S = n.getTintAppendFloatAlpha(e._tintBR, s.alpha * e._alphaBR); h.setTexture2D(g, 0); let A; let _; let C = 0; let M = 0; let P = 0; let O = 0; const R = e.letterSpacing; let L = 0; let D = 0; let k = 0; let F = 0; const I = e.scrollX; const B = e.scrollY; const N = e.fontData; const Y = N.chars; const X = N.lineHeight; let z = e.fontSize / N.size; let U = 0; const G = e._align; let W = 0; let V = 0; e.getTextBounds(!1); const H = e._bounds.lines; G === 1 ? V = (H.longest - H.lengths[0]) / 2 : G === 2 && (V = H.longest - H.lengths[0]); for (let j = s.roundPixels, q = e.displayCallback, K = e.callbackData, J = 0; J < a; J++) if ((P = o.charCodeAt(J)) !== 10) { if (A = Y[P]) { L = v + A.x, D = m + A.y, k = A.width, F = A.height; let Z = A.xOffset + C - I; let Q = A.yOffset + M - B; if (_ !== null) { const $ = A.kerning[O]; Z += void 0 !== $ ? $ : 0; } if (C += A.xAdvance + R, _ = A, O = P, k !== 0 && F !== 0 && P !== 32) { if (z = e.fontSize / e.fontData.size, U = 0, q) { K.color = 0, K.tint.topLeft = w, K.tint.topRight = b, K.tint.bottomLeft = E, K.tint.bottomRight = S, K.index = J, K.charCode = P, K.x = Z, K.y = Q, K.scale = z, K.rotation = U, K.data = A.data; const tt = q(K); Z = tt.x, Q = tt.y, z = tt.scale, U = tt.rotation, tt.color ? (w = tt.color, b = tt.color, E = tt.color, S = tt.color) : (w = tt.tint.topLeft, b = tt.tint.topRight, E = tt.tint.bottomLeft, S = tt.tint.bottomRight), w = n.getTintAppendFloatAlpha(w, s.alpha * e._alphaTL), b = n.getTintAppendFloatAlpha(b, s.alpha * e._alphaTR), E = n.getTintAppendFloatAlpha(E, s.alpha * e._alphaBL), S = n.getTintAppendFloatAlpha(S, s.alpha * e._alphaBR); }Z *= z, Q *= z, Z -= e.displayOriginX, Q -= e.displayOriginY, Z += V, f.applyITRS(Z, Q, U, z, z), d.multiply(f, c); const et = L / y; const it = D / x; const nt = (L + k) / y; const st = (D + F) / x; const rt = k; const ot = F; let at = c.e; let ht = c.f; let lt = ot * c.c + c.e; let ut = ot * c.d + c.f; let ct = rt * c.a + ot * c.c + c.e; let dt = rt * c.b + ot * c.d + c.f; let ft = rt * c.a + c.e; let pt = rt * c.b + c.f; j && (at = Math.round(at), ht = Math.round(ht), lt = Math.round(lt), ut = Math.round(ut), ct = Math.round(ct), dt = Math.round(dt), ft = Math.round(ft), pt = Math.round(pt)), h.batchQuad(at, ht, lt, ut, ct, dt, ft, pt, et, it, nt, st, w, b, E, S, T, g, 0); } } } else W++, G === 1 ? V = (H.longest - H.lengths[W]) / 2 : G === 2 && (V = H.longest - H.lengths[W]), C = 0, M += X, _ = null; l && (h.flush(), t.popScissor()); } };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(31); t.exports = function (t, e, i, s, r) { const o = e._text; const a = o.length; const h = t.currentContext; if (a !== 0 && n(t, h, e, s, r)) { const l = e.frame; const u = e.displayCallback; const c = e.callbackData; const d = e.fontData.chars; const f = e.fontData.lineHeight; const p = e._letterSpacing; let g = 0; let v = 0; let m = 0; let y = null; let x = 0; let T = 0; let w = 0; let b = 0; let E = 0; let S = 0; let A = null; let _ = 0; const C = e.frame.source.image; const M = l.cutX; const P = l.cutY; let O = 0; let R = 0; const L = e._fontSize / e.fontData.size; const D = e._align; let k = 0; let F = 0; e.getTextBounds(!1); const I = e._bounds.lines; D === 1 ? F = (I.longest - I.lengths[0]) / 2 : D === 2 && (F = I.longest - I.lengths[0]), h.translate(-e.displayOriginX, -e.displayOriginY); const B = s.roundPixels; e.cropWidth > 0 && e.cropHeight > 0 && (h.beginPath(), h.rect(0, 0, e.cropWidth, e.cropHeight), h.clip()); for (let N = 0; N < a; N++) if (R = L, O = 0, (m = o.charCodeAt(N)) !== 10) { if (y = d[m]) { if (x = M + y.x, T = P + y.y, w = y.width, b = y.height, E = y.xOffset + g - e.scrollX, S = y.yOffset + v - e.scrollY, A !== null) { const Y = y.kerning[_]; E += void 0 !== Y ? Y : 0; } if (u) { c.index = N, c.charCode = m, c.x = E, c.y = S, c.scale = R, c.rotation = O, c.data = y.data; const X = u(c); E = X.x, S = X.y, R = X.scale, O = X.rotation; }E *= R, S *= R, E += F, g += y.xAdvance + p, A = y, _ = m, w !== 0 && b !== 0 && m !== 32 && (B && (E = Math.round(E), S = Math.round(S)), h.save(), h.translate(E, S), h.rotate(O), h.scale(R, R), h.drawImage(C, x, T, w, b, 0, 0, w, b), h.restore()); } } else k++, D === 1 ? F = (I.longest - I.lengths[k]) / 2 : D === 2 && (F = I.longest - I.lengths[k]), g = 0, v += f, A = null; h.restore(); } };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  let n = i(1); let s = i(1); n = i(993), s = i(994), t.exports = { renderWebGL: n, renderCanvas: s };
}, function (t, e) { t.exports = function (t, e, i, n, s) { const r = t.currentPipeline; t.clearPipeline(); const o = t._tempMatrix1; const a = t._tempMatrix2; const h = t._tempMatrix3; a.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY), o.copyFrom(n.matrix), s ? (o.multiplyWithOffset(s, -n.scrollX * e.scrollFactorX, -n.scrollY * e.scrollFactorY), a.e = e.x, a.f = e.y, o.multiply(a, h)) : (a.e -= n.scrollX * e.scrollFactorX, a.f -= n.scrollY * e.scrollFactorY, o.multiply(a, h)), e.render.call(e, t, n, h), t.rebindPipeline(r); }; }, function (t, e) {}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  let n = i(1); let s = i(1); n = i(996), s = i(433), s = i(433), t.exports = { renderWebGL: n, renderCanvas: s };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(210); const s = i(11); const r = function (t, e, i) { this.x = t, this.y = e, this.width = i; }; const o = function (t, e, i) { this.points = [], this.pointsLength = 1, this.points[0] = new r(t, e, i); }; const a = []; t.exports = function (t, e, i, h, l) { if (e.commandBuffer.length !== 0) { const u = this.pipeline; t.setPipeline(u, e); const c = e._tempMatrix1; const d = e._tempMatrix2; const f = e._tempMatrix3; f.loadIdentity(), d.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY), c.copyFrom(h.matrix), l ? (c.multiplyWithOffset(l, -h.scrollX * e.scrollFactorX, -h.scrollY * e.scrollFactorY), d.e = e.x, d.f = e.y, c.multiply(d)) : (d.e -= h.scrollX * e.scrollFactorX, d.f -= h.scrollY * e.scrollFactorY, c.multiply(d)); for (let p = e.commandBuffer, g = h.alpha * e.alpha, v = 1, m = u.fillTint, y = u.strokeTint, x = 0, T = 0, w = 0, b = 2 * Math.PI, E = [], S = 0, A = !1, _ = null, C = s.getTintAppendFloatAlphaAndSwap, M = t.blankTexture.glTexture, P = 0; P < p.length; P++) switch (p[P]) { case n.BEGIN_PATH: E.length = 0, _ = null, A = !0; break; case n.CLOSE_PATH: A = !1, _ && _.points.length && _.points.push(_.points[0]); break; case n.FILL_PATH: for (S = 0; S < E.length; S++)u.setTexture2D(M), u.batchFillPath(E[S].points, f, c); break; case n.STROKE_PATH: for (S = 0; S < E.length; S++)u.setTexture2D(M), u.batchStrokePath(E[S].points, v, A, f, c); break; case n.LINE_STYLE: v = p[++P]; var O = C(p[++P], p[++P] * g); y.TL = O, y.TR = O, y.BL = O, y.BR = O; break; case n.FILL_STYLE: var R = C(p[++P], p[++P] * g); m.TL = R, m.TR = R, m.BL = R, m.BR = R; break; case n.GRADIENT_FILL_STYLE: var L = p[++P] * g; m.TL = C(p[++P], L), m.TR = C(p[++P], L), m.BL = C(p[++P], L), m.BR = C(p[++P], L); break; case n.GRADIENT_LINE_STYLE: v = p[++P]; var D = p[++P] * g; y.TL = C(p[++P], D), y.TR = C(p[++P], D), y.BL = C(p[++P], D), y.BR = C(p[++P], D); break; case n.ARC: var k = 0; var F = p[++P]; var I = p[++P]; var B = p[++P]; var N = p[++P]; var Y = p[++P]; var X = p[++P]; var z = p[++P]; for (Y -= N, X ? Y < -b ? Y = -b : Y > 0 && (Y = Y % b - b) : Y > b ? Y = b : Y < 0 && (Y = b + Y % b), _ === null && (_ = new o(F + Math.cos(N) * B, I + Math.sin(N) * B, v), E.push(_), k += 0.01); k < 1 + z;)w = Y * k + N, x = F + Math.cos(w) * B, T = I + Math.sin(w) * B, _.points.push(new r(x, T, v)), k += 0.01; w = Y + N, x = F + Math.cos(w) * B, T = I + Math.sin(w) * B, _.points.push(new r(x, T, v)); break; case n.FILL_RECT: u.setTexture2D(M), u.batchFillRect(p[++P], p[++P], p[++P], p[++P], f, c); break; case n.FILL_TRIANGLE: u.setTexture2D(M), u.batchFillTriangle(p[++P], p[++P], p[++P], p[++P], p[++P], p[++P], f, c); break; case n.STROKE_TRIANGLE: u.setTexture2D(M), u.batchStrokeTriangle(p[++P], p[++P], p[++P], p[++P], p[++P], p[++P], v, f, c); break; case n.LINE_TO: _ !== null ? _.points.push(new r(p[++P], p[++P], v)) : (_ = new o(p[++P], p[++P], v), E.push(_)); break; case n.MOVE_TO: _ = new o(p[++P], p[++P], v), E.push(_); break; case n.SAVE: a.push(f.copyToArray()); break; case n.RESTORE: f.copyFromArray(a.pop()); break; case n.TRANSLATE: F = p[++P], I = p[++P], f.translate(F, I); break; case n.SCALE: F = p[++P], I = p[++P], f.scale(F, I); break; case n.ROTATE: f.rotate(p[++P]); break; case n.SET_TEXTURE: var U = p[++P]; var G = p[++P]; u.currentFrame = U, u.setTexture2D(U.glTexture, 0), u.tintEffect = G, M = U.glTexture; break; case n.CLEAR_TEXTURE: u.currentFrame = t.blankTexture, u.tintEffect = 2, M = t.blankTexture.glTexture; } } };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  let n = i(1); let s = i(1); n = i(998), s = i(999), t.exports = { renderWebGL: n, renderCanvas: s };
}, function (t, e) { t.exports = function (t, e, i, n, s) { this.pipeline.batchSprite(e, n, s); }; }, function (t, e) { t.exports = function (t, e, i, n, s) { t.batchSprite(e, e.frame, n, s); }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  let n = i(1); let s = i(1); n = i(1001), s = i(1002), t.exports = { renderWebGL: n, renderCanvas: s };
}, function (t, e) { t.exports = function (t, e, i, n, s) { this.pipeline.batchSprite(e, n, s); }; }, function (t, e) { t.exports = function (t, e, i, n, s) { t.batchSprite(e, e.frame, n, s); }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = {
    GravityWell: i(434), Particle: i(435), ParticleEmitter: i(436), ParticleEmitterManager: i(212), Zones: i(1008),
  };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(129); const r = i(76); const o = i(2); const a = i(64); const h = new n({
    initialize(t, e, i, n) { void 0 === n && (n = !1), this.propertyKey = e, this.propertyValue = i, this.defaultValue = i, this.steps = 0, this.counter = 0, this.start = 0, this.end = 0, this.ease, this.emitOnly = n, this.onEmit = this.defaultEmit, this.onUpdate = this.defaultUpdate, this.loadConfig(t); }, loadConfig(t, e) { void 0 === t && (t = {}), e && (this.propertyKey = e), this.propertyValue = o(t, this.propertyKey, this.defaultValue), this.setMethods(), this.emitOnly && (this.onUpdate = this.defaultUpdate); }, toJSON() { return this.propertyValue; }, onChange(t) { return this.propertyValue = t, this.setMethods(); }, setMethods() { const t = this.propertyValue; const e = typeof t; if (e === 'number') this.onEmit = this.staticValueEmit, this.onUpdate = this.staticValueUpdate; else if (Array.isArray(t)) this.onEmit = this.randomStaticValueEmit; else if (e === 'function') this.emitOnly ? this.onEmit = t : this.onUpdate = t; else if (e === 'object' && (this.has(t, 'random') || this.hasBoth(t, 'start', 'end') || this.hasBoth(t, 'min', 'max'))) { this.start = this.has(t, 'start') ? t.start : t.min, this.end = this.has(t, 'end') ? t.end : t.max; const i = this.hasBoth(t, 'min', 'max') || !!t.random; if (i) { const n = t.random; Array.isArray(n) && (this.start = n[0], this.end = n[1]), this.onEmit = this.randomRangedValueEmit; } if (this.has(t, 'steps')) this.steps = t.steps, this.counter = this.start, this.onEmit = this.steppedEmit; else { const s = this.has(t, 'ease') ? t.ease : 'Linear'; this.ease = r(s), i || (this.onEmit = this.easedValueEmit), this.onUpdate = this.easeValueUpdate; } } else e === 'object' && this.hasEither(t, 'onEmit', 'onUpdate') && (this.has(t, 'onEmit') && (this.onEmit = t.onEmit), this.has(t, 'onUpdate') && (this.onUpdate = t.onUpdate)); return this; }, has(t, e) { return t.hasOwnProperty(e); }, hasBoth(t, e, i) { return t.hasOwnProperty(e) && t.hasOwnProperty(i); }, hasEither(t, e, i) { return t.hasOwnProperty(e) || t.hasOwnProperty(i); }, defaultEmit(t, e, i) { return i; }, defaultUpdate(t, e, i, n) { return n; }, staticValueEmit() { return this.propertyValue; }, staticValueUpdate() { return this.propertyValue; }, randomStaticValueEmit() { const t = Math.floor(Math.random() * this.propertyValue.length); return this.propertyValue[t]; }, randomRangedValueEmit(t, e) { const i = s(this.start, this.end); return t && t.data[e] && (t.data[e].min = i), i; }, steppedEmit() { const t = this.counter; const e = this.counter + (this.end - this.start) / this.steps; return this.counter = a(e, this.start, this.end), t; }, easedValueEmit(t, e) { if (t && t.data[e]) { const i = t.data[e]; i.min = this.start, i.max = this.end; } return this.start; }, easeValueUpdate(t, e, i) { const n = t.data[e]; return (n.max - n.min) * this.ease(i) + n.min; },
  }); t.exports = h;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  let n = i(1); let s = i(1); n = i(1006), s = i(1007), t.exports = { renderWebGL: n, renderCanvas: s };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(11); t.exports = function (t, e, i, s, r) { const o = e.emitters.list; const a = o.length; if (a !== 0) { const h = this.pipeline; const l = h._tempMatrix1.copyFrom(s.matrix); const u = h._tempMatrix2; const c = h._tempMatrix3; const d = h._tempMatrix4.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY); l.multiply(d), t.setPipeline(h); const f = s.roundPixels; const p = e.defaultFrame.glTexture; const g = n.getTintAppendFloatAlphaAndSwap; h.setTexture2D(p, 0); for (let v = 0; v < a; v++) { const m = o[v]; const y = m.alive; const x = y.length; if (m.visible && x !== 0) { let T = s.scrollX * m.scrollFactorX; let w = s.scrollY * m.scrollFactorY; r && (l.multiplyWithOffset(r, -T, -w), T = 0, w = 0), t.setBlendMode(m.blendMode) && h.setTexture2D(p, 0), m.mask && (m.mask.preRenderWebGL(t, m, s), h.setTexture2D(p, 0)); for (let b = 0; b < x; b++) { const E = y[b]; const S = E.alpha * s.alpha; if (!(S <= 0)) { const A = E.frame; const _ = -A.halfWidth; const C = -A.halfHeight; const M = _ + A.width; const P = C + A.height; c.applyITRS(0, 0, E.rotation, E.scaleX, E.scaleY), c.e = E.x - T, c.f = E.y - w, l.multiply(c, u); let O = u.getX(_, C); let R = u.getY(_, C); let L = u.getX(_, P); let D = u.getY(_, P); let k = u.getX(M, P); let F = u.getY(M, P); let I = u.getX(M, C); let B = u.getY(M, C); f && (O = Math.round(O), R = Math.round(R), L = Math.round(L), D = Math.round(D), k = Math.round(k), F = Math.round(F), I = Math.round(I), B = Math.round(B)); const N = g(E.tint, S); h.batchQuad(O, R, L, D, k, F, I, B, A.u0, A.v0, A.u1, A.v1, N, N, N, N, 0, p, 0); } }m.mask && (m.mask.postRenderWebGL(t, s), h.setTexture2D(p, 0)); } } } };
}, function (t, e) { t.exports = function (t, e, i, n, s) { const r = e.emitters.list; const o = r.length; if (o !== 0) { const a = t._tempMatrix1.copyFrom(n.matrix); const h = t._tempMatrix2; const l = t._tempMatrix3; const u = t._tempMatrix4.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY); a.multiply(u); const c = n.roundPixels; const d = t.currentContext; d.save(); for (let f = 0; f < o; f++) { const p = r[f]; const g = p.alive; const v = g.length; if (p.visible && v !== 0) { let m = n.scrollX * p.scrollFactorX; let y = n.scrollY * p.scrollFactorY; s && (a.multiplyWithOffset(s, -m, -y), m = 0, y = 0), d.globalCompositeOperation = t.blendModes[p.blendMode]; for (let x = 0; x < v; x++) { const T = g[x]; const w = T.alpha * n.alpha; if (!(w <= 0)) { const b = T.frame; const E = b.canvasData; let S = -b.halfWidth; let A = -b.halfHeight; l.applyITRS(0, 0, T.rotation, T.scaleX, T.scaleY), l.e = T.x - m, l.f = T.y - y, a.multiply(l, h), d.globalAlpha = w, d.save(), h.copyToContext(d), c && (S = Math.round(S), A = Math.round(A)), d.imageSmoothingEnabled = !(!t.antialias || b.source.scaleMode), d.drawImage(b.source.image, E.x, E.y, E.width, E.height, S, A, E.width, E.height), d.restore(); } } } }d.restore(); } }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = { DeathZone: i(437), EdgeZone: i(438), RandomZone: i(440) };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  let n = i(1); let s = i(1); n = i(1010), s = i(1011), t.exports = { renderWebGL: n, renderCanvas: s };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(11); t.exports = function (t, e, i, s, r) { const o = e.frame; const a = o.width; const h = o.height; const l = n.getTintAppendFloatAlpha; this.pipeline.batchTexture(e, o.glTexture, a, h, e.x, e.y, a, h, e.scaleX, e.scaleY, e.rotation, e.flipX, !e.flipY, e.scrollFactorX, e.scrollFactorY, e.displayOriginX, e.displayOriginY, 0, 0, a, h, l(e._tintTL, s.alpha * e._alphaTL), l(e._tintTR, s.alpha * e._alphaTR), l(e._tintBL, s.alpha * e._alphaBL), l(e._tintBR, s.alpha * e._alphaBR), e._isTinted && e.tintFill, 0, 0, s, r), t.setBlankTexture(!0); };
}, function (t, e) { t.exports = function (t, e, i, n, s) { t.batchSprite(e, e.frame, n, s); }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(1013); const s = i(19); let r = { Parse: i(1014) }; r = s(!1, r, n), t.exports = r;
}, function (t, e) {
  t.exports = {
    TEXT_SET1: " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~", TEXT_SET2: " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ", TEXT_SET3: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789 ', TEXT_SET4: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ 0123456789', TEXT_SET5: "ABCDEFGHIJKLMNOPQRSTUVWXYZ.,/() '!?-*:0123456789", TEXT_SET6: "ABCDEFGHIJKLMNOPQRSTUVWXYZ!?:;0123456789\"(),-.' ", TEXT_SET7: "AGMSY+:4BHNTZ!;5CIOU.?06DJPV,(17EKQW\")28FLRX-'39", TEXT_SET8: '0123456789 .ABCDEFGHIJKLMNOPQRSTUVWXYZ', TEXT_SET9: "ABCDEFGHIJKLMNOPQRSTUVWXYZ()-0123456789.:,'\"?!", TEXT_SET10: 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', TEXT_SET11: "ABCDEFGHIJKLMNOPQRSTUVWXYZ.,\"-+!?()':;0123456789",
  };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(6); t.exports = function (t, e) {
    const i = e.width; const s = e.height; const r = Math.floor(i / 2); const o = Math.floor(s / 2); const a = n(e, 'chars', ''); if (a !== '') {
      const h = n(e, 'image', ''); const l = n(e, 'offset.x', 0); const u = n(e, 'offset.y', 0); const c = n(e, 'spacing.x', 0); const d = n(e, 'spacing.y', 0); const f = n(e, 'lineSpacing', 0); let p = n(e, 'charsPerRow', null); p === null && (p = t.sys.textures.getFrame(h).width / i) > a.length && (p = a.length); for (var g = l, v = u, m = {
          retroFont: !0, font: h, size: i, lineHeight: s + f, chars: {},
        }, y = 0, x = 0; x < a.length; x++) {
        const T = a.charCodeAt(x); m.chars[T] = {
          x: g, y: v, width: i, height: s, centerX: r, centerY: o, xOffset: 0, yOffset: 0, xAdvance: i, data: {}, kerning: {},
        }, ++y === p ? (y = 0, g = l, v += s + d) : g += i + c;
      } return { data: m, frame: null, texture: h };
    }
  };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  let n = i(1); let s = i(1); n = i(1016), s = i(1017), t.exports = { renderWebGL: n, renderCanvas: s };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(11); t.exports = function (t, e, i, s, r) { const o = e.pipeline; t.setPipeline(o, e); const a = o._tempMatrix1; const h = o._tempMatrix2; const l = o._tempMatrix3; h.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY), a.copyFrom(s.matrix), r ? (a.multiplyWithOffset(r, -s.scrollX * e.scrollFactorX, -s.scrollY * e.scrollFactorY), h.e = e.x, h.f = e.y, a.multiply(h, l)) : (h.e -= s.scrollX * e.scrollFactorX, h.f -= s.scrollY * e.scrollFactorY, a.multiply(h, l)); const u = e.frame.glTexture; const c = e.vertices; const d = e.uv; const f = e.colors; const p = e.alphas; const g = e.alpha; const v = n.getTintAppendFloatAlphaAndSwap; const m = s.roundPixels; const y = c.length; const x = Math.floor(0.5 * y); o.flush(), o.setTexture2D(u, 0); const T = o.vertexViewF32; const w = o.vertexViewU32; let b = o.vertexCount * o.vertexComponentCount - 1; let E = 0; const S = e.tintFill; e.dirty && e.updateVertices(); for (var A = e.debugCallback, _ = [], C = 0; C < y; C += 2) { const M = c[C + 0]; const P = c[C + 1]; let O = M * l.a + P * l.c + l.e; let R = M * l.b + P * l.d + l.f; m && (O = Math.round(O), R = Math.round(R)), T[++b] = O, T[++b] = R, T[++b] = d[C + 0], T[++b] = d[C + 1], T[++b] = S, w[++b] = v(f[E], s.alpha * (p[E] * g)), E++, A && (_[C + 0] = O, _[C + 1] = R); }A && A.call(e, e, y, _), o.vertexCount += x; };
}, function (t, e) { t.exports = function () {}; }, function (t, e) {
  t.exports = function (t, e, i) {
    const n = t.canvas; const s = t.context; const r = t.style; const o = []; let a = 0; let h = i.length; r.maxLines > 0 && r.maxLines < i.length && (h = r.maxLines), r.syncFont(n, s); for (let l = 0; l < h; l++) { let u = r.strokeThickness; u += s.measureText(i[l]).width, r.wordWrap && (u -= s.measureText(' ').width), o[l] = Math.ceil(u), a = Math.max(a, o[l]); } const c = e.fontSize + r.strokeThickness; let d = c * h; const f = t.lineSpacing; return h > 1 && (d += f * (h - 1)), {
      width: a, height: d, lines: h, lineWidths: o, lineSpacing: f, lineHeight: c,
    };
  };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  let n = i(1); let s = i(1); n = i(1020), s = i(1021), t.exports = { renderWebGL: n, renderCanvas: s };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(11); t.exports = function (t, e, i, s, r) { if (e.width !== 0 && e.height !== 0) { const o = e.frame; const a = o.width; const h = o.height; const l = n.getTintAppendFloatAlpha; this.pipeline.batchTexture(e, o.glTexture, a, h, e.x, e.y, a / e.style.resolution, h / e.style.resolution, e.scaleX, e.scaleY, e.rotation, e.flipX, e.flipY, e.scrollFactorX, e.scrollFactorY, e.displayOriginX, e.displayOriginY, 0, 0, a, h, l(e._tintTL, s.alpha * e._alphaTL), l(e._tintTR, s.alpha * e._alphaTR), l(e._tintBL, s.alpha * e._alphaBL), l(e._tintBR, s.alpha * e._alphaBR), e._isTinted && e.tintFill, 0, 0, s, r); } };
}, function (t, e) { t.exports = function (t, e, i, n, s) { e.width !== 0 && e.height !== 0 && t.batchSprite(e, e.frame, n, s); }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(15); const r = i(6); const o = i(1023); const a = {
    fontFamily: ['fontFamily', 'Courier'], fontSize: ['fontSize', '16px'], fontStyle: ['fontStyle', ''], backgroundColor: ['backgroundColor', null], color: ['color', '#fff'], stroke: ['stroke', '#fff'], strokeThickness: ['strokeThickness', 0], shadowOffsetX: ['shadow.offsetX', 0], shadowOffsetY: ['shadow.offsetY', 0], shadowColor: ['shadow.color', '#000'], shadowBlur: ['shadow.blur', 0], shadowStroke: ['shadow.stroke', !1], shadowFill: ['shadow.fill', !1], align: ['align', 'left'], maxLines: ['maxLines', 0], fixedWidth: ['fixedWidth', 0], fixedHeight: ['fixedHeight', 0], resolution: ['resolution', 0], rtl: ['rtl', !1], testString: ['testString', '|Mqgy'], baselineX: ['baselineX', 1.2], baselineY: ['baselineY', 1.4], wordWrapWidth: ['wordWrap.width', null], wordWrapCallback: ['wordWrap.callback', null], wordWrapCallbackScope: ['wordWrap.callbackScope', null], wordWrapUseAdvanced: ['wordWrap.useAdvancedWrap', !1],
  }; const h = new n({
    initialize(t, e) { this.parent = t, this.fontFamily, this.fontSize, this.fontStyle, this.backgroundColor, this.color, this.stroke, this.strokeThickness, this.shadowOffsetX, this.shadowOffsetY, this.shadowColor, this.shadowBlur, this.shadowStroke, this.shadowFill, this.align, this.maxLines, this.fixedWidth, this.fixedHeight, this.resolution, this.rtl, this.testString, this.baselineX, this.baselineY, this._font, this.setStyle(e, !1, !0); const i = r(e, 'metrics', !1); this.metrics = i ? { ascent: r(i, 'ascent', 0), descent: r(i, 'descent', 0), fontSize: r(i, 'fontSize', 0) } : o(this); }, setStyle(t, e, i) { for (const n in void 0 === e && (e = !0), void 0 === i && (i = !1), t && t.hasOwnProperty('fontSize') && typeof t.fontSize === 'number' && (t.fontSize = `${t.fontSize.toString()}px`), a) { const o = i ? a[n][1] : this[n]; this[n] = n === 'wordWrapCallback' || n === 'wordWrapCallbackScope' ? r(t, a[n][0], o) : s(t, a[n][0], o); } const h = r(t, 'font', null); h !== null && this.setFont(h, !1), this._font = [this.fontStyle, this.fontSize, this.fontFamily].join(' ').trim(); const l = r(t, 'fill', null); return l !== null && (this.color = l), e ? this.update(!0) : this.parent; }, syncFont(t, e) { e.font = this._font; }, syncStyle(t, e) { e.textBaseline = 'alphabetic', e.fillStyle = this.color, e.strokeStyle = this.stroke, e.lineWidth = this.strokeThickness, e.lineCap = 'round', e.lineJoin = 'round'; }, syncShadow(t, e) { e ? (t.shadowOffsetX = this.shadowOffsetX, t.shadowOffsetY = this.shadowOffsetY, t.shadowColor = this.shadowColor, t.shadowBlur = this.shadowBlur) : (t.shadowOffsetX = 0, t.shadowOffsetY = 0, t.shadowColor = 0, t.shadowBlur = 0); }, update(t) { return t && (this._font = [this.fontStyle, this.fontSize, this.fontFamily].join(' ').trim(), this.metrics = o(this)), this.parent.updateText(); }, setFont(t, e) { void 0 === e && (e = !0); let i = t; let n = ''; let s = ''; if (typeof t !== 'string')i = r(t, 'fontFamily', 'Courier'), n = r(t, 'fontSize', '16px'), s = r(t, 'fontStyle', ''); else { const o = t.split(' '); let a = 0; s = o.length > 2 ? o[a++] : '', n = o[a++] || '16px', i = o[a++] || 'Courier'; } return i === this.fontFamily && n === this.fontSize && s === this.fontStyle || (this.fontFamily = i, this.fontSize = n, this.fontStyle = s, e && this.update(!0)), this.parent; }, setFontFamily(t) { return this.fontFamily !== t && (this.fontFamily = t, this.update(!0)), this.parent; }, setFontStyle(t) { return this.fontStyle !== t && (this.fontStyle = t, this.update(!0)), this.parent; }, setFontSize(t) { return typeof t === 'number' && (t = `${t.toString()}px`), this.fontSize !== t && (this.fontSize = t, this.update(!0)), this.parent; }, setTestString(t) { return this.testString = t, this.update(!0); }, setFixedSize(t, e) { return this.fixedWidth = t, this.fixedHeight = e, t && (this.parent.width = t), e && (this.parent.height = e), this.update(!1); }, setBackgroundColor(t) { return this.backgroundColor = t, this.update(!1); }, setFill(t) { return this.color = t, this.update(!1); }, setColor(t) { return this.color = t, this.update(!1); }, setResolution(t) { return this.resolution = t, this.update(!1); }, setStroke(t, e) { return void 0 === e && (e = this.strokeThickness), void 0 === t && this.strokeThickness !== 0 ? (this.strokeThickness = 0, this.update(!0)) : this.stroke === t && this.strokeThickness === e || (this.stroke = t, this.strokeThickness = e, this.update(!0)), this.parent; }, setShadow(t, e, i, n, s, r) { return void 0 === t && (t = 0), void 0 === e && (e = 0), void 0 === i && (i = '#000'), void 0 === n && (n = 0), void 0 === s && (s = !1), void 0 === r && (r = !0), this.shadowOffsetX = t, this.shadowOffsetY = e, this.shadowColor = i, this.shadowBlur = n, this.shadowStroke = s, this.shadowFill = r, this.update(!1); }, setShadowOffset(t, e) { return void 0 === t && (t = 0), void 0 === e && (e = t), this.shadowOffsetX = t, this.shadowOffsetY = e, this.update(!1); }, setShadowColor(t) { return void 0 === t && (t = '#000'), this.shadowColor = t, this.update(!1); }, setShadowBlur(t) { return void 0 === t && (t = 0), this.shadowBlur = t, this.update(!1); }, setShadowStroke(t) { return this.shadowStroke = t, this.update(!1); }, setShadowFill(t) { return this.shadowFill = t, this.update(!1); }, setWordWrapWidth(t, e) { return void 0 === e && (e = !1), this.wordWrapWidth = t, this.wordWrapUseAdvanced = e, this.update(!1); }, setWordWrapCallback(t, e) { return void 0 === e && (e = null), this.wordWrapCallback = t, this.wordWrapCallbackScope = e, this.update(!1); }, setAlign(t) { return void 0 === t && (t = 'left'), this.align = t, this.update(!1); }, setMaxLines(t) { return void 0 === t && (t = 0), this.maxLines = t, this.update(!1); }, getTextMetrics() { const t = this.metrics; return { ascent: t.ascent, descent: t.descent, fontSize: t.fontSize }; }, toJSON() { const t = {}; for (const e in a)t[e] = this[e]; return t.metrics = this.getTextMetrics(), t; }, destroy() { this.parent = void 0; },
  }); t.exports = h;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(30); t.exports = function (t) { const e = n.create(this); const i = e.getContext('2d'); t.syncFont(e, i); const s = Math.ceil(i.measureText(t.testString).width * t.baselineX); let r = s; const o = 2 * r; r = r * t.baselineY | 0, e.width = s, e.height = o, i.fillStyle = '#f00', i.fillRect(0, 0, s, o), i.font = t._font, i.textBaseline = 'alphabetic', i.fillStyle = '#000', i.fillText(t.testString, 0, r); const a = { ascent: 0, descent: 0, fontSize: 0 }; if (!i.getImageData(0, 0, s, o)) return a.ascent = r, a.descent = r + 6, a.fontSize = a.ascent + a.descent, n.remove(e), a; let h; let l; const u = i.getImageData(0, 0, s, o).data; const c = u.length; const d = 4 * s; let f = 0; let p = !1; for (h = 0; h < r; h++) { for (l = 0; l < d; l += 4) if (u[f + l] !== 255) { p = !0; break; } if (p) break; f += d; } for (a.ascent = r - h, f = c - d, p = !1, h = o; h > r; h--) { for (l = 0; l < d; l += 4) if (u[f + l] !== 255) { p = !0; break; } if (p) break; f -= d; } return a.descent = h - r, a.fontSize = a.ascent + a.descent, n.remove(e), a; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  let n = i(1); let s = i(1); n = i(1025), s = i(1026), t.exports = { renderWebGL: n, renderCanvas: s };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(11); t.exports = function (t, e, i, s, r) { e.updateCanvas(); const o = n.getTintAppendFloatAlpha; this.pipeline.batchTexture(e, e.fillPattern, e.displayFrame.width * e.tileScaleX, e.displayFrame.height * e.tileScaleY, e.x, e.y, e.width, e.height, e.scaleX, e.scaleY, e.rotation, e.flipX, e.flipY, e.scrollFactorX, e.scrollFactorY, e.originX * e.width, e.originY * e.height, 0, 0, e.width, e.height, o(e._tintTL, s.alpha * e._alphaTL), o(e._tintTR, s.alpha * e._alphaTR), o(e._tintBL, s.alpha * e._alphaBL), o(e._tintBR, s.alpha * e._alphaBR), e._isTinted && e.tintFill, e.tilePositionX % e.displayFrame.width / e.displayFrame.width, e.tilePositionY % e.displayFrame.height / e.displayFrame.height, s, r); };
}, function (t, e) { t.exports = function (t, e, i, n, s) { e.updateCanvas(), t.batchSprite(e, e.frame, n, s); }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  let n = i(1); let s = i(1); n = i(1028), s = i(1029), t.exports = { renderWebGL: n, renderCanvas: s };
}, function (t, e) { t.exports = function (t, e, i, n, s) { e.videoTexture && this.pipeline.batchSprite(e, n, s); }; }, function (t, e) { t.exports = function (t, e, i, n, s) { e.videoTexture && t.batchSprite(e, e.frame, n, s); }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  let n = i(1); let s = i(1); n = i(1031), s = i(1032), t.exports = { renderWebGL: n, renderCanvas: s };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(114); const s = i(77); t.exports = function (t, e, i, r, o) { const a = this.pipeline; const h = a._tempMatrix1; const l = a._tempMatrix2; const u = a._tempMatrix3; t.setPipeline(a), l.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY), h.copyFrom(r.matrix), o ? (h.multiplyWithOffset(o, -r.scrollX * e.scrollFactorX, -r.scrollY * e.scrollFactorY), l.e = e.x, l.f = e.y) : (l.e -= r.scrollX * e.scrollFactorX, l.f -= r.scrollY * e.scrollFactorY), h.multiply(l, u); const c = e._displayOriginX; const d = e._displayOriginY; const f = r.alpha * e.alpha; e.isFilled && n(a, u, e, f, c, d), e.isStroked && s(a, e, f, c, d); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(41); const s = i(43); const r = i(58); const o = i(31); t.exports = function (t, e, i, a, h) { const l = t.currentContext; if (o(t, l, e, a, h)) { const u = e.radius; l.beginPath(), l.arc(u - e.originX * (2 * u), u - e.originY * (2 * u), u, n(e._startAngle), n(e._endAngle), e.anticlockwise), e.closePath && l.closePath(), e.isFilled && (s(l, e), l.fill()), e.isStroked && (r(l, e), l.stroke()), l.restore(); } };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  let n = i(1); let s = i(1); n = i(1034), s = i(1035), t.exports = { renderWebGL: n, renderCanvas: s };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(114); const s = i(77); t.exports = function (t, e, i, r, o) { const a = this.pipeline; const h = a._tempMatrix1; const l = a._tempMatrix2; const u = a._tempMatrix3; t.setPipeline(a), l.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY), h.copyFrom(r.matrix), o ? (h.multiplyWithOffset(o, -r.scrollX * e.scrollFactorX, -r.scrollY * e.scrollFactorY), l.e = e.x, l.f = e.y) : (l.e -= r.scrollX * e.scrollFactorX, l.f -= r.scrollY * e.scrollFactorY), h.multiply(l, u); const c = e._displayOriginX + e._curveBounds.x; const d = e._displayOriginY + e._curveBounds.y; const f = r.alpha * e.alpha; e.isFilled && n(a, u, e, f, c, d), e.isStroked && s(a, e, f, c, d); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(43); const s = i(58); const r = i(31); t.exports = function (t, e, i, o, a) { const h = t.currentContext; if (r(t, h, e, o, a)) { const l = e._displayOriginX + e._curveBounds.x; const u = e._displayOriginY + e._curveBounds.y; const c = e.pathData; let d = c.length - 1; const f = c[0] - l; const p = c[1] - u; h.beginPath(), h.moveTo(f, p), e.closePath || (d -= 2); for (let g = 2; g < d; g += 2) { const v = c[g] - l; const m = c[g + 1] - u; h.lineTo(v, m); }e.closePath && h.closePath(), e.isFilled && (n(h, e), h.fill()), e.isStroked && (s(h, e), h.stroke()), h.restore(); } };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  let n = i(1); let s = i(1); n = i(1037), s = i(1038), t.exports = { renderWebGL: n, renderCanvas: s };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(114); const s = i(77); t.exports = function (t, e, i, r, o) { const a = this.pipeline; const h = a._tempMatrix1; const l = a._tempMatrix2; const u = a._tempMatrix3; t.setPipeline(a), l.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY), h.copyFrom(r.matrix), o ? (h.multiplyWithOffset(o, -r.scrollX * e.scrollFactorX, -r.scrollY * e.scrollFactorY), l.e = e.x, l.f = e.y) : (l.e -= r.scrollX * e.scrollFactorX, l.f -= r.scrollY * e.scrollFactorY), h.multiply(l, u); const c = e._displayOriginX; const d = e._displayOriginY; const f = r.alpha * e.alpha; e.isFilled && n(a, u, e, f, c, d), e.isStroked && s(a, e, f, c, d); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(43); const s = i(58); const r = i(31); t.exports = function (t, e, i, o, a) { const h = t.currentContext; if (r(t, h, e, o, a)) { const l = e._displayOriginX; const u = e._displayOriginY; const c = e.pathData; let d = c.length - 1; const f = c[0] - l; const p = c[1] - u; h.beginPath(), h.moveTo(f, p), e.closePath || (d -= 2); for (let g = 2; g < d; g += 2) { const v = c[g] - l; const m = c[g + 1] - u; h.lineTo(v, m); }h.closePath(), e.isFilled && (n(h, e), h.fill()), e.isStroked && (s(h, e), h.stroke()), h.restore(); } };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  let n = i(1); let s = i(1); n = i(1040), s = i(1041), t.exports = { renderWebGL: n, renderCanvas: s };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(11); t.exports = function (t, e, i, s, r) { const o = this.pipeline; const a = o._tempMatrix1; const h = o._tempMatrix2; const l = o._tempMatrix3; t.setPipeline(o), h.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY), a.copyFrom(s.matrix), r ? (a.multiplyWithOffset(r, -s.scrollX * e.scrollFactorX, -s.scrollY * e.scrollFactorY), h.e = e.x, h.f = e.y) : (h.e -= s.scrollX * e.scrollFactorX, h.f -= s.scrollY * e.scrollFactorY), a.multiply(h, l), l.translate(-e._displayOriginX, -e._displayOriginY); let u; let c; const d = s.alpha * e.alpha; const f = e.width; const p = e.height; const g = e.cellWidth; const v = e.cellHeight; const m = Math.ceil(f / g); const y = Math.ceil(p / v); let x = g; let T = v; let w = g - (m * g - f); let b = v - (y * v - p); const E = e.showCells; const S = e.showAltCells; const A = e.showOutline; let _ = 0; let C = 0; let M = 0; let P = 0; let O = 0; if (A && (x--, T--, w === g && w--, b === v && b--), E && e.fillAlpha > 0) for (u = o.fillTint, c = n.getTintAppendFloatAlphaAndSwap(e.fillColor, e.fillAlpha * d), u.TL = c, u.TR = c, u.BL = c, u.BR = c, C = 0; C < y; C++) for (S && (M = C % 2), _ = 0; _ < m; _++)S && M ? M = 0 : (M++, P = _ < m - 1 ? x : w, O = C < y - 1 ? T : b, o.setTexture2D(), o.batchFillRect(_ * g, C * v, P, O)); if (S && e.altFillAlpha > 0) for (u = o.fillTint, c = n.getTintAppendFloatAlphaAndSwap(e.altFillColor, e.altFillAlpha * d), u.TL = c, u.TR = c, u.BL = c, u.BR = c, C = 0; C < y; C++) for (S && (M = C % 2), _ = 0; _ < m; _++)!S || M ? (M = 0, P = _ < m - 1 ? x : w, O = C < y - 1 ? T : b, o.setTexture2D(), o.batchFillRect(_ * g, C * v, P, O)) : M = 1; if (A && e.outlineFillAlpha > 0) { const R = o.strokeTint; const L = n.getTintAppendFloatAlphaAndSwap(e.outlineFillColor, e.outlineFillAlpha * d); for (R.TL = L, R.TR = L, R.BL = L, R.BR = L, _ = 1; _ < m; _++) { const D = _ * g; o.setTexture2D(), o.batchLine(D, 0, D, p, 1, 1, 1, 0, !1); } for (C = 1; C < y; C++) { const k = C * v; o.setTexture2D(), o.batchLine(0, k, f, k, 1, 1, 1, 0, !1); } } };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(43); const s = i(58); const r = i(31); t.exports = function (t, e, i, o, a) { const h = t.currentContext; if (r(t, h, e, o, a)) { const l = -e._displayOriginX; const u = -e._displayOriginY; const c = o.alpha * e.alpha; const d = e.width; const f = e.height; const p = e.cellWidth; const g = e.cellHeight; const v = Math.ceil(d / p); const m = Math.ceil(f / g); let y = p; let x = g; let T = p - (v * p - d); let w = g - (m * g - f); const b = e.showCells; const E = e.showAltCells; const S = e.showOutline; let A = 0; let _ = 0; let C = 0; let M = 0; let P = 0; if (S && (y--, x--, T === p && T--, w === g && w--), b && e.fillAlpha > 0) for (n(h, e), _ = 0; _ < m; _++) for (E && (C = _ % 2), A = 0; A < v; A++)E && C ? C = 0 : (C++, M = A < v - 1 ? y : T, P = _ < m - 1 ? x : w, h.fillRect(l + A * p, u + _ * g, M, P)); if (E && e.altFillAlpha > 0) for (n(h, e, e.altFillColor, e.altFillAlpha * c), _ = 0; _ < m; _++) for (E && (C = _ % 2), A = 0; A < v; A++)!E || C ? (C = 0, M = A < v - 1 ? y : T, P = _ < m - 1 ? x : w, h.fillRect(l + A * p, u + _ * g, M, P)) : C = 1; if (S && e.outlineFillAlpha > 0) { for (s(h, e, e.outlineFillColor, e.outlineFillAlpha * c), A = 1; A < v; A++) { const O = A * p; h.beginPath(), h.moveTo(O + l, u), h.lineTo(O + l, f + u), h.stroke(); } for (_ = 1; _ < m; _++) { const R = _ * g; h.beginPath(), h.moveTo(l, R + u), h.lineTo(l + d, R + u), h.stroke(); } }h.restore(); } };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  let n = i(1); let s = i(1); n = i(1043), s = i(1044), t.exports = { renderWebGL: n, renderCanvas: s };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(11); t.exports = function (t, e, i, s, r) { const o = this.pipeline; const a = o._tempMatrix1; const h = o._tempMatrix2; const l = o._tempMatrix3; t.setPipeline(o), h.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY), a.copyFrom(s.matrix), r ? (a.multiplyWithOffset(r, -s.scrollX * e.scrollFactorX, -s.scrollY * e.scrollFactorY), h.e = e.x, h.f = e.y) : (h.e -= s.scrollX * e.scrollFactorX, h.f -= s.scrollY * e.scrollFactorY), a.multiply(h, l); let u; let c; let d; let f; let p; let g; let v; let m; let y; const x = e.width; const T = e.height; const w = x / 2; const b = x / e.projection; const E = s.alpha * e.alpha; e.isFilled && (e.showTop && (u = n.getTintAppendFloatAlphaAndSwap(e.fillTop, E), c = l.getX(-w, -T), d = l.getY(-w, -T), f = l.getX(0, -b - T), p = l.getY(0, -b - T), g = l.getX(w, -T), v = l.getY(w, -T), m = l.getX(0, b - T), y = l.getY(0, b - T), o.setTexture2D(), o.batchQuad(c, d, f, p, g, v, m, y, 0, 0, 1, 1, u, u, u, u, 2)), e.showLeft && (u = n.getTintAppendFloatAlphaAndSwap(e.fillLeft, E), c = l.getX(-w, 0), d = l.getY(-w, 0), f = l.getX(0, b), p = l.getY(0, b), g = l.getX(0, b - T), v = l.getY(0, b - T), m = l.getX(-w, -T), y = l.getY(-w, -T), o.setTexture2D(), o.batchQuad(c, d, f, p, g, v, m, y, 0, 0, 1, 1, u, u, u, u, 2)), e.showRight && (u = n.getTintAppendFloatAlphaAndSwap(e.fillRight, E), c = l.getX(w, 0), d = l.getY(w, 0), f = l.getX(0, b), p = l.getY(0, b), g = l.getX(0, b - T), v = l.getY(0, b - T), m = l.getX(w, -T), y = l.getY(w, -T), o.setTexture2D(), o.batchQuad(c, d, f, p, g, v, m, y, 0, 0, 1, 1, u, u, u, u, 2))); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(43); const s = i(31); t.exports = function (t, e, i, r, o) { const a = t.currentContext; if (s(t, a, e, r, o) && e.isFilled) { const h = e.width; const l = e.height; const u = h / 2; const c = h / e.projection; e.showTop && (n(a, e, e.fillTop), a.beginPath(), a.moveTo(-u, -l), a.lineTo(0, -c - l), a.lineTo(u, -l), a.lineTo(u, -1), a.lineTo(0, c - 1), a.lineTo(-u, -1), a.lineTo(-u, -l), a.fill()), e.showLeft && (n(a, e, e.fillLeft), a.beginPath(), a.moveTo(-u, 0), a.lineTo(0, c), a.lineTo(0, c - l), a.lineTo(-u, -l), a.lineTo(-u, 0), a.fill()), e.showRight && (n(a, e, e.fillRight), a.beginPath(), a.moveTo(u, 0), a.lineTo(0, c), a.lineTo(0, c - l), a.lineTo(u, -l), a.lineTo(u, 0), a.fill()), a.restore(); } };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  let n = i(1); let s = i(1); n = i(1046), s = i(1047), t.exports = { renderWebGL: n, renderCanvas: s };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(11); t.exports = function (t, e, i, s, r) { const o = this.pipeline; const a = o._tempMatrix1; const h = o._tempMatrix2; const l = o._tempMatrix3; t.setPipeline(o), h.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY), a.copyFrom(s.matrix), r ? (a.multiplyWithOffset(r, -s.scrollX * e.scrollFactorX, -s.scrollY * e.scrollFactorY), h.e = e.x, h.f = e.y) : (h.e -= s.scrollX * e.scrollFactorX, h.f -= s.scrollY * e.scrollFactorY), a.multiply(h, l); const u = e.width; const c = e.height; const d = u / 2; const f = u / e.projection; const p = e.isReversed; const g = s.alpha * e.alpha; if (e.isFilled) { let v; let m; let y; let x; let T; let w; let b; if (e.showTop && p) { v = n.getTintAppendFloatAlphaAndSwap(e.fillTop, g), m = l.getX(-d, -c), y = l.getY(-d, -c), x = l.getX(0, -f - c), T = l.getY(0, -f - c), w = l.getX(d, -c), b = l.getY(d, -c); const E = l.getX(0, f - c); const S = l.getY(0, f - c); o.setTexture2D(), o.batchQuad(m, y, x, T, w, b, E, S, 0, 0, 1, 1, v, v, v, v, 2); }e.showLeft && (v = n.getTintAppendFloatAlphaAndSwap(e.fillLeft, g), p ? (m = l.getX(-d, -c), y = l.getY(-d, -c), x = l.getX(0, f), T = l.getY(0, f), w = l.getX(0, f - c), b = l.getY(0, f - c)) : (m = l.getX(-d, 0), y = l.getY(-d, 0), x = l.getX(0, f), T = l.getY(0, f), w = l.getX(0, f - c), b = l.getY(0, f - c)), o.batchTri(m, y, x, T, w, b, 0, 0, 1, 1, v, v, v, 2)), e.showRight && (v = n.getTintAppendFloatAlphaAndSwap(e.fillRight, g), p ? (m = l.getX(d, -c), y = l.getY(d, -c), x = l.getX(0, f), T = l.getY(0, f), w = l.getX(0, f - c), b = l.getY(0, f - c)) : (m = l.getX(d, 0), y = l.getY(d, 0), x = l.getX(0, f), T = l.getY(0, f), w = l.getX(0, f - c), b = l.getY(0, f - c)), o.setTexture2D(), o.batchTri(m, y, x, T, w, b, 0, 0, 1, 1, v, v, v, 2)); } };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(43); const s = i(31); t.exports = function (t, e, i, r, o) { const a = t.currentContext; if (s(t, a, e, r, o) && e.isFilled) { const h = e.width; const l = e.height; const u = h / 2; const c = h / e.projection; const d = e.isReversed; e.showTop && d && (n(a, e, e.fillTop), a.beginPath(), a.moveTo(-u, -l), a.lineTo(0, -c - l), a.lineTo(u, -l), a.lineTo(0, c - l), a.fill()), e.showLeft && (n(a, e, e.fillLeft), a.beginPath(), d ? (a.moveTo(-u, -l), a.lineTo(0, c), a.lineTo(0, c - l)) : (a.moveTo(-u, 0), a.lineTo(0, c), a.lineTo(0, c - l)), a.fill()), e.showRight && (n(a, e, e.fillRight), a.beginPath(), d ? (a.moveTo(u, -l), a.lineTo(0, c), a.lineTo(0, c - l)) : (a.moveTo(u, 0), a.lineTo(0, c), a.lineTo(0, c - l)), a.fill()), a.restore(); } };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  let n = i(1); let s = i(1); n = i(1049), s = i(1050), t.exports = { renderWebGL: n, renderCanvas: s };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(11); t.exports = function (t, e, i, s, r) { const o = this.pipeline; const a = o._tempMatrix1; const h = o._tempMatrix2; t.setPipeline(o), h.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY), a.copyFrom(s.matrix), r ? (a.multiplyWithOffset(r, -s.scrollX * e.scrollFactorX, -s.scrollY * e.scrollFactorY), h.e = e.x, h.f = e.y) : (h.e -= s.scrollX * e.scrollFactorX, h.f -= s.scrollY * e.scrollFactorY); const l = e._displayOriginX; const u = e._displayOriginY; const c = s.alpha * e.alpha; if (e.isStroked) { const d = o.strokeTint; const f = n.getTintAppendFloatAlphaAndSwap(e.strokeColor, e.strokeAlpha * c); d.TL = f, d.TR = f, d.BL = f, d.BR = f; const p = e._startWidth; const g = e._endWidth; o.setTexture2D(), o.batchLine(e.geom.x1 - l, e.geom.y1 - u, e.geom.x2 - l, e.geom.y2 - u, p, g, 1, 0, !1, h, a); } };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(58); const s = i(31); t.exports = function (t, e, i, r, o) { const a = t.currentContext; if (s(t, a, e, r, o)) { const h = e._displayOriginX; const l = e._displayOriginY; e.isStroked && (n(a, e), a.beginPath(), a.moveTo(e.geom.x1 - h, e.geom.y1 - l), a.lineTo(e.geom.x2 - h, e.geom.y2 - l), a.stroke()), a.restore(); } };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  let n = i(1); let s = i(1); n = i(1052), s = i(1053), t.exports = { renderWebGL: n, renderCanvas: s };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(114); const s = i(77); t.exports = function (t, e, i, r, o) { const a = this.pipeline; const h = a._tempMatrix1; const l = a._tempMatrix2; const u = a._tempMatrix3; t.setPipeline(a), l.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY), h.copyFrom(r.matrix), o ? (h.multiplyWithOffset(o, -r.scrollX * e.scrollFactorX, -r.scrollY * e.scrollFactorY), l.e = e.x, l.f = e.y) : (l.e -= r.scrollX * e.scrollFactorX, l.f -= r.scrollY * e.scrollFactorY), h.multiply(l, u); const c = e._displayOriginX; const d = e._displayOriginY; const f = r.alpha * e.alpha; e.isFilled && n(a, u, e, f, c, d), e.isStroked && s(a, e, f, c, d); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(43); const s = i(58); const r = i(31); t.exports = function (t, e, i, o, a) { const h = t.currentContext; if (r(t, h, e, o, a)) { const l = e._displayOriginX; const u = e._displayOriginY; const c = e.pathData; let d = c.length - 1; const f = c[0] - l; const p = c[1] - u; h.beginPath(), h.moveTo(f, p), e.closePath || (d -= 2); for (let g = 2; g < d; g += 2) { const v = c[g] - l; const m = c[g + 1] - u; h.lineTo(v, m); }h.closePath(), e.isFilled && (n(h, e), h.fill()), e.isStroked && (s(h, e), h.stroke()), h.restore(); } };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  let n = i(1); let s = i(1); n = i(1055), s = i(1056), t.exports = { renderWebGL: n, renderCanvas: s };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(77); const s = i(11); t.exports = function (t, e, i, r, o) { const a = this.pipeline; const h = a._tempMatrix1; const l = a._tempMatrix2; const u = a._tempMatrix3; t.setPipeline(a), l.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY), h.copyFrom(r.matrix), o ? (h.multiplyWithOffset(o, -r.scrollX * e.scrollFactorX, -r.scrollY * e.scrollFactorY), l.e = e.x, l.f = e.y) : (l.e -= r.scrollX * e.scrollFactorX, l.f -= r.scrollY * e.scrollFactorY), h.multiply(l, u); const c = e._displayOriginX; const d = e._displayOriginY; const f = r.alpha * e.alpha; if (e.isFilled) { const p = a.fillTint; const g = s.getTintAppendFloatAlphaAndSwap(e.fillColor, e.fillAlpha * f); p.TL = g, p.TR = g, p.BL = g, p.BR = g, a.setTexture2D(), a.batchFillRect(-c, -d, e.width, e.height); }e.isStroked && n(a, e, f, c, d); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(43); const s = i(58); const r = i(31); t.exports = function (t, e, i, o, a) { const h = t.currentContext; if (r(t, h, e, o, a)) { const l = e._displayOriginX; const u = e._displayOriginY; e.isFilled && (n(h, e), h.fillRect(-l, -u, e.width, e.height)), e.isStroked && (s(h, e), h.beginPath(), h.rect(-l, -u, e.width, e.height), h.stroke()), h.restore(); } };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  let n = i(1); let s = i(1); n = i(1058), s = i(1059), t.exports = { renderWebGL: n, renderCanvas: s };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(114); const s = i(77); t.exports = function (t, e, i, r, o) { const a = this.pipeline; const h = a._tempMatrix1; const l = a._tempMatrix2; const u = a._tempMatrix3; t.setPipeline(a), l.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY), h.copyFrom(r.matrix), o ? (h.multiplyWithOffset(o, -r.scrollX * e.scrollFactorX, -r.scrollY * e.scrollFactorY), l.e = e.x, l.f = e.y) : (l.e -= r.scrollX * e.scrollFactorX, l.f -= r.scrollY * e.scrollFactorY), h.multiply(l, u); const c = e._displayOriginX; const d = e._displayOriginY; const f = r.alpha * e.alpha; e.isFilled && n(a, u, e, f, c, d), e.isStroked && s(a, e, f, c, d); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(43); const s = i(58); const r = i(31); t.exports = function (t, e, i, o, a) { const h = t.currentContext; if (r(t, h, e, o, a)) { const l = e._displayOriginX; const u = e._displayOriginY; const c = e.pathData; let d = c.length - 1; const f = c[0] - l; const p = c[1] - u; h.beginPath(), h.moveTo(f, p), e.closePath || (d -= 2); for (let g = 2; g < d; g += 2) { const v = c[g] - l; const m = c[g + 1] - u; h.lineTo(v, m); }h.closePath(), e.isFilled && (n(h, e), h.fill()), e.isStroked && (s(h, e), h.stroke()), h.restore(); } };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  let n = i(1); let s = i(1); n = i(1061), s = i(1062), t.exports = { renderWebGL: n, renderCanvas: s };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(77); const s = i(11); t.exports = function (t, e, i, r, o) { const a = this.pipeline; const h = a._tempMatrix1; const l = a._tempMatrix2; const u = a._tempMatrix3; t.setPipeline(a), l.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY), h.copyFrom(r.matrix), o ? (h.multiplyWithOffset(o, -r.scrollX * e.scrollFactorX, -r.scrollY * e.scrollFactorY), l.e = e.x, l.f = e.y) : (l.e -= r.scrollX * e.scrollFactorX, l.f -= r.scrollY * e.scrollFactorY), h.multiply(l, u); const c = e._displayOriginX; const d = e._displayOriginY; const f = r.alpha * e.alpha; if (e.isFilled) { const p = a.fillTint; const g = s.getTintAppendFloatAlphaAndSwap(e.fillColor, e.fillAlpha * f); p.TL = g, p.TR = g, p.BL = g, p.BR = g; const v = e.geom.x1 - c; const m = e.geom.y1 - d; const y = e.geom.x2 - c; const x = e.geom.y2 - d; const T = e.geom.x3 - c; const w = e.geom.y3 - d; a.setTexture2D(), a.batchFillTriangle(v, m, y, x, T, w, l, h); }e.isStroked && n(a, e, f, c, d); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(43); const s = i(58); const r = i(31); t.exports = function (t, e, i, o, a) { const h = t.currentContext; if (r(t, h, e, o, a)) { const l = e._displayOriginX; const u = e._displayOriginY; const c = e.geom.x1 - l; const d = e.geom.y1 - u; const f = e.geom.x2 - l; const p = e.geom.y2 - u; const g = e.geom.x3 - l; const v = e.geom.y3 - u; h.beginPath(), h.moveTo(c, d), h.lineTo(f, p), h.lineTo(g, v), h.closePath(), e.isFilled && (n(h, e), h.fill()), e.isStroked && (s(h, e), h.stroke()), h.restore(); } };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(206); i(5).register('blitter', (function (t, e, i, s) { return this.displayList.add(new n(this.scene, t, e, i, s)); }));
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Felipe Alfonso <@bitnenfer>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(207); i(5).register('container', (function (t, e, i) { return this.displayList.add(new n(this.scene, t, e, i)); }));
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(427); i(5).register('dom', (function (t, e, i, s, r) { const o = new n(this.scene, t, e, i, s, r); return this.displayList.add(o), this.updateList.add(o), o; }));
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(208); i(5).register('dynamicBitmapText', (function (t, e, i, s, r) { return this.displayList.add(new n(this.scene, t, e, i, s, r)); }));
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(429); i(5).register('extern', (function () { const t = new n(this.scene); return this.displayList.add(t), this.updateList.add(t), t; }));
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(209); i(5).register('graphics', (function (t) { return this.displayList.add(new n(this.scene, t)); }));
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(110); i(5).register('group', (function (t, e) { return this.updateList.add(new n(this.scene, t, e)); }));
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(112); i(5).register('image', (function (t, e, i, s) { return this.displayList.add(new n(this.scene, t, e, i, s)); }));
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(5); const s = i(212); n.register('particles', (function (t, e, i) { const n = new s(this.scene, t, e, i); return this.displayList.add(n), this.updateList.add(n), n; }));
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(5); const s = i(441); n.register('follower', (function (t, e, i, n, r) { const o = new s(this.scene, t, e, i, n, r); return this.displayList.add(o), this.updateList.add(o), o; }));
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(5); const s = i(213); n.register('renderTexture', (function (t, e, i, n, r, o) { return this.displayList.add(new s(this.scene, t, e, i, n, r, o)); }));
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(215); i(5).register('rope', (function (t, e, i, s, r, o, a, h) { const l = new n(this.scene, t, e, i, s, r, o, a, h); return this.displayList.add(l), this.updateList.add(l); }));
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(5); const s = i(66); n.register('sprite', (function (t, e, i, n) { const r = new s(this.scene, t, e, i, n); return this.displayList.add(r), this.updateList.add(r), r; }));
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(143); i(5).register('bitmapText', (function (t, e, i, s, r, o) { return this.displayList.add(new n(this.scene, t, e, i, s, r, o)); }));
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(216); i(5).register('text', (function (t, e, i, s) { return this.displayList.add(new n(this.scene, t, e, i, s)); }));
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(217); i(5).register('tileSprite', (function (t, e, i, s, r, o) { return this.displayList.add(new n(this.scene, t, e, i, s, r, o)); }));
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(120); i(5).register('zone', (function (t, e, i, s) { return this.displayList.add(new n(this.scene, t, e, i, s)); }));
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(218); i(5).register('video', (function (t, e, i) { const s = new n(this.scene, t, e, i); return this.displayList.add(s), this.updateList.add(s), s; }));
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(442); const s = i(5); s.register('arc', (function (t, e, i, s, r, o, a, h) { return this.displayList.add(new n(this.scene, t, e, i, s, r, o, a, h)); })), s.register('circle', (function (t, e, i, s, r) { return this.displayList.add(new n(this.scene, t, e, i, 0, 360, !1, s, r)); }));
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(5); const s = i(443); n.register('curve', (function (t, e, i, n, r) { return this.displayList.add(new s(this.scene, t, e, i, n, r)); }));
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(444); i(5).register('ellipse', (function (t, e, i, s, r, o) { return this.displayList.add(new n(this.scene, t, e, i, s, r, o)); }));
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(5); const s = i(445); n.register('grid', (function (t, e, i, n, r, o, a, h, l, u) { return this.displayList.add(new s(this.scene, t, e, i, n, r, o, a, h, l, u)); }));
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(5); const s = i(446); n.register('isobox', (function (t, e, i, n, r, o, a) { return this.displayList.add(new s(this.scene, t, e, i, n, r, o, a)); }));
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(5); const s = i(447); n.register('isotriangle', (function (t, e, i, n, r, o, a, h) { return this.displayList.add(new s(this.scene, t, e, i, n, r, o, a, h)); }));
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(5); const s = i(448); n.register('line', (function (t, e, i, n, r, o, a, h) { return this.displayList.add(new s(this.scene, t, e, i, n, r, o, a, h)); }));
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(5); const s = i(449); n.register('polygon', (function (t, e, i, n, r) { return this.displayList.add(new s(this.scene, t, e, i, n, r)); }));
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(5); const s = i(454); n.register('rectangle', (function (t, e, i, n, r, o) { return this.displayList.add(new s(this.scene, t, e, i, n, r, o)); }));
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(455); i(5).register('star', (function (t, e, i, s, r, o, a) { return this.displayList.add(new n(this.scene, t, e, i, s, r, o, a)); }));
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(5); const s = i(456); n.register('triangle', (function (t, e, i, n, r, o, a, h, l, u) { return this.displayList.add(new s(this.scene, t, e, i, n, r, o, a, h, l, u)); }));
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(206); const s = i(29); const r = i(17); const o = i(15); r.register('blitter', (function (t, e) { void 0 === t && (t = {}); const i = o(t, 'key', null); const r = o(t, 'frame', null); const a = new n(this.scene, 0, 0, i, r); return void 0 !== e && (t.add = e), s(this.scene, a, t), a; }));
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Felipe Alfonso <@bitnenfer>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(29); const s = i(207); const r = i(17); const o = i(15); r.register('container', (function (t, e) { void 0 === t && (t = {}); const i = o(t, 'x', 0); const r = o(t, 'y', 0); const a = new s(this.scene, i, r); return void 0 !== e && (t.add = e), n(this.scene, a, t), a; }));
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(208); const s = i(29); const r = i(17); const o = i(15); r.register('dynamicBitmapText', (function (t, e) { void 0 === t && (t = {}); const i = o(t, 'font', ''); const r = o(t, 'text', ''); const a = o(t, 'size', !1); const h = new n(this.scene, 0, 0, i, r, a); return void 0 !== e && (t.add = e), s(this.scene, h, t), h; }));
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(17); const s = i(209); n.register('graphics', (function (t, e) { void 0 === t && (t = {}), void 0 !== e && (t.add = e); const i = new s(this.scene, t); return t.add && this.scene.sys.displayList.add(i), i; }));
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(17); const s = i(110); n.register('group', (function (t) { return new s(this.scene, null, t); }));
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(29); const s = i(17); const r = i(15); const o = i(112); s.register('image', (function (t, e) { void 0 === t && (t = {}); const i = r(t, 'key', null); const s = r(t, 'frame', null); const a = new o(this.scene, 0, 0, i, s); return void 0 !== e && (t.add = e), n(this.scene, a, t), a; }));
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(17); const s = i(15); const r = i(2); const o = i(212); n.register('particles', (function (t, e) { void 0 === t && (t = {}); const i = s(t, 'key', null); const n = s(t, 'frame', null); const a = r(t, 'emitters', null); const h = new o(this.scene, i, n, a); return void 0 !== e && (t.add = e), r(t, 'add', !1) && this.displayList.add(h), this.updateList.add(h), h; }));
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(29); const s = i(17); const r = i(15); const o = i(213); s.register('renderTexture', (function (t, e) { void 0 === t && (t = {}); const i = r(t, 'x', 0); const s = r(t, 'y', 0); const a = r(t, 'width', 32); const h = r(t, 'height', 32); const l = r(t, 'key', void 0); const u = r(t, 'frame', void 0); const c = new o(this.scene, i, s, a, h, l, u); return void 0 !== e && (t.add = e), n(this.scene, c, t), c; }));
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(29); const s = i(17); const r = i(15); const o = i(6); const a = i(215); s.register('rope', (function (t, e) { void 0 === t && (t = {}); const i = r(t, 'key', null); const s = r(t, 'frame', null); const h = r(t, 'horizontal', !0); const l = o(t, 'points', void 0); const u = o(t, 'colors', void 0); const c = o(t, 'alphas', void 0); const d = new a(this.scene, 0, 0, i, s, l, h, u, c); return void 0 !== e && (t.add = e), n(this.scene, d, t), d; }));
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(29); const s = i(204); const r = i(17); const o = i(15); const a = i(66); r.register('sprite', (function (t, e) { void 0 === t && (t = {}); const i = o(t, 'key', null); const r = o(t, 'frame', null); const h = new a(this.scene, 0, 0, i, r); return void 0 !== e && (t.add = e), n(this.scene, h, t), s(h, t), h; }));
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(143); const s = i(29); const r = i(17); const o = i(15); const a = i(6); r.register('bitmapText', (function (t, e) { void 0 === t && (t = {}); const i = a(t, 'font', ''); const r = o(t, 'text', ''); const h = o(t, 'size', !1); const l = a(t, 'align', 0); const u = new n(this.scene, 0, 0, i, r, h, l); return void 0 !== e && (t.add = e), s(this.scene, u, t), u; }));
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(29); const s = i(17); const r = i(15); const o = i(216); s.register('text', (function (t, e) { void 0 === t && (t = {}); const i = r(t, 'text', ''); const s = r(t, 'style', null); const a = r(t, 'padding', null); a !== null && (s.padding = a); const h = new o(this.scene, 0, 0, i, s); return void 0 !== e && (t.add = e), n(this.scene, h, t), h.autoRound = r(t, 'autoRound', !0), h.resolution = r(t, 'resolution', 1), h; }));
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(29); const s = i(17); const r = i(15); const o = i(217); s.register('tileSprite', (function (t, e) { void 0 === t && (t = {}); const i = r(t, 'x', 0); const s = r(t, 'y', 0); const a = r(t, 'width', 512); const h = r(t, 'height', 512); const l = r(t, 'key', ''); const u = r(t, 'frame', ''); const c = new o(this.scene, i, s, a, h, l, u); return void 0 !== e && (t.add = e), n(this.scene, c, t), c; }));
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(17); const s = i(15); const r = i(120); n.register('zone', (function (t) { const e = s(t, 'x', 0); const i = s(t, 'y', 0); const n = s(t, 'width', 1); const o = s(t, 'height', n); return new r(this.scene, e, i, n, o); }));
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(29); const s = i(17); const r = i(15); const o = i(218); s.register('video', (function (t, e) { void 0 === t && (t = {}); const i = r(t, 'key', null); const s = new o(this.scene, 0, 0, i); return void 0 !== e && (t.add = e), n(this.scene, s, t), s; }));
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  let n = i(1); let s = i(1); n = i(1108), s = i(1109), t.exports = { renderWebGL: n, renderCanvas: s };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(11); t.exports = function (t, e, i, s, r) { const o = this.pipeline; t.setPipeline(o, e); const a = o._tempMatrix1; const h = o._tempMatrix2; const l = o._tempMatrix3; h.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY), a.copyFrom(s.matrix), r ? (a.multiplyWithOffset(r, -s.scrollX * e.scrollFactorX, -s.scrollY * e.scrollFactorY), h.e = e.x, h.f = e.y, a.multiply(h, l)) : (h.e -= s.scrollX * e.scrollFactorX, h.f -= s.scrollY * e.scrollFactorY, a.multiply(h, l)); const u = e.frame.glTexture; const c = e.vertices; const d = e.uv; const f = e.colors; const p = e.alphas; const g = c.length; const v = Math.floor(0.5 * g); o.vertexCount + v > o.vertexCapacity && o.flush(), o.setTexture2D(u, 0); for (let m = o.vertexViewF32, y = o.vertexViewU32, x = o.vertexCount * o.vertexComponentCount - 1, T = 0, w = e.tintFill, b = 0; b < g; b += 2) { const E = c[b + 0]; const S = c[b + 1]; let A = E * l.a + S * l.c + l.e; let _ = E * l.b + S * l.d + l.f; s.roundPixels && (A = Math.round(A), _ = Math.round(_)), m[++x] = A, m[++x] = _, m[++x] = d[b + 0], m[++x] = d[b + 1], m[++x] = w, y[++x] = n.getTintAppendFloatAlpha(f[T], s.alpha * p[T]), T++; }o.vertexCount += v; };
}, function (t, e) { t.exports = function () {}; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  let n = i(1); let s = i(1); n = i(1111), s = i(1112), t.exports = { renderWebGL: n, renderCanvas: s };
}, function (t, e) { t.exports = function (t, e, i, n, s) { if (e.shader) { const r = t.currentPipeline; if (t.clearPipeline(), e.renderToTexture)e.load(), e.flush(); else { const o = e._tempMatrix1; const a = e._tempMatrix2; const h = e._tempMatrix3; a.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY), o.copyFrom(n.matrix), s ? (o.multiplyWithOffset(s, -n.scrollX * e.scrollFactorX, -n.scrollY * e.scrollFactorY), a.e = e.x, a.f = e.y) : (a.e -= n.scrollX * e.scrollFactorX, a.f -= n.scrollY * e.scrollFactorY), o.multiply(a, h), t.width === e._rendererWidth && t.height === e._rendererHeight || e.projOrtho(0, t.width, t.height, 0), e.load(h.matrix), e.flush(); }t.rebindPipeline(r); } }; }, function (t, e) { t.exports = function () {}; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(144); i(5).register('mesh', (function (t, e, i, s, r, o, a, h) { return this.displayList.add(new n(this.scene, t, e, i, s, r, o, a, h)); }));
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(221); i(5).register('quad', (function (t, e, i, s) { return this.displayList.add(new n(this.scene, t, e, i, s)); }));
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(222); i(5).register('shader', (function (t, e, i, s, r, o, a) { return this.displayList.add(new n(this.scene, t, e, i, s, r, o, a)); }));
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(29); const s = i(17); const r = i(15); const o = i(6); const a = i(144); s.register('mesh', (function (t, e) { void 0 === t && (t = {}); const i = r(t, 'key', null); const s = r(t, 'frame', null); const h = o(t, 'vertices', []); const l = o(t, 'colors', []); const u = o(t, 'alphas', []); const c = o(t, 'uv', []); const d = new a(this.scene, 0, 0, h, c, l, u, i, s); return void 0 !== e && (t.add = e), n(this.scene, d, t), d; }));
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(29); const s = i(17); const r = i(15); const o = i(221); s.register('quad', (function (t, e) { void 0 === t && (t = {}); const i = r(t, 'x', 0); const s = r(t, 'y', 0); const a = r(t, 'key', null); const h = r(t, 'frame', null); const l = new o(this.scene, i, s, a, h); return void 0 !== e && (t.add = e), n(this.scene, l, t), l; }));
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(29); const s = i(17); const r = i(15); const o = i(222); s.register('shader', (function (t, e) { void 0 === t && (t = {}); const i = r(t, 'key', null); const s = r(t, 'x', 0); const a = r(t, 'y', 0); const h = r(t, 'width', 128); const l = r(t, 'height', 128); const u = new o(this.scene, i, s, a, h, l); return void 0 !== e && (t.add = e), n(this.scene, u, t), u; }));
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(461); const r = i(23); const o = i(24); const a = new n({
    Extends: s, initialize(t) { this.scene = t, this.systems = t.sys, t.sys.settings.isBooted || t.sys.events.once(o.BOOT, this.boot, this), s.call(this); }, boot() { const t = this.systems.events; t.on(o.SHUTDOWN, this.shutdown, this), t.on(o.DESTROY, this.destroy, this); }, destroy() { this.shutdown(), this.scene = void 0, this.systems = void 0; },
  }); r.register('LightsPlugin', a, 'lights'), t.exports = a;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(72); n.Area = i(1121), n.Circumference = i(291), n.CircumferencePoint = i(163), n.Clone = i(1122), n.Contains = i(61), n.ContainsPoint = i(1123), n.ContainsRect = i(1124), n.CopyFrom = i(1125), n.Equals = i(1126), n.GetBounds = i(1127), n.GetPoint = i(289), n.GetPoints = i(290), n.Offset = i(1128), n.OffsetPoint = i(1129), n.Random = i(164), t.exports = n;
}, function (t, e) { t.exports = function (t) { return t.radius > 0 ? Math.PI * t.radius * t.radius : 0; }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(72); t.exports = function (t) { return new n(t.x, t.y, t.radius); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(61); t.exports = function (t, e) { return n(t, e.x, e.y); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(61); t.exports = function (t, e) { return n(t, e.x, e.y) && n(t, e.right, e.y) && n(t, e.x, e.bottom) && n(t, e.right, e.bottom); };
}, function (t, e) { t.exports = function (t, e) { return e.setTo(t.x, t.y, t.radius); }; }, function (t, e) { t.exports = function (t, e) { return t.x === e.x && t.y === e.y && t.radius === e.radius; }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(12); t.exports = function (t, e) { return void 0 === e && (e = new n()), e.x = t.left, e.y = t.top, e.width = t.diameter, e.height = t.diameter, e; };
}, function (t, e) { t.exports = function (t, e, i) { return t.x += e, t.y += i, t; }; }, function (t, e) { t.exports = function (t, e) { return t.x += e.x, t.y += e.y, t; }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(108); n.Area = i(1131), n.Circumference = i(432), n.CircumferencePoint = i(211), n.Clone = i(1132), n.Contains = i(109), n.ContainsPoint = i(1133), n.ContainsRect = i(1134), n.CopyFrom = i(1135), n.Equals = i(1136), n.GetBounds = i(1137), n.GetPoint = i(430), n.GetPoints = i(431), n.Offset = i(1138), n.OffsetPoint = i(1139), n.Random = i(172), t.exports = n;
}, function (t, e) { t.exports = function (t) { return t.isEmpty() ? 0 : t.getMajorRadius() * t.getMinorRadius() * Math.PI; }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(108); t.exports = function (t) { return new n(t.x, t.y, t.width, t.height); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(109); t.exports = function (t, e) { return n(t, e.x, e.y); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(109); t.exports = function (t, e) { return n(t, e.x, e.y) && n(t, e.right, e.y) && n(t, e.x, e.bottom) && n(t, e.right, e.bottom); };
}, function (t, e) { t.exports = function (t, e) { return e.setTo(t.x, t.y, t.width, t.height); }; }, function (t, e) { t.exports = function (t, e) { return t.x === e.x && t.y === e.y && t.width === e.width && t.height === e.height; }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(12); t.exports = function (t, e) { return void 0 === e && (e = new n()), e.x = t.left, e.y = t.top, e.width = t.width, e.height = t.height, e; };
}, function (t, e) { t.exports = function (t, e, i) { return t.x += e, t.y += i, t; }; }, function (t, e) { t.exports = function (t, e) { return t.x += e.x, t.y += e.y, t; }; }, function (t, e, i) {
/**
 * @author       Florian Vazelle
 * @author       Geoffrey Glaive
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(4); const s = i(223); t.exports = function (t, e, i) { if (void 0 === i && (i = []), s(t, e)) { let r; let o; let a; let h; const l = t.x; const u = t.y; const c = t.radius; const d = e.x; const f = e.y; const p = e.radius; if (u === f)(a = (o = -2 * f) * o - 4 * (r = 1) * (d * d + (h = (p * p - c * c - d * d + l * l) / (2 * (l - d))) * h - 2 * d * h + f * f - p * p)) === 0 ? i.push(new n(h, -o / (2 * r))) : a > 0 && (i.push(new n(h, (-o + Math.sqrt(a)) / (2 * r))), i.push(new n(h, (-o - Math.sqrt(a)) / (2 * r)))); else { const g = (l - d) / (u - f); const v = (p * p - c * c - d * d + l * l - f * f + u * u) / (2 * (u - f)); (a = (o = 2 * u * g - 2 * v * g - 2 * l) * o - 4 * (r = g * g + 1) * (l * l + u * u + v * v - c * c - 2 * u * v)) === 0 ? (h = -o / (2 * r), i.push(new n(h, v - h * g))) : a > 0 && (h = (-o + Math.sqrt(a)) / (2 * r), i.push(new n(h, v - h * g)), h = (-o - Math.sqrt(a)) / (2 * r), i.push(new n(h, v - h * g))); } } return i; };
}, function (t, e, i) {
/**
 * @author       Florian Vazelle
 * @author       Geoffrey Glaive
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(225); const s = i(224); t.exports = function (t, e, i) { if (void 0 === i && (i = []), s(t, e)) { const r = e.getLineA(); const o = e.getLineB(); const a = e.getLineC(); const h = e.getLineD(); n(r, t, i), n(o, t, i), n(a, t, i), n(h, t, i); } return i; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(12); const s = i(145); t.exports = function (t, e, i) { return void 0 === i && (i = new n()), s(t, e) && (i.x = Math.max(t.x, e.x), i.y = Math.max(t.y, e.y), i.width = Math.min(t.right, e.right) - i.x, i.height = Math.min(t.bottom, e.bottom) - i.y), i; };
}, function (t, e, i) {
/**
 * @author       Florian Vazelle
 * @author       Geoffrey Glaive
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(227); const s = i(145); t.exports = function (t, e, i) { if (void 0 === i && (i = []), s(t, e)) { const r = t.getLineA(); const o = t.getLineB(); const a = t.getLineC(); const h = t.getLineD(); n(r, e, i), n(o, e, i), n(a, e, i), n(h, e, i); } return i; };
}, function (t, e, i) {
/**
 * @author       Florian Vazelle
 * @author       Geoffrey Glaive
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(465); const s = i(227); t.exports = function (t, e, i) { if (void 0 === i && (i = []), n(t, e)) { const r = e.getLineA(); const o = e.getLineB(); const a = e.getLineC(); s(r, t, i), s(o, t, i), s(a, t, i); } return i; };
}, function (t, e, i) {
/**
 * @author       Florian Vazelle
 * @author       Geoffrey Glaive
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(225); const s = i(467); t.exports = function (t, e, i) { if (void 0 === i && (i = []), s(t, e)) { const r = t.getLineA(); const o = t.getLineB(); const a = t.getLineC(); n(r, e, i), n(o, e, i), n(a, e, i); } return i; };
}, function (t, e, i) {
/**
 * @author       Florian Vazelle
 * @author       Geoffrey Glaive
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(470); const s = i(468); t.exports = function (t, e, i) { if (void 0 === i && (i = []), n(t, e)) { const r = e.getLineA(); const o = e.getLineB(); const a = e.getLineC(); s(t, r, i), s(t, o, i), s(t, a, i); } return i; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(472); t.exports = function (t, e) { if (!n(t, e)) return !1; const i = Math.min(e.x1, e.x2); const s = Math.max(e.x1, e.x2); const r = Math.min(e.y1, e.y2); const o = Math.max(e.y1, e.y2); return t.x >= i && t.x <= s && t.y >= r && t.y <= o; };
}, function (t, e) { t.exports = function (t, e, i, n, s, r) { return void 0 === r && (r = 0), !(e > t.right + r || i < t.left - r || n > t.bottom + r || s < t.top - r); }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(62); n.Angle = i(93), n.BresenhamPoints = i(312), n.CenterOn = i(1150), n.Clone = i(1151), n.CopyFrom = i(1152), n.Equals = i(1153), n.Extend = i(1154), n.GetEasedPoints = i(1155), n.GetMidPoint = i(1156), n.GetNearestPoint = i(1157), n.GetNormal = i(1158), n.GetPoint = i(299), n.GetPoints = i(167), n.GetShortestDistance = i(1159), n.Height = i(1160), n.Length = i(63), n.NormalAngle = i(473), n.NormalX = i(1161), n.NormalY = i(1162), n.Offset = i(1163), n.PerpSlope = i(1164), n.Random = i(168), n.ReflectAngle = i(1165), n.Rotate = i(1166), n.RotateAroundPoint = i(1167), n.RotateAroundXY = i(229), n.SetToAngle = i(1168), n.Slope = i(1169), n.Width = i(1170), t.exports = n;
}, function (t, e) { t.exports = function (t, e, i) { const n = e - (t.x1 + t.x2) / 2; const s = i - (t.y1 + t.y2) / 2; return t.x1 += n, t.y1 += s, t.x2 += n, t.y2 += s, t; }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(62); t.exports = function (t) { return new n(t.x1, t.y1, t.x2, t.y2); };
}, function (t, e) { t.exports = function (t, e) { return e.setTo(t.x1, t.y1, t.x2, t.y2); }; }, function (t, e) { t.exports = function (t, e) { return t.x1 === e.x1 && t.y1 === e.y1 && t.x2 === e.x2 && t.y2 === e.y2; }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(63); t.exports = function (t, e, i) { void 0 === i && (i = e); const s = n(t); const r = t.x2 - t.x1; const o = t.y2 - t.y1; return e && (t.x1 -= r / s * e, t.y1 -= o / s * e), i && (t.x2 += r / s * i, t.y2 += o / s * i), t; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(343); const s = i(76); const r = i(4); t.exports = function (t, e, i, o, a) { void 0 === o && (o = 0), void 0 === a && (a = []); let h; let l; const u = []; const c = t.x1; const d = t.y1; const f = t.x2 - c; const p = t.y2 - d; const g = s(e, a); const v = i - 1; for (h = 0; h < v; h++)l = g(h / v), u.push(new r(c + f * l, d + p * l)); if (l = g(1), u.push(new r(c + f * l, d + p * l)), o > 0) { let m = u[0]; const y = [m]; for (h = 1; h < u.length - 1; h++) { const x = u[h]; n(m, x) >= o && (y.push(x), m = x); } const T = u[u.length - 1]; return n(m, T) < o && y.pop(), y.push(T), y; } return u; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(4); t.exports = function (t, e) { return void 0 === e && (e = new n()), e.x = (t.x1 + t.x2) / 2, e.y = (t.y1 + t.y2) / 2, e; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Florian Mertens
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(4); t.exports = function (t, e, i) { void 0 === i && (i = new n()); const s = t.x1; const r = t.y1; const o = t.x2; const a = t.y2; const h = (o - s) * (o - s) + (a - r) * (a - r); if (h === 0) return i; const l = ((e.x - s) * (o - s) + (e.y - r) * (a - r)) / h; return i.x = s + l * (o - s), i.y = r + l * (a - r), i; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(16); const s = i(93); const r = i(4); t.exports = function (t, e) { void 0 === e && (e = new r()); const i = s(t) - n.TAU; return e.x = Math.cos(i), e.y = Math.sin(i), e; };
}, function (t, e) { t.exports = function (t, e) { const i = t.x1; const n = t.y1; const s = t.x2; const r = t.y2; const o = (s - i) * (s - i) + (r - n) * (r - n); if (o === 0) return !1; const a = ((n - e.y) * (s - i) - (i - e.x) * (r - n)) / o; return Math.abs(a) * Math.sqrt(o); }; }, function (t, e) { t.exports = function (t) { return Math.abs(t.y1 - t.y2); }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(16); const s = i(93); t.exports = function (t) { return Math.cos(s(t) - n.TAU); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(16); const s = i(93); t.exports = function (t) { return Math.sin(s(t) - n.TAU); };
}, function (t, e) { t.exports = function (t, e, i) { return t.x1 += e, t.y1 += i, t.x2 += e, t.y2 += i, t; }; }, function (t, e) { t.exports = function (t) { return -(t.x2 - t.x1) / (t.y2 - t.y1); }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(93); const s = i(473); t.exports = function (t, e) { return 2 * s(e) - Math.PI - n(t); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(229); t.exports = function (t, e) { const i = (t.x1 + t.x2) / 2; const s = (t.y1 + t.y2) / 2; return n(t, i, s, e); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(229); t.exports = function (t, e, i) { return n(t, e.x, e.y, i); };
}, function (t, e) { t.exports = function (t, e, i, n, s) { return t.x1 = e, t.y1 = i, t.x2 = e + Math.cos(n) * s, t.y2 = i + Math.sin(n) * s, t; }; }, function (t, e) { t.exports = function (t) { return (t.y2 - t.y1) / (t.x2 - t.x1); }; }, function (t, e) { t.exports = function (t) { return Math.abs(t.x1 - t.x2); }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(4); n.Ceil = i(1172), n.Clone = i(1173), n.CopyFrom = i(1174), n.Equals = i(1175), n.Floor = i(1176), n.GetCentroid = i(1177), n.GetMagnitude = i(474), n.GetMagnitudeSq = i(475), n.GetRectangleFromPoints = i(1178), n.Interpolate = i(1179), n.Invert = i(1180), n.Negative = i(1181), n.Project = i(1182), n.ProjectUnit = i(1183), n.SetMagnitude = i(1184), t.exports = n;
}, function (t, e) { t.exports = function (t) { return t.setTo(Math.ceil(t.x), Math.ceil(t.y)); }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(4); t.exports = function (t) { return new n(t.x, t.y); };
}, function (t, e) { t.exports = function (t, e) { return e.setTo(t.x, t.y); }; }, function (t, e) { t.exports = function (t, e) { return t.x === e.x && t.y === e.y; }; }, function (t, e) { t.exports = function (t) { return t.setTo(Math.floor(t.x), Math.floor(t.y)); }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(4); t.exports = function (t, e) { if (void 0 === e && (e = new n()), !Array.isArray(t)) throw new Error('GetCentroid points argument must be an array'); const i = t.length; if (i < 1) throw new Error('GetCentroid points array must not be empty'); if (i === 1)e.x = t[0].x, e.y = t[0].y; else { for (let s = 0; s < i; s++)e.x += t[s].x, e.y += t[s].y; e.x /= i, e.y /= i; } return e; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(12); t.exports = function (t, e) { void 0 === e && (e = new n()); for (var i = Number.NEGATIVE_INFINITY, s = Number.POSITIVE_INFINITY, r = Number.NEGATIVE_INFINITY, o = Number.POSITIVE_INFINITY, a = 0; a < t.length; a++) { const h = t[a]; h.x > i && (i = h.x), h.x < s && (s = h.x), h.y > r && (r = h.y), h.y < o && (o = h.y); } return e.x = s, e.y = o, e.width = i - s, e.height = r - o, e; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(4); t.exports = function (t, e, i, s) { return void 0 === i && (i = 0), void 0 === s && (s = new n()), s.x = t.x + (e.x - t.x) * i, s.y = t.y + (e.y - t.y) * i, s; };
}, function (t, e) { t.exports = function (t) { return t.setTo(t.y, t.x); }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(4); t.exports = function (t, e) { return void 0 === e && (e = new n()), e.setTo(-t.x, -t.y); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(4); const s = i(475); t.exports = function (t, e, i) { void 0 === i && (i = new n()); const r = (t.x * e.x + t.y * e.y) / s(e); return r !== 0 && (i.x = r * e.x, i.y = r * e.y), i; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(4); t.exports = function (t, e, i) { void 0 === i && (i = new n()); const s = t.x * e.x + t.y * e.y; return s !== 0 && (i.x = s * e.x, i.y = s * e.y), i; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(474); t.exports = function (t, e) { if (t.x !== 0 || t.y !== 0) { const i = n(t); t.x /= i, t.y /= i; } return t.x *= e, t.y *= e, t; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(219); n.Clone = i(1186), n.Contains = i(220), n.ContainsPoint = i(1187), n.GetAABB = i(450), n.GetNumberArray = i(1188), n.GetPoints = i(451), n.Perimeter = i(452), n.Reverse = i(1189), n.Smooth = i(453), t.exports = n;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(219); t.exports = function (t) { return new n(t.points); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(220); t.exports = function (t, e) { return n(t, e.x, e.y); };
}, function (t, e) { t.exports = function (t, e) { void 0 === e && (e = []); for (let i = 0; i < t.points.length; i++)e.push(t.points[i].x), e.push(t.points[i].y); return e; }; }, function (t, e) { t.exports = function (t) { return t.points.reverse(), t; }; }, function (t, e) { t.exports = function (t) { return t.width * t.height; }; }, function (t, e) { t.exports = function (t) { return t.x = Math.ceil(t.x), t.y = Math.ceil(t.y), t; }; }, function (t, e) { t.exports = function (t) { return t.x = Math.ceil(t.x), t.y = Math.ceil(t.y), t.width = Math.ceil(t.width), t.height = Math.ceil(t.height), t; }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(12); t.exports = function (t) { return new n(t.x, t.y, t.width, t.height); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(55); t.exports = function (t, e) { return n(t, e.x, e.y); };
}, function (t, e) { t.exports = function (t, e) { return e.setTo(t.x, t.y, t.width, t.height); }; }, function (t, e) { t.exports = function (t, e) { return t.x === e.x && t.y === e.y && t.width === e.width && t.height === e.height; }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(230); t.exports = function (t, e) { const i = n(t); return i < n(e) ? t.setSize(e.height * i, e.height) : t.setSize(e.width, e.width / i), t.setPosition(e.centerX - t.width / 2, e.centerY - t.height / 2); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(230); t.exports = function (t, e) { const i = n(t); return i > n(e) ? t.setSize(e.height * i, e.height) : t.setSize(e.width, e.width / i), t.setPosition(e.centerX - t.width / 2, e.centerY - t.height / 2); };
}, function (t, e) { t.exports = function (t) { return t.x = Math.floor(t.x), t.y = Math.floor(t.y), t; }; }, function (t, e) { t.exports = function (t) { return t.x = Math.floor(t.x), t.y = Math.floor(t.y), t.width = Math.floor(t.width), t.height = Math.floor(t.height), t; }; }, function (t, e, i) {
/**
 * @author       samme
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(12); t.exports = function (t, e, i, s, r) { return void 0 === r && (r = new n()), r.setTo(Math.min(t, i), Math.min(e, s), Math.abs(t - i), Math.abs(e - s)); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(4); t.exports = function (t, e) { return void 0 === e && (e = new n()), e.x = t.centerX, e.y = t.centerY, e; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(4); t.exports = function (t, e) { return void 0 === e && (e = new n()), e.x = t.width, e.y = t.height, e; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(183); t.exports = function (t, e, i) { const s = t.centerX; const r = t.centerY; return t.setSize(t.width + 2 * e, t.height + 2 * i), n(t, s, r); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(12); const s = i(145); t.exports = function (t, e, i) { return void 0 === i && (i = new n()), s(t, e) ? (i.x = Math.max(t.x, e.x), i.y = Math.max(t.y, e.y), i.width = Math.min(t.right, e.right) - i.x, i.height = Math.min(t.bottom, e.bottom) - i.y) : i.setEmpty(), i; };
}, function (t, e) { t.exports = function (t, e) { for (var i = t.x, n = t.right, s = t.y, r = t.bottom, o = 0; o < e.length; o++)i = Math.min(i, e[o].x), n = Math.max(n, e[o].x), s = Math.min(s, e[o].y), r = Math.max(r, e[o].y); return t.x = i, t.y = s, t.width = n - i, t.height = r - s, t; }; }, function (t, e) { t.exports = function (t, e) { const i = Math.min(t.x, e.x); const n = Math.max(t.right, e.right); t.x = i, t.width = n - i; const s = Math.min(t.y, e.y); const r = Math.max(t.bottom, e.bottom); return t.y = s, t.height = r - s, t; }; }, function (t, e) { t.exports = function (t, e, i) { const n = Math.min(t.x, e); const s = Math.max(t.right, e); t.x = n, t.width = s - n; const r = Math.min(t.y, i); const o = Math.max(t.bottom, i); return t.y = r, t.height = o - r, t; }; }, function (t, e) { t.exports = function (t, e, i) { return t.x += e, t.y += i, t; }; }, function (t, e) { t.exports = function (t, e) { return t.x += e.x, t.y += e.y, t; }; }, function (t, e) { t.exports = function (t, e) { return t.x < e.right && t.right > e.x && t.y < e.bottom && t.bottom > e.y; }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(4); const s = i(41); t.exports = function (t, e, i) { void 0 === i && (i = new n()), e = s(e); const r = Math.sin(e); const o = Math.cos(e); let a = o > 0 ? t.width / 2 : t.width / -2; let h = r > 0 ? t.height / 2 : t.height / -2; return Math.abs(a * r) < Math.abs(h * o) ? h = a * r / o : a = h * o / r, i.x = a + t.centerX, i.y = h + t.centerY, i; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(187); const s = i(477); const r = i(4); t.exports = function (t, e, i) { if (void 0 === i && (i = new r()), s(t, e)) switch (n(0, 3)) { case 0: i.x = t.x + Math.random() * (e.right - t.x), i.y = t.y + Math.random() * (e.top - t.y); break; case 1: i.x = e.x + Math.random() * (t.right - e.x), i.y = e.bottom + Math.random() * (t.bottom - e.bottom); break; case 2: i.x = t.x + Math.random() * (e.x - t.x), i.y = e.y + Math.random() * (t.bottom - e.y); break; case 3: i.x = e.right + Math.random() * (t.right - e.right), i.y = t.y + Math.random() * (e.bottom - t.y); } return i; };
}, function (t, e) { t.exports = function (t, e) { return t.width === e.width && t.height === e.height; }; }, function (t, e) { t.exports = function (t, e, i) { return void 0 === i && (i = e), t.width *= e, t.height *= i, t; }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(78); n.Area = i(1217), n.BuildEquilateral = i(1218), n.BuildFromPolygon = i(1219), n.BuildRight = i(1220), n.CenterOn = i(1221), n.Centroid = i(478), n.CircumCenter = i(1222), n.CircumCircle = i(1223), n.Clone = i(1224), n.Contains = i(91), n.ContainsArray = i(228), n.ContainsPoint = i(1225), n.CopyFrom = i(1226), n.Decompose = i(471), n.Equals = i(1227), n.GetPoint = i(457), n.GetPoints = i(458), n.InCenter = i(480), n.Perimeter = i(1228), n.Offset = i(479), n.Random = i(173), n.Rotate = i(1229), n.RotateAroundPoint = i(1230), n.RotateAroundXY = i(231), t.exports = n;
}, function (t, e) { t.exports = function (t) { const e = t.x1; const i = t.y1; const n = t.x2; const s = t.y2; const r = t.x3; const o = t.y3; return Math.abs(((r - e) * (s - i) - (n - e) * (o - i)) / 2); }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(78); t.exports = function (t, e, i) { const s = i * (Math.sqrt(3) / 2); return new n(t, e, t + i / 2, e + s, t - i / 2, e + s); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(73); const s = i(78); t.exports = function (t, e, i, r, o) { void 0 === e && (e = null), void 0 === i && (i = 1), void 0 === r && (r = 1), void 0 === o && (o = []); for (var a, h, l, u, c, d, f, p, g, v = n(t, e), m = 0; m < v.length; m += 3)a = v[m], h = v[m + 1], l = v[m + 2], u = t[2 * a] * i, c = t[2 * a + 1] * r, d = t[2 * h] * i, f = t[2 * h + 1] * r, p = t[2 * l] * i, g = t[2 * l + 1] * r, o.push(new s(u, c, d, f, p, g)); return o; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(78); t.exports = function (t, e, i, s) { return void 0 === s && (s = i), new n(t, e, t, e - s, t + i, e); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(478); const s = i(479); t.exports = function (t, e, i, r) { void 0 === r && (r = n); const o = r(t); const a = e - o.x; const h = i - o.y; return s(t, a, h); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(3); function s(t, e, i, n) { return t * n - e * i; }t.exports = function (t, e) { void 0 === e && (e = new n()); const i = t.x3; const r = t.y3; const o = t.x1 - i; const a = t.y1 - r; const h = t.x2 - i; const l = t.y2 - r; const u = 2 * s(o, a, h, l); const c = s(a, o * o + a * a, l, h * h + l * l); const d = s(o, o * o + a * a, h, h * h + l * l); return e.x = i - c / u, e.y = r + d / u, e; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(72); t.exports = function (t, e) { void 0 === e && (e = new n()); let i; let s; const r = t.x1; const o = t.y1; const a = t.x2; const h = t.y2; const l = t.x3; const u = t.y3; const c = a - r; const d = h - o; const f = l - r; const p = u - o; const g = c * (r + a) + d * (o + h); const v = f * (r + l) + p * (o + u); const m = 2 * (c * (u - h) - d * (l - a)); if (Math.abs(m) < 1e-6) { const y = Math.min(r, a, l); const x = Math.min(o, h, u); i = 0.5 * (Math.max(r, a, l) - y), s = 0.5 * (Math.max(o, h, u) - x), e.x = y + i, e.y = x + s, e.radius = Math.sqrt(i * i + s * s); } else e.x = (p * g - d * v) / m, e.y = (c * v - f * g) / m, i = e.x - r, s = e.y - o, e.radius = Math.sqrt(i * i + s * s); return e; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(78); t.exports = function (t) { return new n(t.x1, t.y1, t.x2, t.y2, t.x3, t.y3); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(91); t.exports = function (t, e) { return n(t, e.x, e.y); };
}, function (t, e) { t.exports = function (t, e) { return e.setTo(t.x1, t.y1, t.x2, t.y2, t.x3, t.y3); }; }, function (t, e) { t.exports = function (t, e) { return t.x1 === e.x1 && t.y1 === e.y1 && t.x2 === e.x2 && t.y2 === e.y2 && t.x3 === e.x3 && t.y3 === e.y3; }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(63); t.exports = function (t) { const e = t.getLineA(); const i = t.getLineB(); const s = t.getLineC(); return n(e) + n(i) + n(s); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(231); const s = i(480); t.exports = function (t, e) { const i = s(t); return n(t, i.x, i.y, e); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(231); t.exports = function (t, e, i) { return n(t, e.x, e.y, i); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(196); const s = i(19); let r = {
    CreateInteractiveObject: i(481), Events: i(57), Gamepad: i(1232), InputManager: i(397), InputPlugin: i(1244), InputPluginCache: i(146), Keyboard: i(1246), Mouse: i(1263), Pointer: i(400), Touch: i(1264),
  }; r = s(!1, r, n), t.exports = r;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = {
    Axis: i(482), Button: i(483), Events: i(232), Gamepad: i(484), GamepadPlugin: i(1239), Configs: i(1240),
  };
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'down';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'up';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'connected';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'disconnected';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'down';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'up';
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(10); const r = i(232); const o = i(484); const a = i(6); const h = i(146); const l = i(57); const u = new n({
    Extends: s, initialize(t) { s.call(this), this.scene = t.scene, this.settings = this.scene.sys.settings, this.sceneInputPlugin = t, this.enabled = !0, this.target, this.gamepads = [], this.queue = [], this.onGamepadHandler, this._pad1, this._pad2, this._pad3, this._pad4, t.pluginEvents.once(l.BOOT, this.boot, this), t.pluginEvents.on(l.START, this.start, this); }, boot() { const t = this.scene.sys.game; const e = this.settings.input; const i = t.config; this.enabled = a(e, 'gamepad', i.inputGamepad) && t.device.input.gamepads, this.target = a(e, 'gamepad.target', i.inputGamepadEventTarget), this.sceneInputPlugin.pluginEvents.once(l.DESTROY, this.destroy, this); }, start() { this.enabled && this.startListeners(), this.sceneInputPlugin.pluginEvents.once(l.SHUTDOWN, this.shutdown, this); }, isActive() { return this.enabled && this.scene.sys.isActive(); }, startListeners() { const t = this; const e = this.target; const i = function (e) { !e.defaultPrevented && t.isActive() && (t.refreshPads(), t.queue.push(e)); }; this.onGamepadHandler = i, e.addEventListener('gamepadconnected', i, !1), e.addEventListener('gamepaddisconnected', i, !1), this.sceneInputPlugin.pluginEvents.on(l.UPDATE, this.update, this); }, stopListeners() { this.target.removeEventListener('gamepadconnected', this.onGamepadHandler), this.target.removeEventListener('gamepaddisconnected', this.onGamepadHandler), this.sceneInputPlugin.pluginEvents.off(l.UPDATE, this.update); }, disconnectAll() { for (let t = 0; t < this.gamepads.length; t++) this.gamepads.connected = !1; }, refreshPads() { const t = navigator.getGamepads(); if (t) for (let e = this.gamepads, i = 0; i < t.length; i++) { const n = t[i]; if (n) { const s = n.id; const r = n.index; const a = e[r]; if (a)a.id !== s ? (a.destroy(), e[r] = new o(this, n)) : a.update(n); else { const h = new o(this, n); e[r] = h, this._pad1 ? this._pad2 ? this._pad3 ? this._pad4 || (this._pad4 = h) : this._pad3 = h : this._pad2 = h : this._pad1 = h; } } } else this.disconnectAll(); }, getAll() { for (var t = [], e = this.gamepads, i = 0; i < e.length; i++)e[i] && t.push(e[i]); return t; }, getPad(t) { for (let e = this.gamepads, i = 0; i < e.length; i++) if (e[i] && e[i].index === t) return e[i]; }, update() { if (this.enabled) { this.refreshPads(); const t = this.queue.length; if (t !== 0) for (let e = this.queue.splice(0, t), i = 0; i < t; i++) { const n = e[i]; const s = this.getPad(n.gamepad.index); n.type === 'gamepadconnected' ? this.emit(r.CONNECTED, s, n) : n.type === 'gamepaddisconnected' && this.emit(r.DISCONNECTED, s, n); } } }, shutdown() { this.stopListeners(), this.disconnectAll(), this.removeAllListeners(); }, destroy() { this.shutdown(); for (let t = 0; t < this.gamepads.length; t++) this.gamepads[t] && this.gamepads[t].destroy(); this.gamepads = [], this.scene = null, this.settings = null, this.sceneInputPlugin = null, this.target = null; }, total: { get() { return this.gamepads.length; } }, pad1: { get() { return this._pad1; } }, pad2: { get() { return this._pad2; } }, pad3: { get() { return this._pad3; } }, pad4: { get() { return this._pad4; } },
  }); h.register('GamepadPlugin', u, 'gamepad', 'gamepad', 'inputGamepad'), t.exports = u;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = { DUALSHOCK_4: i(1241), SNES_USB: i(1242), XBOX_360: i(1243) };
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = {
    UP: 12, DOWN: 13, LEFT: 14, RIGHT: 15, SHARE: 8, OPTIONS: 9, PS: 16, TOUCHBAR: 17, X: 0, CIRCLE: 1, SQUARE: 2, TRIANGLE: 3, L1: 4, R1: 5, L2: 6, R2: 7, L3: 10, R3: 11, LEFT_STICK_H: 0, LEFT_STICK_V: 1, RIGHT_STICK_H: 2, RIGHT_STICK_V: 3,
  };
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = {
    UP: 12, DOWN: 13, LEFT: 14, RIGHT: 15, SELECT: 8, START: 9, B: 0, A: 1, Y: 2, X: 3, LEFT_SHOULDER: 4, RIGHT_SHOULDER: 5,
  };
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = {
    UP: 12, DOWN: 13, LEFT: 14, RIGHT: 15, MENU: 16, A: 0, B: 1, X: 2, Y: 3, LB: 4, RB: 5, LT: 6, RT: 7, BACK: 8, START: 9, LS: 10, RS: 11, LEFT_STICK_H: 0, LEFT_STICK_V: 1, RIGHT_STICK_H: 2, RIGHT_STICK_V: 3,
  };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(72); const s = i(61); const r = i(0); const o = i(196); const a = i(481); const h = i(1245); const l = i(56); const u = i(108); const c = i(109); const d = i(57); const f = i(10); const p = i(2); const g = i(54); const v = i(146); const m = i(8); const y = i(23); const x = i(12); const T = i(55); const w = i(24); const b = i(78); const E = i(91); const S = new r({
    Extends: f,
    initialize(t) {
      f.call(this), this.scene = t, this.systems = t.sys, this.settings = t.sys.settings, this.manager = t.sys.game.input, this.pluginEvents = new f(), this.enabled = !0, this.displayList, this.cameras, v.install(this), this.mouse = this.manager.mouse, this.topOnly = !0, this.pollRate = -1, this._pollTimer = 0; const e = { cancelled: !1 }; this._eventContainer = { stopPropagation() { e.cancelled = !0; } }, this._eventData = e, this.dragDistanceThreshold = 0, this.dragTimeThreshold = 0, this._temp = [], this._tempZones = [], this._list = [], this._pendingInsertion = [], this._pendingRemoval = [], this._draggable = [], this._drag = {
        0: [], 1: [], 2: [], 3: [], 4: [], 5: [], 6: [], 7: [], 8: [], 9: [], 10: [],
      }, this._dragState = [], this._over = {
        0: [], 1: [], 2: [], 3: [], 4: [], 5: [], 6: [], 7: [], 8: [], 9: [], 10: [],
      }, this._validTypes = ['onDown', 'onUp', 'onOver', 'onOut', 'onMove', 'onDragStart', 'onDrag', 'onDragEnd', 'onDragEnter', 'onDragLeave', 'onDragOver', 'onDrop'], this._updatedThisFrame = !1, t.sys.events.once(w.BOOT, this.boot, this), t.sys.events.on(w.START, this.start, this);
    },
    boot() { this.cameras = this.systems.cameras, this.displayList = this.systems.displayList, this.systems.events.once(w.DESTROY, this.destroy, this), this.pluginEvents.emit(d.BOOT); },
    start() { const t = this.systems.events; t.on(w.TRANSITION_START, this.transitionIn, this), t.on(w.TRANSITION_OUT, this.transitionOut, this), t.on(w.TRANSITION_COMPLETE, this.transitionComplete, this), t.on(w.PRE_UPDATE, this.preUpdate, this), t.once(w.SHUTDOWN, this.shutdown, this), this.manager.events.on(d.GAME_OUT, this.onGameOut, this), this.manager.events.on(d.GAME_OVER, this.onGameOver, this), this.enabled = !0, this._dragState = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0], this.pluginEvents.emit(d.START); },
    onGameOver(t) { this.isActive() && this.emit(d.GAME_OVER, t.timeStamp, t); },
    onGameOut(t) { this.isActive() && this.emit(d.GAME_OUT, t.timeStamp, t); },
    preUpdate() { this.pluginEvents.emit(d.PRE_UPDATE); const t = this._pendingRemoval; const e = this._pendingInsertion; const i = t.length; const n = e.length; if (i !== 0 || n !== 0) { for (var s = this._list, r = 0; r < i; r++) { const o = t[r]; const a = s.indexOf(o); a > -1 && (s.splice(a, 1), this.clear(o, !0)); }t.length = 0, this._pendingRemoval.length = 0, this._list = s.concat(e.splice(0)); } },
    isActive() { return this.enabled && this.scene.sys.isActive(); },
    updatePoll(t, e) { if (!this.isActive()) return !1; if (this.pluginEvents.emit(d.UPDATE, t, e), this._updatedThisFrame) return this._updatedThisFrame = !1, !1; let i; const n = this.manager; const s = n.pointers; const r = n.pointersTotal; for (i = 0; i < r; i++)s[i].updateMotion(); if (this._list.length === 0) return !1; const o = this.pollRate; if (o === -1) return !1; if (o > 0) { if (this._pollTimer -= e, !(this._pollTimer < 0)) return !1; this._pollTimer = this.pollRate; } let a = !1; for (i = 0; i < r; i++) { let h = 0; const l = s[i]; this._tempZones = [], this._temp = this.hitTestPointer(l), this.sortGameObjects(this._temp), this.sortGameObjects(this._tempZones), this.topOnly && (this._temp.length && this._temp.splice(1), this._tempZones.length && this._tempZones.splice(1)), h += this.processOverOutEvents(l), this.getDragState(l) === 2 && this.processDragThresholdEvent(l, t), h > 0 && (a = !0); } return a; },
    update(t, e) { if (!this.isActive()) return !1; for (var i = e.length, n = !1, s = 0; s < i; s++) { let r = 0; const a = e[s]; switch (this._tempZones = [], this._temp = this.hitTestPointer(a), this.sortGameObjects(this._temp), this.sortGameObjects(this._tempZones), this.topOnly && (this._temp.length && this._temp.splice(1), this._tempZones.length && this._tempZones.splice(1)), t) { case o.MOUSE_DOWN: r += this.processDragDownEvent(a), r += this.processDownEvents(a), r += this.processOverOutEvents(a); break; case o.MOUSE_UP: r += this.processDragUpEvent(a), r += this.processUpEvents(a), r += this.processOverOutEvents(a); break; case o.TOUCH_START: r += this.processDragDownEvent(a), r += this.processDownEvents(a), r += this.processOverEvents(a); break; case o.TOUCH_END: case o.TOUCH_CANCEL: r += this.processDragUpEvent(a), r += this.processUpEvents(a), r += this.processOutEvents(a); break; case o.MOUSE_MOVE: case o.TOUCH_MOVE: r += this.processDragMoveEvent(a), r += this.processMoveEvents(a), r += this.processOverOutEvents(a); break; case o.MOUSE_WHEEL: r += this.processWheelEvent(a); }r > 0 && (n = !0); } return this._updatedThisFrame = !0, n; },
    clear(t, e) { void 0 === e && (e = !1); const i = t.input; if (i) { e || this.queueForRemoval(t), i.gameObject = void 0, i.target = void 0, i.hitArea = void 0, i.hitAreaCallback = void 0, i.callbackContext = void 0, this.manager.resetCursor(i), t.input = null; let n = this._draggable.indexOf(t); return n > -1 && this._draggable.splice(n, 1), (n = this._drag[0].indexOf(t)) > -1 && this._drag[0].splice(n, 1), (n = this._over[0].indexOf(t)) > -1 && this._over[0].splice(n, 1), t; } },
    disable(t) { t.input.enabled = !1; },
    enable(t, e, i, n) { return void 0 === n && (n = !1), t.input ? t.input.enabled = !0 : this.setHitArea(t, e, i), t.input && n && !t.input.dropZone && (t.input.dropZone = n), this; },
    hitTestPointer(t) { for (var e = this.cameras.getCamerasBelowPointer(t), i = 0; i < e.length; i++) { for (var n = e[i], s = this.manager.hitTest(t, this._list, n), r = 0; r < s.length; r++) { const o = s[r]; o.input.dropZone && this._tempZones.push(o); } if (s.length > 0) return t.camera = n, s; } return t.camera = e[0], []; },
    processDownEvents(t) { let e = 0; const i = this._temp; const n = this._eventData; const s = this._eventContainer; n.cancelled = !1; for (var r = !1, o = 0; o < i.length; o++) { const a = i[o]; if (a.input) { if (e++, a.emit(d.GAMEOBJECT_POINTER_DOWN, t, a.input.localX, a.input.localY, s), n.cancelled || !a.input) { r = !0; break; } if (this.emit(d.GAMEOBJECT_DOWN, t, a, s), n.cancelled || !a.input) { r = !0; break; } } } return !r && this.manager && (t.downElement === this.manager.game.canvas ? this.emit(d.POINTER_DOWN, t, i) : this.emit(d.POINTER_DOWN_OUTSIDE, t)), e; },
    getDragState(t) { return this._dragState[t.id]; },
    setDragState(t, e) { this._dragState[t.id] = e; },
    processDragThresholdEvent(t, e) { let i = !1; const n = this.dragTimeThreshold; const s = this.dragDistanceThreshold; if ((s > 0 && l(t.x, t.y, t.downX, t.downY) >= s || n > 0 && e >= t.downTime + n) && (i = !0), i) return this.setDragState(t, 3), this.processDragStartList(t); },
    processDragStartList(t) { if (this.getDragState(t) !== 3) return 0; for (var e = this._drag[t.id], i = 0; i < e.length; i++) { const n = e[i]; const s = n.input; s.dragState = 2, s.dragStartX = n.x, s.dragStartY = n.y, s.dragStartXGlobal = t.x, s.dragStartYGlobal = t.y, s.dragX = s.dragStartXGlobal - s.dragStartX, s.dragY = s.dragStartYGlobal - s.dragStartY, n.emit(d.GAMEOBJECT_DRAG_START, t, s.dragX, s.dragY), this.emit(d.DRAG_START, t, n); } return this.setDragState(t, 4), e.length; },
    processDragDownEvent(t) { const e = this._temp; if (this._draggable.length === 0 || e.length === 0 || !t.primaryDown || this.getDragState(t) !== 0) return 0; this.setDragState(t, 1); for (var i = [], n = 0; n < e.length; n++) { const s = e[n]; s.input.draggable && s.input.dragState === 0 && i.push(s); } return i.length === 0 ? (this.setDragState(t, 0), 0) : (i.length > 1 && (this.sortGameObjects(i), this.topOnly && i.splice(1)), this._drag[t.id] = i, this.dragDistanceThreshold === 0 && this.dragTimeThreshold === 0 ? (this.setDragState(t, 3), this.processDragStartList(t)) : (this.setDragState(t, 2), 0)); },
    processDragMoveEvent(t) { if (this.getDragState(t) === 2 && this.processDragThresholdEvent(t, this.manager.game.loop.now), this.getDragState(t) !== 4) return 0; for (var e = this._tempZones, i = this._drag[t.id], n = 0; n < i.length; n++) { var s; var r; const o = i[n]; const a = o.input; let h = a.target; if (h) { const l = e.indexOf(h); l === 0 ? (o.emit(d.GAMEOBJECT_DRAG_OVER, t, h), this.emit(d.DRAG_OVER, t, o, h)) : l > 0 ? (o.emit(d.GAMEOBJECT_DRAG_LEAVE, t, h), this.emit(d.DRAG_LEAVE, t, o, h), a.target = e[0], h = a.target, o.emit(d.GAMEOBJECT_DRAG_ENTER, t, h), this.emit(d.DRAG_ENTER, t, o, h)) : (o.emit(d.GAMEOBJECT_DRAG_LEAVE, t, h), this.emit(d.DRAG_LEAVE, t, o, h), e[0] ? (a.target = e[0], h = a.target, o.emit(d.GAMEOBJECT_DRAG_ENTER, t, h), this.emit(d.DRAG_ENTER, t, o, h)) : a.target = null); } else !h && e[0] && (a.target = e[0], h = a.target, o.emit(d.GAMEOBJECT_DRAG_ENTER, t, h), this.emit(d.DRAG_ENTER, t, o, h)); if (o.parentContainer) { const u = t.x - a.dragStartXGlobal; const c = t.y - a.dragStartYGlobal; const f = o.getParentRotation(); let p = u * Math.cos(f) + c * Math.sin(f); let g = c * Math.cos(f) - u * Math.sin(f); p *= 1 / o.parentContainer.scaleX, g *= 1 / o.parentContainer.scaleY, s = p + a.dragStartX, r = g + a.dragStartY; } else s = t.x - a.dragX, r = t.y - a.dragY; o.emit(d.GAMEOBJECT_DRAG, t, s, r), this.emit(d.DRAG, t, o, s, r); } return i.length; },
    processDragUpEvent(t) { for (var e = this._drag[t.id], i = 0; i < e.length; i++) { const n = e[i]; const s = n.input; if (s && s.dragState === 2) { s.dragState = 0, s.dragX = s.localX - n.displayOriginX, s.dragY = s.localY - n.displayOriginY; let r = !1; const o = s.target; o && (n.emit(d.GAMEOBJECT_DROP, t, o), this.emit(d.DROP, t, n, o), s.target = null, r = !0), n.input && (n.emit(d.GAMEOBJECT_DRAG_END, t, s.dragX, s.dragY, r), this.emit(d.DRAG_END, t, n, r)); } } return this.setDragState(t, 0), e.splice(0), 0; },
    processMoveEvents(t) { let e = 0; const i = this._temp; const n = this._eventData; const s = this._eventContainer; n.cancelled = !1; for (var r = !1, o = 0; o < i.length; o++) { const a = i[o]; if (a.input) { if (e++, a.emit(d.GAMEOBJECT_POINTER_MOVE, t, a.input.localX, a.input.localY, s), n.cancelled || !a.input) { r = !0; break; } if (this.emit(d.GAMEOBJECT_MOVE, t, a, s), n.cancelled || !a.input) { r = !0; break; } if (this.topOnly) break; } } return r || this.emit(d.POINTER_MOVE, t, i), e; },
    processWheelEvent(t) { let e = 0; const i = this._temp; const n = this._eventData; const s = this._eventContainer; n.cancelled = !1; for (var r = !1, o = t.deltaX, a = t.deltaY, h = t.deltaZ, l = 0; l < i.length; l++) { const u = i[l]; if (u.input) { if (e++, u.emit(d.GAMEOBJECT_POINTER_WHEEL, t, o, a, h, s), n.cancelled || !u.input) { r = !0; break; } if (this.emit(d.GAMEOBJECT_WHEEL, t, u, o, a, h, s), n.cancelled || !u.input) { r = !0; break; } } } return r || this.emit(d.POINTER_WHEEL, t, i, o, a, h), e; },
    processOverEvents(t) { const e = this._temp; let i = 0; const n = e.length; const s = []; if (n > 0) { const r = this.manager; const o = this._eventData; const a = this._eventContainer; o.cancelled = !1; for (var h = !1, l = 0; l < n; l++) { const u = e[l]; if (u.input) { if (s.push(u), r.setCursor(u.input), u.emit(d.GAMEOBJECT_POINTER_OVER, t, u.input.localX, u.input.localY, a), i++, o.cancelled || !u.input) { h = !0; break; } if (this.emit(d.GAMEOBJECT_OVER, t, u, a), o.cancelled || !u.input) { h = !0; break; } } }h || this.emit(d.POINTER_OVER, t, s); } return this._over[t.id] = s, i; },
    processOutEvents(t) { const e = this._over[t.id]; let i = 0; const n = e.length; if (n > 0) { const s = this.manager; const r = this._eventData; const o = this._eventContainer; r.cancelled = !1; let a = !1; this.sortGameObjects(e); for (let h = 0; h < n; h++) { let l = e[h]; for (h = 0; h < n; h++) if ((l = e[h]).input) { if (s.resetCursor(l.input), l.emit(d.GAMEOBJECT_POINTER_OUT, t, o), i++, r.cancelled || !l.input) { a = !0; break; } if (this.emit(d.GAMEOBJECT_OUT, t, l, o), r.cancelled || !l.input) { a = !0; break; } }a || this.emit(d.POINTER_OUT, t, e); } this._over[t.id] = []; } return i; },
    processOverOutEvents(t) { let e; let i; const n = this._temp; const s = []; const r = []; const o = []; let a = this._over[t.id]; const h = this._drag[t.id]; const l = this.manager; for (e = 0; e < a.length; e++)i = a[e], n.indexOf(i) === -1 && h.indexOf(i) === -1 ? s.push(i) : o.push(i); for (e = 0; e < n.length; e++)i = n[e], a.indexOf(i) === -1 && r.push(i); let u = s.length; let c = 0; const f = this._eventData; const p = this._eventContainer; f.cancelled = !1; let g = !1; if (u > 0) { for (this.sortGameObjects(s), e = 0; e < u; e++) if ((i = s[e]).input) { if (l.resetCursor(i.input), i.emit(d.GAMEOBJECT_POINTER_OUT, t, p), c++, f.cancelled || !i.input) { g = !0; break; } if (this.emit(d.GAMEOBJECT_OUT, t, i, p), f.cancelled || !i.input) { g = !0; break; } }g || this.emit(d.POINTER_OUT, t, s); } if (u = r.length, f.cancelled = !1, g = !1, u > 0) { for (this.sortGameObjects(r), e = 0; e < u; e++) if ((i = r[e]).input) { if (l.setCursor(i.input), i.emit(d.GAMEOBJECT_POINTER_OVER, t, i.input.localX, i.input.localY, p), c++, f.cancelled || !i.input) { g = !0; break; } if (this.emit(d.GAMEOBJECT_OVER, t, i, p), f.cancelled || !i.input) { g = !0; break; } }g || this.emit(d.POINTER_OVER, t, r); } return a = o.concat(r), this._over[t.id] = this.sortGameObjects(a), c; },
    processUpEvents(t) { const e = this._temp; const i = this._eventData; const n = this._eventContainer; i.cancelled = !1; for (var s = !1, r = 0; r < e.length; r++) { const o = e[r]; if (o.input) { if (o.emit(d.GAMEOBJECT_POINTER_UP, t, o.input.localX, o.input.localY, n), i.cancelled || !o.input) { s = !0; break; } if (this.emit(d.GAMEOBJECT_UP, t, o, n), i.cancelled || !o.input) { s = !0; break; } } } return !s && this.manager && (t.upElement === this.manager.game.canvas ? this.emit(d.POINTER_UP, t, e) : this.emit(d.POINTER_UP_OUTSIDE, t)), e.length; },
    queueForInsertion(t) { return this._pendingInsertion.indexOf(t) === -1 && this._list.indexOf(t) === -1 && this._pendingInsertion.push(t), this; },
    queueForRemoval(t) { return this._pendingRemoval.push(t), this; },
    setDraggable(t, e) { void 0 === e && (e = !0), Array.isArray(t) || (t = [t]); for (let i = 0; i < t.length; i++) { const n = t[i]; n.input.draggable = e; const s = this._draggable.indexOf(n); e && s === -1 ? this._draggable.push(n) : !e && s > -1 && this._draggable.splice(s, 1); } return this; },
    makePixelPerfect(t) { void 0 === t && (t = 1); const e = this.systems.textures; return h(e, t); },
    setHitArea(t, e, i) { if (void 0 === e) return this.setHitAreaFromTexture(t); Array.isArray(t) || (t = [t]); let n = !1; let s = !1; let r = !1; let o = !1; let h = !1; let l = !0; if (m(e)) { const u = e; e = p(u, 'hitArea', null), i = p(u, 'hitAreaCallback', null), n = p(u, 'draggable', !1), s = p(u, 'dropZone', !1), r = p(u, 'cursor', !1), o = p(u, 'useHandCursor', !1), h = p(u, 'pixelPerfect', !1); const c = p(u, 'alphaTolerance', 1); h && (e = {}, i = this.makePixelPerfect(c)), e && i || (this.setHitAreaFromTexture(t), l = !1); } else typeof e !== 'function' || i || (i = e, e = {}); for (let d = 0; d < t.length; d++) { const f = t[d]; if (h && f.type === 'Container')console.warn('Cannot pixelPerfect test a Container. Use a custom callback.'); else { const g = f.input ? f.input : a(f, e, i); g.customHitArea = l, g.dropZone = s, g.cursor = o ? 'pointer' : r, f.input = g, n && this.setDraggable(f), this.queueForInsertion(f); } } return this; },
    setHitAreaCircle(t, e, i, r, o) { void 0 === o && (o = s); const a = new n(e, i, r); return this.setHitArea(t, a, o); },
    setHitAreaEllipse(t, e, i, n, s, r) { void 0 === r && (r = c); const o = new u(e, i, n, s); return this.setHitArea(t, o, r); },
    setHitAreaFromTexture(t, e) { void 0 === e && (e = T), Array.isArray(t) || (t = [t]); for (let i = 0; i < t.length; i++) { const n = t[i]; const s = n.frame; let r = 0; let o = 0; n.width ? (r = n.width, o = n.height) : s && (r = s.realWidth, o = s.realHeight), n.type !== 'Container' || r !== 0 && o !== 0 ? r !== 0 && o !== 0 && (n.input = a(n, new x(0, 0, r, o), e), this.queueForInsertion(n)) : console.warn('Container.setInteractive must specify a Shape or call setSize() first'); } return this; },
    setHitAreaRectangle(t, e, i, n, s, r) { void 0 === r && (r = T); const o = new x(e, i, n, s); return this.setHitArea(t, o, r); },
    setHitAreaTriangle(t, e, i, n, s, r, o, a) { void 0 === a && (a = E); const h = new b(e, i, n, s, r, o); return this.setHitArea(t, h, a); },
    enableDebug(t, e) { void 0 === e && (e = 65280); const i = t.input; if (!i || !i.hitArea) return this; const n = i.hitArea; const s = n.type; let r = i.hitAreaDebug; const o = this.systems.add; const a = this.systems.updateList; r && (a.remove(r), r.destroy(), r = null); let h = 0; let l = 0; switch (s) { case g.CIRCLE: r = o.arc(0, 0, n.radius), h = n.x - n.radius, l = n.y - n.radius; break; case g.ELLIPSE: r = o.ellipse(0, 0, n.width, n.height), h = n.x - n.width / 2, l = n.y - n.height / 2; break; case g.LINE: r = o.line(0, 0, n.x1, n.y1, n.x2, n.y2); break; case g.POLYGON: r = o.polygon(0, 0, n.points); break; case g.RECTANGLE: r = o.rectangle(0, 0, n.width, n.height), h = n.x, l = n.y; break; case g.TRIANGLE: r = o.triangle(0, 0, n.x1, n.y1, n.x2, n.y2, n.x3, n.y3); } return r && (r.isFilled = !1, r.preUpdate = function () { r.setStrokeStyle(1 / t.scale, e), r.setDisplayOrigin(t.displayOriginX, t.displayOriginY); let i = t.x; let n = t.y; let s = t.rotation; let o = t.scaleX; let a = t.scaleY; if (t.parentContainer) { const u = t.getWorldTransformMatrix(); i = u.tx, n = u.ty, s = u.rotation, o = u.scaleX, a = u.scaleY; }r.setRotation(s), r.setScale(o, a), r.setPosition(i + h, n + l), r.setScrollFactor(t.scrollFactorX, t.scrollFactorY), r.setDepth(t.depth); }, a.add(r), i.hitAreaDebug = r), this; },
    removeDebug(t) { const e = t.input; if (e && e.hitAreaDebug) { const i = e.hitAreaDebug; this.systems.updateList.remove(i), i.destroy(), e.hitAreaDebug = null; } return this; },
    setPollAlways() { return this.setPollRate(0); },
    setPollOnMove() { return this.setPollRate(-1); },
    setPollRate(t) { return this.pollRate = t, this._pollTimer = 0, this; },
    setGlobalTopOnly(t) { return this.manager.globalTopOnly = t, this; },
    setTopOnly(t) { return this.topOnly = t, this; },
    sortGameObjects(t) { return t.length < 2 ? t : (this.scene.sys.depthSort(), t.sort(this.sortHandlerGO.bind(this))); },
    sortHandlerGO(t, e) { if (t.parentContainer || e.parentContainer) { if (t.parentContainer === e.parentContainer) return e.parentContainer.getIndex(e) - t.parentContainer.getIndex(t); if (t.parentContainer === e) return -1; if (e.parentContainer === t) return 1; for (var i = t.getIndexList(), n = e.getIndexList(), s = Math.min(i.length, n.length), r = 0; r < s; r++) { const o = i[r]; const a = n[r]; if (o !== a) return a - o; } return n.length - i.length; } return this.displayList.getIndex(e) - this.displayList.getIndex(t); },
    stopPropagation() { return this.manager._tempSkip = !0, this; },
    addPointer(t) { return this.manager.addPointer(t); },
    setDefaultCursor(t) { return this.manager.setDefaultCursor(t), this; },
    transitionIn() { this.enabled = this.settings.transitionAllowInput; },
    transitionComplete() { this.settings.transitionAllowInput || (this.enabled = !0); },
    transitionOut() { this.enabled = this.settings.transitionAllowInput; },
    shutdown() { this.pluginEvents.emit(d.SHUTDOWN), this._temp.length = 0, this._list.length = 0, this._draggable.length = 0, this._pendingRemoval.length = 0, this._pendingInsertion.length = 0, this._dragState.length = 0; for (let t = 0; t < 10; t++) this._drag[t] = [], this._over[t] = []; this.removeAllListeners(); const e = this.systems.events; e.off(w.TRANSITION_START, this.transitionIn, this), e.off(w.TRANSITION_OUT, this.transitionOut, this), e.off(w.TRANSITION_COMPLETE, this.transitionComplete, this), e.off(w.PRE_UPDATE, this.preUpdate, this), this.manager.events.off(d.GAME_OUT, this.onGameOut, this), this.manager.events.off(d.GAME_OVER, this.onGameOver, this), e.off(w.SHUTDOWN, this.shutdown, this); },
    destroy() { this.shutdown(), this.pluginEvents.emit(d.DESTROY), this.pluginEvents.removeAllListeners(), this.scene.sys.events.off(w.START, this.start, this), this.scene = null, this.cameras = null, this.manager = null, this.events = null, this.mouse = null; },
    x: { get() { return this.manager.activePointer.x; } },
    y: { get() { return this.manager.activePointer.y; } },
    isOver: { get() { return this.manager.isOver; } },
    mousePointer: { get() { return this.manager.mousePointer; } },
    activePointer: { get() { return this.manager.activePointer; } },
    pointer1: { get() { return this.manager.pointers[1]; } },
    pointer2: { get() { return this.manager.pointers[2]; } },
    pointer3: { get() { return this.manager.pointers[3]; } },
    pointer4: { get() { return this.manager.pointers[4]; } },
    pointer5: { get() { return this.manager.pointers[5]; } },
    pointer6: { get() { return this.manager.pointers[6]; } },
    pointer7: { get() { return this.manager.pointers[7]; } },
    pointer8: { get() { return this.manager.pointers[8]; } },
    pointer9: { get() { return this.manager.pointers[9]; } },
    pointer10: { get() { return this.manager.pointers[10]; } },
  }); y.register('InputPlugin', S, 'input'), t.exports = S;
}, function (t, e) { t.exports = function (t, e) { return function (i, n, s, r) { const o = t.getPixelAlpha(n, s, r.texture.key, r.frame.name); return o && o >= e; }; }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = {
    Events: i(147), KeyboardManager: i(398), KeyboardPlugin: i(1254), Key: i(485), KeyCodes: i(136), KeyCombo: i(486), JustDown: i(1259), JustUp: i(1260), DownDuration: i(1261), UpDuration: i(1262),
  };
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'keydown';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'keyup';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'keycombomatch';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'down';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'keydown-';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'keyup-';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'up';
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(10); const r = i(147); const o = i(22); const a = i(6); const h = i(57); const l = i(146); const u = i(485); const c = i(136); const d = i(486); const f = i(1258); const p = i(105); const g = new n({
    Extends: s,
    initialize(t) { s.call(this), this.game = t.systems.game, this.scene = t.scene, this.settings = this.scene.sys.settings, this.sceneInputPlugin = t, this.manager = t.manager.keyboard, this.enabled = !0, this.keys = [], this.combos = [], t.pluginEvents.once(h.BOOT, this.boot, this), t.pluginEvents.on(h.START, this.start, this); },
    boot() { const t = this.settings.input; this.enabled = a(t, 'keyboard', !0); const e = a(t, 'keyboard.capture', null); e && this.addCaptures(e), this.sceneInputPlugin.pluginEvents.once(h.DESTROY, this.destroy, this); },
    start() { this.sceneInputPlugin.manager.useQueue ? this.sceneInputPlugin.pluginEvents.on(h.UPDATE, this.update, this) : this.sceneInputPlugin.manager.events.on(h.MANAGER_PROCESS, this.update, this), this.sceneInputPlugin.pluginEvents.once(h.SHUTDOWN, this.shutdown, this), this.game.events.on(o.BLUR, this.resetKeys, this); },
    isActive() { return this.enabled && this.scene.sys.isActive(); },
    addCapture(t) { return this.manager.addCapture(t), this; },
    removeCapture(t) { return this.manager.removeCapture(t), this; },
    getCaptures() { return this.manager.captures; },
    enableGlobalCapture() { return this.manager.preventDefault = !0, this; },
    disableGlobalCapture() { return this.manager.preventDefault = !1, this; },
    clearCaptures() { return this.manager.clearCaptures(), this; },
    createCursorKeys() {
      return this.addKeys({
        up: c.UP, down: c.DOWN, left: c.LEFT, right: c.RIGHT, space: c.SPACE, shift: c.SHIFT,
      });
    },
    addKeys(t, e, i) { void 0 === e && (e = !0), void 0 === i && (i = !1); const n = {}; if (typeof t === 'string') { t = t.split(','); for (let s = 0; s < t.length; s++) { const r = t[s].trim(); r && (n[r] = this.addKey(r, e, i)); } } else for (const o in t)n[o] = this.addKey(t[o], e, i); return n; },
    addKey(t, e, i) { void 0 === e && (e = !0), void 0 === i && (i = !1); const n = this.keys; if (t instanceof u) { const s = n.indexOf(t); return s > -1 ? n[s] = t : n[t.keyCode] = t, e && this.addCapture(t.keyCode), t.setEmitOnRepeat(i), t; } return typeof t === 'string' && (t = c[t.toUpperCase()]), n[t] || (n[t] = new u(this, t), e && this.addCapture(t), n[t].setEmitOnRepeat(i)), n[t]; },
    removeKey(t, e) { void 0 === e && (e = !1); let i; const n = this.keys; if (t instanceof u) { const s = n.indexOf(t); s > -1 && (i = this.keys[s], this.keys[s] = void 0); } else typeof t === 'string' && (t = c[t.toUpperCase()]); return n[t] && (i = n[t], n[t] = void 0), i && (i.plugin = null, e && i.destroy()), this; },
    createCombo(t, e) { return new d(this, t, e); },
    checkDown(t, e) { if (this.enabled && t.isDown) { const i = p(this.time - t.timeDown, e); if (i > t._tick) return t._tick = i, !0; } return !1; },
    update() { const t = this.manager.queue; const e = t.length; if (this.isActive() && e !== 0) for (let i = this.keys, n = 0; n < e; n++) { var s = t[n]; const o = s.keyCode; const a = i[o]; let h = !1; void 0 === s.cancelled && (s.cancelled = 0, s.stopImmediatePropagation = function () { s.cancelled = 1; }, s.stopPropagation = function () { s.cancelled = -1; }), s.cancelled !== -1 && (s.type === 'keydown' ? (a && (h = a.isDown, a.onDown(s)), s.cancelled || a && h || (f[o] && (this.emit(r.KEY_DOWN + f[o], s), this.emit(`keydown_${f[o]}`, s)), s.cancelled || this.emit(r.ANY_KEY_DOWN, s))) : (a && a.onUp(s), s.cancelled || (f[o] && (this.emit(r.KEY_UP + f[o], s), this.emit(`keyup_${f[o]}`, s)), s.cancelled || this.emit(r.ANY_KEY_UP, s))), s.cancelled === 1 && (s.cancelled = 0)); } },
    resetKeys() { for (let t = this.keys, e = 0; e < t.length; e++)t[e] && t[e].reset(); return this; },
    shutdown() { this.resetKeys(), this.sceneInputPlugin.manager.useQueue ? this.sceneInputPlugin.pluginEvents.off(h.UPDATE, this.update, this) : this.sceneInputPlugin.manager.events.off(h.MANAGER_PROCESS, this.update, this), this.game.events.off(o.BLUR, this.resetKeys), this.removeAllListeners(), this.queue = []; },
    destroy() { this.shutdown(); for (let t = this.keys, e = 0; e < t.length; e++)t[e] && t[e].destroy(); this.keys = [], this.combos = [], this.queue = [], this.scene = null, this.settings = null, this.sceneInputPlugin = null, this.manager = null; },
    time: { get() { return this.sceneInputPlugin.manager.time; } },
  }); l.register('KeyboardPlugin', g, 'keyboard', 'keyboard', 'inputKeyboard'), t.exports = g;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(1256); t.exports = function (t, e) { if (e.matched) return !0; let i = !1; let s = !1; if (t.keyCode === e.current) if (e.index > 0 && e.maxKeyDelay > 0) { const r = e.timeLastMatched + e.maxKeyDelay; t.timeStamp <= r && (s = !0, i = n(t, e)); } else s = !0, i = n(t, e); return !s && e.resetOnWrongKey && (e.index = 0, e.current = e.keyCodes[0]), i && (e.timeLastMatched = t.timeStamp, e.matched = !0, e.timeMatched = t.timeStamp), i; };
}, function (t, e) { t.exports = function (t, e) { return e.timeLastMatched = t.timeStamp, e.index++, e.index === e.size || (e.current = e.keyCodes[e.index], !1); }; }, function (t, e) { t.exports = function (t) { return t.current = t.keyCodes[0], t.index = 0, t.timeLastMatched = 0, t.matched = !1, t.timeMatched = 0, t; }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(136); const s = {}; for (const r in n)s[n[r]] = r; t.exports = s;
}, function (t, e) { t.exports = function (t) { return !!t._justDown && (t._justDown = !1, !0); }; }, function (t, e) { t.exports = function (t) { return !!t._justUp && (t._justUp = !1, !0); }; }, function (t, e) { t.exports = function (t, e) { void 0 === e && (e = 50); const i = t.plugin.game.loop.time - t.timeDown; return t.isDown && i < e; }; }, function (t, e) { t.exports = function (t, e) { void 0 === e && (e = 50); const i = t.plugin.game.loop.time - t.timeUp; return t.isUp && i < e; }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = { MouseManager: i(399) };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = { TouchManager: i(401) };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(18); const s = i(19); let r = {
    Events: i(90), FileTypes: i(1266), File: i(25), FileTypesManager: i(9), GetURL: i(148), LoaderPlugin: i(1290), MergeXHRSettings: i(233), MultiFile: i(68), XHRLoader: i(487), XHRSettings: i(149),
  }; r = s(!1, r, n), t.exports = r;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = {
    AnimationJSONFile: i(1267), AtlasJSONFile: i(1268), AtlasXMLFile: i(1269), AudioFile: i(488), AudioSpriteFile: i(1270), BinaryFile: i(1271), BitmapFontFile: i(1272), CSSFile: i(1273), GLSLFile: i(1274), HTML5AudioFile: i(489), HTMLFile: i(1275), HTMLTextureFile: i(1276), ImageFile: i(79), JSONFile: i(67), MultiAtlasFile: i(1277), MultiScriptFile: i(1278), PackFile: i(1279), PluginFile: i(1280), SceneFile: i(1281), ScenePluginFile: i(1282), ScriptFile: i(490), SpriteSheetFile: i(1283), SVGFile: i(1284), TextFile: i(491), TilemapCSVFile: i(1285), TilemapImpactFile: i(1286), TilemapJSONFile: i(1287), UnityAtlasFile: i(1288), VideoFile: i(1289), XMLFile: i(234),
  };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(9); const r = i(67); const o = i(90); const a = new n({
    Extends: r, initialize(t, e, i, n, s) { r.call(this, t, e, i, n, s), this.type = 'animationJSON'; }, onProcess() { this.loader.once(o.POST_PROCESS, this.onLoadComplete, this), r.prototype.onProcess.call(this); }, onLoadComplete() { this.loader.systems.anims.fromJSON(this.data); },
  }); s.register('animation', (function (t, e, i, n) { if (Array.isArray(t)) for (let s = 0; s < t.length; s++) this.addFile(new a(this, t[s])); else this.addFile(new a(this, t, e, n, i)); return this; })), t.exports = a;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(9); const r = i(2); const o = i(79); const a = i(8); const h = i(67); const l = i(68); const u = new n({
    Extends: l,
    initialize(t, e, i, n, s, u) {
      let c; let d; if (a(e)) {
        const f = e; e = r(f, 'key'), c = new o(t, {
          key: e, url: r(f, 'textureURL'), extension: r(f, 'textureExtension', 'png'), normalMap: r(f, 'normalMap'), xhrSettings: r(f, 'textureXhrSettings'),
        }), d = new h(t, {
          key: e, url: r(f, 'atlasURL'), extension: r(f, 'atlasExtension', 'json'), xhrSettings: r(f, 'atlasXhrSettings'),
        });
      } else c = new o(t, e, i, s), d = new h(t, e, n, u); c.linkFile ? l.call(this, t, 'atlasjson', e, [c, d, c.linkFile]) : l.call(this, t, 'atlasjson', e, [c, d]);
    },
    addToCache() { if (this.isReadyToProcess()) { const t = this.files[0]; const e = this.files[1]; const i = this.files[2] ? this.files[2].data : null; this.loader.textureManager.addAtlas(t.key, t.data, e.data, i), e.addToCache(), this.complete = !0; } },
  }); s.register('atlas', (function (t, e, i, n, s) { let r; if (Array.isArray(t)) for (let o = 0; o < t.length; o++)r = new u(this, t[o]), this.addFile(r.files); else r = new u(this, t, e, i, n, s), this.addFile(r.files); return this; })), t.exports = u;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(9); const r = i(2); const o = i(79); const a = i(8); const h = i(68); const l = i(234); const u = new n({
    Extends: h,
    initialize(t, e, i, n, s, u) {
      let c; let d; if (a(e)) {
        const f = e; e = r(f, 'key'), c = new o(t, {
          key: e, url: r(f, 'textureURL'), extension: r(f, 'textureExtension', 'png'), normalMap: r(f, 'normalMap'), xhrSettings: r(f, 'textureXhrSettings'),
        }), d = new l(t, {
          key: e, url: r(f, 'atlasURL'), extension: r(f, 'atlasExtension', 'xml'), xhrSettings: r(f, 'atlasXhrSettings'),
        });
      } else c = new o(t, e, i, s), d = new l(t, e, n, u); c.linkFile ? h.call(this, t, 'atlasxml', e, [c, d, c.linkFile]) : h.call(this, t, 'atlasxml', e, [c, d]);
    },
    addToCache() { if (this.isReadyToProcess()) { const t = this.files[0]; const e = this.files[1]; const i = this.files[2] ? this.files[2].data : null; this.loader.textureManager.addAtlasXML(t.key, t.data, e.data, i), e.addToCache(), this.complete = !0; } },
  }); s.register('atlasXML', (function (t, e, i, n, s) { let r; if (Array.isArray(t)) for (let o = 0; o < t.length; o++)r = new u(this, t[o]), this.addFile(r.files); else r = new u(this, t, e, i, n, s), this.addFile(r.files); return this; })), t.exports = u;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(488); const s = i(0); const r = i(9); const o = i(2); const a = i(8); const h = i(67); const l = i(68); const u = new s({
    Extends: l, initialize(t, e, i, s, r, u, c) { if (a(e)) { const d = e; e = o(d, 'key'), i = o(d, 'jsonURL'), s = o(d, 'audioURL'), r = o(d, 'audioConfig'), u = o(d, 'audioXhrSettings'), c = o(d, 'jsonXhrSettings'); } let f; if (s) { const p = n.create(t, e, s, r, u); p && (f = new h(t, e, i, c), l.call(this, t, 'audiosprite', e, [p, f]), this.config.resourceLoad = !1); } else f = new h(t, e, i, c), l.call(this, t, 'audiosprite', e, [f]), this.config.resourceLoad = !0, this.config.audioConfig = r, this.config.audioXhrSettings = u; }, onFileComplete(t) { if (this.files.indexOf(t) !== -1 && (this.pending--, this.config.resourceLoad && t.type === 'json' && t.data.hasOwnProperty('resources'))) { const e = t.data.resources; const i = o(this.config, 'audioConfig'); const s = o(this.config, 'audioXhrSettings'); const r = n.create(this.loader, t.key, e, i, s); r && (this.addToMultiFile(r), this.loader.addFile(r)); } }, addToCache() { if (this.isReadyToProcess()) { const t = this.files[0]; const e = this.files[1]; t.addToCache(), e.addToCache(), this.complete = !0; } },
  }); r.register('audioSprite', (function (t, e, i, n, s, r) { let o; const a = this.systems.game; const h = a.config.audio; const l = a.device.audio; if (h && h.noAudio || !l.webAudio && !l.audioData) return this; if (Array.isArray(t)) for (let c = 0; c < t.length; c++)(o = new u(this, t[c])).files && this.addFile(o.files); else (o = new u(this, t, e, i, n, s, r)).files && this.addFile(o.files); return this; }));
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(18); const r = i(25); const o = i(9); const a = i(2); const h = i(8); const l = new n({
    Extends: r,
    initialize(t, e, i, n, s) {
      let o = 'bin'; if (h(e)) { const l = e; e = a(l, 'key'), i = a(l, 'url'), n = a(l, 'xhrSettings'), o = a(l, 'extension', o), s = a(l, 'dataType', s); } const u = {
        type: 'binary', cache: t.cacheManager.binary, extension: o, responseType: 'arraybuffer', key: e, url: i, xhrSettings: n, config: { dataType: s },
      }; r.call(this, t, u);
    },
    onProcess() { this.state = s.FILE_PROCESSING; const t = this.config.dataType; this.data = t ? new t(this.xhrLoader.response) : this.xhrLoader.response, this.onProcessComplete(); },
  }); o.register('binary', (function (t, e, i, n) { if (Array.isArray(t)) for (let s = 0; s < t.length; s++) this.addFile(new l(this, t[s])); else this.addFile(new l(this, t, e, n, i)); return this; })), t.exports = l;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(9); const r = i(2); const o = i(79); const a = i(8); const h = i(68); const l = i(205); const u = i(234); const c = new n({
    Extends: h,
    initialize(t, e, i, n, s, l) {
      let c; let d; if (a(e)) {
        const f = e; e = r(f, 'key'), c = new o(t, {
          key: e, url: r(f, 'textureURL'), extension: r(f, 'textureExtension', 'png'), normalMap: r(f, 'normalMap'), xhrSettings: r(f, 'textureXhrSettings'),
        }), d = new u(t, {
          key: e, url: r(f, 'fontDataURL'), extension: r(f, 'fontDataExtension', 'xml'), xhrSettings: r(f, 'fontDataXhrSettings'),
        });
      } else c = new o(t, e, i, s), d = new u(t, e, n, l); c.linkFile ? h.call(this, t, 'bitmapfont', e, [c, d, c.linkFile]) : h.call(this, t, 'bitmapfont', e, [c, d]);
    },
    addToCache() { if (this.isReadyToProcess()) { const t = this.files[0]; const e = this.files[1]; t.addToCache(), e.addToCache(), this.loader.cacheManager.bitmapFont.add(t.key, { data: l(e.data), texture: t.key, frame: null }), this.complete = !0; } },
  }); s.register('bitmapFont', (function (t, e, i, n, s) { let r; if (Array.isArray(t)) for (let o = 0; o < t.length; o++)r = new c(this, t[o]), this.addFile(r.files); else r = new c(this, t, e, i, n, s), this.addFile(r.files); return this; })), t.exports = c;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(18); const r = i(25); const o = i(9); const a = i(2); const h = i(8); const l = new n({
    Extends: r,
    initialize(t, e, i, n) {
      let s = 'css'; if (h(e)) { const o = e; e = a(o, 'key'), i = a(o, 'url'), n = a(o, 'xhrSettings'), s = a(o, 'extension', s); } const l = {
        type: 'script', cache: !1, extension: s, responseType: 'text', key: e, url: i, xhrSettings: n,
      }; r.call(this, t, l);
    },
    onProcess() { this.state = s.FILE_PROCESSING, this.data = document.createElement('style'), this.data.defer = !1, this.data.innerHTML = this.xhrLoader.responseText, document.head.appendChild(this.data), this.onProcessComplete(); },
  }); o.register('css', (function (t, e, i) { if (Array.isArray(t)) for (let n = 0; n < t.length; n++) this.addFile(new l(this, t[n])); else this.addFile(new l(this, t, e, i)); return this; })), t.exports = l;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(18); const r = i(25); const o = i(9); const a = i(2); const h = i(8); const l = i(385); const u = new n({
    Extends: r,
    initialize(t, e, i, n, s) {
      let o = 'glsl'; if (h(e)) { const l = e; e = a(l, 'key'), i = a(l, 'url'), n = a(l, 'shaderType', 'fragment'), s = a(l, 'xhrSettings'), o = a(l, 'extension', o); } else void 0 === n && (n = 'fragment'); const u = {
        type: 'glsl', cache: t.cacheManager.shader, extension: o, responseType: 'text', key: e, url: i, config: { shaderType: n }, xhrSettings: s,
      }; r.call(this, t, u);
    },
    onProcess() { this.state = s.FILE_PROCESSING, this.data = this.xhrLoader.responseText, this.onProcessComplete(); },
    addToCache() { const t = this.data.split('\n'); let e = this.extractBlock(t, 0); if (e) for (;e;) { const i = this.getShaderName(e.header); const n = this.getShaderType(e.header); const s = this.getShaderUniforms(e.header); const r = e.shader; if (this.cache.has(i)) { const o = this.cache.get(i); n === 'fragment' ? o.fragmentSrc = r : o.vertexSrc = r, o.uniforms || (o.uniforms = s); } else n === 'fragment' ? this.cache.add(i, new l(i, r, '', s)) : this.cache.add(i, new l(i, '', r, s)); e = this.extractBlock(t, e.offset); } else this.config.shaderType === 'fragment' ? this.cache.add(this.key, new l(this.key, this.data)) : this.cache.add(this.key, new l(this.key, '', this.data)); this.pendingDestroy(); },
    getShaderName(t) { for (let e = 0; e < t.length; e++) { const i = t[e].trim(); if (i.substring(0, 5) === 'name:') return i.substring(5).trim(); } return this.key; },
    getShaderType(t) { for (let e = 0; e < t.length; e++) { const i = t[e].trim(); if (i.substring(0, 5) === 'type:') return i.substring(5).trim(); } return this.config.shaderType; },
    getShaderUniforms(t) { for (var e = {}, i = 0; i < t.length; i++) { const n = t[i].trim(); if (n.substring(0, 8) === 'uniform.') { const s = n.indexOf(':'); if (s) { const r = n.substring(8, s); try { e[r] = JSON.parse(n.substring(s + 1)); } catch (t) { console.warn(`Invalid uniform JSON: ${r}`); } } } } return e; },
    extractBlock(t, e) { for (var i = -1, n = -1, s = -1, r = !1, o = !1, a = [], h = [], l = e; l < t.length; l++) { const u = t[l].trim(); if (u === '---') if (i === -1)i = l, r = !0; else { if (!r) { o = !1; break; }n = l, r = !1, o = !0; } else r ? a.push(u) : o && (h.push(u), s = l); } return r || n === -1 ? null : { header: a, shader: h.join('\n'), offset: s }; },
  }); o.register('glsl', (function (t, e, i, n) { if (Array.isArray(t)) for (let s = 0; s < t.length; s++) this.addFile(new u(this, t[s])); else this.addFile(new u(this, t, e, i, n)); return this; })), t.exports = u;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(18); const r = i(25); const o = i(9); const a = i(2); const h = i(8); const l = new n({
    Extends: r,
    initialize(t, e, i, n) {
      let s = 'html'; if (h(e)) { const o = e; e = a(o, 'key'), i = a(o, 'url'), n = a(o, 'xhrSettings'), s = a(o, 'extension', s); } const l = {
        type: 'text', cache: t.cacheManager.html, extension: s, responseType: 'text', key: e, url: i, xhrSettings: n,
      }; r.call(this, t, l);
    },
    onProcess() { this.state = s.FILE_PROCESSING, this.data = this.xhrLoader.responseText, this.onProcessComplete(); },
  }); o.register('html', (function (t, e, i) { if (Array.isArray(t)) for (let n = 0; n < t.length; n++) this.addFile(new l(this, t[n])); else this.addFile(new l(this, t, e, i)); return this; })), t.exports = l;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(18); const r = i(25); const o = i(9); const a = i(2); const h = i(8); const l = new n({
    Extends: r,
    initialize(t, e, i, n, s, o) {
      void 0 === n && (n = 512), void 0 === s && (s = 512); let l = 'html'; if (h(e)) { const u = e; e = a(u, 'key'), i = a(u, 'url'), o = a(u, 'xhrSettings'), l = a(u, 'extension', l), n = a(u, 'width', n), s = a(u, 'height', s); } const c = {
        type: 'html', cache: t.textureManager, extension: l, responseType: 'text', key: e, url: i, xhrSettings: o, config: { width: n, height: s },
      }; r.call(this, t, c);
    },
    onProcess() { this.state = s.FILE_PROCESSING; const t = this.config.width; const e = this.config.height; const i = []; i.push(`<svg width="${t}px" height="${e}px" viewBox="0 0 ${t} ${e}" xmlns="http://www.w3.org/2000/svg">`), i.push('<foreignObject width="100%" height="100%">'), i.push('<body xmlns="http://www.w3.org/1999/xhtml">'), i.push(this.xhrLoader.responseText), i.push('</body>'), i.push('</foreignObject>'), i.push('</svg>'); const n = [i.join('\n')]; const o = this; try { var a = new window.Blob(n, { type: 'image/svg+xml;charset=utf-8' }); } catch (t) { return o.state = s.FILE_ERRORED, void o.onProcessComplete(); } this.data = new Image(), this.data.crossOrigin = this.crossOrigin, this.data.onload = function () { r.revokeObjectURL(o.data), o.onProcessComplete(); }, this.data.onerror = function () { r.revokeObjectURL(o.data), o.onProcessError(); }, r.createObjectURL(this.data, a, 'image/svg+xml'); },
    addToCache() { const t = this.cache.addImage(this.key, this.data); this.pendingDestroy(t); },
  }); o.register('htmlTexture', (function (t, e, i, n, s) { if (Array.isArray(t)) for (let r = 0; r < t.length; r++) this.addFile(new l(this, t[r])); else this.addFile(new l(this, t, e, i, n, s)); return this; })), t.exports = l;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(9); const r = i(2); const o = i(79); const a = i(8); const h = i(67); const l = i(68); const u = new n({
    Extends: l, initialize(t, e, i, n, s, o, u) { if (a(e)) { const c = e; e = r(c, 'key'), i = r(c, 'url', !1) ? r(c, 'url') : r(c, 'atlasURL'), o = r(c, 'xhrSettings'), n = r(c, 'path'), s = r(c, 'baseURL'), u = r(c, 'textureXhrSettings'); } const d = new h(t, e, i, o); l.call(this, t, 'multiatlas', e, [d]), this.config.path = n, this.config.baseURL = s, this.config.textureXhrSettings = u; }, onFileComplete(t) { if (this.files.indexOf(t) !== -1 && (this.pending--, t.type === 'json' && t.data.hasOwnProperty('textures'))) { const e = t.data.textures; const i = this.config; const n = this.loader; const s = n.baseURL; const a = n.path; const h = n.prefix; const l = r(i, 'baseURL', this.baseURL); const u = r(i, 'path', this.path); const c = r(i, 'prefix', this.prefix); const d = r(i, 'textureXhrSettings'); n.setBaseURL(l), n.setPath(u), n.setPrefix(c); for (let f = 0; f < e.length; f++) { const p = e[f].image; const g = `MA${this.multiKeyIndex}_${p}`; const v = new o(n, g, p, d); if (this.addToMultiFile(v), n.addFile(v), e[f].normalMap) { const m = new o(n, g, e[f].normalMap, d); m.type = 'normalMap', v.setLink(m), this.addToMultiFile(m), n.addFile(m); } }n.setBaseURL(s), n.setPath(a), n.setPrefix(h); } }, addToCache() { if (this.isReadyToProcess()) { for (var t = this.files[0], e = [], i = [], n = [], s = 1; s < this.files.length; s++) { const r = this.files[s]; if (r.type !== 'normalMap') for (let o = r.key.indexOf('_'), a = r.key.substr(o + 1), h = r.data, l = 0; l < t.data.textures.length; l++) { const u = t.data.textures[l]; if (u.image === a) { i.push(h), e.push(u), r.linkFile && n.push(r.linkFile.data); break; } } } for (n.length === 0 && (n = void 0), this.loader.textureManager.addAtlasJSONArray(this.key, i, e, n), this.complete = !0, s = 0; s < this.files.length; s++) this.files[s].pendingDestroy(); } },
  }); s.register('multiatlas', (function (t, e, i, n, s) { let r; if (Array.isArray(t)) for (let o = 0; o < t.length; o++)r = new u(this, t[o]), this.addFile(r.files); else r = new u(this, t, e, i, n, s), this.addFile(r.files); return this; })), t.exports = u;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(9); const r = i(2); const o = i(8); const a = i(68); const h = i(490); const l = new n({
    Extends: a,
    initialize(t, e, i, n) {
      let s = 'js'; const l = []; if (o(e)) { const u = e; e = r(u, 'key'), i = r(u, 'url'), n = r(u, 'xhrSettings'), s = r(u, 'extension', s); }Array.isArray(i) || (i = [i]); for (let c = 0; c < i.length; c++) {
        const d = new h(t, {
          key: `${e}_${c.toString()}`, url: i[c], extension: s, xhrSettings: n,
        }); d.onProcess = function () { this.onProcessComplete(); }, l.push(d);
      }a.call(this, t, 'scripts', e, l);
    },
    addToCache() { if (this.isReadyToProcess()) { for (let t = 0; t < this.files.length; t++) { const e = this.files[t]; e.data = document.createElement('script'), e.data.language = 'javascript', e.data.type = 'text/javascript', e.data.defer = !1, e.data.text = e.xhrLoader.responseText, document.head.appendChild(e.data); } this.complete = !0; } },
  }); s.register('scripts', (function (t, e, i) { let n; if (Array.isArray(t)) for (let s = 0; s < t.length; s++)n = new l(this, t[s]), this.addFile(n.files); else n = new l(this, t, e, i), this.addFile(n.files); return this; })), t.exports = l;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(18); const r = i(9); const o = i(67); const a = new n({ Extends: o, initialize(t, e, i, n, s) { o.call(this, t, e, i, n, s), this.type = 'packfile'; }, onProcess() { this.state !== s.FILE_POPULATED && (this.state = s.FILE_PROCESSING, this.data = JSON.parse(this.xhrLoader.responseText)), this.loader.addPack(this.data, this.config), this.onProcessComplete(); } }); r.register('pack', (function (t, e, i, n) { if (Array.isArray(t)) for (let s = 0; s < t.length; s++) this.addFile(new a(this, t[s])); else this.addFile(new a(this, t, e, n, i)); return this; })), t.exports = a;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(18); const r = i(25); const o = i(9); const a = i(2); const h = i(8); const l = new n({
    Extends: r,
    initialize(t, e, i, n, o, l) {
      let u = 'js'; if (h(e)) { const c = e; e = a(c, 'key'), i = a(c, 'url'), l = a(c, 'xhrSettings'), u = a(c, 'extension', u), n = a(c, 'start'), o = a(c, 'mapping'); } const d = {
        type: 'plugin', cache: !1, extension: u, responseType: 'text', key: e, url: i, xhrSettings: l, config: { start: n, mapping: o },
      }; r.call(this, t, d), typeof i === 'function' && (this.data = i, this.state = s.FILE_POPULATED);
    },
    onProcess() { const t = this.loader.systems.plugins; const e = this.config; const i = a(e, 'start', !1); const n = a(e, 'mapping', null); if (this.state === s.FILE_POPULATED)t.install(this.key, this.data, i, n); else { this.state = s.FILE_PROCESSING, this.data = document.createElement('script'), this.data.language = 'javascript', this.data.type = 'text/javascript', this.data.defer = !1, this.data.text = this.xhrLoader.responseText, document.head.appendChild(this.data); const r = t.install(this.key, window[this.key], i, n); (i || n) && (this.loader.systems[n] = r, this.loader.scene[n] = r); } this.onProcessComplete(); },
  }); o.register('plugin', (function (t, e, i, n, s) { if (Array.isArray(t)) for (let r = 0; r < t.length; r++) this.addFile(new l(this, t[r])); else this.addFile(new l(this, t, e, i, n, s)); return this; })), t.exports = l;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(18); const r = i(25); const o = i(9); const a = i(2); const h = i(8); const l = new n({
    Extends: r,
    initialize(t, e, i, n) {
      let s = 'js'; if (h(e)) { const o = e; e = a(o, 'key'), i = a(o, 'url'), n = a(o, 'xhrSettings'), s = a(o, 'extension', s); } const l = {
        type: 'text', cache: t.cacheManager.text, extension: s, responseType: 'text', key: e, url: i, xhrSettings: n,
      }; r.call(this, t, l);
    },
    onProcess() { this.state = s.FILE_PROCESSING, this.data = this.xhrLoader.responseText, this.onProcessComplete(); },
    addToCache() { const t = this.data.concat(`(function(){\nreturn new ${this.key}();\n}).call(this);`); const e = eval; this.loader.sceneManager.add(this.key, e(t)), this.complete = !0; },
  }); o.register('sceneFile', (function (t, e, i) { if (Array.isArray(t)) for (let n = 0; n < t.length; n++) this.addFile(new l(this, t[n])); else this.addFile(new l(this, t, e, i)); return this; })), t.exports = l;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(18); const r = i(25); const o = i(9); const a = i(2); const h = i(8); const l = new n({
    Extends: r,
    initialize(t, e, i, n, o, l) {
      let u = 'js'; if (h(e)) { const c = e; e = a(c, 'key'), i = a(c, 'url'), l = a(c, 'xhrSettings'), u = a(c, 'extension', u), n = a(c, 'systemKey'), o = a(c, 'sceneKey'); } const d = {
        type: 'scenePlugin', cache: !1, extension: u, responseType: 'text', key: e, url: i, xhrSettings: l, config: { systemKey: n, sceneKey: o },
      }; r.call(this, t, d), typeof i === 'function' && (this.data = i, this.state = s.FILE_POPULATED);
    },
    onProcess() { const t = this.loader.systems.plugins; const e = this.config; const i = this.key; const n = a(e, 'systemKey', i); const r = a(e, 'sceneKey', i); this.state === s.FILE_POPULATED ? t.installScenePlugin(n, this.data, r, this.loader.scene, !0) : (this.state = s.FILE_PROCESSING, this.data = document.createElement('script'), this.data.language = 'javascript', this.data.type = 'text/javascript', this.data.defer = !1, this.data.text = this.xhrLoader.responseText, document.head.appendChild(this.data), t.installScenePlugin(n, window[this.key], r, this.loader.scene, !0)), this.onProcessComplete(); },
  }); o.register('scenePlugin', (function (t, e, i, n, s) { if (Array.isArray(t)) for (let r = 0; r < t.length; r++) this.addFile(new l(this, t[r])); else this.addFile(new l(this, t, e, i, n, s)); return this; })), t.exports = l;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(9); const r = i(79); const o = new n({ Extends: r, initialize(t, e, i, n, s) { r.call(this, t, e, i, s, n), this.type = 'spritesheet'; }, addToCache() { const t = this.cache.addSpriteSheet(this.key, this.data, this.config); this.pendingDestroy(t); } }); s.register('spritesheet', (function (t, e, i, n) { if (Array.isArray(t)) for (let s = 0; s < t.length; s++) this.addFile(new o(this, t[s])); else this.addFile(new o(this, t, e, i, n)); return this; })), t.exports = o;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(18); const r = i(25); const o = i(9); const a = i(2); const h = i(8); const l = new n({
    Extends: r,
    initialize(t, e, i, n, s) {
      let o = 'svg'; if (h(e)) { const l = e; e = a(l, 'key'), i = a(l, 'url'), n = a(l, 'svgConfig', {}), s = a(l, 'xhrSettings'), o = a(l, 'extension', o); } const u = {
        type: 'svg', cache: t.textureManager, extension: o, responseType: 'text', key: e, url: i, xhrSettings: s, config: { width: a(n, 'width'), height: a(n, 'height'), scale: a(n, 'scale') },
      }; r.call(this, t, u);
    },
    onProcess() { this.state = s.FILE_PROCESSING; const t = this.xhrLoader.responseText; let e = [t]; let i = this.config.width; let n = this.config.height; const o = this.config.scale; t:if (i && n || o) { const a = (new DOMParser()).parseFromString(t, 'text/xml').getElementsByTagName('svg')[0]; const h = a.hasAttribute('viewBox'); let l = parseFloat(a.getAttribute('width')); let u = parseFloat(a.getAttribute('height')); if (!h && l && u)a.setAttribute('viewBox', `0  0 ${l} ${u}`); else if (h && !l && !u) { const c = a.getAttribute('viewBox').split(/\s+|,/); l = c[2], u = c[3]; } if (o) { if (!l || !u) break t; i = l * o, n = u * o; }a.setAttribute('width', `${i.toString()}px`), a.setAttribute('height', `${n.toString()}px`), e = [(new XMLSerializer()).serializeToString(a)]; } try { var d = new window.Blob(e, { type: 'image/svg+xml;charset=utf-8' }); } catch (t) { return void this.onProcessError(); } this.data = new Image(), this.data.crossOrigin = this.crossOrigin; const f = this; let p = !1; this.data.onload = function () { p || r.revokeObjectURL(f.data), f.onProcessComplete(); }, this.data.onerror = function () { p ? f.onProcessError() : (p = !0, r.revokeObjectURL(f.data), f.data.src = `data:image/svg+xml,${encodeURIComponent(e.join(''))}`); }, r.createObjectURL(this.data, d, 'image/svg+xml'); },
    addToCache() { const t = this.cache.addImage(this.key, this.data); this.pendingDestroy(t); },
  }); o.register('svg', (function (t, e, i, n) { if (Array.isArray(t)) for (let s = 0; s < t.length; s++) this.addFile(new l(this, t[s])); else this.addFile(new l(this, t, e, i, n)); return this; })), t.exports = l;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(18); const r = i(25); const o = i(9); const a = i(2); const h = i(8); const l = i(36); const u = new n({
    Extends: r,
    initialize(t, e, i, n) {
      let s = 'csv'; if (h(e)) { const o = e; e = a(o, 'key'), i = a(o, 'url'), n = a(o, 'xhrSettings'), s = a(o, 'extension', s); } const u = {
        type: 'tilemapCSV', cache: t.cacheManager.tilemap, extension: s, responseType: 'text', key: e, url: i, xhrSettings: n,
      }; r.call(this, t, u), this.tilemapFormat = l.CSV;
    },
    onProcess() { this.state = s.FILE_PROCESSING, this.data = this.xhrLoader.responseText, this.onProcessComplete(); },
    addToCache() { const t = { format: this.tilemapFormat, data: this.data }; this.cache.add(this.key, t), this.pendingDestroy(t); },
  }); o.register('tilemapCSV', (function (t, e, i) { if (Array.isArray(t)) for (let n = 0; n < t.length; n++) this.addFile(new u(this, t[n])); else this.addFile(new u(this, t, e, i)); return this; })), t.exports = u;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(9); const r = i(67); const o = i(36); const a = new n({ Extends: r, initialize(t, e, i, n) { r.call(this, t, e, i, n), this.type = 'tilemapJSON', this.cache = t.cacheManager.tilemap; }, addToCache() { const t = { format: o.WELTMEISTER, data: this.data }; this.cache.add(this.key, t), this.pendingDestroy(t); } }); s.register('tilemapImpact', (function (t, e, i) { if (Array.isArray(t)) for (let n = 0; n < t.length; n++) this.addFile(new a(this, t[n])); else this.addFile(new a(this, t, e, i)); return this; })), t.exports = a;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(9); const r = i(67); const o = i(36); const a = new n({ Extends: r, initialize(t, e, i, n) { r.call(this, t, e, i, n), this.type = 'tilemapJSON', this.cache = t.cacheManager.tilemap; }, addToCache() { const t = { format: o.TILED_JSON, data: this.data }; this.cache.add(this.key, t), this.pendingDestroy(t); } }); s.register('tilemapTiledJSON', (function (t, e, i) { if (Array.isArray(t)) for (let n = 0; n < t.length; n++) this.addFile(new a(this, t[n])); else this.addFile(new a(this, t, e, i)); return this; })), t.exports = a;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(9); const r = i(2); const o = i(79); const a = i(8); const h = i(68); const l = i(491); const u = new n({
    Extends: h,
    initialize(t, e, i, n, s, u) {
      let c; let d; if (a(e)) {
        const f = e; e = r(f, 'key'), c = new o(t, {
          key: e, url: r(f, 'textureURL'), extension: r(f, 'textureExtension', 'png'), normalMap: r(f, 'normalMap'), xhrSettings: r(f, 'textureXhrSettings'),
        }), d = new l(t, {
          key: e, url: r(f, 'atlasURL'), extension: r(f, 'atlasExtension', 'txt'), xhrSettings: r(f, 'atlasXhrSettings'),
        });
      } else c = new o(t, e, i, s), d = new l(t, e, n, u); c.linkFile ? h.call(this, t, 'unityatlas', e, [c, d, c.linkFile]) : h.call(this, t, 'unityatlas', e, [c, d]);
    },
    addToCache() { if (this.isReadyToProcess()) { const t = this.files[0]; const e = this.files[1]; const i = this.files[2] ? this.files[2].data : null; this.loader.textureManager.addUnityAtlas(t.key, t.data, e.data, i), e.addToCache(), this.complete = !0; } },
  }); s.register('unityAtlas', (function (t, e, i, n, s) { let r; if (Array.isArray(t)) for (let o = 0; o < t.length; o++)r = new u(this, t[o]), this.addFile(r.files); else r = new u(this, t, e, i, n, s), this.addFile(r.files); return this; })), t.exports = u;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(18); const r = i(25); const o = i(9); const a = i(148); const h = i(2); const l = i(8); const u = new n({
    Extends: r,
    initialize(t, e, i, n, s, o, a) {
      void 0 === n && (n = 'loadeddata'), void 0 === s && (s = !1), void 0 === o && (o = !1), n !== 'loadeddata' && n !== 'canplay' && n !== 'canplaythrough' && (n = 'loadeddata'); const h = {
        type: 'video', cache: t.cacheManager.video, extension: i.type, responseType: 'blob', key: e, url: i.url, xhrSettings: a, config: { loadEvent: n, asBlob: s, noAudio: o },
      }; this.onLoadCallback = this.onVideoLoadHandler.bind(this), this.onErrorCallback = this.onVideoErrorHandler.bind(this), r.call(this, t, h);
    },
    onProcess() { if (this.state = s.FILE_PROCESSING, this.config.asBlob) { const t = this.createVideoElement(); this.data = t; const e = this; this.data.onloadeddata = function () { e.onProcessComplete(); }, this.data.onerror = function () { r.revokeObjectURL(e.data), e.onProcessError(); }, r.createObjectURL(t, this.xhrLoader.response, ''), t.load(); } else this.onProcessComplete(); },
    createVideoElement() { const t = document.createElement('video'); return t.controls = !1, t.crossOrigin = this.loader.crossOrigin, this.config.noAudio && (t.muted = !0, t.defaultMuted = !0, t.setAttribute('autoplay', 'autoplay')), t.setAttribute('playsinline', 'playsinline'), t.setAttribute('preload', 'auto'), t; },
    onVideoLoadHandler(t) { const e = t.target; e.removeEventListener(this.config.loadEvent, this.onLoadCallback, !0), e.removeEventListener('error', this.onErrorCallback, !0), this.data = e, this.resetXHR(), this.loader.nextFile(this, !0); },
    onVideoErrorHandler(t) { const e = t.target; e && (e.removeEventListener(this.config.loadEvent, this.onLoadCallback, !0), e.removeEventListener('error', this.onErrorCallback, !0)), this.resetXHR(), this.loader.nextFile(this, !1); },
    load() { const t = this.config.loadEvent; if (this.config.asBlob)r.prototype.load.call(this); else { this.percentComplete = 0; const e = this.createVideoElement(); e.addEventListener(t, this.onLoadCallback, !0), e.addEventListener('error', this.onErrorCallback, !0), e.src = a(this, this.loader.baseURL), e.load(); } },
  }); u.create = function (t, e, i, n, s, r, o) { const a = t.systems.game; l(e) && (i = h(e, 'url', []), n = h(e, 'loadEvent', 'loadeddata'), s = h(e, 'asBlob', !1), r = h(e, 'noAudio', !1), o = h(e, 'xhrSettings')); const c = u.getVideoURL(a, i); if (c) return new u(t, e, c, n, s, r, o); }, u.getVideoURL = function (t, e) { Array.isArray(e) || (e = [e]); for (let i = 0; i < e.length; i++) { var n; const s = h(e[i], 'url', e[i]); if (s.indexOf('blob:') === 0) return { url: s, type: '' }; if (n = s.indexOf('data:') === 0 ? s.split(',')[0].match(/\/(.*?);/) : s.match(/\.([a-zA-Z0-9]+)($|\?)/), n = h(e[i], 'type', n ? n[1] : '').toLowerCase(), t.device.video[n]) return { url: s, type: n }; } return null; }, o.register('video', (function (t, e, i, n, s, r) { let o; if (Array.isArray(t)) for (let a = 0; a < t.length; a++)(o = u.create(this, t[a])) && this.addFile(o); else (o = u.create(this, t, e, i, n, s, r)) && this.addFile(o); return this; })), t.exports = u;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(18); const r = i(111); const o = i(10); const a = i(90); const h = i(9); const l = i(2); const u = i(23); const c = i(24); const d = i(149); const f = new n({
    Extends: o, initialize(t) { o.call(this); const e = t.sys.game.config; const i = t.sys.settings.loader; this.scene = t, this.systems = t.sys, this.cacheManager = t.sys.cache, this.textureManager = t.sys.textures, this.sceneManager = t.sys.game.scene, h.install(this), this.prefix = '', this.path = '', this.baseURL = '', this.setBaseURL(l(i, 'baseURL', e.loaderBaseURL)), this.setPath(l(i, 'path', e.loaderPath)), this.setPrefix(l(i, 'prefix', e.loaderPrefix)), this.maxParallelDownloads = l(i, 'maxParallelDownloads', e.loaderMaxParallelDownloads), this.xhr = d(l(i, 'responseType', e.loaderResponseType), l(i, 'async', e.loaderAsync), l(i, 'user', e.loaderUser), l(i, 'password', e.loaderPassword), l(i, 'timeout', e.loaderTimeout), l(i, 'withCredentials', e.loaderWithCredentials)), this.crossOrigin = l(i, 'crossOrigin', e.loaderCrossOrigin), this.totalToLoad = 0, this.progress = 0, this.list = new r(), this.inflight = new r(), this.queue = new r(), this._deleteQueue = new r(), this.totalFailed = 0, this.totalComplete = 0, this.state = s.LOADER_IDLE, this.multiKeyIndex = 0, t.sys.events.once(c.BOOT, this.boot, this), t.sys.events.on(c.START, this.pluginStart, this); }, boot() { this.systems.events.once(c.DESTROY, this.destroy, this); }, pluginStart() { this.systems.events.once(c.SHUTDOWN, this.shutdown, this); }, setBaseURL(t) { return void 0 === t && (t = ''), t !== '' && t.substr(-1) !== '/' && (t = t.concat('/')), this.baseURL = t, this; }, setPath(t) { return void 0 === t && (t = ''), t !== '' && t.substr(-1) !== '/' && (t = t.concat('/')), this.path = t, this; }, setPrefix(t) { return void 0 === t && (t = ''), this.prefix = t, this; }, setCORS(t) { return this.crossOrigin = t, this; }, addFile(t) { Array.isArray(t) || (t = [t]); for (let e = 0; e < t.length; e++) { const i = t[e]; this.keyExists(i) || (this.list.set(i), this.emit(a.ADD, i.key, i.type, this, i), this.isLoading() && (this.totalToLoad++, this.updateProgress())); } }, keyExists(t) { let e = t.hasCacheConflict(); return e || this.list.iterate(((i) => { if (i.type === t.type && i.key === t.key) return e = !0, !1; })), !e && this.isLoading() && (this.inflight.iterate(((i) => { if (i.type === t.type && i.key === t.key) return e = !0, !1; })), this.queue.iterate(((i) => { if (i.type === t.type && i.key === t.key) return e = !0, !1; }))), e; }, addPack(t, e) { e && t.hasOwnProperty(e) && (t = { packKey: t[e] }); let i = 0; const n = this.baseURL; const s = this.path; const r = this.prefix; for (const o in t) if (Object.prototype.hasOwnProperty.call(t, o)) { const a = t[o]; const h = l(a, 'baseURL', n); const u = l(a, 'path', s); const c = l(a, 'prefix', r); const d = l(a, 'files', null); const f = l(a, 'defaultType', 'void'); if (Array.isArray(d)) { this.setBaseURL(h), this.setPath(u), this.setPrefix(c); for (let p = 0; p < d.length; p++) { const g = d[p]; const v = g.hasOwnProperty('type') ? g.type : f; this[v] && (this[v](g), i++); } } } return this.setBaseURL(n), this.setPath(s), this.setPrefix(r), i > 0; }, isLoading() { return this.state === s.LOADER_LOADING || this.state === s.LOADER_PROCESSING; }, isReady() { return this.state === s.LOADER_IDLE || this.state === s.LOADER_COMPLETE; }, start() { this.isReady() && (this.progress = 0, this.totalFailed = 0, this.totalComplete = 0, this.totalToLoad = this.list.size, this.emit(a.START, this), this.list.size === 0 ? this.loadComplete() : (this.state = s.LOADER_LOADING, this.inflight.clear(), this.queue.clear(), this.updateProgress(), this.checkLoadQueue(), this.systems.events.on(c.UPDATE, this.update, this))); }, updateProgress() { this.progress = 1 - (this.list.size + this.inflight.size) / this.totalToLoad, this.emit(a.PROGRESS, this.progress); }, update() { this.state === s.LOADER_LOADING && this.list.size > 0 && this.inflight.size < this.maxParallelDownloads && this.checkLoadQueue(); }, checkLoadQueue() { this.list.each((function (t) { if ((t.state === s.FILE_POPULATED || t.state === s.FILE_PENDING && this.inflight.size < this.maxParallelDownloads) && (this.inflight.set(t), this.list.delete(t), t.crossOrigin || (t.crossOrigin = this.crossOrigin), t.load()), this.inflight.size === this.maxParallelDownloads) return !1; }), this); }, nextFile(t, e) { this.inflight && (this.inflight.delete(t), this.updateProgress(), e ? (this.totalComplete++, this.queue.set(t), this.emit(a.FILE_LOAD, t), t.onProcess()) : (this.totalFailed++, this._deleteQueue.set(t), this.emit(a.FILE_LOAD_ERROR, t), this.fileProcessComplete(t))); }, fileProcessComplete(t) { this.scene && this.systems && this.systems.game && !this.systems.game.pendingDestroy && (t.state === s.FILE_ERRORED ? t.multiFile && t.multiFile.onFileFailed(t) : t.state === s.FILE_COMPLETE && (t.multiFile ? t.multiFile.isReadyToProcess() && t.multiFile.addToCache() : t.addToCache()), this.queue.delete(t), this.list.size === 0 && this.inflight.size === 0 && this.queue.size === 0 && this.loadComplete()); }, loadComplete() { this.emit(a.POST_PROCESS, this), this.list.clear(), this.inflight.clear(), this.queue.clear(), this.progress = 1, this.state = s.LOADER_COMPLETE, this.systems.events.off(c.UPDATE, this.update, this), this._deleteQueue.iterateLocal('destroy'), this._deleteQueue.clear(), this.emit(a.COMPLETE, this, this.totalComplete, this.totalFailed); }, flagForRemoval(t) { this._deleteQueue.set(t); }, saveJSON(t, e) { return this.save(JSON.stringify(t), e); }, save(t, e, i) { void 0 === e && (e = 'file.json'), void 0 === i && (i = 'application/json'); const n = new Blob([t], { type: i }); const s = URL.createObjectURL(n); const r = document.createElement('a'); return r.download = e, r.textContent = `Download ${e}`, r.href = s, r.click(), this; }, reset() { this.list.clear(), this.inflight.clear(), this.queue.clear(); const t = this.systems.game.config; const e = this.systems.settings.loader; this.setBaseURL(l(e, 'baseURL', t.loaderBaseURL)), this.setPath(l(e, 'path', t.loaderPath)), this.setPrefix(l(e, 'prefix', t.loaderPrefix)), this.state = s.LOADER_IDLE; }, shutdown() { this.reset(), this.state = s.LOADER_SHUTDOWN, this.systems.events.off(c.UPDATE, this.update, this), this.systems.events.off(c.SHUTDOWN, this.shutdown, this); }, destroy() { this.shutdown(), this.state = s.LOADER_DESTROYED, this.systems.events.off(c.UPDATE, this.update, this), this.systems.events.off(c.START, this.pluginStart, this), this.list = null, this.inflight = null, this.queue = null, this.scene = null, this.systems = null, this.textureManager = null, this.cacheManager = null, this.sceneManager = null; },
  }); u.register('Loader', f, 'load'), t.exports = f;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = { Arcade: i(1292), Matter: i(1323) };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(59); const s = i(19); let r = {
    ArcadePhysics: i(1293), Body: i(498), Collider: i(499), Components: i(235), Events: i(236), Factory: i(492), Group: i(494), Image: i(493), Sprite: i(150), StaticBody: i(504), StaticGroup: i(495), World: i(497),
  }; r = s(!1, r, n), t.exports = r;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(41); const r = i(56); const o = i(344); const a = i(492); const h = i(2); const l = i(106); const u = i(1306); const c = i(496); const d = i(23); const f = i(24); const p = i(3); const g = i(497); const v = new n({
    initialize(t) { this.scene = t, this.systems = t.sys, this.config = this.getConfig(), this.world, this.add, t.sys.events.once(f.BOOT, this.boot, this), t.sys.events.on(f.START, this.start, this); }, boot() { this.world = new g(this.scene, this.config), this.add = new a(this.world), this.systems.events.once(f.DESTROY, this.destroy, this); }, start() { this.world || (this.world = new g(this.scene, this.config), this.add = new a(this.world)); const t = this.systems.events; t.on(f.UPDATE, this.world.update, this.world), t.on(f.POST_UPDATE, this.world.postUpdate, this.world), t.once(f.SHUTDOWN, this.shutdown, this); }, getConfig() { const t = this.systems.game.config.physics; const e = this.systems.settings.physics; return l(h(e, 'arcade', {}), h(t, 'arcade', {})); }, overlap(t, e, i, n, s) { return void 0 === i && (i = null), void 0 === n && (n = null), void 0 === s && (s = i), this.world.collideObjects(t, e, i, n, s, !0); }, collide(t, e, i, n, s) { return void 0 === i && (i = null), void 0 === n && (n = null), void 0 === s && (s = i), this.world.collideObjects(t, e, i, n, s, !1); }, collideTiles(t, e, i, n, s) { return this.world.collideTiles(t, e, i, n, s); }, overlapTiles(t, e, i, n, s) { return this.world.overlapTiles(t, e, i, n, s); }, pause() { return this.world.pause(); }, resume() { return this.world.resume(); }, accelerateTo(t, e, i, n, s, r) { void 0 === n && (n = 60); const o = Math.atan2(i - t.y, e - t.x); return t.body.acceleration.setToPolar(o, n), void 0 !== s && void 0 !== r && t.body.maxVelocity.set(s, r), o; }, accelerateToObject(t, e, i, n, s) { return this.accelerateTo(t, e.x, e.y, i, n, s); }, closest(t, e) { e || (e = this.world.bodies.entries); for (var i = Number.MAX_VALUE, n = null, s = t.x, r = t.y, a = e.length, h = 0; h < a; h++) { const l = e[h]; const u = l.body || l; if (t !== l && t !== u && t !== u.gameObject && t !== u.center) { const c = o(s, r, u.center.x, u.center.y); c < i && (n = l, i = c); } } return n; }, furthest(t, e) { e || (e = this.world.bodies.entries); for (var i = -1, n = null, s = t.x, r = t.y, a = e.length, h = 0; h < a; h++) { const l = e[h]; const u = l.body || l; if (t !== l && t !== u && t !== u.gameObject && t !== u.center) { const c = o(s, r, u.center.x, u.center.y); c > i && (n = l, i = c); } } return n; }, moveTo(t, e, i, n, s) { void 0 === n && (n = 60), void 0 === s && (s = 0); const o = Math.atan2(i - t.y, e - t.x); return s > 0 && (n = r(t.x, t.y, e, i) / (s / 1e3)), t.body.velocity.setToPolar(o, n), o; }, moveToObject(t, e, i, n) { return this.moveTo(t, e.x, e.y, i, n); }, velocityFromAngle(t, e, i) { return void 0 === e && (e = 60), void 0 === i && (i = new p()), i.setToPolar(s(t), e); }, velocityFromRotation(t, e, i) { return void 0 === e && (e = 60), void 0 === i && (i = new p()), i.setToPolar(t, e); }, overlapRect(t, e, i, n, s, r) { return c(this.world, t, e, i, n, s, r); }, overlapCirc(t, e, i, n, s) { return u(this.world, t, e, i, n, s); }, shutdown() { if (this.world) { const t = this.systems.events; t.off(f.UPDATE, this.world.update, this.world), t.off(f.POST_UPDATE, this.world.postUpdate, this.world), t.off(f.SHUTDOWN, this.shutdown, this), this.add.destroy(), this.world.destroy(), this.add = null, this.world = null; } }, destroy() { this.shutdown(), this.scene.sys.events.off(f.START, this.start, this), this.scene = null, this.systems = null; },
  }); d.register('ArcadePhysics', v, 'arcadePhysics'), t.exports = v;
}, function (t, e) { t.exports = { setAcceleration(t, e) { return this.body.acceleration.set(t, e), this; }, setAccelerationX(t) { return this.body.acceleration.x = t, this; }, setAccelerationY(t) { return this.body.acceleration.y = t, this; } }; }, function (t, e) { t.exports = { setAngularVelocity(t) { return this.body.angularVelocity = t, this; }, setAngularAcceleration(t) { return this.body.angularAcceleration = t, this; }, setAngularDrag(t) { return this.body.angularDrag = t, this; } }; }, function (t, e) {
  t.exports = {
    setBounce(t, e) { return this.body.bounce.set(t, e), this; }, setBounceX(t) { return this.body.bounce.x = t, this; }, setBounceY(t) { return this.body.bounce.y = t, this; }, setCollideWorldBounds(t, e, i) { return this.body.setCollideWorldBounds(t, e, i), this; },
  };
}, function (t, e) {
  t.exports = {
    setDebug(t, e, i) { return this.debugShowBody = t, this.debugShowVelocity = e, this.debugBodyColor = i, this; }, setDebugBodyColor(t) { return this.body.debugBodyColor = t, this; }, debugShowBody: { get() { return this.body.debugShowBody; }, set(t) { this.body.debugShowBody = t; } }, debugShowVelocity: { get() { return this.body.debugShowVelocity; }, set(t) { this.body.debugShowVelocity = t; } }, debugBodyColor: { get() { return this.body.debugBodyColor; }, set(t) { this.body.debugBodyColor = t; } },
  };
}, function (t, e) {
  t.exports = {
    setDrag(t, e) { return this.body.drag.set(t, e), this; }, setDragX(t) { return this.body.drag.x = t, this; }, setDragY(t) { return this.body.drag.y = t, this; }, setDamping(t) { return this.body.useDamping = t, this; },
  };
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const i = { enableBody(t, e, i, n, s) { return t && this.body.reset(e, i), n && (this.body.gameObject.active = !0), s && (this.body.gameObject.visible = !0), this.body.enable = !0, this; }, disableBody(t, e) { return void 0 === t && (t = !1), void 0 === e && (e = !1), this.body.stop(), this.body.enable = !1, t && (this.body.gameObject.active = !1), e && (this.body.gameObject.visible = !1), this; }, refreshBody() { return this.body.updateFromGameObject(), this; } }; t.exports = i;
}, function (t, e) { t.exports = { setFriction(t, e) { return this.body.friction.set(t, e), this; }, setFrictionX(t) { return this.body.friction.x = t, this; }, setFrictionY(t) { return this.body.friction.y = t, this; } }; }, function (t, e) { t.exports = { setGravity(t, e) { return this.body.gravity.set(t, e), this; }, setGravityX(t) { return this.body.gravity.x = t, this; }, setGravityY(t) { return this.body.gravity.y = t, this; } }; }, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const i = { setImmovable(t) { return void 0 === t && (t = !0), this.body.immovable = t, this; } }; t.exports = i;
}, function (t, e) { t.exports = { setMass(t) { return this.body.mass = t, this; } }; }, function (t, e) { t.exports = { setOffset(t, e) { return this.body.setOffset(t, e), this; }, setSize(t, e, i) { return this.body.setSize(t, e, i), this; }, setCircle(t, e, i) { return this.body.setCircle(t, e, i), this; } }; }, function (t, e) {
  t.exports = {
    setVelocity(t, e) { return this.body.setVelocity(t, e), this; }, setVelocityX(t) { return this.body.setVelocityX(t), this; }, setVelocityY(t) { return this.body.setVelocityY(t), this; }, setMaxVelocity(t, e) { return this.body.maxVelocity.set(t, e), this; },
  };
}, function (t, e, i) { const n = i(496); const s = i(72); const r = i(223); const o = i(224); t.exports = function (t, e, i, a, h, l) { const u = n(t, e - a, i - a, 2 * a, 2 * a, h, l); if (u.length === 0) return u; for (var c = new s(e, i, a), d = new s(), f = [], p = 0; p < u.length; p++) { const g = u[p]; g.isCircle ? (d.setTo(g.center.x, g.center.y, g.halfWidth), r(c, d) && f.push(g)) : o(c, g) && f.push(g); } return f; }; }, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'collide';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'overlap';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'pause';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'resume';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'tilecollide';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'tileoverlap';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'worldbounds';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'worldstep';
}, function (t, e) { t.exports = function (t, e) { return t.collisionCallback ? !t.collisionCallback.call(t.collisionCallbackContext, e, t) : !t.layer.callbacks[t.index] || !t.layer.callbacks[t.index].callback.call(t.layer.callbacks[t.index].callbackContext, e, t); }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(1317); const s = i(1319); const r = i(503); t.exports = function (t, e, i, o, a, h, l) { const u = o.left; const c = o.top; const d = o.right; const f = o.bottom; let p = i.faceLeft || i.faceRight; let g = i.faceTop || i.faceBottom; if (l || (p = !0, g = !0), !p && !g) return !1; let v = 0; let m = 0; let y = 0; let x = 1; if (e.deltaAbsX() > e.deltaAbsY() ? y = -1 : e.deltaAbsX() < e.deltaAbsY() && (x = -1), e.deltaX() !== 0 && e.deltaY() !== 0 && p && g && (y = Math.min(Math.abs(e.position.x - d), Math.abs(e.right - u)), x = Math.min(Math.abs(e.position.y - f), Math.abs(e.bottom - c))), y < x) { if (p && (v = n(e, i, u, d, h, l)) !== 0 && !r(o, e)) return !0; g && (m = s(e, i, c, f, h, l)); } else { if (g && (m = s(e, i, c, f, h, l)) !== 0 && !r(o, e)) return !0; p && (v = n(e, i, u, d, h, l)); } return v !== 0 || m !== 0; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(1318); t.exports = function (t, e, i, s, r, o) { let a = 0; let h = e.faceLeft; let l = e.faceRight; let u = e.collideLeft; let c = e.collideRight; return o || (h = !0, l = !0, u = !0, c = !0), t.deltaX() < 0 && c && t.checkCollision.left ? l && t.x < s && (a = t.x - s) < -r && (a = 0) : t.deltaX() > 0 && u && t.checkCollision.right && h && t.right > i && (a = t.right - i) > r && (a = 0), a !== 0 && (t.customSeparateX ? t.overlapX = a : n(t, a)), a; };
}, function (t, e) { t.exports = function (t, e) { e < 0 ? (t.blocked.none = !1, t.blocked.left = !0) : e > 0 && (t.blocked.none = !1, t.blocked.right = !0), t.position.x -= e, t.bounce.x === 0 ? t.velocity.x = 0 : t.velocity.x = -t.velocity.x * t.bounce.x; }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(1320); t.exports = function (t, e, i, s, r, o) { let a = 0; let h = e.faceTop; let l = e.faceBottom; let u = e.collideUp; let c = e.collideDown; return o || (h = !0, l = !0, u = !0, c = !0), t.deltaY() < 0 && c && t.checkCollision.up ? l && t.y < s && (a = t.y - s) < -r && (a = 0) : t.deltaY() > 0 && u && t.checkCollision.down && h && t.bottom > i && (a = t.bottom - i) > r && (a = 0), a !== 0 && (t.customSeparateY ? t.overlapY = a : n(t, a)), a; };
}, function (t, e) { t.exports = function (t, e) { e < 0 ? (t.blocked.none = !1, t.blocked.up = !0) : e > 0 && (t.blocked.none = !1, t.blocked.down = !0), t.position.y -= e, t.bounce.y === 0 ? t.velocity.y = 0 : t.velocity.y = -t.velocity.y * t.bounce.y; }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(500); t.exports = function (t, e, i, s) { let r = n(t, e, i, s); if (i || r === 0 || t.immovable && e.immovable || t.customSeparateX || e.customSeparateX) return r !== 0 || t.embedded && e.embedded; const o = t.velocity.x; const a = e.velocity.x; if (t.immovable || e.immovable)t.immovable ? (e.x += r, e.velocity.x = o - a * e.bounce.x, t.moves && (e.y += (t.y - t.prev.y) * t.friction.y)) : (t.x -= r, t.velocity.x = a - o * t.bounce.x, e.moves && (t.y += (e.y - e.prev.y) * e.friction.y)); else { r *= 0.5, t.x -= r, e.x += r; let h = Math.sqrt(a * a * e.mass / t.mass) * (a > 0 ? 1 : -1); let l = Math.sqrt(o * o * t.mass / e.mass) * (o > 0 ? 1 : -1); const u = 0.5 * (h + l); h -= u, l -= u, t.velocity.x = u + h * t.bounce.x, e.velocity.x = u + l * e.bounce.x; } return !0; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(501); t.exports = function (t, e, i, s) { let r = n(t, e, i, s); if (i || r === 0 || t.immovable && e.immovable || t.customSeparateY || e.customSeparateY) return r !== 0 || t.embedded && e.embedded; const o = t.velocity.y; const a = e.velocity.y; if (t.immovable || e.immovable)t.immovable ? (e.y += r, e.velocity.y = o - a * e.bounce.y, t.moves && (e.x += (t.x - t.prev.x) * t.friction.x)) : (t.y -= r, t.velocity.y = a - o * t.bounce.y, e.moves && (t.x += (e.x - e.prev.x) * e.friction.x)); else { r *= 0.5, t.y -= r, e.y += r; let h = Math.sqrt(a * a * e.mass / t.mass) * (a > 0 ? 1 : -1); let l = Math.sqrt(o * o * t.mass / e.mass) * (o > 0 ? 1 : -1); const u = 0.5 * (h + l); h -= u, l -= u, t.velocity.y = u + h * t.bounce.y, e.velocity.y = u + l * e.bounce.y; } return !0; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = {
    BodyBounds: i(505), Factory: i(506), Image: i(508), Matter: i(243), MatterPhysics: i(1355), PolyDecomp: i(507), Sprite: i(509), TileBody: i(242), PhysicsEditorParser: i(239), PhysicsJSONParser: i(240), World: i(513),
  };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(152); const s = i(2); const r = i(3); t.exports = function (t, e, i, o) { void 0 === i && (i = {}), void 0 === o && (o = !0); const a = e.x; const h = e.y; if (e.body = { temp: !0, position: { x: a, y: h } }, [n.Bounce, n.Collision, n.Force, n.Friction, n.Gravity, n.Mass, n.Sensor, n.SetBody, n.Sleep, n.Static, n.Transform, n.Velocity].forEach(((t) => { for (const i in t)(n = t[i]).get && typeof n.get === 'function' || n.set && typeof n.set === 'function' ? Object.defineProperty(e, i, { get: t[i].get, set: t[i].set }) : Object.defineProperty(e, i, { value: t[i] }); let n; })), e.world = t, e._tempVec2 = new r(a, h), i.hasOwnProperty('type') && i.type === 'body')e.setExistingBody(i, o); else { let l = s(i, 'shape', null); l || (l = 'rectangle'), i.addToWorld = o, e.setBody(l, i); } return e; };
}, function (t, e) { t.exports = { setBounce(t) { return this.body.restitution = t, this; } }; }, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const i = {
    setCollisionCategory(t) { return this.body.collisionFilter.category = t, this; }, setCollisionGroup(t) { return this.body.collisionFilter.group = t, this; }, setCollidesWith(t) { let e = 0; if (Array.isArray(t)) for (let i = 0; i < t.length; i++)e |= t[i]; else e = t; return this.body.collisionFilter.mask = e, this; }, setOnCollide(t) { return this.body.onCollideCallback = t, this; }, setOnCollideEnd(t) { return this.body.onCollideEndCallback = t, this; }, setOnCollideActive(t) { return this.body.onCollideActiveCallback = t, this; }, setOnCollideWith(t, e) { Array.isArray(t) || (t = [t]); for (let i = 0; i < t.length; i++) { const n = t[i].hasOwnProperty('body') ? t[i].body : t[i]; this.body.setOnCollideWith(n, e); } return this; },
  }; t.exports = i;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(26); const s = {
    applyForce(t) { return this._tempVec2.set(this.body.position.x, this.body.position.y), n.applyForce(this.body, this._tempVec2, t), this; }, applyForceFrom(t, e) { return n.applyForce(this.body, t, e), this; }, thrust(t) { const e = this.body.angle; return this._tempVec2.set(t * Math.cos(e), t * Math.sin(e)), n.applyForce(this.body, { x: this.body.position.x, y: this.body.position.y }, this._tempVec2), this; }, thrustLeft(t) { const e = this.body.angle - Math.PI / 2; return this._tempVec2.set(t * Math.cos(e), t * Math.sin(e)), n.applyForce(this.body, { x: this.body.position.x, y: this.body.position.y }, this._tempVec2), this; }, thrustRight(t) { const e = this.body.angle + Math.PI / 2; return this._tempVec2.set(t * Math.cos(e), t * Math.sin(e)), n.applyForce(this.body, { x: this.body.position.x, y: this.body.position.y }, this._tempVec2), this; }, thrustBack(t) { const e = this.body.angle - Math.PI; return this._tempVec2.set(t * Math.cos(e), t * Math.sin(e)), n.applyForce(this.body, { x: this.body.position.x, y: this.body.position.y }, this._tempVec2), this; },
  }; t.exports = s;
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const i = { setFriction(t, e, i) { return this.body.friction = t, void 0 !== e && (this.body.frictionAir = e), void 0 !== i && (this.body.frictionStatic = i), this; }, setFrictionAir(t) { return this.body.frictionAir = t, this; }, setFrictionStatic(t) { return this.body.frictionStatic = t, this; } }; t.exports = i;
}, function (t, e) { t.exports = { setIgnoreGravity(t) { return this.body.ignoreGravity = t, this; } }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(26); const s = i(3); const r = { setMass(t) { return n.setMass(this.body, t), this; }, setDensity(t) { return n.setDensity(this.body, t), this; }, centerOfMass: { get() { return new s(this.body.centerOfMass.x, this.body.centerOfMass.y); } } }; t.exports = r;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(26); const s = { setStatic(t) { return n.setStatic(this.body, t), this; }, isStatic() { return this.body.isStatic; } }; t.exports = s;
}, function (t, e) { t.exports = { setSensor(t) { return this.body.isSensor = t, this; }, isSensor() { return this.body.isSensor; } }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(44); const s = i(26); const r = i(98); const o = i(2); const a = i(239); const h = i(240); const l = i(32); const u = {
    setRectangle(t, e, i) { return this.setBody({ type: 'rectangle', width: t, height: e }, i); },
    setCircle(t, e) { return this.setBody({ type: 'circle', radius: t }, e); },
    setPolygon(t, e, i) { return this.setBody({ type: 'polygon', sides: e, radius: t }, i); },
    setTrapezoid(t, e, i, n) {
      return this.setBody({
        type: 'trapezoid', width: t, height: e, slope: i,
      }, n);
    },
    setExistingBody(t, e) { void 0 === e && (e = !0), this.body && this.world.remove(this.body, !0), this.body = t; for (let i = 0; i < t.parts.length; i++)t.parts[i].gameObject = this; const n = this; if (t.destroy = function () { n.world.remove(n.body, !0), n.body.gameObject = null; }, e && (this.world.has(t) && this.world.remove(t, !0), this.world.add(t)), this._originComponent) { const s = t.render.sprite.xOffset; const o = t.render.sprite.yOffset; const a = t.centerOfMass.x; const h = t.centerOfMass.y; if (r(a, 0.5) && r(h, 0.5)) this.setOrigin(s + 0.5, o + 0.5); else { const l = t.centerOffset.x; const u = t.centerOffset.y; this.setOrigin(s + l / this.displayWidth, o + u / this.displayHeight); } } return this; },
    setBody(t, e) { if (!t) return this; let i; typeof t === 'string' && (t = { type: t }); const r = o(t, 'type', 'rectangle'); const u = o(t, 'x', this._tempVec2.x); const c = o(t, 'y', this._tempVec2.y); const d = o(t, 'width', this.width); const f = o(t, 'height', this.height); switch (r) { case 'rectangle': i = n.rectangle(u, c, d, f, e); break; case 'circle': var p = o(t, 'radius', Math.max(d, f) / 2); var g = o(t, 'maxSides', 25); i = n.circle(u, c, p, e, g); break; case 'trapezoid': var v = o(t, 'slope', 0.5); i = n.trapezoid(u, c, d, f, v, e); break; case 'polygon': var m = o(t, 'sides', 5); var y = o(t, 'radius', Math.max(d, f) / 2); i = n.polygon(u, c, m, y, e); break; case 'fromVertices': case 'fromVerts': var x = o(t, 'verts', null); if (x) if (typeof x === 'string' && (x = l.fromPath(x)), this.body && !this.body.hasOwnProperty('temp'))s.setVertices(this.body, x), i = this.body; else { const T = o(t, 'flagInternal', !1); const w = o(t, 'removeCollinear', 0.01); const b = o(t, 'minimumArea', 10); i = n.fromVertices(u, c, x, e, T, w, b); } break; case 'fromPhysicsEditor': i = a.parseBody(u, c, t, e); break; case 'fromPhysicsTracer': i = h.parseBody(u, c, t, e); } return i && this.setExistingBody(i, t.addToWorld), this; },
  }; t.exports = u;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(241); const s = i(94); const r = i(95); const o = {
    setToSleep() { s.set(this.body, !0); }, setAwake() { s.set(this.body, !1); }, setSleepThreshold(t) { return void 0 === t && (t = 60), this.body.sleepThreshold = t, this; }, setSleepEvents(t, e) { return this.setSleepStartEvent(t), this.setSleepEndEvent(e), this; }, setSleepStartEvent(t) { if (t) { const e = this.world; r.on(this.body, 'sleepStart', (function (t) { e.emit(n.SLEEP_START, t, this); })); } else r.off(this.body, 'sleepStart'); return this; }, setSleepEndEvent(t) { if (t) { const e = this.world; r.on(this.body, 'sleepEnd', (function (t) { e.emit(n.SLEEP_END, t, this); })); } else r.off(this.body, 'sleepEnd'); return this; },
  }; t.exports = o;
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'afteradd';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'afterremove';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'afterupdate';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'beforeadd';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'beforeremove';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'beforeupdate';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'collisionactive';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'collisionend';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'collisionstart';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'dragend';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'drag';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'dragstart';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'pause';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'resume';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'sleepend';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'sleepstart';
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(26); const s = i(16); const r = i(170); const o = i(171); const a = {
    x: { get() { return this.body.position.x; }, set(t) { this._tempVec2.set(t, this.y), n.setPosition(this.body, this._tempVec2); } }, y: { get() { return this.body.position.y; }, set(t) { this._tempVec2.set(this.x, t), n.setPosition(this.body, this._tempVec2); } }, scaleX: { get() { return this._scaleX; }, set(t) { const e = 1 / this._scaleX; const i = 1 / this._scaleY; this._scaleX = t, this._scaleX === 0 ? this.renderFlags &= -5 : this.renderFlags |= 4, n.scale(this.body, e, i), n.scale(this.body, t, this._scaleY); } }, scaleY: { get() { return this._scaleY; }, set(t) { const e = 1 / this._scaleX; const i = 1 / this._scaleY; this._scaleY = t, this._scaleY === 0 ? this.renderFlags &= -5 : this.renderFlags |= 4, n.scale(this.body, e, i), n.scale(this.body, this._scaleX, t); } }, angle: { get() { return o(this.body.angle * s.RAD_TO_DEG); }, set(t) { this.rotation = o(t) * s.DEG_TO_RAD; } }, rotation: { get() { return this.body.angle; }, set(t) { this._rotation = r(t), n.setAngle(this.body, this._rotation); } }, setPosition(t, e) { return void 0 === t && (t = 0), void 0 === e && (e = t), this._tempVec2.set(t, e), n.setPosition(this.body, this._tempVec2), this; }, setRotation(t) { return void 0 === t && (t = 0), this._rotation = r(t), n.setAngle(this.body, t), this; }, setFixedRotation() { return n.setInertia(this.body, 1 / 0), this; }, setAngle(t) { return void 0 === t && (t = 0), this.angle = t, n.setAngle(this.body, this.rotation), this; }, setScale(t, e, i) { void 0 === t && (t = 1), void 0 === e && (e = t); const s = 1 / this._scaleX; const r = 1 / this._scaleY; return this._scaleX = t, this._scaleY = e, n.scale(this.body, s, r, i), n.scale(this.body, t, e, i), this; },
  }; t.exports = a;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(26); const s = {
    setAngularVelocity(t) { return n.setAngularVelocity(this.body, t), this; }, setVelocityX(t) { return this._tempVec2.set(t, this.body.velocity.y), n.setVelocity(this.body, this._tempVec2), this; }, setVelocityY(t) { return this._tempVec2.set(this.body.velocity.x, t), n.setVelocity(this.body, this._tempVec2), this; }, setVelocity(t, e) { return this._tempVec2.set(t, e), n.setVelocity(this.body, this._tempVec2), this; },
  }; t.exports = s;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(38); const s = i(0); const r = i(69); const o = i(80); const a = i(153); const h = i(241); const l = i(57); const u = i(106); const c = i(94); const d = i(3); const f = i(32); const p = new s({
    initialize(t, e, i) {
      void 0 === i && (i = {}); this.scene = t, this.world = e, this.camera = null, this.pointer = null, this.active = !0, this.position = new d(), this.body = null, this.part = null, this.constraint = o.create(u(i, {
        label: 'Pointer Constraint', pointA: { x: 0, y: 0 }, pointB: { x: 0, y: 0 }, length: 0.01, stiffness: 0.1, angularStiffness: 1, collisionFilter: { category: 1, mask: 4294967295, group: 0 },
      })), this.world.on(h.BEFORE_UPDATE, this.update, this), t.sys.input.on(l.POINTER_DOWN, this.onDown, this), t.sys.input.on(l.POINTER_UP, this.onUp, this);
    },
    onDown(t) { this.pointer || (this.pointer = t, this.camera = t.camera); },
    onUp(t) { t === this.pointer && (this.pointer = null); },
    getBody(t) { const e = this.position; const i = this.constraint; this.camera.getWorldPoint(t.x, t.y, e); for (let s = r.allBodies(this.world.localWorld), o = 0; o < s.length; o++) { const l = s[o]; if (!l.ignorePointer && n.contains(l.bounds, e) && a.canCollide(l.collisionFilter, i.collisionFilter) && this.hitTestBody(l, e)) return this.world.emit(h.DRAG_START, l, this.part, this), !0; } return !1; },
    hitTestBody(t, e) { for (let i = this.constraint, n = t.parts.length, s = n > 1 ? 1 : 0; s < n; s++) { const r = t.parts[s]; if (f.contains(r.vertices, e)) return i.pointA = e, i.pointB = { x: e.x - t.position.x, y: e.y - t.position.y }, i.bodyB = t, i.angleB = t.angle, c.set(t, !1), this.part = r, this.body = t, !0; } return !1; },
    update() { const t = this.pointer; let e = this.body; if (this.active && t) if (t.isDown || !e) { if (t.isDown) { if (!e && !this.getBody(t)) return; e = this.body; const i = this.position; const n = this.constraint; this.camera.getWorldPoint(t.x, t.y, i), n.pointA.x = i.x, n.pointA.y = i.y, c.set(e, !1), this.world.emit(h.DRAG, e, this); } } else this.stopDrag(); else e && this.stopDrag(); },
    stopDrag() { const t = this.body; const e = this.constraint; e.bodyB = null, e.pointB = null, this.pointer = null, this.body = null, this.part = null, t && this.world.emit(h.DRAG_END, t, this); },
    destroy() { this.world.removeConstraint(this.constraint), this.pointer = null, this.constraint = null, this.body = null, this.part = null, this.world.off(h.BEFORE_UPDATE, this.update), this.scene.sys.input.off(l.POINTER_DOWN, this.onDown, this), this.scene.sys.input.off(l.POINTER_UP, this.onUp, this); },
  }); t.exports = p;
}, function (t, e, i) {
  const n = {}; t.exports = n; const s = i(69); const r = i(21); n.create = function (t) {
    return r.extend({
      extended: !1, narrowDetections: 0, narrowphaseTests: 0, narrowReuse: 0, narrowReuseCount: 0, midphaseTests: 0, broadphaseTests: 0, narrowEff: 1e-4, midEff: 1e-4, broadEff: 1e-4, collisions: 0, buckets: 0, bodies: 0, pairs: 0,
    }, !1, t);
  }, n.reset = function (t) { t.extended && (t.narrowDetections = 0, t.narrowphaseTests = 0, t.narrowReuse = 0, t.narrowReuseCount = 0, t.midphaseTests = 0, t.broadphaseTests = 0, t.narrowEff = 0, t.midEff = 0, t.broadEff = 0, t.collisions = 0, t.buckets = 0, t.pairs = 0, t.bodies = 0); }, n.update = function (t, e) { if (t.extended) { const i = e.world; const n = s.allBodies(i); t.collisions = t.narrowDetections, t.pairs = e.pairs.list.length, t.bodies = n.length, t.midEff = (t.narrowDetections / (t.midphaseTests || 1)).toFixed(2), t.narrowEff = (t.narrowDetections / (t.narrowphaseTests || 1)).toFixed(2), t.broadEff = (1 - t.broadphaseTests / (n.length || 1)).toFixed(2), t.narrowReuse = (t.narrowReuseCount / (t.narrowphaseTests || 1)).toFixed(2); } };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(96); const s = i(151); const r = i(44); const o = i(26); const a = i(505); const h = i(38); const l = i(0); const u = i(69); const c = i(237); const d = i(80); const f = i(153); const p = i(56); const g = i(506); const v = i(2); const m = i(6); const y = i(246); const x = i(1356); const T = i(1357); const w = i(510); const b = i(1358); const E = i(106); const S = i(115); const A = i(247); const _ = i(244); const C = i(23); const M = i(511); const P = i(248); const O = i(154); const R = i(24); const L = i(238); const D = i(37); const k = i(32); const F = i(513); const I = new l({
    initialize(t) { this.scene = t, this.systems = t.sys, this.config = this.getConfig(), this.world, this.add, this.bodyBounds, this.body = o, this.composite = u, this.detector = f, this.grid = y, this.pair = S, this.pairs = A, this.query = M, this.resolver = P, this.sat = O, this.constraint = d, this.bodies = r, this.composites = c, this.axes = s, this.bounds = h, this.svg = L, this.vector = D, this.vertices = k, this.verts = k, this._tempVec2 = D.create(), m(this.config, 'plugins.collisionevents', !0) && this.enableCollisionEventsPlugin(), m(this.config, 'plugins.attractors', !1) && this.enableAttractorPlugin(), m(this.config, 'plugins.wrap', !1) && this.enableWrapPlugin(), P._restingThresh = m(this.config, 'restingThresh', 4), P._restingThreshTangent = m(this.config, 'restingThreshTangent', 6), P._positionDampen = m(this.config, 'positionDampen', 0.9), P._positionWarming = m(this.config, 'positionWarming', 0.8), P._frictionNormalMultiplier = m(this.config, 'frictionNormalMultiplier', 5), t.sys.events.once(R.BOOT, this.boot, this), t.sys.events.on(R.START, this.start, this); }, boot() { this.world = new F(this.scene, this.config), this.add = new g(this.world), this.bodyBounds = new a(), this.systems.events.once(R.DESTROY, this.destroy, this); }, start() { this.world || (this.world = new F(this.scene, this.config), this.add = new g(this.world)); const t = this.systems.events; t.on(R.UPDATE, this.world.update, this.world), t.on(R.POST_UPDATE, this.world.postUpdate, this.world), t.once(R.SHUTDOWN, this.shutdown, this); }, getConfig() { const t = this.systems.game.config.physics; const e = this.systems.settings.physics; return E(v(e, 'matter', {}), v(t, 'matter', {})); }, enableAttractorPlugin() { return _.register(x), _.use(w, x), this; }, enableWrapPlugin() { return _.register(b), _.use(w, b), this; }, enableCollisionEventsPlugin() { return _.register(T), _.use(w, T), this; }, pause() { return this.world.pause(); }, resume() { return this.world.resume(); }, set60Hz() { return this.world.getDelta = this.world.update60Hz, this.world.autoUpdate = !0, this; }, set30Hz() { return this.world.getDelta = this.world.update30Hz, this.world.autoUpdate = !0, this; }, step(t, e) { this.world.step(t, e); }, containsPoint(t, e, i) { t = this.getMatterBodies(t); const n = D.create(e, i); return M.point(t, n).length > 0; }, intersectPoint(t, e, i) { i = this.getMatterBodies(i); const n = D.create(t, e); const s = []; return M.point(i, n).forEach(((t) => { s.indexOf(t) === -1 && s.push(t); })), s; }, intersectRect(t, e, i, n, s, r) { void 0 === s && (s = !1), r = this.getMatterBodies(r); const o = { min: { x: t, y: e }, max: { x: t + i, y: e + n } }; const a = []; return M.region(r, o, s).forEach(((t) => { a.indexOf(t) === -1 && a.push(t); })), a; }, intersectRay(t, e, i, n, s, r) { void 0 === s && (s = 1), r = this.getMatterBodies(r); for (var o = [], a = M.ray(r, D.create(t, e), D.create(i, n), s), h = 0; h < a.length; h++)o.push(a[h].body); return o; }, intersectBody(t, e) { e = this.getMatterBodies(e); for (var i = [], n = M.collides(t, e), s = 0; s < n.length; s++) { const r = n[s]; r.bodyA === t ? i.push(r.bodyB) : i.push(r.bodyA); } return i; }, overlap(t, e, i, n, s) { void 0 === i && (i = null), void 0 === n && (n = null), void 0 === s && (s = i), Array.isArray(t) || (t = [t]), t = this.getMatterBodies(t), e = this.getMatterBodies(e); for (var r = !1, o = 0; o < t.length; o++) for (let a = t[o], h = M.collides(a, e), l = 0; l < h.length; l++) { const u = h[l]; const c = u.bodyA.id === a.id ? u.bodyB : u.bodyA; if (!n || n.call(s, a, c, u)) if (r = !0, i)i.call(s, a, c, u); else if (!n) return !0; } return r; }, setCollisionCategory(t, e) { return (t = this.getMatterBodies(t)).forEach(((t) => { t.collisionFilter.category = e; })), this; }, setCollisionGroup(t, e) { return (t = this.getMatterBodies(t)).forEach(((t) => { t.collisionFilter.group = e; })), this; }, setCollidesWith(t, e) { t = this.getMatterBodies(t); let i = 0; if (Array.isArray(e)) for (let n = 0; n < e.length; n++)i |= e[n]; else i = e; return t.forEach(((t) => { t.collisionFilter.mask = i; })), this; }, getMatterBodies(t) { if (!t) return this.world.getAllBodies(); Array.isArray(t) || (t = [t]); for (var e = [], i = 0; i < t.length; i++) { const n = t[i].hasOwnProperty('body') ? t[i].body : t[i]; e.push(n); } return e; }, setVelocity(t, e, i) { t = this.getMatterBodies(t); const n = this._tempVec2; return n.x = e, n.y = i, t.forEach(((t) => { o.setVelocity(t, n); })), this; }, setVelocityX(t, e) { t = this.getMatterBodies(t); const i = this._tempVec2; return i.x = e, t.forEach(((t) => { i.y = t.velocity.y, o.setVelocity(t, i); })), this; }, setVelocityY(t, e) { t = this.getMatterBodies(t); const i = this._tempVec2; return i.y = e, t.forEach(((t) => { i.x = t.velocity.x, o.setVelocity(t, i); })), this; }, setAngularVelocity(t, e) { return (t = this.getMatterBodies(t)).forEach(((t) => { o.setAngularVelocity(t, e); })), this; }, applyForce(t, e) { t = this.getMatterBodies(t); const i = this._tempVec2; return t.forEach(((t) => { i.x = t.position.x, i.y = t.position.y, o.applyForce(t, i, e); })), this; }, applyForceFromPosition(t, e, i, n) { t = this.getMatterBodies(t); const s = this._tempVec2; return t.forEach(((t) => { void 0 === n && (n = t.angle), s.x = i * Math.cos(n), s.y = i * Math.sin(n), o.applyForce(t, e, s); })), this; }, applyForceFromAngle(t, e, i) { t = this.getMatterBodies(t); const n = this._tempVec2; return t.forEach(((t) => { void 0 === i && (i = t.angle), n.x = e * Math.cos(i), n.y = e * Math.sin(i), o.applyForce(t, { x: t.position.x, y: t.position.y }, n); })), this; }, getConstraintLength(t) { let e = t.pointA.x; let i = t.pointA.y; let n = t.pointB.x; let s = t.pointB.y; return t.bodyA && (e += t.bodyA.position.x, i += t.bodyA.position.y), t.bodyB && (n += t.bodyB.position.x, s += t.bodyB.position.y), p(e, i, n, s); }, alignBody(t, e, i, s) { let r; switch (t = t.hasOwnProperty('body') ? t.body : t, s) { case n.TOP_LEFT: case n.LEFT_TOP: r = this.bodyBounds.getTopLeft(t, e, i); break; case n.TOP_CENTER: r = this.bodyBounds.getTopCenter(t, e, i); break; case n.TOP_RIGHT: case n.RIGHT_TOP: r = this.bodyBounds.getTopRight(t, e, i); break; case n.LEFT_CENTER: r = this.bodyBounds.getLeftCenter(t, e, i); break; case n.CENTER: r = this.bodyBounds.getCenter(t, e, i); break; case n.RIGHT_CENTER: r = this.bodyBounds.getRightCenter(t, e, i); break; case n.LEFT_BOTTOM: case n.BOTTOM_LEFT: r = this.bodyBounds.getBottomLeft(t, e, i); break; case n.BOTTOM_CENTER: r = this.bodyBounds.getBottomCenter(t, e, i); break; case n.BOTTOM_RIGHT: case n.RIGHT_BOTTOM: r = this.bodyBounds.getBottomRight(t, e, i); } return r && o.setPosition(t, r), this; }, shutdown() { const t = this.systems.events; this.world && (t.off(R.UPDATE, this.world.update, this.world), t.off(R.POST_UPDATE, this.world.postUpdate, this.world)), t.off(R.SHUTDOWN, this.shutdown, this), this.add && this.add.destroy(), this.world && this.world.destroy(), this.add = null, this.world = null; }, destroy() { this.shutdown(), this.scene.sys.events.off(R.START, this.start, this), this.scene = null, this.systems = null; },
  }); C.register('MatterPhysics', I, 'matterPhysics'), t.exports = I;
}, function (t, e, i) {
  const n = i(243); var s = {
    name: 'matter-attractors', version: '0.1.7', for: 'matter-js@^0.14.2', silent: !0, install(t) { t.after('Body.create', (function () { s.Body.init(this); })), t.before('Engine.update', ((t) => { s.Engine.update(t); })); }, Body: { init(t) { t.plugin.attractors = t.plugin.attractors || []; } }, Engine: { update(t) { for (let e = t.world, i = n.Composite.allBodies(e), s = 0; s < i.length; s += 1) { const r = i[s]; const o = r.plugin.attractors; if (o && o.length > 0) for (let a = s + 1; a < i.length; a += 1) for (let h = i[a], l = 0; l < o.length; l += 1) { const u = o[l]; let c = u; n.Common.isFunction(u) && (c = u(r, h)), c && n.Body.applyForce(h, h.position, c); } } } }, Attractors: { gravityConstant: 0.001, gravity(t, e) { const i = n.Vector.sub(e.position, t.position); const r = n.Vector.magnitudeSquared(i) || 1e-4; const o = n.Vector.normalise(i); const a = -s.Attractors.gravityConstant * (t.mass * e.mass / r); const h = n.Vector.mult(o, a); n.Body.applyForce(t, t.position, n.Vector.neg(h)), n.Body.applyForce(e, e.position, h); } },
  }; t.exports = s;
}, function (t, e) {
  t.exports = {
    name: 'matter-collision-events', version: '0.1.6', for: 'matter-js@^0.14.2', silent: !0, install(t) { t.after('Engine.create', (function () { t.Events.on(this, 'collisionStart', ((e) => { e.pairs.map(((e) => { const i = e.bodyA; const n = e.bodyB; i.gameObject && i.gameObject.emit('collide', i, n, e), n.gameObject && n.gameObject.emit('collide', n, i, e), t.Events.trigger(i, 'onCollide', { pair: e }), t.Events.trigger(n, 'onCollide', { pair: e }), i.onCollideCallback && i.onCollideCallback(e), n.onCollideCallback && n.onCollideCallback(e), i.onCollideWith[n.id] && i.onCollideWith[n.id](n, e), n.onCollideWith[i.id] && n.onCollideWith[i.id](i, e); })); })), t.Events.on(this, 'collisionActive', ((e) => { e.pairs.map(((e) => { const i = e.bodyA; const n = e.bodyB; i.gameObject && i.gameObject.emit('collideActive', i, n, e), n.gameObject && n.gameObject.emit('collideActive', n, i, e), t.Events.trigger(i, 'onCollideActive', { pair: e }), t.Events.trigger(n, 'onCollideActive', { pair: e }), i.onCollideActiveCallback && i.onCollideActiveCallback(e), n.onCollideActiveCallback && n.onCollideActiveCallback(e); })); })), t.Events.on(this, 'collisionEnd', ((e) => { e.pairs.map(((e) => { const i = e.bodyA; const n = e.bodyB; i.gameObject && i.gameObject.emit('collideEnd', i, n, e), n.gameObject && n.gameObject.emit('collideEnd', n, i, e), t.Events.trigger(i, 'onCollideEnd', { pair: e }), t.Events.trigger(n, 'onCollideEnd', { pair: e }), i.onCollideEndCallback && i.onCollideEndCallback(e), n.onCollideEndCallback && n.onCollideEndCallback(e); })); })); })); },
  };
}, function (t, e, i) {
  const n = i(243); var s = {
    name: 'matter-wrap', version: '0.1.4', for: 'matter-js@^0.14.2', silent: !0, install(t) { t.after('Engine.update', (function () { s.Engine.update(this); })); }, Engine: { update(t) { for (var e = t.world, i = n.Composite.allBodies(e), r = n.Composite.allComposites(e), o = 0; o < i.length; o += 1) { const a = i[o]; a.plugin.wrap && s.Body.wrap(a, a.plugin.wrap); } for (o = 0; o < r.length; o += 1) { const h = r[o]; h.plugin.wrap && s.Composite.wrap(h, h.plugin.wrap); } } }, Bounds: { wrap(t, e) { let i = null; let n = null; if (void 0 !== e.min.x && void 0 !== e.max.x && (t.min.x > e.max.x ? i = e.min.x - t.max.x : t.max.x < e.min.x && (i = e.max.x - t.min.x)), void 0 !== e.min.y && void 0 !== e.max.y && (t.min.y > e.max.y ? n = e.min.y - t.max.y : t.max.y < e.min.y && (n = e.max.y - t.min.y)), i !== null || n !== null) return { x: i || 0, y: n || 0 }; } }, Body: { wrap(t, e) { const i = s.Bounds.wrap(t.bounds, e); return i && n.Body.translate(t, i), i; } }, Composite: { bounds(t) { for (var e = n.Composite.allBodies(t), i = [], s = 0; s < e.length; s += 1) { const r = e[s]; i.push(r.bounds.min, r.bounds.max); } return n.Bounds.create(i); }, wrap(t, e) { const i = s.Bounds.wrap(s.Composite.bounds(t), e); return i && n.Composite.translate(t, i), i; } },
  }; t.exports = s;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = {
    BasePlugin: i(514), DefaultPlugins: i(190), PluginCache: i(23), PluginManager: i(402), ScenePlugin: i(1360),
  };
}, function (t, e, i) {
/**
* @author       Richard Davey <rich@photonstorm.com>
* @copyright    2020 Photon Storm Ltd.
* @license      {@link https://github.com/photonstorm/phaser3-plugin-template/blob/master/LICENSE|MIT License}
*/
  const n = i(514); const s = i(0); const r = i(24); const o = new s({
    Extends: n, initialize(t, e) { n.call(this, e), this.scene = t, this.systems = t.sys, t.sys.events.once(r.BOOT, this.boot, this); }, boot() {}, destroy() { this.pluginManager = null, this.game = null, this.scene = null, this.systems = null; },
  }); t.exports = o;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = { Canvas: i(1362), Snapshot: i(1363), WebGL: i(1364) };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = { CanvasRenderer: i(364), GetBlendModes: i(366), SetTransform: i(31) };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = { Canvas: i(365), WebGL: i(368) };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = {
    Utils: i(11), WebGLPipeline: i(133), WebGLRenderer: i(367), Pipelines: i(1365), BYTE: 0, SHORT: 1, UNSIGNED_BYTE: 2, UNSIGNED_SHORT: 3, FLOAT: 4,
  };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = {
    BitmapMaskPipeline: i(369), ForwardDiffuseLightPipeline: i(370), TextureTintPipeline: i(191), TextureTintStripPipeline: i(373), ModelViewProjection: i(192),
  };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(19); const s = i(194); let r = {
    Center: i(391), Events: i(104), Orientation: i(392), ScaleManager: i(403), ScaleModes: i(393), Zoom: i(394),
  }; r = n(!1, r, s.CENTER), r = n(!1, r, s.ORIENTATION), r = n(!1, r, s.SCALE_MODE), r = n(!1, r, s.ZOOM), t.exports = r;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(137); const s = i(19); let r = {
    Events: i(24), SceneManager: i(405), ScenePlugin: i(1368), Settings: i(407), Systems: i(197),
  }; r = s(!1, r, n), t.exports = r;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(20); const s = i(0); const r = i(24); const o = i(2); const a = i(23); const h = new s({
    initialize(t) { this.scene = t, this.systems = t.sys, this.settings = t.sys.settings, this.key = t.sys.settings.key, this.manager = t.sys.game.scene, this.transitionProgress = 0, this._elapsed = 0, this._target = null, this._duration = 0, this._onUpdate, this._onUpdateScope, this._willSleep = !1, this._willRemove = !1, t.sys.events.once(r.BOOT, this.boot, this), t.sys.events.on(r.START, this.pluginStart, this); }, boot() { this.systems.events.once(r.DESTROY, this.destroy, this); }, pluginStart() { this._target = null, this.systems.events.once(r.SHUTDOWN, this.shutdown, this); }, start(t, e) { return void 0 === t && (t = this.key), this.manager.queueOp('stop', this.key), this.manager.queueOp('start', t, e), this; }, restart(t) { const e = this.key; return this.manager.queueOp('stop', e), this.manager.queueOp('start', e, t), this; }, transition(t) { void 0 === t && (t = {}); const e = o(t, 'target', !1); const i = this.manager.getScene(e); if (!e || !this.checkValidTransition(i)) return !1; const n = o(t, 'duration', 1e3); this._elapsed = 0, this._target = i, this._duration = n, this._willSleep = o(t, 'sleep', !1), this._willRemove = o(t, 'remove', !1); const s = o(t, 'onUpdate', null); s && (this._onUpdate = s, this._onUpdateScope = o(t, 'onUpdateScope', this.scene)); const a = o(t, 'allowInput', !1); this.settings.transitionAllowInput = a; const h = i.sys.settings; return h.isTransition = !0, h.transitionFrom = this.scene, h.transitionDuration = n, h.transitionAllowInput = a, o(t, 'moveAbove', !1) ? this.manager.moveAbove(this.key, e) : o(t, 'moveBelow', !1) && this.manager.moveBelow(this.key, e), i.sys.isSleeping() ? i.sys.wake(o(t, 'data')) : this.manager.start(e, o(t, 'data')), this.systems.events.emit(r.TRANSITION_OUT, i, n), this.systems.events.on(r.UPDATE, this.step, this), !0; }, checkValidTransition(t) { return !(!t || t.sys.isActive() || t.sys.isTransitioning() || t === this.scene || this.systems.isTransitioning()); }, step(t, e) { this._elapsed += e, this.transitionProgress = n(this._elapsed / this._duration, 0, 1), this._onUpdate && this._onUpdate.call(this._onUpdateScope, this.transitionProgress), this._elapsed >= this._duration && this.transitionComplete(); }, transitionComplete() { const t = this._target.sys; const e = this._target.sys.settings; this.systems.events.off(r.UPDATE, this.step, this), t.events.emit(r.TRANSITION_COMPLETE, this.scene), e.isTransition = !1, e.transitionFrom = null, this._duration = 0, this._target = null, this._onUpdate = null, this._onUpdateScope = null, this._willRemove ? this.manager.remove(this.key) : this._willSleep ? this.systems.sleep() : this.manager.stop(this.key); }, add(t, e, i, n) { return this.manager.add(t, e, i, n); }, launch(t, e) { return t && t !== this.key && this.manager.queueOp('start', t, e), this; }, run(t, e) { return t && t !== this.key && this.manager.queueOp('run', t, e), this; }, pause(t, e) { return void 0 === t && (t = this.key), this.manager.queueOp('pause', t, e), this; }, resume(t, e) { return void 0 === t && (t = this.key), this.manager.queueOp('resume', t, e), this; }, sleep(t, e) { return void 0 === t && (t = this.key), this.manager.queueOp('sleep', t, e), this; }, wake(t, e) { return void 0 === t && (t = this.key), this.manager.queueOp('wake', t, e), this; }, switch(t) { return t !== this.key && this.manager.queueOp('switch', this.key, t), this; }, stop(t, e) { return void 0 === t && (t = this.key), this.manager.queueOp('stop', t, e), this; }, setActive(t, e, i) { void 0 === e && (e = this.key); const n = this.manager.getScene(e); return n && n.sys.setActive(t, i), this; }, setVisible(t, e) { void 0 === e && (e = this.key); const i = this.manager.getScene(e); return i && i.sys.setVisible(t), this; }, isSleeping(t) { return void 0 === t && (t = this.key), this.manager.isSleeping(t); }, isActive(t) { return void 0 === t && (t = this.key), this.manager.isActive(t); }, isPaused(t) { return void 0 === t && (t = this.key), this.manager.isPaused(t); }, isVisible(t) { return void 0 === t && (t = this.key), this.manager.isVisible(t); }, swapPosition(t, e) { return void 0 === e && (e = this.key), t !== e && this.manager.swapPosition(t, e), this; }, moveAbove(t, e) { return void 0 === e && (e = this.key), t !== e && this.manager.moveAbove(t, e), this; }, moveBelow(t, e) { return void 0 === e && (e = this.key), t !== e && this.manager.moveBelow(t, e), this; }, remove(t) { return void 0 === t && (t = this.key), this.manager.remove(t), this; }, moveUp(t) { return void 0 === t && (t = this.key), this.manager.moveUp(t), this; }, moveDown(t) { return void 0 === t && (t = this.key), this.manager.moveDown(t), this; }, bringToTop(t) { return void 0 === t && (t = this.key), this.manager.bringToTop(t), this; }, sendToBack(t) { return void 0 === t && (t = this.key), this.manager.sendToBack(t), this; }, get(t) { return this.manager.getScene(t); }, getIndex(t) { return void 0 === t && (t = this.key), this.manager.getIndex(t); }, shutdown() { const t = this.systems.events; t.off(r.SHUTDOWN, this.shutdown, this), t.off(r.POST_UPDATE, this.step, this), t.off(r.TRANSITION_OUT); }, destroy() { this.shutdown(), this.scene.sys.events.off(r.START, this.start, this), this.scene = null, this.systems = null, this.settings = null, this.manager = null; },
  }); a.register('ScenePlugin', h, 'scenePlugin'), t.exports = h;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = {
    List: i(140), Map: i(177), ProcessQueue: i(203), RTree: i(502), Set: i(111), Size: i(404),
  };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(19); const s = i(1371); let r = {
    CanvasTexture: i(409), Events: i(132), FilterMode: s, Frame: i(107), Parsers: i(411), Texture: i(199), TextureManager: i(408), TextureSource: i(410),
  }; r = n(!1, r, s), t.exports = r;
}, function (t, e) { t.exports = { LINEAR: 0, NEAREST: 1 }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = {
    Components: i(155), Parsers: i(1402), Formats: i(36), ImageCollection: i(525), ParseToTilemap: i(256), Tile: i(82), Tilemap: i(534), TilemapCreator: i(1411), TilemapFactory: i(1412), Tileset: i(119), LayerData: i(117), MapData: i(118), ObjectLayer: i(528), DynamicTilemapLayer: i(535), StaticTilemapLayer: i(536),
  };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(27); const s = i(60); t.exports = function (t, e, i, r, o, a, h, l) { t < 0 && (t = 0), e < 0 && (e = 0), void 0 === h && (h = !0); for (let u = n(t, e, i, r, null, l), c = o - t, d = a - e, f = 0; f < u.length; f++) { const p = u[f].x + c; const g = u[f].y + d; p >= 0 && p < l.width && g >= 0 && g < l.height && l.data[g][p] && l.data[g][p].copy(u[f]); }h && s(o - 1, a - 1, i + 2, r + 2, l); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(157); const s = i(158); const r = i(27); const o = i(515); t.exports = function (t, e, i, a, h, l) { void 0 === i && (i = {}), Array.isArray(t) || (t = [t]); const u = l.tilemapLayer; void 0 === a && (a = u.scene), void 0 === h && (h = a.cameras.main); let c; const d = r(0, 0, l.width, l.height, null, l); const f = []; for (c = 0; c < d.length; c++) { const p = d[c]; if (t.indexOf(p.index) !== -1) { i.x = n(p.x, h, l), i.y = s(p.y, h, l); const g = a.make.sprite(i); f.push(g); } } if (typeof e === 'number') for (c = 0; c < t.length; c++)o(t[c], e, 0, 0, l.width, l.height, l); else if (Array.isArray(e)) for (c = 0; c < t.length; c++)o(t[c], e[c], 0, 0, l.width, l.height, l); return f; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(105); const s = i(353); t.exports = function (t, e, i, r) { void 0 === i && (i = []), void 0 === r && (r = 0), i.length = 0; let o; let a; let h; const l = t.tilemapLayer.tilemap; const u = t.tilemapLayer; const c = t.data; const d = t.width; const f = t.height; const p = Math.floor(l.tileWidth * u.scaleX); const g = Math.floor(l.tileHeight * u.scaleY); let v = 0; let m = d; let y = 0; let x = f; if (!u.skipCull && u.scrollFactorX === 1 && u.scrollFactorY === 1) { const T = n(e.worldView.x - u.x, p, 0, !0) - u.cullPaddingX; const w = s(e.worldView.right - u.x, p, 0, !0) + u.cullPaddingX; const b = n(e.worldView.y - u.y, g, 0, !0) - u.cullPaddingY; const E = s(e.worldView.bottom - u.y, g, 0, !0) + u.cullPaddingY; v = Math.max(0, T), m = Math.min(d, w), y = Math.max(0, b), x = Math.min(f, E); } if (r === 0) for (a = y; a < x; a++) for (o = v; c[a] && o < m; o++)(h = c[a][o]) && h.index !== -1 && h.visible && h.alpha !== 0 && i.push(h); else if (r === 1) for (a = y; a < x; a++) for (o = m; c[a] && o >= v; o--)(h = c[a][o]) && h.index !== -1 && h.visible && h.alpha !== 0 && i.push(h); else if (r === 2) for (a = x; a >= y; a--) for (o = v; c[a] && o < m; o++)(h = c[a][o]) && h.index !== -1 && h.visible && h.alpha !== 0 && i.push(h); else if (r === 3) for (a = x; a >= y; a--) for (o = m; c[a] && o >= v; o--)(h = c[a][o]) && h.index !== -1 && h.visible && h.alpha !== 0 && i.push(h); return u.tilesDrawn = i.length, u.tilesTotal = d * f, i; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(27); const s = i(60); const r = i(81); t.exports = function (t, e, i, o, a, h, l) { for (let u = l.collideIndexes.indexOf(t) !== -1, c = n(e, i, o, a, null, l), d = 0; d < c.length; d++)c[d].index = t, r(c[d], u); h && s(e - 1, i - 1, o + 2, a + 2, l); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(27); t.exports = function (t, e, i, s, r, o, a, h) { return n(i, s, r, o, a, h).filter(t, e); };
}, function (t, e) { t.exports = function (t, e, i, n) { void 0 === e && (e = 0), void 0 === i && (i = !1); let s; let r; let o; let a = 0; if (i) { for (r = n.height - 1; r >= 0; r--) for (s = n.width - 1; s >= 0; s--) if ((o = n.data[r][s]) && o.index === t) { if (a === e) return o; a += 1; } } else for (r = 0; r < n.height; r++) for (s = 0; s < n.width; s++) if ((o = n.data[r][s]) && o.index === t) { if (a === e) return o; a += 1; } return null; }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(27); t.exports = function (t, e, i, s, r, o, a, h) { return n(i, s, r, o, a, h).find(t, e) || null; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(27); t.exports = function (t, e, i, s, r, o, a, h) { n(i, s, r, o, a, h).forEach(t, e); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(156); const s = i(70); const r = i(71); t.exports = function (t, e, i, o, a) { const h = s(t, !0, o, a); const l = r(e, !0, o, a); return n(h, l, i, a); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(462); const s = i(27); const r = i(463); const o = i(1); const a = i(157); const h = i(158); const l = i(70); const u = i(71); const c = function (t, e) { return r.RectangleToTriangle(e, t); }; t.exports = function (t, e, i, d) { if (void 0 === t) return []; let f = o; t instanceof n.Circle ? f = r.CircleToRectangle : t instanceof n.Rectangle ? f = r.RectangleToRectangle : t instanceof n.Triangle ? f = c : t instanceof n.Line && (f = r.LineToRectangle); const p = l(t.left, !0, i, d); const g = u(t.top, !0, i, d); const v = Math.ceil(l(t.right, !1, i, d)); const m = Math.ceil(u(t.bottom, !1, i, d)); const y = Math.max(v - p, 1); const x = Math.max(m - g, 1); const T = s(p, g, y, x, e, d); let w = d.tileWidth; let b = d.tileHeight; d.tilemapLayer && (w *= d.tilemapLayer.scaleX, b *= d.tilemapLayer.scaleY); for (var E = [], S = new n.Rectangle(0, 0, w, b), A = 0; A < T.length; A++) { const _ = T[A]; S.x = a(_.x, i, d), S.y = h(_.y, i, d), f(t, S) && E.push(_); } return E; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(27); const s = i(70); const r = i(71); t.exports = function (t, e, i, o, a, h, l) { const u = s(t, !0, h, l); const c = r(e, !0, h, l); const d = Math.ceil(s(t + i, !1, h, l)); const f = Math.ceil(r(e + o, !1, h, l)); return n(u, c, d - u, f - c, a, l); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(516); const s = i(70); const r = i(71); t.exports = function (t, e, i, o) { const a = s(t, !0, i, o); const h = r(e, !0, i, o); return n(a, h, o); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(250); const s = i(70); const r = i(71); t.exports = function (t, e, i, o, a, h) { const l = s(e, !0, a, h); const u = r(i, !0, a, h); return n(t, l, u, o, h); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(60); const s = i(250); t.exports = function (t, e, i, r, o) { if (!Array.isArray(t)) return null; void 0 === r && (r = !0), Array.isArray(t[0]) || (t = [t]); for (var a = t.length, h = t[0].length, l = 0; l < a; l++) for (let u = 0; u < h; u++) { const c = t[l][u]; s(c, e + u, i + l, !1, o); }r && n(e - 1, i - 1, h + 2, a + 2, o); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(27); const s = i(202); t.exports = function (t, e, i, r, o, a) { let h; const l = n(t, e, i, r, null, a); if (void 0 === o) for (o = [], h = 0; h < l.length; h++)o.indexOf(l[h].index) === -1 && o.push(l[h].index); for (h = 0; h < l.length; h++)l[h].index = s(o); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(517); const s = i(70); const r = i(71); t.exports = function (t, e, i, o, a, h) { const l = s(t, !0, a, h); const u = r(e, !0, a, h); return n(l, u, i, o, h); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(27); const s = i(386); const r = new s(105, 210, 231, 150); const o = new s(243, 134, 48, 200); const a = new s(40, 39, 37, 150); t.exports = function (t, e, i) { void 0 === e && (e = {}); const s = void 0 !== e.tileColor ? e.tileColor : r; const h = void 0 !== e.collidingTileColor ? e.collidingTileColor : o; const l = void 0 !== e.faceColor ? e.faceColor : a; const u = n(0, 0, i.width, i.height, null, i); t.translateCanvas(i.tilemapLayer.x, i.tilemapLayer.y), t.scaleCanvas(i.tilemapLayer.scaleX, i.tilemapLayer.scaleY); for (let c = 0; c < u.length; c++) { const d = u[c]; let f = d.width; let p = d.height; let g = d.pixelX; let v = d.pixelY; const m = d.collides ? h : s; m !== null && (t.fillStyle(m.color, m.alpha / 255), t.fillRect(g, v, f, p)), g += 1, v += 1, f -= 2, p -= 2, l !== null && (t.lineStyle(1, l.color, l.alpha / 255), d.faceTop && t.lineBetween(g, v, g + f, v), d.faceRight && t.lineBetween(g + f, v, g + f, v + p), d.faceBottom && t.lineBetween(g, v + p, g + f, v + p), d.faceLeft && t.lineBetween(g, v, g, v + p)); } };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(81); const s = i(60); const r = i(251); t.exports = function (t, e, i, o, a) { void 0 === e && (e = !0), void 0 === i && (i = !0), Array.isArray(t) || (t = [t]), void 0 === a && (a = !0); for (let h = 0; h < t.length; h++)r(t[h], e, o); if (a) for (let l = 0; l < o.height; l++) for (let u = 0; u < o.width; u++) { const c = o.data[l][u]; c && t.indexOf(c.index) !== -1 && n(c, e); }i && s(0, 0, o.width, o.height, o); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(81); const s = i(60); const r = i(251); t.exports = function (t, e, i, o, a, h) { if (void 0 === i && (i = !0), void 0 === o && (o = !0), void 0 === h && (h = !0), !(t > e)) { for (let l = t; l <= e; l++)r(l, i, a); if (h) for (let u = 0; u < a.height; u++) for (let c = 0; c < a.width; c++) { const d = a.data[u][c]; d && d.index >= t && d.index <= e && n(d, i); }o && s(0, 0, a.width, a.height, a); } };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(81); const s = i(60); const r = i(251); t.exports = function (t, e, i, o) { void 0 === e && (e = !0), void 0 === i && (i = !0), Array.isArray(t) || (t = [t]); for (let a = 0; a < o.height; a++) for (let h = 0; h < o.width; h++) { const l = o.data[a][h]; l && t.indexOf(l.index) === -1 && (n(l, e), r(l.index, e, o)); }i && s(0, 0, o.width, o.height, o); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(81); const s = i(60); const r = i(113); t.exports = function (t, e, i, o) { void 0 === e && (e = !0), void 0 === i && (i = !0); for (let a = 0; a < o.height; a++) for (let h = 0; h < o.width; h++) { const l = o.data[a][h]; if (l) for (const u in t) if (r(l.properties, u)) { let c = t[u]; Array.isArray(c) || (c = [c]); for (let d = 0; d < c.length; d++)l.properties[u] === c[d] && n(l, e); } }i && s(0, 0, o.width, o.height, o); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(81); const s = i(60); t.exports = function (t, e, i) { void 0 === t && (t = !0), void 0 === e && (e = !0); for (let r = 0; r < i.height; r++) for (let o = 0; o < i.width; o++) { const a = i.data[r][o]; if (a) { const h = a.getCollisionGroup(); h && h.objects && h.objects.length > 0 && n(a, t); } }e && s(0, 0, i.width, i.height, i); };
}, function (t, e) { t.exports = function (t, e, i, n) { if (typeof t === 'number')n.callbacks[t] = e !== null ? { callback: e, callbackContext: i } : void 0; else for (let s = 0, r = t.length; s < r; s++)n.callbacks[t[s]] = e !== null ? { callback: e, callbackContext: i } : void 0; }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(27); t.exports = function (t, e, i, s, r, o, a) { for (let h = n(t, e, i, s, null, a), l = 0; l < h.length; l++)h[l].setCollisionCallback(r, o); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(27); const s = i(124); t.exports = function (t, e, i, r, o) { const a = n(t, e, i, r, null, o); const h = a.map(((t) => t.index)); s(h); for (let l = 0; l < a.length; l++)a[l].index = h[l]; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(27); t.exports = function (t, e, i, s, r, o, a) { for (let h = n(i, s, r, o, null, a), l = 0; l < h.length; l++)h[l] && (h[l].index === t ? h[l].index = e : h[l].index === e && (h[l].index = t)); };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(157); const s = i(158); const r = i(3); t.exports = function (t, e, i, o, a) { return void 0 === i && (i = new r(0, 0)), i.x = n(t, o, a), i.y = s(e, o, a), i; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(27); t.exports = function (t, e, i, s, r, o) { if (void 0 !== r) { let a; const h = n(t, e, i, s, null, o); let l = 0; for (a = 0; a < r.length; a++)l += r[a].weight; if (!(l <= 0)) for (a = 0; a < h.length; a++) { for (var u = Math.random() * l, c = 0, d = -1, f = 0; f < r.length; f++) if (u <= (c += r[f].weight)) { const p = r[f].index; d = Array.isArray(p) ? p[Math.floor(Math.random() * p.length)] : p; break; }h[a].index = d; } } };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(70); const s = i(71); const r = i(3); t.exports = function (t, e, i, o, a, h) { return void 0 === o && (o = new r(0, 0)), o.x = n(t, i, a, h), o.y = s(e, i, a, h), o; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = {
    Parse: i(518), Parse2DArray: i(252), ParseCSV: i(519), Impact: i(1403), Tiled: i(1404),
  };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = { ParseTileLayers: i(532), ParseTilesets: i(533), ParseWeltmeister: i(531) };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = {
    AssignTileProperties: i(530), Base64Decode: i(522), BuildTilesetIndex: i(529), ParseGID: i(253), ParseImageLayers: i(523), ParseJSONTiled: i(520), ParseObject: i(255), ParseObjectLayers: i(527), ParseTileLayers: i(521), ParseTilesets: i(524),
  };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  let n = i(1); let s = i(1); n = i(1406), s = i(1407), t.exports = { renderWebGL: n, renderCanvas: s };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(11); t.exports = function (t, e, i, s) { e.cull(s); const r = e.culledTiles; const o = r.length; const a = s.alpha * e.alpha; if (!(o === 0 || a <= 0)) for (let h = e.gidMap, l = e.pipeline, u = n.getTintAppendFloatAlphaAndSwap, c = e.scrollFactorX, d = e.scrollFactorY, f = e.x, p = e.y, g = e.scaleX, v = e.scaleY, m = e.tileset, y = 0; y < m.length; y++) for (let x = m[y], T = x.glTexture, w = 0; w < o; w++) { const b = r[w]; const E = h[b.index]; if (E === x) { const S = E.getTileTextureCoordinates(b.index); if (S !== null) { const A = b.width; const _ = b.height; const C = S.x; const M = S.y; const P = 0.5 * b.width; const O = 0.5 * b.height; const R = u(b.tint, a * b.alpha); l.batchTexture(e, T, T.width, T.height, f + (P + b.pixelX) * g, p + (O + b.pixelY) * v, b.width, b.height, g, v, b.rotation, b.flipX, b.flipY, c, d, P, O, C, M, A, _, R, R, R, R, !1, 0, 0, s, null, !0); } } } };
}, function (t, e) { t.exports = function (t, e, i, n, s) { e.cull(n); const r = e.culledTiles; const o = r.length; if (o !== 0) { const a = t._tempMatrix1; const h = t._tempMatrix2; const l = t._tempMatrix3; h.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY), a.copyFrom(n.matrix); const u = t.currentContext; const c = e.gidMap; u.save(), s ? (a.multiplyWithOffset(s, -n.scrollX * e.scrollFactorX, -n.scrollY * e.scrollFactorY), h.e = e.x, h.f = e.y, a.multiply(h, l), l.copyToContext(u)) : (h.e -= n.scrollX * e.scrollFactorX, h.f -= n.scrollY * e.scrollFactorY, h.copyToContext(u)); const d = n.alpha * e.alpha; (!t.antialias || e.scaleX > 1 || e.scaleY > 1) && (u.imageSmoothingEnabled = !1); for (let f = 0; f < o; f++) { const p = r[f]; const g = c[p.index]; if (g) { const v = g.image.getSourceImage(); const m = g.getTileTextureCoordinates(p.index); if (m) { const y = p.width / 2; const x = p.height / 2; u.save(), u.translate(p.pixelX + y, p.pixelY + x), p.rotation !== 0 && u.rotate(p.rotation), (p.flipX || p.flipY) && u.scale(p.flipX ? -1 : 1, p.flipY ? -1 : 1), u.globalAlpha = d * p.alpha, u.drawImage(v, m.x, m.y, p.width, p.height, -y, -x, p.width, p.height), u.restore(); } } }u.restore(); } }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  let n = i(1); let s = i(1); n = i(1409), s = i(1410), t.exports = { renderWebGL: n, renderCanvas: s };
}, function (t, e) { t.exports = function (t, e, i, n) { const s = e.tileset; const r = e.pipeline; const o = r.vertexBuffer; t.setPipeline(r), r.modelIdentity(), r.modelTranslate(e.x - n.scrollX * e.scrollFactorX, e.y - n.scrollY * e.scrollFactorY, 0), r.modelScale(e.scaleX, e.scaleY, 1), r.viewLoad2D(n.matrix.matrix); for (let a = 0; a < s.length; a++)e.upload(n, a), e.vertexCount[a] > 0 && (t.currentPipeline && t.currentPipeline.vertexCount > 0 && t.flush(), r.vertexBuffer = e.vertexBuffer[a], t.setPipeline(r), t.setTexture2D(s[a].glTexture, 0), t.gl.drawArrays(r.topology, 0, e.vertexCount[a])); r.vertexBuffer = o, r.viewIdentity(), r.modelIdentity(); }; }, function (t, e) { t.exports = function (t, e, i, n, s) { e.cull(n); const r = e.culledTiles; const o = r.length; if (o !== 0) { const a = t._tempMatrix1; const h = t._tempMatrix2; const l = t._tempMatrix3; h.applyITRS(e.x, e.y, e.rotation, e.scaleX, e.scaleY), a.copyFrom(n.matrix); const u = t.currentContext; const c = e.gidMap; u.save(), s ? (a.multiplyWithOffset(s, -n.scrollX * e.scrollFactorX, -n.scrollY * e.scrollFactorY), h.e = e.x, h.f = e.y, a.multiply(h, l), l.copyToContext(u)) : (h.e -= n.scrollX * e.scrollFactorX, h.f -= n.scrollY * e.scrollFactorY, h.copyToContext(u)); const d = n.alpha * e.alpha; (!t.antialias || e.scaleX > 1 || e.scaleY > 1) && (u.imageSmoothingEnabled = !1); for (let f = 0; f < o; f++) { const p = r[f]; const g = c[p.index]; if (g) { const v = g.image.getSourceImage(); const m = g.getTileTextureCoordinates(p.index); if (m) { const y = g.tileWidth; const x = g.tileHeight; const T = y / 2; const w = x / 2; u.save(), u.translate(p.pixelX + T, p.pixelY + w), p.rotation !== 0 && u.rotate(p.rotation), (p.flipX || p.flipY) && u.scale(p.flipX ? -1 : 1, p.flipY ? -1 : 1), u.globalAlpha = d * p.alpha, u.drawImage(v, m.x, m.y, y, x, -T, -w, y, x), u.restore(); } } }u.restore(); } }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(17); const s = i(256); n.register('tilemap', (function (t) { const e = void 0 !== t ? t : {}; return s(this.scene, e.key, e.tileWidth, e.tileHeight, e.width, e.height, e.data, e.insertNull); }));
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(5); const s = i(256); n.register('tilemap', (function (t, e, i, n, r, o, a) { return t === null && (t = void 0), e === null && (e = void 0), i === null && (i = void 0), n === null && (n = void 0), r === null && (r = void 0), s(this.scene, t, e, i, n, r, o, a); }));
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = { Clock: i(1414), TimerEvent: i(537) };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(0); const s = i(23); const r = i(24); const o = i(537); const a = new n({
    initialize(t) { this.scene = t, this.systems = t.sys, this.now = 0, this.timeScale = 1, this.paused = !1, this._active = [], this._pendingInsertion = [], this._pendingRemoval = [], t.sys.events.once(r.BOOT, this.boot, this), t.sys.events.on(r.START, this.start, this); },
    boot() { this.now = this.systems.game.loop.time, this.systems.events.once(r.DESTROY, this.destroy, this); },
    start() { const t = this.systems.events; t.on(r.PRE_UPDATE, this.preUpdate, this), t.on(r.UPDATE, this.update, this), t.once(r.SHUTDOWN, this.shutdown, this); },
    addEvent(t) { const e = new o(t); return this._pendingInsertion.push(e), e; },
    delayedCall(t, e, i, n) {
      return this.addEvent({
        delay: t, callback: e, args: i, callbackScope: n,
      });
    },
    clearPendingEvents() { return this._pendingInsertion = [], this; },
    removeAllEvents() { return this._pendingRemoval = this._pendingRemoval.concat(this._active), this; },
    preUpdate() { const t = this._pendingRemoval.length; const e = this._pendingInsertion.length; if (t !== 0 || e !== 0) { let i; let n; for (i = 0; i < t; i++) { n = this._pendingRemoval[i]; const s = this._active.indexOf(n); s > -1 && this._active.splice(s, 1), n.destroy(); } for (i = 0; i < e; i++)n = this._pendingInsertion[i], this._active.push(n); this._pendingRemoval.length = 0, this._pendingInsertion.length = 0; } },
    update(t, e) { if (this.now = t, !this.paused) { e *= this.timeScale; for (let i = 0; i < this._active.length; i++) { const n = this._active[i]; if (!n.paused && (n.elapsed += e * n.timeScale, n.elapsed >= n.delay)) { const s = n.elapsed - n.delay; n.elapsed = n.delay, !n.hasDispatched && n.callback && (n.hasDispatched = !0, n.callback.apply(n.callbackScope, n.args)), n.repeatCount > 0 ? (n.repeatCount--, n.elapsed = s, n.hasDispatched = !1) : this._pendingRemoval.push(n); } } } },
    shutdown() { let t; for (t = 0; t < this._pendingInsertion.length; t++) this._pendingInsertion[t].destroy(); for (t = 0; t < this._active.length; t++) this._active[t].destroy(); for (t = 0; t < this._pendingRemoval.length; t++) this._pendingRemoval[t].destroy(); this._active.length = 0, this._pendingRemoval.length = 0, this._pendingInsertion.length = 0; const e = this.systems.events; e.off(r.PRE_UPDATE, this.preUpdate, this), e.off(r.UPDATE, this.update, this), e.off(r.SHUTDOWN, this.shutdown, this); },
    destroy() { this.shutdown(), this.scene.sys.events.off(r.START, this.start, this), this.scene = null, this.systems = null; },
  }); s.register('Clock', a, 'time'), t.exports = a;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(100); const s = i(19); let r = {
    Builders: i(1416), Events: i(261), TweenManager: i(1431), Tween: i(260), TweenData: i(262), Timeline: i(543),
  }; r = s(!1, r, n), t.exports = r;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = {
    GetBoolean: i(99), GetEaseFunction: i(76), GetNewValue: i(159), GetProps: i(538), GetTargets: i(257), GetTweens: i(539), GetValueOp: i(258), NumberTweenBuilder: i(540), StaggerBuilder: i(541), TimelineBuilder: i(542), TweenBuilder: i(160),
  };
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = ['callbackScope', 'completeDelay', 'delay', 'duration', 'ease', 'easeParams', 'flipX', 'flipY', 'hold', 'loop', 'loopDelay', 'offset', 'onActive', 'onActiveParams', 'onActiveScope', 'onComplete', 'onCompleteParams', 'onCompleteScope', 'onLoop', 'onLoopParams', 'onLoopScope', 'onRepeat', 'onRepeatParams', 'onRepeatScope', 'onStart', 'onStartParams', 'onStartScope', 'onUpdate', 'onUpdateParams', 'onUpdateScope', 'onYoyo', 'onYoyoParams', 'onYoyoScope', 'paused', 'props', 'repeat', 'repeatDelay', 'targets', 'useFrames', 'yoyo'];
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'complete';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'loop';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'pause';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'resume';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'start';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'update';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'active';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'complete';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'loop';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'repeat';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'start';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'update';
}, function (t, e) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = 'yoyo';
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(135); const s = i(0); const r = i(540); const o = i(23); const a = i(24); const h = i(541); const l = i(542); const u = i(100); const c = i(160); const d = new s({
    initialize(t) { this.scene = t, this.systems = t.sys, this.timeScale = 1, this._add = [], this._pending = [], this._active = [], this._destroy = [], this._toProcess = 0, t.sys.events.once(a.BOOT, this.boot, this), t.sys.events.on(a.START, this.start, this); }, boot() { this.systems.events.once(a.DESTROY, this.destroy, this); }, start() { const t = this.systems.events; t.on(a.PRE_UPDATE, this.preUpdate, this), t.on(a.UPDATE, this.update, this), t.once(a.SHUTDOWN, this.shutdown, this), this.timeScale = 1; }, createTimeline(t) { return l(this, t); }, timeline(t) { const e = l(this, t); return e.paused || (this._add.push(e), this._toProcess++), e; }, create(t) { return c(this, t); }, add(t) { const e = c(this, t); return this._add.push(e), this._toProcess++, e; }, existing(t) { return this._add.push(t), this._toProcess++, this; }, addCounter(t) { const e = r(this, t); return this._add.push(e), this._toProcess++, e; }, stagger(t, e) { return h(t, e); }, preUpdate() { if (this._toProcess !== 0) { let t; let e; let i = this._destroy; const n = this._active; const s = this._pending; for (t = 0; t < i.length; t++) { e = i[t]; let r = n.indexOf(e); r === -1 ? (r = s.indexOf(e)) > -1 && (e.state = u.REMOVED, s.splice(r, 1)) : (e.state = u.REMOVED, n.splice(r, 1)); } for (i.length = 0, i = this._add, t = 0; t < i.length; t++)(e = i[t]).state === u.PENDING_ADD && (e.init() ? (e.play(), this._active.push(e)) : this._pending.push(e)); i.length = 0, this._toProcess = 0; } }, update(t, e) { let i; const n = this._active; e *= this.timeScale; for (let s = 0; s < n.length; s++)(i = n[s]).update(t, e) && (this._destroy.push(i), this._toProcess++); }, remove(t) { return n(this._add, t), n(this._pending, t), n(this._active, t), n(this._destroy, t), t.state = u.REMOVED, this; }, makeActive(t) { if (this._add.indexOf(t) !== -1 || this._active.indexOf(t) !== -1) return this; const e = this._pending.indexOf(t); return e !== -1 && this._pending.splice(e, 1), this._add.push(t), t.state = u.PENDING_ADD, this._toProcess++, this; }, each(t, e) { for (var i = [null], n = 1; n < arguments.length; n++)i.push(arguments[n]); for (const s in this.list)i[0] = this.list[s], t.apply(e, i); }, getAllTweens() { for (var t = this._active, e = [], i = 0; i < t.length; i++)e.push(t[i]); return e; }, getGlobalTimeScale() { return this.timeScale; }, getTweensOf(t) { let e; let i; const n = this._active; const s = []; if (Array.isArray(t)) for (i = 0; i < n.length; i++) { e = n[i]; for (let r = 0; r < t.length; r++)e.hasTarget(t[r]) && s.push(e); } else for (i = 0; i < n.length; i++)(e = n[i]).hasTarget(t) && s.push(e); return s; }, isTweening(t) { for (var e, i = this._active, n = 0; n < i.length; n++) if ((e = i[n]).hasTarget(t) && e.isPlaying()) return !0; return !1; }, killAll() { for (let t = this.getAllTweens(), e = 0; e < t.length; e++)t[e].stop(); return this; }, killTweensOf(t) { for (let e = this.getTweensOf(t), i = 0; i < e.length; i++)e[i].stop(); return this; }, pauseAll() { for (let t = this._active, e = 0; e < t.length; e++)t[e].pause(); return this; }, resumeAll() { for (let t = this._active, e = 0; e < t.length; e++)t[e].resume(); return this; }, setGlobalTimeScale(t) { return this.timeScale = t, this; }, shutdown() { this.killAll(), this._add = [], this._pending = [], this._active = [], this._destroy = [], this._toProcess = 0; const t = this.systems.events; t.off(a.PRE_UPDATE, this.preUpdate, this), t.off(a.UPDATE, this.update, this), t.off(a.SHUTDOWN, this.shutdown, this); }, destroy() { this.shutdown(), this.scene.sys.events.off(a.START, this.start, this), this.scene = null, this.systems = null; },
  }); o.register('TweenManager', d, 'tweens'), t.exports = d;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = {
    Array: i(200), Base64: i(1433), Objects: i(1435), String: i(1439),
  };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = { ArrayBufferToBase64: i(1434), Base64ToArrayBuffer: i(420) };
}, function (t, e) {
/**
 * @author       Niklas von Hertzen (https://github.com/niklasvh/base64-arraybuffer)
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const i = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'; t.exports = function (t, e) { for (var n = new Uint8Array(t), s = n.length, r = e ? `data:${e};base64,` : '', o = 0; o < s; o += 3)r += i[n[o] >> 2], r += i[(3 & n[o]) << 4 | n[o + 1] >> 4], r += i[(15 & n[o + 1]) << 2 | n[o + 2] >> 6], r += i[63 & n[o + 2]]; return s % 3 == 2 ? r = `${r.substring(0, r.length - 1)}=` : s % 3 == 1 && (r = `${r.substring(0, r.length - 2)}==`), r; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = {
    Clone: i(74), Extend: i(19), GetAdvancedValue: i(15), GetFastValue: i(2), GetMinMaxValue: i(1436), GetValue: i(6), HasAll: i(1437), HasAny: i(439), HasValue: i(113), IsPlainObject: i(8), Merge: i(106), MergeRight: i(1438), Pick: i(526), SetValue: i(459),
  };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(6); const s = i(20); t.exports = function (t, e, i, r, o) { void 0 === o && (o = i); const a = n(t, e, o); return s(a, i, r); };
}, function (t, e) { t.exports = function (t, e) { for (let i = 0; i < e.length; i++) if (!t.hasOwnProperty(e[i])) return !1; return !0; }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  const n = i(74); t.exports = function (t, e) { const i = n(t); for (const s in e)i.hasOwnProperty(s) && (i[s] = e[s]); return i; };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = {
    Format: i(1440), Pad: i(178), Reverse: i(1441), UppercaseFirst: i(198), UUID: i(214),
  };
}, function (t, e) { t.exports = function (t, e) { return t.replace(/%([0-9]+)/g, ((t, i) => e[Number(i) - 1])); }; }, function (t, e) { t.exports = function (t) { return t.split('').reverse().join(''); }; }, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @author       Pavle Goloskokovic <pgoloskokovic@gmail.com> (http://prunegames.com)
 * @copyright    2020 Photon Storm Ltd.
 * @license      {@link https://opensource.org/licenses/MIT|MIT License}
 */
  t.exports = {
    SoundManagerCreator: i(412), Events: i(65), BaseSound: i(139), BaseSoundManager: i(138), WebAudioSound: i(421), WebAudioSoundManager: i(419), HTML5AudioSound: i(416), HTML5AudioSoundManager: i(413), NoAudioSound: i(418), NoAudioSoundManager: i(417),
  };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2018 Photon Storm Ltd.
 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
 */
  t.exports = {
    Camera: i(263), CameraManager: i(1444), OrthographicCamera: i(544), PerspectiveCamera: i(545),
  };
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2018 Photon Storm Ltd.
 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
 */
  const n = i(0); const s = i(544); const r = i(545); const o = i(23); const a = new n({
    initialize(t) { this.scene = t, this.systems = t.sys, this.cameras = [], t.sys.events.once('boot', this.boot, this), t.sys.events.on('start', this.start, this); }, boot() { this.systems.events.once('destroy', this.destroy, this); }, start() { const t = this.systems.events; t.on('update', this.update, this), t.once('shutdown', this.shutdown, this); }, add(t, e, i) { return this.addPerspectiveCamera(t, e, i); }, addOrthographicCamera(t, e) { const i = this.scene.sys.game.config; void 0 === t && (t = i.width), void 0 === e && (e = i.height); const n = new s(this.scene, t, e); return this.cameras.push(n), n; }, addPerspectiveCamera(t, e, i) { const n = this.scene.sys.game.config; void 0 === t && (t = 80), void 0 === e && (e = n.width), void 0 === i && (i = n.height); const s = new r(this.scene, t, e, i); return this.cameras.push(s), s; }, getCamera(t) { for (let e = 0; e < this.cameras.length; e++) if (this.cameras[e].name === t) return this.cameras[e]; return null; }, removeCamera(t) { const e = this.cameras.indexOf(t); e !== -1 && this.cameras.splice(e, 1); }, removeAll() { for (;this.cameras.length > 0;) { this.cameras.pop().destroy(); } return this.main; }, update(t, e) { for (let i = 0, n = this.cameras.length; i < n; ++i) this.cameras[i].update(t, e); }, shutdown() { const t = this.systems.events; t.off('update', this.update, this), t.off('shutdown', this.shutdown, this), this.removeAll(); }, destroy() { this.shutdown(), this.scene.sys.events.off('start', this.start, this), this.scene = null, this.systems = null; },
  }); o.register('CameraManager3D', a, 'cameras3d'), t.exports = a;
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2018 Photon Storm Ltd.
 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
 */
  const n = i(161); i(5).register('sprite3D', (function (t, e, i, s, r) { const o = new n(this.scene, t, e, i, s, r); return this.displayList.add(o.gameObject), this.updateList.add(o.gameObject), o; }));
}, function (t, e, i) {
/**
 * @author       Richard Davey <rich@photonstorm.com>
 * @copyright    2018 Photon Storm Ltd.
 * @license      {@link https://github.com/photonstorm/phaser/blob/master/license.txt|MIT License}
 */
  const n = i(29); const s = i(204); const r = i(17); const o = i(15); const a = i(161); r.register('sprite3D', (function (t, e) { void 0 === t && (t = {}); const i = o(t, 'key', null); const r = o(t, 'frame', null); const h = new a(this.scene, 0, 0, i, r); return void 0 !== e && (t.add = e), n(this.scene, h, t), s(h, t), h; }));
}, function (t, e, i) {
  i.r(e); const n = i(7); const s = i.n(n); const r = Object.freeze({
    colors: Object.freeze({
      aqua: '#62f6ff', black: '#000', gold: '#fed141', white: '#fff', gray: '#fafafa', purple: '#a29bfe',
    }),
    hexColors: Object.freeze({ darkGray: 2236962, red: 16720384, white: 16777215 }),
    fonts: Object.freeze({
      default: 'Futura, system-ui, sans-serif', title: '42px', big: '32px', normal: '24px', small: '12px', tiny: '8px',
    }),
  }); class o extends s.a.GameObjects.Sprite {
    constructor(t, e, i, n, s) { super(t, e, i, n), this.scene = t, this.scene.add.existing(this), this.scene.physics.world.enableBody(this, 0), this.setData({ type: s, isDead: !1 }); }

    isDead() { return this.getData('isDead'); }

    explode(t) { this.getData('isDead') || (this.setTexture('sprExplosion'), this.play('sprExplosion'), this.setData('isDead', !0), this.body.setEnable(!1), this.scene.sfx.explosions[s.a.Math.Between(0, 1)].play(), void 0 !== this.shootTimer && this.shootTimer && (this.shootTimer.remove(!1), this.shootTimer.destroy()), this.setAngle(0), this.body.setVelocity(0, 0), this.on('animationcomplete', () => { t ? this.destroy() : this.setVisible(!1); })); }
  } const a = o; const h = class extends a {constructor(t, e, i) { super(t, e, i, 'sprLaserPNew'), this.body.setVelocityY(-200); }}; const l = class extends a {
    constructor(t, e, i, n) { super(t, e, i, n, 'Player'), this.setData({ speed: 200, isShooting: !1, timerShootDelay: 15 }), this.setData('timerShootTick', this.getData('timerShootDelay') - 1); }

    moveRight() { this.body.setVelocityX(this.getData('speed')); }

    moveLeft() { this.body.setVelocityX(-this.getData('speed')); }

    moveUp() { this.body.setVelocityY(-this.getData('speed')); }

    moveDown() { this.body.setVelocityY(this.getData('speed')); }

    onDestroy() { this.scene.cameras.main.shake(450), this.scene.time.addEvent({ delay: 1100, callback: () => { this.scene.scene.start('SceneGameOver'); }, loop: !1 }); }

    update() { if (this.body.setVelocity(0, 0), this.x = s.a.Math.Clamp(this.x, 5 + this.displayWidth / 2, window.global.width - (this.displayWidth / 2 + 5)), this.getData('isShooting') && !this.isDead()) if (this.getData('timerShootTick') < this.getData('timerShootDelay')) this.setData('timerShootTick', this.getData('timerShootTick') + 1); else { const t = new h(this.scene, this.x, this.y - 25); const e = 0; t.setDepth(-0.1), t.body.setSize(0.85 * t.displayWidth, t.displayHeight), this.scene.playerLasers.add(t), this.scene.sfx.laser[e].play(), this.setData('timerShootTick', 0); } for (let t = 0; t < this.scene.playerLasers.getChildren().length; t += 1) { const e = this.scene.playerLasers.getChildren()[t]; e.y < 0 && (this.scene.playerLasers.remove(e), e.destroy()); } }
  }; const u = class extends a {
    constructor(t, e, i, n, r) { super(t, e, i, n, r), this.setSpeed(s.a.Math.RND.between(50, 100)), this.setHP(1), this.states = { MOVE_DOWN: 'MOVE_DOWN', CHASE: 'CHASE' }; }

    setSpeed(t) { this.body.setVelocityY(t); }

    setSpeedXY(t, e) { this.body.setVelocity(t, e); }

    damageEffect() { this.setTint(r.hexColors.red), this.scene.time.addEvent({ delay: 120, callback: () => { this.setTint(r.hexColors.white); }, loop: !1 }); }

    damaged(t) { if (!this.isDead()) { const e = this.remainHP(); this.damageEffect(), t = void 0 === t ? 1 : t, this.setHP(e - t), this.remainHP() <= 0 && (this.scene.scoreAdd(3), this.explode(!0), this.setHP(0), this.setData('isDead', !0)); } }

    remainHP() { return this.getData('health'); }

    setHP(t) { this.setData('health', t); }
  }; const c = class extends u {
    constructor(t, e, i) { super(t, e, i, 'sprEnemy1', 'ChaserShip'), this.x < this.displayWidth ? this.x = this.displayWidth : this.x > window.global.width - this.displayWidth && (this.x = window.global.width - this.displayWidth), this.state = this.states.MOVE_DOWN, this.speed = 200; }

    update() { if (this.isDead() || this.scene.player.isDead()) this.scene.player.isDead() && (this.setSpeedXY(0, this.speed), this.isDead() || (this.angle += 5)); else { switch (s.a.Math.Distance.Between(this.x, this.y, this.scene.player.x, this.scene.player.y) < 100 ? this.state = this.states.CHASE : this.state = this.states.MOVE_DOWN, this.state) { case this.states.CHASE: const t = this.scene.player.y - this.y; const e = this.scene.player.x - this.x; const i = Math.atan2(t, e); this.setSpeedXY(Math.cos(i) * (0.75 * this.speed), Math.sin(i) * (0.75 * this.speed)); break; default: this.setSpeedXY(0, this.speed); } this.x < this.scene.player.x ? this.angle -= 5 : this.angle += 5; } }
  }; const d = class extends a {constructor(t, e, i) { super(t, e, i, 'sprLaserENew'), this.body.setVelocityY(220); }}; const f = class extends u {
    constructor(t, e, i) { super(t, e, i, 'gunship2', 'GunShip'), this.x < this.displayWidth ? this.x = this.displayWidth : this.x > window.global.width - this.displayWidth && (this.x = window.global.width - this.displayWidth), this.play('gunship2'), this.body.setSize(0.5 * this.displayWidth, this.displayHeight, !0), this.shootTimer = this.scene.time.addEvent({ delay: s.a.Math.RND.between(1e3, 2e3), callback: this.doShoot.bind(this), loop: !0 }); }

    doShoot() { const t = new d(this.scene, this.x, this.y + 15); t.setDepth(-0.3), t.body.setSize(t.displayWidth / 2, t.displayHeight), t.setScale(this.scaleX), this.scene.enemyLasers.add(t); }

    onDestroy() { this.shootTimer.remove(!1), this.destroy(); }
  }; const p = class extends u {constructor(t, e, i) { super(t, e, i, 'carriership', 'CarrierShip'), this.x < this.displayWidth ? this.x = this.displayWidth : this.x > window.global.width - this.displayWidth && (this.x = window.global.width - this.displayWidth), this.play('carriership'), this.body.setSize(0.7 * this.displayWidth, 0.8 * this.displayHeight, !0); }}; const g = class {
    constructor(t, e, i) { this.scene = t, this.key = e, this.velocityY = i, this.layers = this.scene.add.group(), this.createLayers(); }

    createLayers() { for (let t = 0; t < 2; t += 1) { const e = this.scene.add.sprite(0, 0, this.key); e.y = e.displayHeight * t; const i = s.a.Math.Between(0, 10) >= 5 ? -1 : 1; const n = s.a.Math.Between(0, 10) >= 5 ? -1 : 1; e.setScale(2 * i, 2 * n), e.setDepth(-5 - (t - 1)), this.scene.physics.world.enableBody(e, 0), e.body.setVelocityY(this.velocityY), this.layers.add(e); } }

    update() { if (this.layers.getChildren()[0].y > 0) for (let t = 0; t < this.layers.getChildren().length; t += 1) { const e = this.layers.getChildren()[t]; e.y = -e.displayHeight + e.displayHeight * t; } }
  }; class v extends s.a.Scene {
    constructor() { super({ key: 'SceneMain' }); }

    preload() { this.load.spritesheet('rplrocket', 'assets/rplrocket.png', { frameWidth: 35, frameHeight: 56 }), this.load.spritesheet('gunship', 'assets/gunship.png', { frameWidth: 39, frameHeight: 33 }), this.load.spritesheet('carriership', 'assets/carriership.png', { frameWidth: 40, frameHeight: 50 }), this.load.spritesheet('gunship2', 'assets/gunship2.png', { frameWidth: 32, frameHeight: 32 }), this.load.spritesheet('sprExplosion', 'assets/sprExplosion.png', { frameWidth: 32, frameHeight: 32 }), this.load.spritesheet('sprEnemy0', 'assets/sprEnemy0.png', { frameWidth: 16, frameHeight: 16 }), this.load.image('sprEnemy1', 'assets/sprEnemy1.png'), this.load.spritesheet('sprEnemy2', 'assets/sprEnemy2.png', { frameWidth: 16, frameHeight: 16 }), this.load.image('sprLaserEnemy0', 'assets/sprLaserEnemy0.png'), this.load.image('sprLaserPlayer', 'assets/sprLaserPlayer.png'), this.load.image('sprLaserENew', 'assets/sprLaserEnemyn.png'), this.load.image('sprLaserPNew', 'assets/sprLaserPlayern.png'), this.load.spritesheet('sprPlayer', 'assets/sprPlayer.png', { frameWidth: 16, frameHeight: 16 }); }

    create() {
      this.anims.create({
        key: 'rplrocket', frames: this.anims.generateFrameNumbers('rplrocket'), frameRate: 12, repeat: -1,
      }), this.anims.create({
        key: 'gunship', frames: this.anims.generateFrameNumbers('gunship'), frameRate: 12, repeat: -1,
      }), this.anims.create({
        key: 'carriership', frames: this.anims.generateFrameNumbers('carriership'), frameRate: 12, repeat: -1,
      }), this.anims.create({
        key: 'gunship2', frames: this.anims.generateFrameNumbers('gunship2'), frameRate: 12, repeat: -1,
      }), this.anims.create({
        key: 'sprEnemy0', frames: this.anims.generateFrameNumbers('sprEnemy0'), frameRate: 20, repeat: -1,
      }), this.anims.create({
        key: 'sprEnemy2', frames: this.anims.generateFrameNumbers('sprEnemy2'), frameRate: 20, repeat: -1,
      }), this.anims.create({
        key: 'sprExplosion', frames: this.anims.generateFrameNumbers('sprExplosion'), frameRate: 20, repeat: 0,
      }), this.anims.create({
        key: 'sprPlayer', frames: this.anims.generateFrameNumbers('sprPlayer'), frameRate: 20, repeat: -1,
      }), this.sfx = { explosions: [this.sound.add('sndExplode0'), this.sound.add('sndExplode1')], laser: [this.sound.add('sndLaser', { volume: 0.5 }), this.sound.add('sndLaser0', { volume: 0.5 })] }, this.backgrounds = []; for (let t = 0; t < 5; t += 1) { const e = new g(this, 'sprBg0', 10 * t); this.backgrounds.push(e); } this.player = new l(this, window.global.width / 2, window.global.height - 64, 'rplrocket'), this.player.play('rplrocket', !0), this.player.body.setSize(0.5 * this.player.displayWidth, 0.8 * this.player.displayHeight), this.keyW = this.input.keyboard.addKey(s.a.Input.Keyboard.KeyCodes.W), this.keyS = this.input.keyboard.addKey(s.a.Input.Keyboard.KeyCodes.S), this.keyA = this.input.keyboard.addKey(s.a.Input.Keyboard.KeyCodes.A), this.keyD = this.input.keyboard.addKey(s.a.Input.Keyboard.KeyCodes.D), this.cursors = this.input.keyboard.createCursorKeys(), this.keySpace = this.input.keyboard.addKey(s.a.Input.Keyboard.KeyCodes.SPACE), this.enemies = this.add.group(), this.enemyLasers = this.add.group(), this.playerLasers = this.add.group(), this.physics.add.collider(this.playerLasers, this.enemies, (t, e) => { e && (t.destroy(), this.isEnemyType(e, 'ChaserShip') || this.isEnemyType(e, 'CarrierShip') ? e.damaged() : (this.scoreAdd(), e.explode(!0))); }), this.physics.add.overlap(this.player, this.enemies, (t, e) => { t.isDead() || e.isDead() || (t.onDestroy(), t.explode(!1), t.setData('isDead', !0), e.explode(!0)); }), this.physics.add.overlap(this.player, this.enemyLasers, (t, e) => { t.isDead() || (t.onDestroy(), t.explode(!1), e.destroy()); }), this.time.addEvent({ delay: s.a.Math.RND.between(800, 1e3), callback: this.createEnemy.bind(this), loop: !0 }), this.scoreText = this.add.text(16, 16, '0', {
        fontFamily: 'monospace', fontSize: r.fonts.big, fontStyle: 'bold', color: r.colors.white, align: 'left', stroke: r.colors.purple, strokeThickness: 2,
      }), this.scoreText.setDepth(10), this.scoreReset();
    }

    createEnemy() { let t = null; let e = s.a.Math.RND.between(0, window.global.height); if (this.getEnemiesByPosX(380).length >= 3 && (e = s.a.Math.RND.between(10, 0.5 * window.global.height)), s.a.Math.RND.between(0, 10) >= 3 ? t = new f(this, e, 0) : s.a.Math.RND.between(0, 10) >= 5 ? this.getEnemiesByType('ChaserShip').length < 5 && (t = new c(this, e, 0), t.setHP(2), t.body.setImmovable()) : (t = new p(this, e, 0), t.setHP(3), t.setSpeed(s.a.Math.RND.between(100, 180)), t.body.setImmovable()), t !== null) { const e = this.isEnemyType(t, 'ChaserShip') ? 0.1 * s.a.Math.RND.between(10, 20) : 1; t.setScale(e), this.enemies.add(t); } }

    getEnemiesByPosX(t) { const e = []; return this.enemies.children.iterate(i => { i.x > t && e.push(i); }), e; }

    getEnemiesByType(t) { const e = []; for (let i = 0; i < this.enemies.getChildren().length; i += 1) { const n = this.enemies.getChildren()[i]; this.isEnemyType(n, t) && e.push(n); } return e; }

    isEnemyType(t, e) { let i = !1; return t.getData('type') === e && (i = !0), i; }

    scoreAdd(t = 1) {
      window.global.score += t, this.scoreText.setText(window.global.score), this.tweens.add({
        targets: this.scoreText, scaleX: 1.3, scaleY: 1.3, yoyo: !0, duration: 60, repeat: 0, onComplete: () => { this.scoreText.scaleX = 1, this.scoreText.scaleY = this.scoreText.scaleX; },
      });
    }

    scoreReset() { window.global.score = 0, this.scoreText.setText(window.global.score); }

    update() { this.player.update(), this.player.isDead() || (this.keyA.isDown || this.cursors.left.isDown ? this.player.moveLeft() : (this.keyD.isDown || this.cursors.right.isDown) && this.player.moveRight(), this.keySpace.isDown && !this.player.isDead() ? this.player.setData('isShooting', !0) : (this.player.setData('timerShootTick', this.player.getData('timerShootDelay') - 1), this.player.setData('isShooting', !1))); for (let t = 0; t < this.enemies.getChildren().length; t += 1) { const e = this.enemies.getChildren()[t]; e.update(), (e.y < 4 * -e.displayHeight || e.y > window.global.height + e.displayHeight) && (this.enemies.remove(e), void 0 !== e.onDestroy ? e.onDestroy() : e.destroy()); } for (let t = 0; t < this.enemyLasers.getChildren().length; t += 1) { const e = this.enemyLasers.getChildren()[t]; e.y > window.global.height && (this.enemyLasers.remove(e), e.destroy()); } for (let t = 0; t < this.backgrounds.length; t += 1) this.backgrounds[t].update(); }
  } const m = v; const y = class {
    constructor() { this.getData('localScore', !0); }

    setHighscore() { let t = !1; if (this.getData('localScore')) { const e = window.global.score; e > this.getData('localScore') && (this.saveData('localScore', e), console.log('New Highscore!'), t = !0); } return t; }

    saveData(t, e) { localStorage.setItem(t, e), this.getData(t) ? console.log(`Data ${t} saved`) : console.log(`Data ${t} not saved!`); }

    getData(t, e = !1) { let i = localStorage.getItem(t); return i === null && (i = window.global.score, console.log(`Not found: ${t}`), e && this.saveData('localScore', i)), i; }

    deleteData(t) { this.getData(t) ? (localStorage.removeItem(t), console.log(`Data ${t} deleted!`)) : console.log(`Data ${t} not deleted!`); }
  }; class x extends s.a.Scene {
    constructor() { super({ key: 'SceneMainMenu' }); }

    init() { window.global.width = this.game.config.width, window.global.height = this.game.config.height, window.emitter = new s.a.Events.EventEmitter(), this.dbLocal = new y(); }

    preload() {
      const t = this.make.text({
        x: window.global.width / 2, y: window.global.height / 2 - 70, text: '', style: { font: '18px monospace', fill: r.colors.white },
      }).setOrigin(0.5); const e = this.make.text({
        x: t.x, y: t.y + 32, text: '', style: { font: '18px monospace', fill: r.colors.white },
      }).setOrigin(0.5); this.load.on('progress', t => { e.setText(`${parseInt(100 * t)} %`); }), this.load.on('fileprogress', e => { t.setText(`Loading asset: ${e.key}`); }), this.load.on('complete', () => { t.destroy(), e.destroy(); }), this.load.image('sprBtnPlay', 'assets/sprBtnPlay.png'), this.load.image('sprBtnPlayHover', 'assets/sprBtnPlayHover.png'), this.load.image('sprBtnPlayDown', 'assets/sprBtnPlayDown.png'), this.load.image('sprBtnRestart', 'assets/sprBtnRestart.png'), this.load.image('sprBtnRestartHover', 'assets/sprBtnRestartHover.png'), this.load.image('sprBtnRestartDown', 'assets/sprBtnRestartDown.png'), this.load.image('sprBg0', 'assets/sprBg0.png'), this.load.image('sprBg1', 'assets/sprBg1.png'), this.load.audio('sndBtnOver', 'assets/audio/sndBtnOver.wav'), this.load.audio('sndBtnDown', 'assets/audio/sndBtnDown.wav'), this.load.audio('sndExplode0', 'assets/audio/sndExplode0.wav'), this.load.audio('sndExplode1', 'assets/audio/sndExplode1.wav'), this.load.audio('sndLaser', 'assets/audio/sndLaser.wav'), this.load.audio('sndLaser0', ['assets/audio/sndLaser0.mp3', 'assets/audio/sndLaser0.ogg']), this.load.audio('bgm', ['assets/audio/bgm_bit.mp3', 'assets/audio/bgm_bit.ogg']);
    }

    create() {
      this.add.text(2, this.game.config.height - 2, `Play Control\nMove: [A (Left), D (Right)]\nShoot: [Space]\n${window.global.signature}`).setOrigin(0, 1); const t = this.dbLocal.getData('localScore'); t && this.add.text(window.global.width / 2, 235, t, {
        fontFamily: 'monospace', fontSize: r.fonts.big, fontStyle: 'bold', color: r.colors.white, align: 'center',
      }).setOrigin(0.5), void 0 === window.global.bgmInstance && (this.bgm = this.sound.add('bgm', { loop: !0, volume: 0.5 }), this.bgm.play(), window.global.bgmInstance = this.bgm), this.sfx = { btnOver: this.sound.add('sndBtnOver'), btnDown: this.sound.add('sndBtnDown') }, this.btnPlay = this.add.sprite(window.global.width / 2, window.global.height / 2 + 100, 'sprBtnPlay'), this.btnPlay.setInteractive(), this.btnPlay.on('pointerover', this.onHover.bind(this)), this.btnPlay.on('pointerout', this.onOut.bind(this)), this.btnPlay.on('pointerdown', this.onClick.bind(this)), this.btnPlay.on('pointerup', () => { this.btnPlay.setTexture('sprBtnPlayHover'); }), this.title = this.add.text(0.5 * window.global.width, 128, 'SPACESHOOTER', {
        fontFamily: 'monospace', fontSize: r.fonts.title, fontStyle: 'bold', color: r.colors.white, align: 'center',
      }), this.title.setOrigin(0.5), this.backgrounds = []; for (let t = 0; t < 5; t += 1) { const e = ['sprBg0', 'sprBg1']; const i = e[s.a.Math.Between(0, e.length - 1)]; const n = new g(this, i, 10 * t); this.backgrounds.push(n); }
    }

    onClick() { this.btnPlay.setTexture('sprBtnPlayDown'), this.sfx.btnDown.play(), this.time.addEvent({ delay: 90, callback: () => { this.scene.start('SceneMain'); }, loop: !1 }); }

    onOut() { this.btnPlay.setTexture('sprBtnPlay'); }

    onHover() { this.btnPlay.setTexture('sprBtnPlayHover'), this.sfx.btnOver.play(); }

    update() { for (let t = 0; t < this.backgrounds.length; t += 1) this.backgrounds[t].update(); }
  } const T = x; class w extends s.a.Scene {
    constructor() { super('SceneGameOver'); }

    init() { this.dbLocal = new y(), this.isHighscore = this.dbLocal.setHighscore(); }

    create() {
      this.title = this.add.text(0.5 * window.global.width, 64, 'GAME OVER', {
        fontFamily: 'monospace', fontSize: r.fonts.title, fontStyle: 'bold', color: r.colors.white, align: 'center',
      }), this.title.setOrigin(0.5), this.scoreLabel = this.add.text(0.5 * window.global.width, 188, 'SCORE: 99', {
        fontFamily: 'monospace', fontSize: r.fonts.big, fontStyle: 'bold', color: r.colors.white, align: 'center',
      }), this.scoreLabel.setOrigin(0.5), this.scoreLabel.setText(`SCORE: ${this.getScore()}`), this.highscoreLabel = this.add.text(0.5 * window.global.width, 128, 'YOUR HIGHSCORE: 99', {
        fontFamily: 'monospace', fontSize: r.fonts.normal, fontStyle: 'bold', color: r.colors.white, align: 'center',
      }), this.highscoreLabel.setOrigin(0.5); let t = `YOUR HIGHSCORE: ${this.dbLocal.getData('localScore')}`; this.isHighscore && (t += ' (NEW)'), this.highscoreLabel.setText(t), this.sfx = { btnOver: this.sound.add('sndBtnOver'), btnDown: this.sound.add('sndBtnDown') }, this.btnRestart = this.add.sprite(window.global.width / 2, window.global.height - 128, 'sprBtnRestart'), this.btnRestart.setInteractive(), this.btnRestart.on('pointerover', this.onHover.bind(this)), this.btnRestart.on('pointerout', this.onOut.bind(this)), this.btnRestart.on('pointerdown', this.onClick.bind(this)), this.btnRestart.on('pointerup', () => { this.btnRestart.setTexture('sprBtnRestartHover'); });
    }

    getScore() { return window.global.score; }

    onClick() { this.btnRestart.setTexture('sprBtnRestartDown'), this.sfx.btnDown.play(), this.scene.start('SceneMain'); }

    onOut() { this.btnRestart.setTexture('sprBtnRestart'); }

    onHover() { this.btnRestart.setTexture('sprBtnRestartHover'), this.sfx.btnOver.play(); }
  } const b = w; let E; const S = []; const A = Date.now(); S.push(T), S.push(m), S.push(b), window.onload = () => {
    const t = {
      type: s.a.AUTO, parent: 'phaser-game', width: 480, height: 640, backgroundColor: 'black', pixelArt: !0, seed: [A], physics: { default: 'arcade', arcade: { gravity: { x: 0, y: 0 }, debug: !1 } }, scene: S,
    }; E = new s.a.Game(t);
  }, window.global = { signature: 'Made with Love by Abubakar Diallo', score: 0, emitter: null };
}]));